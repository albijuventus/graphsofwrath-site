<!DOCTYPE html>
<!--
================================================================================
  GridLab - 3D Grid Graph Visualization & Hamiltonian Path/Cycle Tool
  
  Copyright ¬© 2025 Albi. All rights reserved.
  
  Version: 1.0.0
  Build: GL-2025-11A7B91F3E-YORK
  Author: Albi (York University)
  Contact: albijuventus@yahoo.com
  Website: https://graphsofwrath.com
  
  LICENSED UNDER: PolyForm Noncommercial License 1.0.0
  
  This software implements novel algorithms for Hamiltonian cycle and path
  reconfiguration on rectangular grid graphs, based on doctoral research
  conducted at York University (2024).
  
================================================================================
  
  PolyForm Noncommercial License 1.0.0
  
  https://polyformproject.org/licenses/noncommercial/1.0.0
  
  Acceptance
  
  In order to get any license under these terms, you must agree to them as
  both strict obligations and conditions to all your licenses.
  
  Copyright License
  
  The licensor grants you a copyright license for the software to do
  everything you might do with the software that would otherwise infringe
  the licensor's copyright in it for any permitted purpose. However, you
  may only distribute the software according to Distribution License and
  make changes or new works based on the software according to Changes and
  New Works License.
  
  Distribution License
  
  The licensor grants you an additional copyright license to distribute
  copies of the software. Your license to distribute covers distributing
  the software with changes and new works permitted by Changes and New
  Works License.
  
  Notices
  
  You must ensure that anyone who gets a copy of any part of the software
  from you also gets a copy of these terms or the URL for them above, as
  well as copies of any plain-text lines beginning with Required Notice:
  that the licensor provided with the software. For example:
  
  Required Notice: Copyright ¬© 2025 Albi (https://graphsofwrath.com)
  
  Changes and New Works License
  
  The licensor grants you an additional copyright license to make changes
  and new works based on the software for any permitted purpose.
  
  Patent License
  
  The licensor grants you a patent license for the software that covers
  patent claims the licensor can license, or becomes able to license, that
  you would infringe by using the software.
  
  Noncommercial Purposes
  
  Any noncommercial purpose is a permitted purpose.
  
  Personal Uses
  
  Personal use for research, experiment, and testing for the benefit of
  public knowledge, personal study, private entertainment, hobby projects,
  amateur pursuits, or religious observance, without any anticipated
  commercial application, is use for a permitted purpose.
  
  Noncommercial Organizations
  
  Use by any charitable organization, educational institution, public
  research organization, public safety or health organization,
  environmental protection organization, or government institution is use
  for a permitted purpose regardless of the source of funding or
  obligations resulting from the funding.
  
  Fair Use
  
  You may have "fair use" rights for the software under the law. These
  terms do not limit them.
  
  No Other Rights
  
  These terms do not allow you to sublicense or transfer any of your
  licenses to anyone else, or prevent the licensor from granting licenses
  to anyone else. These terms do not imply any other licenses.
  
  Patent Defense
  
  If you make any written claim that the software infringes or contributes
  to infringement of any patent, your patent license for the software
  granted under these terms ends immediately. If your company makes such a
  claim, your patent license ends immediately for work on behalf of your
  company.
  
  Violations
  
  The first time you are notified in writing that you have violated any of
  these terms, or done anything with the software not covered by your
  licenses, your licenses can nonetheless continue if you come into full
  compliance with these terms, and take practical steps to correct past
  violations, within 32 days of receiving notice. Otherwise, all your
  licenses end immediately.
  
  No Liability
  
  ***As far as the law allows, the software comes as is, without any
  warranty or condition, and the licensor will not be liable to you for any
  damages arising out of these terms or the use or nature of the software,
  under any kind of legal claim.***
  
  Definitions
  
  The "licensor" is the individual or entity offering these terms, and the
  "software" is the software the licensor makes available under these
  terms.
  
  "You" refers to the individual or entity agreeing to these terms.
  
  "Your company" is any legal entity, sole proprietorship, or other kind of
  organization that you work for, plus all organizations that have control
  over, are under the control of, or are under common control with that
  organization. "Control" means ownership of substantially all the assets
  of an entity, or the power to direct its management and policies by vote,
  contract, or otherwise. Control can be direct or indirect.
  
  "Your licenses" are all the licenses granted to you for the software
  under these terms.
  
  "Use" means anything you do with the software requiring one of your
  licenses.
  
================================================================================
  COMMERCIAL LICENSING
  
  For commercial use inquiries, please contact: albijuventus@yahoo.com
================================================================================

  Dev Signature: GL.ALBI.20251116.YORK.RECT_GRID_HAM
-->
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>GridLab - 3D Grid Graph Visualization</title>
<style>
  /* === THEME VARIABLES === */
  :root {
    /* Contrast 1 theme (renamed from Light) */
    --bg-main: linear-gradient(135deg, #f7f5e9 0%, #fefefe 100%);
    --topbar-bg: rgba(240, 240, 240, 0.85);
    --topbar-text: #111827;
    --sidebar-bg: #f8f8f8;
    --sidebar-text: #111827;
    --sidebar-shadow: 4px 0 18px rgba(0, 0, 0, 0.08);
    --button-bg: rgba(2, 6, 23, 0.8);
    --button-hover: rgba(2, 6, 23, 0.95);
    --button-active: rgba(2, 6, 23, 0.7);
    --button-text: #e5e7eb;
  }
  
  :root.dark-theme {
    /* Dark theme */
    --bg-main: linear-gradient(135deg, #0c0c0c 0%, #1a1a1a 100%);
    --topbar-bg: rgba(90, 94, 102, 0.85);
    --topbar-text: #f9fafb;
    --sidebar-bg: #5a5e66;
    --sidebar-text: #f9fafb;
    --sidebar-shadow: 4px 0 18px rgba(0, 0, 0, 0.22);
    --button-bg: rgba(30, 41, 59, 0.9);
    --button-hover: rgba(30, 41, 59, 1);
    --button-active: rgba(30, 41, 59, 0.75);
    --button-text: #f9fafb;
  }
  
  :root.warm-light-theme {
    /* Warm Light theme */
    --bg-main: linear-gradient(135deg, #f7f5e9 0%, #FFFDF9 100%);
    --topbar-bg: rgba(255, 253, 249, 0.85);
    --topbar-text: #1f2937;
    --sidebar-bg: #FFFCF6;
    --sidebar-text: #1f2937;
    --sidebar-shadow: 4px 0 18px rgba(0, 0, 0, 0.08);
    --button-bg: #FCE8D8;
    --button-hover: #F5DCC5;
    --button-active: #EED0B3;
    --button-text: #4B3A2E;
  }
  
  :root.mist-blue-theme {
    /* Mist Blue theme */
    --bg-main: linear-gradient(135deg, #f7f5e9 0%, #F8FBFF 100%);
    --topbar-bg: rgba(248, 251, 255, 0.85);
    --topbar-text: #0f172a;
    --sidebar-bg: #F6FAFF;
    --sidebar-text: #0f172a;
    --sidebar-shadow: 4px 0 18px rgba(0, 0, 0, 0.08);
    --button-bg: #E6F0FF;
    --button-hover: #D5E3F6;
    --button-active: #C9DCED;
    --button-text: #1e293b;
  }
  
  :root.paper-white-theme {
    /* Paper White theme - all button text black */
    --bg-main: linear-gradient(135deg, #f7f5e9 0%, #FFFFFF 100%);
    --topbar-bg: rgba(255, 255, 255, 0.85);
    --topbar-text: #111827;
    --sidebar-bg: #FFFFFF;
    --sidebar-text: #111827;
    --sidebar-shadow: 4px 0 18px rgba(0, 0, 0, 0.08);
    --button-bg: #F1F5F9;
    --button-hover: #E2E8F0;
    --button-active: #CBD5E1;
    --button-text: #111827;
  }
  
  :root.sandstone-theme {
    /* Sandstone theme - all button text black */
    --bg-main: linear-gradient(135deg, #f7f5e9 0%, #FEFEFD 100%);
    --topbar-bg: rgba(254, 254, 253, 0.85);
    --topbar-text: #1f2937;
    --sidebar-bg: #FBFAF7;
    --sidebar-text: #1f2937;
    --sidebar-shadow: 4px 0 18px rgba(0, 0, 0, 0.08);
    --button-bg: #E9E6E0;
    --button-hover: #DBD8D2;
    --button-active: #CCC9C3;
    --button-text: #374151;
  }

  /* Text color overrides for better visibility in light themes */
  :root.warm-light-theme .color-label,
  :root.warm-light-theme .grid-dim-label,
  :root.warm-light-theme .grid-dimmer-label,
  :root.warm-light-theme .grid-dimmer-row span,
  :root.warm-light-theme .coord-checkbox-row label,
  :root.warm-light-theme .coord-rel-inputs label,
  :root.warm-light-theme .plane-opacity-label,
  :root.warm-light-theme .plane-opacity-value,
  :root.warm-light-theme .plane-coeff-label,
  :root.warm-light-theme .plane-item,
  :root.mist-blue-theme .color-label,
  :root.mist-blue-theme .grid-dim-label,
  :root.mist-blue-theme .grid-dimmer-label,
  :root.mist-blue-theme .grid-dimmer-row span,
  :root.mist-blue-theme .coord-checkbox-row label,
  :root.mist-blue-theme .coord-rel-inputs label,
  :root.mist-blue-theme .plane-opacity-label,
  :root.mist-blue-theme .plane-opacity-value,
  :root.mist-blue-theme .plane-coeff-label,
  :root.mist-blue-theme .plane-item,
  :root.paper-white-theme .color-label,
  :root.paper-white-theme .grid-dim-label,
  :root.paper-white-theme .grid-dimmer-label,
  :root.paper-white-theme .grid-dimmer-row span,
  :root.paper-white-theme .coord-checkbox-row label,
  :root.paper-white-theme .coord-rel-inputs label,
  :root.paper-white-theme .plane-opacity-label,
  :root.paper-white-theme .plane-opacity-value,
  :root.paper-white-theme .plane-coeff-label,
  :root.paper-white-theme .plane-item,
  :root.sandstone-theme .color-label,
  :root.sandstone-theme .grid-dim-label,
  :root.sandstone-theme .grid-dimmer-label,
  :root.sandstone-theme .grid-dimmer-row span,
  :root.sandstone-theme .coord-checkbox-row label,
  :root.sandstone-theme .coord-rel-inputs label,
  :root.sandstone-theme .plane-opacity-label,
  :root.sandstone-theme .plane-opacity-value,
  :root.sandstone-theme .plane-coeff-label,
  :root.sandstone-theme .plane-item {
    color: #000000 !important;
  }
  
  /* Active color label text should be black in non-dark themes */
  :root.warm-light-theme .color-label-active,
  :root.mist-blue-theme .color-label-active,
  :root.paper-white-theme .color-label-active,
  :root.sandstone-theme .color-label-active {
    color: #000000 !important;
  }
  
  /* Number input boxes should have white background in non-dark themes */
  :root.warm-light-theme .grid-dim-inputs input,
  :root.warm-light-theme .coord-rel-inputs input,
  :root.warm-light-theme .bb-row input[type="number"],
  :root.warm-light-theme .plane-row input[type="number"],
  :root.mist-blue-theme .grid-dim-inputs input,
  :root.mist-blue-theme .coord-rel-inputs input,
  :root.mist-blue-theme .bb-row input[type="number"],
  :root.mist-blue-theme .plane-row input[type="number"],
  :root.paper-white-theme .grid-dim-inputs input,
  :root.paper-white-theme .coord-rel-inputs input,
  :root.paper-white-theme .bb-row input[type="number"],
  :root.paper-white-theme .plane-row input[type="number"],
  :root.sandstone-theme .grid-dim-inputs input,
  :root.sandstone-theme .coord-rel-inputs input,
  :root.sandstone-theme .bb-row input[type="number"],
  :root.sandstone-theme .plane-row input[type="number"] {
    background: #ffffff !important;
    color: #000000 !important;
    border-color: #d1d5db !important;
  }

  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    width: 100%;
    height: 100%;
    background: var(--bg-main);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  }
  
  /* === TOP BAR === */
  .topbar {
    position: fixed;
    left: 0;
    right: 0;
    top: 0;
    height: 52px;
    z-index: 1000;
    display: flex;
    justify-content: center;
    pointer-events: none;
  }
  
  .topbar-inner {
    pointer-events: auto;
    width: 100%;
    margin: 0;
    padding: 12px 20px;
    border-radius: 0;
    background: var(--topbar-bg);
    color: var(--topbar-text);
    backdrop-filter: blur(8px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 16px;
  }
  
  .tb-left {
    font-weight: 700;
    font-size: 16px;
  }
  
  .tb-left span {
    opacity: 0.65;
    margin-left: 4px;
    font-size: 14px;
  }
  
  .tb-right {
    display: flex;
    gap: 8px;
  }
  
  /* Topbar buttons */
  .tb-btn {
    padding: 6px 10px;
    border-radius: 10px;
    border: 0;
    cursor: pointer;
    background: var(--button-bg);
    color: var(--button-text);
    font-size: 13px;
    font-weight: 500;
    transition: all 0.2s ease;
  }
  
  .tb-btn:hover {
    background: var(--button-hover);
  }
  
  .tb-btn:active {
    background: var(--button-active);
  }
  
  /* Help dropdown menu */
  .help-dropdown {
    position: absolute;
    top: 100%;
    right: 0;
    margin-top: 4px;
    min-width: 220px;
    background: rgba(248, 250, 252, 0.95);
    backdrop-filter: blur(8px);
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
    padding: 8px;
    display: none;
    z-index: 2000;
  }
  
  .help-dropdown.show {
    display: block;
  }
  
  .help-license-info {
    padding: 8px 12px;
    font-size: 11px;
    color: #6b7280;
    line-height: 1.4;
    border-top: 1px solid rgba(0, 0, 0, 0.1);
    margin-top: 4px;
  }
  
  .help-license-info strong {
    color: #374151;
    display: block;
    margin-bottom: 4px;
  }
  
  .help-license-info a {
    color: #3b82f6;
    text-decoration: none;
  }
  
  .help-license-info a:hover {
    text-decoration: underline;
  }
  
  .help-menu-item {
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    color: #111827;
    font-size: 13px;
    transition: background 0.2s ease;
  }
  
  .help-menu-item:hover {
    background: rgba(0, 0, 0, 0.06);
  }
  
  /* Position help button relative for dropdown */
  .help-btn-wrapper {
    position: relative;
  }
  
  /* === LEFT SIDEBAR === */
  .sidebar {
    position: fixed;
    left: 0;
    top: 0;
    bottom: 0;
    width: 240px;
    padding: 64px 12px 16px 12px;
    background: var(--sidebar-bg);
    color: var(--sidebar-text);
    box-shadow: var(--sidebar-shadow);
    z-index: 900;
    overflow-y: auto;
    overflow-x: hidden;
    transition: transform 0.3s ease;
  }
  
  .sidebar.collapsed {
    transform: translateX(-240px);
  }
  
  .sidebar h2 {
    font-size: 15px;
    margin: 0 0 6px 2px;
    font-weight: 700;
  }
  
  .sidebar .hint {
    font-size: 12px;
    opacity: 0.65;
    margin-bottom: 12px;
  }
  
  /* === GENERATE PANEL === */
  .gen-panel {
    margin-bottom: 8px;
  }
  
  .gen-header-btn {
    width: 100%;
    padding: 8px 10px;
    border-radius: 12px;
    border: 0;
    background: var(--button-bg);
    color: var(--button-text);
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    font-weight: 600;
    font-size: 14px;
    transition: all 0.2s ease;
  }
  
  .gen-header-btn:hover {
    background: var(--button-hover);
  }
  
  .gen-header-btn .caret {
    font-size: 12px;
    opacity: 0.7;
  }
  
  .gen-body {
    margin-top: 6px;
    padding: 8px 10px;
    border-radius: 12px;
    background: var(--button-bg);
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
    display: grid;
    gap: 8px;
  }
  
  .gen-body.collapsed {
    display: none;
  }
  
  .gen-row {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }
  
  .gen-btn {
    flex: 1;
    min-width: 90px;
    padding: 6px 10px;
    border-radius: 10px;
    border: 0;
    background: var(--button-bg);
    color: var(--button-text);
    cursor: pointer;
    font-size: 13px;
    font-weight: 500;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    transition: all 0.2s ease;
  }
  
  .gen-btn:hover {
    background: var(--button-hover);
    transform: translateY(-1px);
  }
  
  .gen-btn:active {
    transform: translateY(0);
  }
  
  .gen-btn.active {
    background: #4CAF50;
    color: white;
    font-weight: 700;
  }
  
  /* Pill toggles inside generate panel */
  .gen-pill {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
    padding: 6px 10px;
    border-radius: 9999px;
    background: var(--button-bg);
    color: var(--button-text);
    font-size: 13px;
    width: 100%;
    cursor: pointer;
    transition: all 0.2s ease;
  }
  
  .gen-pill:hover {
    background: var(--button-hover);
  }
  
  .gen-pill-label {
    white-space: nowrap;
  }
  
  .gen-switch {
    position: relative;
    width: 34px;
    height: 18px;
    border-radius: 9999px;
    background: #4b5563;
    flex: 0 0 auto;
  }
  
  .gen-thumb {
    position: absolute;
    top: 2px;
    left: 2px;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: #f9fafb;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    transition: transform 0.15s ease;
  }
  
  .gen-pill.active .gen-switch {
    background: #4CAF50;
  }
  
  .gen-pill.active .gen-thumb {
    transform: translateX(16px);
  }
  
  /* === UNDO/REDO BUTTONS === */
  .undo-redo-row {
    display: flex;
    gap: 0;
    margin-bottom: 6px;
  }
  
  .undo-btn, .redo-btn {
    flex: 1 1 50%;
    padding: 6px 8px;
    border: 0;
    background: var(--button-bg);
    color: var(--button-text);
    cursor: pointer;
    font-size: 13px;
    font-weight: 500;
    transition: all 0.2s ease;
  }
  
  .undo-btn {
    border-radius: 10px 0 0 10px;
  }
  
  .redo-btn {
    border-radius: 0 10px 10px 0;
  }
  
  .undo-btn:hover, .redo-btn:hover {
    background: var(--button-hover);
  }
  
  .undo-btn:active, .redo-btn:active {
    background: var(--button-active);
  }
  
  /* === SIDEBAR TOOL BUTTONS === */
  .sidebar .tool-btn {
    width: 100%;
    padding: 7px 10px;
    border-radius: 10px;
    border: 0;
    background: var(--button-bg);
    color: var(--button-text);
    cursor: pointer;
    text-align: left;
    font-size: 13px;
    font-weight: 500;
    margin-bottom: 6px;
    transition: all 0.2s ease;
  }
  
  .sidebar .tool-btn:hover {
    background: var(--button-hover);
  }
  
  .sidebar .tool-btn:active {
    background: var(--button-active);
  }
  
  .sidebar .tool-btn.active {
    background: #4CAF50;
    color: white;
    font-weight: 700;
  }
  
  /* Arrow pill specific styling in sidebar */
  .sidebar .gen-pill {
    margin-bottom: 6px;
    width: calc(100% - 20px);
    margin-left: 0px;
    margin-right: 10px;
  }
  
  /* === LAYER BUTTONS === */
  .layer-buttons {
    display: flex;
    gap: 8px;
    margin-bottom: 6px;
  }
  
  .layer-btn {
    flex: 1;
    padding: 7px 10px;
    border-radius: 10px;
    border: 0;
    background: var(--button-bg);
    color: var(--button-text);
    cursor: pointer;
    font-size: 13px;
    font-weight: 500;
    transition: all 0.2s ease;
  }
  
  .layer-btn:hover {
    background: var(--button-hover);
  }
  
  .layer-btn:active {
    background: var(--button-active);
  }
  
  /* === RIGHT SIDEBAR === */
  .sidebar-right {
    position: fixed;
    right: 0;
    top: 0;
    bottom: 0;
    width: 240px;
    padding: 64px 12px 16px 12px;
    background: var(--sidebar-bg);
    color: var(--sidebar-text);
    box-shadow: -4px 0 18px rgba(0, 0, 0, 0.22);
    z-index: 900;
    overflow-y: auto;
    overflow-x: hidden;
    transition: transform 0.3s ease;
  }
  
  .sidebar-right.collapsed {
    transform: translateX(240px);
  }
  
/* Sidebar toggle buttons - Overleaf style */
.sidebar-toggle {
  position: fixed;
  top: 52px;  /* Start below topbar */
  bottom: 0;
  width: 9px;
  background: #9ca3af;  /* Gray bar */
  cursor: pointer;
  z-index: 1000;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  border: none;
  transition: background 0.18s ease, left 0.3s ease, right 0.3s ease;
}



/* Green button in the middle */
.sidebar-toggle::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 0;
  transform: translateY(-50%);
  width: 8px;
  height: 56px;  /* ~1.5cm */
  background: #4CAF50;
  border-radius: 4px;
  border: 1px solid rgba(0, 0, 0, 0.15);
  box-shadow: 0 0px 8px rgba(0, 0, 0, 0.15);
  transition: background 0.18s ease;
  pointer-events: none;
}

.sidebar-toggle:hover::after {
  background: #45a049;
}

/* LEFT SIDEBAR TOGGLE - immediately to the RIGHT of left sidebar */
.sidebar-toggle-left {
  left: 261px;
}

/* When left sidebar is collapsed */
.sidebar.collapsed {
  transform: translateX(-270px);
}

.sidebar-toggle-left.sidebar-collapsed {
  left: 0;
}

/* RIGHT SIDEBAR TOGGLE - immediately to the LEFT of right sidebar */
.sidebar-toggle-right {
  right: 261px;
}

/* When right sidebar is collapsed */
.sidebar-right.collapsed {
  transform: translateX(270px);
}

.sidebar-toggle-right.sidebar-collapsed {
  right: 0;
}

/* Chevron styling */
.chev-svg {
  width: 10px;
  height: 20px;
  display: block;
  position: relative;
  z-index: 1;
  filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.3));
}

.chev-path {
  fill: none;
  stroke: #ffffff;
  stroke-width: 3.2;
  stroke-linecap: round;
  stroke-linejoin: round;
}


  
  /* Grid dimension controls in right sidebar */
  .grid-dimensions {
    margin-bottom: 12px;
    padding: 10px;
    border-radius: 10px;
    background: var(--button-bg);
  }
  
  .grid-dim-label {
    font-size: 12px;
    color: #ffffff;
    margin-bottom: 6px;
    text-align: center;
  }
  
  .grid-dim-inputs {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 4px;
  }
  
  .grid-dim-inputs input {
    width: 40px;
    padding: 4px;
    border: 1px solid #4b5563;
    border-radius: 4px;
    background: rgba(0, 0, 0, 0.3);
    color: var(--button-text);
    font-size: 12px;
    text-align: center;
  }
  
  .grid-dim-inputs span {
    opacity: 0.5;
    font-size: 12px;
  }
  
  /* View pills for right sidebar */
  .view-pill {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
    padding: 6px 10px;
    border-radius: 9999px;
    background: var(--button-bg);
    color: var(--button-text);
    font-size: 13px;
    width: 100%;
    cursor: pointer;
    transition: all 0.2s ease;
    margin-bottom: 6px;
  }
  
  .view-pill:hover {
    background: var(--button-hover);
  }
  
  .view-pill.active .gen-switch {
    background: #4CAF50;
  }
  
  .view-pill.active .gen-thumb {
    transform: translateX(16px);
  }
  
  /* Grid management buttons */
  .grid-mgmt-row {
    display: flex;
    gap: 6px;
    margin-bottom: 12px;
  }
  
  .grid-mgmt-btn {
    flex: 1;
    padding: 7px 10px;
    border-radius: 10px;
    border: 0;
    background: var(--button-bg);
    color: var(--button-text);
    cursor: pointer;
    font-size: 13px;
    font-weight: 500;
    transition: all 0.2s ease;
  }
  
  .grid-mgmt-btn:hover {
    background: var(--button-hover);
  }
  
  .grid-mgmt-btn:active {
    background: var(--button-active);
  }
  
  /* Plane Highlighter in right sidebar */
  .plane-panel {
    margin-top: 12px;
  }
  
  .plane-header-btn {
    width: 100%;
    padding: 7px 10px;
    border-radius: 10px;
    border: 0;
    background: var(--button-bg);
    color: var(--button-text);
    cursor: pointer;
    text-align: left;
    font-size: 13px;
    font-weight: 500;
    display: flex;
    justify-content: space-between;
    align-items: center;
    transition: all 0.2s ease;
  }
  
  .plane-header-btn:hover {
    background: var(--button-hover);
  }
  
  .plane-body {
    margin-top: 6px;
    padding: 10px;
    border-radius: 10px;
    background: var(--button-bg);
    display: grid;
    gap: 10px;
  }
  
  .plane-body.collapsed {
    display: none;
  }
  
  .plane-row {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 11px;
    color: #ffffff;
    /* Removed flex-wrap to keep everything in one row */
  }
  
  .plane-row input[type="number"] {
    width: 28px;  /* Increased to fit 3 digits comfortably */
    padding: 3px;
    border: 1px solid #4b5563;
    border-radius: 4px;
    background: rgba(0, 0, 0, 0.3);
    color: var(--button-text);
    font-size: 11px;
    text-align: center;
  }
  
  .plane-slider-row {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 11px;
    color: #ffffff;
  }
  
  .plane-slider-row input[type="range"] {
    width: 80px; /* Fixed width to prevent overflow */
  }
  
  .plane-buttons {
    display: flex;
    gap: 6px;
  }
  
  .plane-btn {
    flex: 1;
    padding: 6px 10px;
    border-radius: 8px;
    border: 0;
    cursor: pointer;
    font-size: 12px;
    font-weight: 500;
    transition: all 0.2s ease;
  }
  
  .plane-btn-add {
    background: #3498db;
    color: white;
  }
  
  .plane-btn-add:hover {
    background: #2980b9;
  }
  
  .plane-btn-remove {
    background: #e74c3c;
    color: white;
  }
  
  .plane-btn-remove:hover {
    background: #c0392b;
  }
  
  .plane-checkbox-row {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 12px;
  }
  
  .plane-checkbox-row input[type="checkbox"] {
    cursor: pointer;
  }
  
  .plane-rel-row {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 11px;
  }
  
  .plane-rel-row input {
    width: 35px;
    padding: 2px;
    border: 1px solid #4b5563;
    border-radius: 4px;
    background: rgba(0, 0, 0, 0.3);
    color: var(--button-text);
    font-size: 11px;
    text-align: center;
  }
  
  /* Coordinate hover section */
  .coord-hover-section {
    margin-top: 12px;
    margin-bottom: 12px;
    padding: 8px;
    border-radius: 8px;
    background: var(--button-bg);
  }
  
  .coord-checkbox-row {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 6px 8px;
    border-radius: 0;
    background: transparent;
    font-size: 12px;
    margin-bottom: 0;
    color: #ffffff;
  }
  
  .coord-checkbox-row:first-child {
    padding-bottom: 8px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    margin-bottom: 8px;
  }
  
  .coord-checkbox-row input[type="checkbox"] {
    cursor: pointer;
  }
  
  .coord-checkbox-row.disabled {
    /* Removed opacity to keep text visible */
  }
  
  .coord-checkbox-row.disabled input[type="checkbox"] {
    cursor: not-allowed;
  }
  
  .coord-checkbox-row.disabled label {
    cursor: not-allowed;
  }
  
  .coord-rel-inputs {
    display: flex;
    align-items: center;
    gap: 4px;
    margin-left: 8px;
  }
  
  .coord-rel-inputs input {
    width: 35px;
    padding: 3px;
    border: 1px solid #4b5563;
    border-radius: 4px;
    background: rgba(0, 0, 0, 0.3);
    color: var(--button-text);
    font-size: 11px;
    text-align: center;
  }
  
  /* Grid dimmer in right sidebar */
  .grid-dimmer-section {
    margin-top: 12px;
    margin-bottom: 12px;
    padding: 10px;
    border-radius: 10px;
    background: var(--button-bg);
  }
  
  .grid-dimmer-label {
    font-size: 12px;
    margin-bottom: 6px;
    color: #FFFFFF;
  }
  
  .grid-dimmer-row {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .grid-dimmer-row input[type="range"] {
    flex: 1;
  }
  
  .grid-dimmer-row span {
    font-size: 11px;
    min-width: 35px;
    color: #FFFFFF;
  }
  
  /* Grid notes button styling */
  #notesBtn {
    background: linear-gradient(145deg, #FFD966, #FFEB99) !important;
    color: #333 !important;
    border: 1px solid #D4AF37;
    padding: 14px 10px !important; /* 2x height - EDIT THIS VALUE to change button height */
    font-family: 'Source Code Pro', monospace !important;
    font-size: 13px !important;
    font-weight: 500 !important;
  }
  
  #notesBtn:hover {
    background: linear-gradient(145deg, #FFEB99, #FFF4CC) !important;
  }
  
  /* Add Grid and Duplicate Grid buttons - 2x taller */
  #addGridBtn, #duplicateBtn {
    padding: 14px 10px !important; /* 2x height - EDIT THIS VALUE to change button height */
    font-family: 'Source Code Pro', monospace !important;
    font-size: 13px !important;
    font-weight: 500 !important;
  }
  
  /* View pill overrides for right sidebar */
  .sidebar-right .view-pill {
    width: calc(100% - 20px);
    margin-left: 0px;
    margin-right: 10px;
  }
  
  /* === BB DISTANCE PANEL === */
  .bb-panel {
    margin-top: 8px;
    margin-bottom: 8px;
  }
  
  .bb-header-btn {
    width: 100%;
    padding: 7px 10px;
    border-radius: 10px;
    border: 0;
    background: var(--button-bg);
    color: var(--button-text);
    cursor: pointer;
    text-align: left;
    font-size: 13px;
    font-weight: 500;
    display: flex;
    justify-content: space-between;
    align-items: center;
    transition: all 0.2s ease;
  }
  
  .bb-header-btn:hover {
    background: var(--button-bg);
  }
  
  .bb-header-btn .caret {
    font-size: 12px;
    opacity: 0.7;
  }
  
  .bb-body {
    margin-top: 6px;
    padding: 10px 12px;
    border-radius: 10px;
    background: var(--button-bg);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  
  .bb-body.collapsed {
    display: none;
  }
  
  .bb-row {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    color: var(--button-text);
  }
  
  .bb-row input[type="number"] {
    width: 36px;
    padding: 4px 6px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 6px;
    background: rgba(0, 0, 0, 0.3);
    color: var(--button-text);
    font-size: 12px;
    text-align: center;
    -moz-appearance: textfield;
  }
  
  .bb-row input[type="number"]::-webkit-inner-spin-button,
  .bb-row input[type="number"]::-webkit-outer-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }
  
  .bb-row input[type="number"]:focus {
    outline: none;
    border-color: rgba(52, 152, 219, 0.6);
  }
  
  .bb-action-btn {
    width: 100%;
    padding: 6px 10px;
    border: 0;
    border-radius: 6px;
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
  }
  
  .bb-add-btn {
    background: #3498db;
    color: white;
  }
  
  .bb-add-btn:hover {
    background: #2980b9;
  }
  
  .bb-clear-btn {
    background: #e74c3c;
    color: white;
  }
  
  .bb-clear-btn:hover {
    background: #c0392b;
  }
  





/* === COLOR PANEL === */
  .color-panel {
    margin-top: 8px;
    padding: 16px;
    border-radius: 12px;
    background: var(--button-bg);
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
    display: flex;
    flex-direction: column;
  }
  
  .color-panel label {
    color: #ecf0f1;
    font-family: inherit;
    font-weight: 500;
    font-size: 13px;
  }
  
  .color-panel input[type="color"] {
    width: 40px;
    height: 40px;
    border: 3px solid #ecf0f1;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
  }
  
  .color-panel input[type="color"]:hover {
    border-color: #3498db;
    box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
  }
  
  .color-disk {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    border: 2px solid #ecf0f1;
    cursor: pointer;
    transition: all 0.2s ease;
    pointer-events: auto;
    position: relative;
  }
  
  .color-disk:hover {
    transform: scale(1.1);
    border-color: #3498db;
    box-shadow: 0 0 6px rgba(52, 152, 219, 0.4);
  }
  
  /* Active/Inactive color label states */
  .color-label-active {
    font-weight: 700 !important;
    color: #ffffff !important;
    text-shadow: 0 0 4px rgba(255, 255, 255, 0.3);
  }
  
  .color-label-inactive {
    font-weight: 400 !important;
    color: #888888 !important;
    opacity: 0.6;
  }
  
  /* Active/Inactive color input states */
  .color-input-active {
    border-color: #3498db !important;
    box-shadow: 0 0 8px rgba(52, 152, 219, 0.4) !important;
    transform: scale(1.05);
  }
  
  .color-input-inactive {
    border-color: #555555 !important;
    opacity: 0.7;
    transform: scale(1.0);
  }
  
  
  
  /* Remove spinners from number inputs with data-no-spinner attribute */
	input[type="number"][data-no-spinner] {
	  -webkit-appearance: textfield;
	  -moz-appearance: textfield;
	}

	input[type="number"][data-no-spinner]::-webkit-outer-spin-button,
	input[type="number"][data-no-spinner]::-webkit-inner-spin-button {
	  -webkit-appearance: none;
	  margin: 0;
	}

  canvas {
    display: block;
  }

  /* === BUTTON PANEL STYLES === */
  .control-button {
    position: absolute;
    left: 16px;
    z-index: 10;
    padding: 12px 16px;
    background: linear-gradient(145deg, #f0f0f0, #e0e0e0);
    border: none;
    border-radius: 8px;
    box-shadow: 
      0 4px 8px rgba(0, 0, 0, 0.1),
      0 2px 4px rgba(0, 0, 0, 0.06);
    font-family: inherit;
    font-weight: 500;
    font-size: 13px;
    cursor: pointer;
    width: 130px;
    text-align: center;
    transition: all 0.2s ease;
    color: #333;
  }

  .control-button:hover {
    background: linear-gradient(145deg, #e8e8e8, #d8d8d8);
    box-shadow: 
      0 6px 12px rgba(0, 0, 0, 0.15),
      0 3px 6px rgba(0, 0, 0, 0.1);
    transform: translateY(-1px);
  }

  .control-button:active {
    transform: translateY(0);
    box-shadow: 
      0 2px 4px rgba(0, 0, 0, 0.1),
      0 1px 2px rgba(0, 0, 0, 0.06);
  }

  /* === BUTTON POSITIONS === */
  /* Group 1: Main Operations */
  #genH0Btn       { top: 16px; }
  #genCycleBtn    { top: 60px; }
  #checkHamBtn    { top: 104px; }
  #backbiteBtn    { top: 148px; }
  #switchBtn      { top: 192px; }
  
  /* Group 2: Pill Switches (with spacing) */
  #gradientBtn    { top: 246px; }
  #arrowBtn       { top: 284px; }

  /* Group 3: Editing Tools (with extra spacing) */
  #toggleClickBtn { top: 332px; }
  #cubeBtn        { top: 376px; }
  
  
  #verticesBtn    { top: 388px; }
  #addLayerBtn    { top: 434px; }
  #removeLayerBtn { top: 478px; }

  /* Group 3: Grid Management (with spacing) */
  #dimensionControls { top: 642px; }
  #addGridBtn     { top: 701px; }
  #duplicateBtn   { top: 761px; }


  
  /* === PILL SWITCH STYLES === */
  .pill-switch {
    position: absolute;
    right: 16px;
    z-index: 10;
    display: inline-flex;
    align-items: center;
    gap: 10px;
    padding: 8px 12px;
    background: linear-gradient(145deg, #f0f0f0, #e0e0e0);
    border-radius: 20px;
    box-shadow: 
      0 4px 8px rgba(0, 0, 0, 0.1),
      0 2px 4px rgba(0, 0, 0, 0.06);
    cursor: pointer;
    transition: all 0.2s ease;
    user-select: none;
  }
  
  .pill-switch:hover {
    background: linear-gradient(145deg, #e8e8e8, #d8d8d8);
    box-shadow: 
      0 6px 12px rgba(0, 0, 0, 0.15),
      0 3px 6px rgba(0, 0, 0, 0.1);
    transform: translateY(-1px);
  }
  
  .pill-switch-label {
    font-family: inherit;
    font-weight: 500;
    font-size: 13px;
    color: #333;
  }
  
  .pill-switch-toggle {
    position: relative;
    width: 40px;
    height: 20px;
    background: #ccc;
    border-radius: 10px;
    transition: background 0.3s ease;
  }
  
  .pill-switch-toggle::after {
    content: '';
    position: absolute;
    top: 2px;
    left: 2px;
    width: 16px;
    height: 16px;
    background: white;
    border-radius: 50%;
    transition: transform 0.3s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  }
  
  .pill-switch.active .pill-switch-toggle {
    background: #4CAF50;
  }
  
  .pill-switch.active .pill-switch-toggle::after {
    transform: translateX(20px);
  }
  
  /* Right side buttons - NEW POSITIONS */
	#saveBtn        { top: 76px; right: 16px; left: auto; }
	#loadBtn        { top: 120px; right: 16px; left: auto; }
	#preferencesBtn { top: 164px; right: 16px; left: auto; }

	/* Right side buttons G_1*/
	#toggleGridBtn  { top: 258px; right: 16px; left: auto; }
	#coordBtn       { top: 302px; right: 16px; left: auto; }
	/* syncViewBtn removed - now inline in sidebar */

/* === HORIZONTAL GRID LIST PANEL === */
#gridList {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 10;
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  gap: 10px;
  max-width: 85%;
  justify-content: center;
  padding: 12px 16px;
  background: rgba(255, 255, 255, 0.95);
  border: 2px solid #d0d0d0;
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  max-height: 140px;
  overflow-y: auto;
}

.grid-btn {
  position: relative;
  padding: 10px 28px 10px 12px;
  background: linear-gradient(145deg, #f8f8f8, #e8e8e8);
  border: none;
  border-radius: 6px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  cursor: grab;
  font-family: inherit;
  font-size: 14px;
  font-weight: 500;
  color: #444;
  transition: all 0.2s ease;
  width: 110px;
  white-space: nowrap;
}

.grid-btn:hover {
  background: linear-gradient(145deg, #f0f0f0, #e0e0e0);
  transform: translateY(-1px);
}

.grid-btn.dragging {
  opacity: 0.5;
  cursor: grabbing;
}

.grid-btn.drag-over {
  border: 2px dashed #3498db;
}

.grid-info {
  font-size: 9px;
  color: #888;
  opacity: 0.7;
  margin-top: 2px;
  pointer-events: none;
}

.grid-btn .close {
  position: absolute;
  right: 2px;
  top: -4px;
  transform: none;
  font-size: 16px;
  font-weight: 1500;
  color: #e74c3c;
  cursor: pointer;
  transition: color 0.2s ease;
  z-index: 1;
}

.grid-btn .close:hover {
  color: #c0392b;
}

.grid-btn.active {
  background: linear-gradient(145deg, #3498db, #2980b9);
  color: white;
  box-shadow: 
    0 6px 12px rgba(52, 152, 219, 0.3),
    0 3px 6px rgba(52, 152, 219, 0.2);
  border: 2px solid #2980b9;
}

.grid-btn.active .grid-info {
  color: white;
  opacity: 0.9;
}

	 
 /* === DIMENSION CONTROLS === */
 
    #dimensionControls input[type="number"] {
	  -webkit-appearance: textfield;
	  -moz-appearance: textfield;
	}

	#dimensionControls input[type="number"]::-webkit-outer-spin-button,
	#dimensionControls input[type="number"]::-webkit-inner-spin-button {
	  -webkit-appearance: none;
	  margin: 0;
	} 
 
	#dimensionControls {
	 position: absolute;
	 bottom: 140px;
	 left: 160px;
	 z-index: 10;
	 background: linear-gradient(145deg, #f0f0f0, #e0e0e0);
	 padding: 8px 12px;
	 border: none;
	 border-radius: 8px;
	 box-shadow: 
	   0 4px 8px rgba(0, 0, 0, 0.1),
	   0 2px 4px rgba(0, 0, 0, 0.06);
	 display: flex;
	 flex-direction: column;
	 gap: 4px;
	 font-family: inherit;
	 font-weight: 500;
	 font-size: 13px;
	 color: #333;
	 width: 130px;
	}

	#dimensionControls input {
	 width: 35px;
	 padding: 3px 4px;
	 border: 1px solid #ccc;
	 border-radius: 3px;
	 font-family: inherit;
	 font-size: 11px;
	 text-align: center;
	}

 /* === COLOR PICKER === */
   #colorPicker {
     position: absolute;
     bottom: 20px;
     right: 20px;
     z-index: 10;
     background: linear-gradient(145deg, #2c3e50, #34495e);
     padding: 16px;
     border-radius: 12px;
     box-shadow: 
   	0 8px 16px rgba(0, 0, 0, 0.2),
   	0 4px 8px rgba(0, 0, 0, 0.1);
     display: flex;
     align-items: center;
     gap: 12px;
   }

   #colorPicker label {
     color: #ecf0f1;
     font-family: inherit;
     font-weight: 500;
     font-size: 13px;
   }

   #colorInput {
     width: 40px;
     height: 40px;
     border: 3px solid #ecf0f1;
     border-radius: 8px;
     cursor: pointer;
     transition: all 0.2s ease;
   }

   #colorInput:hover {
     border-color: #3498db;
     box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
   }

   .color-disk {
     width: 20px;
     height: 20px;
     border-radius: 50%;
     border: 2px solid #ecf0f1;
     cursor: pointer;
     transition: all 0.2s ease;
     pointer-events: auto;
     position: relative;
     z-index: 1001;
   }

   .color-disk:hover {
     transform: scale(1.1);
     border-color: #3498db;
     box-shadow: 0 0 6px rgba(52, 152, 219, 0.4);
   }

   #colorPicker2 {
     position: absolute;
     bottom: 105px;
     right: 20px;
     z-index: 10;
     background: linear-gradient(145deg, #2c3e50, #34495e);
     padding: 16px;
     border-radius: 12px;
     box-shadow: 
   	0 8px 16px rgba(0, 0, 0, 0.2),
   	0 4px 8px rgba(0, 0, 0, 0.1);
     display: flex;
     align-items: center;
     gap: 12px;
   }

   #colorPicker2 label {
     color: #ecf0f1;
     font-family: inherit;
     font-weight: 500;
     font-size: 13px;
   }

   #colorInput2 {
     width: 40px;
     height: 40px;
     border: 3px solid #ecf0f1;
     border-radius: 8px;
     cursor: pointer;
     transition: all 0.2s ease;
   }

   #colorInput2:hover {
     border-color: #3498db;
     box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
   }
   
   /* Active/Inactive color label states */
	.color-label-active {
	  font-weight: 700 !important;
	  color: #ffffff !important;
	  text-shadow: 0 0 4px rgba(255, 255, 255, 0.3);
	}

	.color-label-inactive {
	  font-weight: 400 !important;
	  color: #888888 !important;
	  opacity: 0.6;
	}

	/* Active/Inactive color input states */
	.color-input-active {
	  border-color: #3498db !important;
	  box-shadow: 0 0 8px rgba(52, 152, 219, 0.4) !important;
	  transform: scale(1.05);
	}

	.color-input-inactive {
	  border-color: #555555 !important;
	  opacity: 0.7;
	  transform: scale(1.0);
	}

  /* === SCROLLBAR STYLING === */
  #gridList::-webkit-scrollbar {
    width: 6px;
    height: 6px;
  }

  #gridList::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 3px;
  }

  #gridList::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.3);
    border-radius: 3px;
  }

  #gridList::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.5);
  }

  /* === ACTIVE STATE STYLING === */
  .control-button.active {
    background: linear-gradient(145deg, #3498db, #2980b9);
    color: white;
    box-shadow: 
      0 4px 8px rgba(52, 152, 219, 0.3),
      0 2px 4px rgba(52, 152, 219, 0.2);
  }

  .control-button.active:hover {
    background: linear-gradient(145deg, #2980b9, #1f618d);
  }


  
  /* Keyboard Shortcuts Button Hover Effect */
#keyboardShortcutsBtn:hover {
  background: rgba(255, 255, 255, 1) !important;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.25) !important;
}

/* Close Button Hover Effect */
#closeShortcutsModal:hover {
  background: #f0f0f0 !important;
  color: #333 !important;
}

/* Modal Scrollbar Styling */
#keyboardShortcutsModal > div::-webkit-scrollbar {
  width: 8px;
}

#keyboardShortcutsModal > div::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 4px;
}

#keyboardShortcutsModal > div::-webkit-scrollbar-thumb {
  background: #888;
  border-radius: 4px;
}

#keyboardShortcutsModal > div::-webkit-scrollbar-thumb:hover {
  background: #555;
}






/* Help Button Hover Effect */
#helpBtn:hover {
  background: rgba(255, 255, 255, 1) !important;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.25) !important;
}

/* Help Dropdown Menu Item Hover */
.help-menu-item:hover {
  background: #f5f5f5 !important;
}

/* Close Button Hover Effect (if not already added) */
#closeAboutModal:hover {
  background: #f0f0f0 !important;
  color: #333 !important;
}

/* Modal Scrollbar Styling (if not already added) */
#aboutModal > div::-webkit-scrollbar {
  width: 8px;
}

#aboutModal > div::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 4px;
}

#aboutModal > div::-webkit-scrollbar-thumb {
  background: #888;
  border-radius: 4px;
}

#aboutModal > div::-webkit-scrollbar-thumb:hover {
  background: #555;
}




/* Preferences Modal Styling */
#preferencesModal input[type="checkbox"]:hover {
  transform: scale(1.1);
}

#savePreferencesBtn:hover {
  background: #2980b9 !important;
}


#preferencesModal label:hover {
  color: #3498db;
}

/* Preference row hover */
#preferencesModal > div > div > div:hover {
  background: #f8f9fa;
}



/* GridLab Logo Icon */
.gridlab-icon {
  width: 1.4em;
  height: 1.4em;
  vertical-align: -0.18em;
  margin-right: 0.35em;  /* space between icon and text */
}
.gridlab-icon .gl-bg {
  fill: #050814;
}

.gridlab-icon .gl-grid {
  stroke: #888888;
  stroke-width: 3;
}

.gridlab-icon .gl-nodes {
  fill: #dfe4ff;
}
.gridlab-icon .gl-path {
  fill: none;
  stroke: #00d9ff;  /* cyan */
  stroke-width: 6;
  stroke-linecap: round;
  stroke-linejoin: round;
}
.gridlab-icon .gl-marker {
  fill: #00d9ff;  /* cyan */
}


</style>

<!-- Source Code Pro Font -->
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;500;600&display=swap" rel="stylesheet">

</head>
<body>

<!-- Top Bar -->
<div class="topbar">
  <div class="topbar-inner">
    <div class="tb-left">
      <svg class="gridlab-icon" viewBox="0 0 100 100" aria-hidden="true">
        <rect x="0" y="0" width="100" height="100" rx="16" class="gl-bg" />
        <g class="gl-grid">
          <line x1="20" y1="20" x2="20" y2="80" />
          <line x1="50" y1="20" x2="50" y2="80" />
          <line x1="80" y1="20" x2="80" y2="80" />
          <line x1="20" y1="20" x2="80" y2="20" />
          <line x1="20" y1="50" x2="80" y2="50" />
          <line x1="20" y1="80" x2="80" y2="80" />
        </g>
        <g class="gl-nodes">
          <circle cx="20" cy="80" r="1.8" />
          <circle cx="50" cy="80" r="1.8" />
          <circle cx="80" cy="80" r="1.8" />
          <circle cx="20" cy="50" r="1.8" />
          <circle cx="50" cy="50" r="1.8" />
          <circle cx="80" cy="50" r="1.8" />
          <circle cx="20" cy="20" r="1.8" />
          <circle cx="50" cy="20" r="1.8" />
          <circle cx="80" cy="20" r="1.8" />
        </g>
        <path class="gl-path" d="M 50 50 L 80 50 L 80 80 L 20 80 L 20 20 L 80 20" stroke-width="8" />
        <rect x="44.5" y="44.5" width="11" height="11" rx="2" class="gl-marker" />
        <rect x="74.5" y="14.5" width="11" height="11" rx="2" class="gl-marker" />
      </svg>
      GridLab <span>v1.0</span>
    </div>
    <div class="tb-right">
      <button class="tb-btn" id="preferencesBtn">Preferences</button>
      <button class="tb-btn" id="saveBtn" title="Ctrl+S">Save</button>
      <button class="tb-btn" id="loadBtn" title="Ctrl+L">Load</button>
      <div class="help-btn-wrapper">
        <button class="tb-btn" id="helpBtn">Help</button>
        <div class="help-dropdown" id="helpDropdown">
          <div class="help-menu-item" data-action="about">About</div>
          <div class="help-menu-item" data-action="shortcuts">Keyboard Shortcuts</div>
          <div class="help-menu-item" data-action="readme">README</div>
          <div style="height: 1px; background: rgba(0, 0, 0, 0.1); margin: 4px 0;"></div>
          <div class="help-license-info">
            <strong>üìÑ License</strong>
            Licensed under <a href="https://polyformproject.org/licenses/noncommercial/1.0.0" target="_blank">PolyForm Noncommercial 1.0.0</a>
            <br><br>
            ‚úÖ Free for research, education, personal use<br>
            ‚ùå Commercial use requires license
            <br><br>
            Contact: <a href="mailto:albijuventus@yahoo.com">albijuventus@yahoo.com</a>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Left Sidebar -->
<aside class="sidebar">
  
  <!-- Generate Panel -->
  <div class="gen-panel">
    <button id="genHeader" class="gen-header-btn">
      <span>Generate</span>
      <span class="caret" id="genCaret">‚ñæ</span>
    </button>
    <div id="genBody" class="gen-body">
      <div class="gen-row">
        <button class="gen-btn" id="genPathBtn">Generate Hamiltonian Path</button>
      </div>
      <div class="gen-row">
        <button class="gen-btn" id="genCycleBtn">Generate Hamiltonian Cycle</button>
      </div>
      <div class="gen-row">
        <button class="gen-btn" id="checkHamBtn">Check Hamiltonicity</button>
      </div>
      <div class="gen-row">
        <div class="gen-pill" id="switchPill">
          <span class="gen-pill-label">Switch mode</span>
          <div class="gen-switch"><div class="gen-thumb"></div></div>
        </div>
      </div>
      <div class="gen-row">
        <div class="gen-pill" id="backbitePill">
          <span class="gen-pill-label">Backbite mode</span>
          <div class="gen-switch"><div class="gen-thumb"></div></div>
        </div>
      </div>
      <div class="gen-row">
        <div style="display: flex; align-items: center; padding: 8px;">
          <input type="checkbox" id="gradientCheckbox" style="width: 18px; height: 18px; cursor: pointer; margin-right: 10px;">
          <label for="gradientCheckbox" style="cursor: pointer; font-size: 13px; color: var(--sidebar-text); user-select: none;">Gradient</label>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Undo/Redo -->
  <div class="undo-redo-row">
    <button class="undo-btn" id="undoBtn" title="Ctrl+Z">‚Ü∂ Undo</button>
    <button class="redo-btn" id="redoBtn" title="Ctrl+Y">Redo ‚Ü∑</button>
  </div>
  
  <!-- Main Editing Tools -->
  <button class="tool-btn" id="toggleClickBtn" title="Press E">Add Edge</button>
  <button class="tool-btn" id="cubeBtn" title="Shift+E">Decorate Edge</button>
  <div style="display: flex; align-items: center; padding: 8px; margin: 8px 0;">
    <input type="checkbox" id="arrowCheckbox" style="width: 18px; height: 18px; cursor: pointer; margin-right: 10px;">
    <label for="arrowCheckbox" style="cursor: pointer; font-size: 13px; color: var(--sidebar-text); user-select: none;">Arrows</label>
  </div>
  <button class="tool-btn" id="verticesBtn" title="Press V">Add Vertex</button>
  <button class="tool-btn" id="decorationBtn" title="Shift+V">Decorate Vertex</button>
  
  <!-- BB Distance Panel -->
  <div class="bb-panel">
    <button id="bbHeader" class="bb-header-btn">
      <span>Add vertices at BB distance</span>
      <span class="caret" id="bbCaret">‚ñæ</span>
    </button>
    <div id="bbBody" class="bb-body collapsed">
      <div class="bb-row">
        <span>At BB distance:</span>
        <input id="bbDistance" type="number" value="1" min="0">
        <span>from</span>
      </div>
      <div class="bb-row">
        <span>v*:</span>
        <input id="bbRefX" type="number" value="0" min="0" placeholder="X">
        <span>,</span>
        <input id="bbRefY" type="number" value="0" min="0" placeholder="Y">
        <span>,</span>
        <input id="bbRefZ" type="number" value="0" min="0" placeholder="Z">
      </div>
      <button id="colorBBDistanceBtn" class="bb-action-btn bb-add-btn">Add Vertices</button>
      <button id="clearBBDistanceBtn" class="bb-action-btn bb-clear-btn">Clear All Vertices</button>
    </div>
  </div>
  
  <!-- Layer Management -->
  <div class="layer-buttons">
    <button class="layer-btn" id="addLayerBtn">Add Layer</button>
    <button class="layer-btn" id="removeLayerBtn">Remove Layer</button>
  </div>
  
<!-- Color Panel -->
  <div class="color-panel">
    <div style="display: flex; align-items: center; gap: 16px; justify-content: space-between;">
      <!-- Main Color Section -->
      <div style="display: flex; flex-direction: column; align-items: center;">
        <label id="mainColorLabel" class="color-label" style="color: #ecf0f1; font-family: inherit; font-weight: 500; font-size: 13px; margin-bottom: 8px; cursor: pointer;">Main Color</label>
        <input type="color" id="colorInput" value="#0000ff" style="width: 40px; height: 40px; border: 3px solid #ecf0f1; border-radius: 8px; cursor: pointer; transition: all 0.2s ease;" />
      </div>
      
      <!-- Second Color Section -->
      <div style="display: flex; flex-direction: column; align-items: center;">
        <label id="secondColorLabel" class="color-label" style="color: #ecf0f1; font-family: inherit; font-weight: 500; font-size: 13px; margin-bottom: 8px; cursor: pointer;">Second Color</label>
        <input type="color" id="colorInput2" value="#ff0000" style="width: 40px; height: 40px; border: 3px solid #ecf0f1; border-radius: 8px; cursor: pointer; transition: all 0.2s ease;" />
      </div>
    </div>
    
    <!-- Shared Color Circles in Honeycomb Pattern -->
    <div style="display: flex; flex-direction: column; align-items: center; gap: 4px; margin-top: 12px;">
      <!-- Top row: 5 circles -->
      <div style="display: flex; gap: 6px;">
        <div class="color-disk" data-color="#0000ff" style="background: #0000ff;"></div>
        <div class="color-disk" data-color="#ff0000" style="background: #ff0000;"></div>
        <div class="color-disk" data-color="#00b300" style="background: #00b300;"></div>
        <div class="color-disk" data-color="#ffff00" style="background: #ffff00;"></div>
        <div class="color-disk" data-color="#ff7300" style="background: #ff7300;"></div>
      </div>
      
      <!-- Bottom row: 4 circles, offset -->
      <div style="display: flex; gap: 6px; margin-left: 13px;">
        <div class="color-disk" data-color="#d400ff" style="background: #d400ff;"></div>
        <div class="color-disk" data-color="#00fbff" style="background: #00fbff;"></div>
        <div class="color-disk" data-color="#00ff00" style="background: #00ff00;"></div>
        <div class="color-disk" data-color="#ffd500" style="background: #ffd500;"></div>
      </div>
    </div>
  </div>
</aside>

<!-- Sidebar Toggle Buttons -->
<button class="sidebar-toggle sidebar-toggle-left" id="leftSidebarToggle" title="Toggle left sidebar">
  <svg class="chev-svg" viewBox="0 0 12 24" aria-hidden="true">
    <path class="chev-path" d="M9 6 L4 12 L9 18" />
  </svg>
</button>
<button class="sidebar-toggle sidebar-toggle-right" id="rightSidebarToggle" title="Toggle right sidebar">
  <svg class="chev-svg" viewBox="0 0 12 24" aria-hidden="true">
    <path class="chev-path" d="M3 6 L8 12 L3 18" />
  </svg>
</button>

<!-- Right Sidebar -->
<aside class="sidebar-right">
  
  <!-- Grid Dimensions -->
  <div class="grid-dimensions">
    <div class="grid-dim-label">Grid Dimensions</div>
    <div class="grid-dim-inputs">
      <input id="widthInput" type="number" value="6" min="1" placeholder="W">
      <span>√ó</span>
      <input id="heightInput" type="number" value="6" min="1" placeholder="H">
      <span>√ó</span>
      <input id="depthInput" type="number" value="6" min="1" placeholder="D">
    </div>
  </div>
  
  <!-- Grid Management Buttons -->
  <div class="grid-mgmt-row">
    <button class="grid-mgmt-btn" id="addGridBtn">Add Grid</button>
    <button class="grid-mgmt-btn" id="duplicateBtn">Duplicate</button>
  </div>
  
  <!-- View Checkboxes -->
  <div style="display: flex; align-items: center; gap: 8px; padding: 8px; margin: 8px 0;">
    <input type="checkbox" id="toggleGridCheckbox" checked style="width: 18px; height: 18px; cursor: pointer; margin-right: 6px;">
    <label for="toggleGridCheckbox" style="cursor: pointer; font-size: 13px; color: var(--sidebar-text); user-select: none; flex: 1;">Toggle Grid</label>
    <button class="grid-mgmt-btn" id="syncViewBtn" title="Press S" style="flex: 0 0 auto; min-width: 85px; padding: 7px 10px; font-size: 13px; border-radius: 10px;">Sync View</button>
  </div>
  
  <div style="display: flex; align-items: center; padding: 8px; margin: 8px 0;">
    <input type="checkbox" id="coordCheckbox" style="width: 18px; height: 18px; cursor: pointer; margin-right: 10px;">
    <label for="coordCheckbox" style="cursor: pointer; font-size: 13px; color: var(--sidebar-text); user-select: none;">Toggle Axis</label>
  </div>
  
  <!-- Grid Dimmer -->
  <div class="grid-dimmer-section">
    <div class="grid-dimmer-label">Grid Dimmer</div>
    <div class="grid-dimmer-row">
      <input type="range" id="gridOpacitySlider" min="0.1" max="1" step="0.1" value="0.3">
      <span id="opacityValue">30%</span>
    </div>
  </div>
  
  <!-- Grid Notes (removed Sync View from here) -->
  <div class="grid-mgmt-row">
    <button class="grid-mgmt-btn" id="notesBtn">Grid Notes</button>
  </div>
  
  <!-- Coordinate Hover Section -->
  <div class="coord-hover-section">
    <div class="coord-checkbox-row">
      <input type="checkbox" id="coordinateHoverCheckbox">
      <label for="coordinateHoverCheckbox">Coordinate Hover</label>
    </div>
    
    <div class="coord-checkbox-row disabled" id="relativeCoordRow" title="Enable 'Coordinate Hover' first to use this feature">
      <input type="checkbox" id="relativeCoordinatesCheckbox" disabled>
      <label for="relativeCoordinatesCheckbox">Relative to v*:</label>
      <div class="coord-rel-inputs">
        <input type="number" id="refK" value="0">
        <input type="number" id="refL" value="0">
        <input type="number" id="refH" value="0">
      </div>
    </div>
  </div>
  
  <!-- Plane Highlighter Panel -->
  <div class="plane-panel">
    <button id="planeHeader" class="plane-header-btn">
      <span>Plane Highlighter</span>
      <span class="caret" id="planeCaret">‚ñæ</span>
    </button>
    <div id="planeBody" class="plane-body collapsed">
      <div class="plane-row">
        <input type="number" id="planeA" value="1" step="1">
        <span class="plane-coeff-label">x +</span>
        <input type="number" id="planeB" value="1" step="1">
        <span class="plane-coeff-label">y +</span>
        <input type="number" id="planeC" value="1" step="1">
        <span class="plane-coeff-label">z =</span>
        <input type="number" id="planeD" value="6" step="1">
      </div>
      
      <div class="plane-slider-row">
        <span class="plane-opacity-label">Opacity:</span>
        <input type="range" id="planeOpacity" min="0.05" max="0.5" step="0.05" value="0.15">
        <span id="planeOpacityValue" class="plane-opacity-value">15%</span>
      </div>
      
      <div class="plane-buttons">
        <button class="plane-btn plane-btn-add" id="addPlaneBtn">Add Plane</button>
        <button class="plane-btn plane-btn-remove" id="removePlaneBtn">Remove</button>
      </div>
      
      <!-- Plane list -->
      <div id="planeList" style="font-size: 10px; margin-top: 8px; max-height: 100px; overflow-y: auto; color: #ffffff;"></div>
    </div>
  </div>
  
  <!-- Camera Sensitivity Panel (shown/hidden by preference) -->
  <div class="camera-sensitivity-panel" id="cameraSensitivityPanel" style="display: none; margin-top: 12px; padding: 12px; background: rgba(255, 255, 255, 0.05); border-radius: 8px;">
    <div style="font-size: 12px; color: var(--sidebar-text); margin-bottom: 8px; font-weight: 500;">Camera Sensitivity</div>
    <div style="display: flex; align-items: center; gap: 8px;">
      <input type="range" id="mainCameraSensitivitySlider" min="0.1" max="2.0" step="0.1" value="1.0" style="flex: 1; cursor: pointer;">
      <span id="mainCameraSensitivityValue" style="font-size: 12px; color: var(--sidebar-text); min-width: 30px;">1.0</span>
    </div>
  </div>
  
</aside>



<!-- Group 1: Main Operations - MOVED TO SIDEBAR -->
<!-- <button id="genH0Btn" class="control-button" title="Generate Hamiltonian path">Gen Path</button> -->
<!-- <button id="genCycleBtn" class="control-button" title="Generate Hamiltonian cycle">Gen Cycle</button> -->
<!-- <button id="checkHamBtn" class="control-button">Hamiltonian ?</button> -->
<!-- <button id="backbiteBtn" class="control-button" title="Make backbite moves">Backbite Mode</button> -->
<!-- <button id="switchBtn" class="control-button" title="Make switch moves">Switch mode</button> -->
<!-- <div id="gradientBtn" class="pill-switch" style="left: 16px; right: auto; width: 105px; justify-content: space-between;">
  <span class="pill-switch-label">Gradient</span>
  <div class="pill-switch-toggle"></div>
</div> -->
<!-- Group 2: Editing Tools - MOVED TO SIDEBAR -->
<!-- <button id="toggleClickBtn" class="control-button" title="Press E">Add Edge</button>
<button id="cubeBtn" class="control-button" title="Shift+E">Decorate Edge</button>
<div id="arrowBtn" class="pill-switch" style="left: 16px; right: auto; width: 105px; justify-content: space-between;">
  <span class="pill-switch-label">Arrows</span>
  <div class="pill-switch-toggle"></div>
</div> -->




<style>
/* Remove spinner arrows from number inputs */
input[type=number]::-webkit-inner-spin-button,
input[type=number]::-webkit-outer-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

input[type=number] {
  -moz-appearance: textfield;
}
</style>






<!-- MOVED TO SIDEBAR -->
<!-- <button id="addLayerBtn" class="control-button">Add Layer ‚ñº</button>
<button id="removeLayerBtn" class="control-button">Remove Layer ‚ñº</button> -->



<!-- MOVED TO SIDEBAR -->
<!-- <div style="position: absolute; left: 16px; top: 522px; z-index: 10; display: flex; gap: 4px; width: 130px;">
  <button id="undoBtn" class="control-button" 
          style="position: relative; left: 0; top: 0; transform: none; width: 63px; padding: 8px;" title="Ctrl+Z">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
      <path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z" fill="#333"/>
    </svg>
  </button>
  <button id="redoBtn" class="control-button"
          style="position: relative; left: 0; top: 0; transform: none; width: 63px; padding: 8px;" title="Ctrl+Y">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
      <path d="M18.4 10.6C16.55 8.99 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7l-3.6 3.6z" fill="#333"/>
    </svg>
  </button>
</div> -->







<!-- Group 3: Grid Management - MOVED TO RIGHT SIDEBAR -->
<div id="dimensionControls" style="display: none;">
</div>

<!-- MOVED TO RIGHT SIDEBAR -->
<button id="oldAddGridBtn" class="control-button" style="display: none;"></button>
<button id="oldDuplicateBtn" class="control-button" style="display: none;"></button>
<div id="oldToggleGridBtn" class="pill-switch" style="display: none;"></div>
<div id="oldCoordBtn" class="pill-switch" style="display: none;"></div>
<button id="oldSyncViewBtn" class="control-button" style="display: none;"></button>

<div id="gridList"></div>





<div id="colorPicker" style="display: none;">
  <div style="display: flex; align-items: center; gap: 20px; justify-content: space-between;">
    <!-- Main Color Section -->
    <div style="display: flex; flex-direction: column; align-items: center;">
      <label id="mainColorLabel" style="color: #ecf0f1; font-family: inherit; font-weight: 500; font-size: 13px; margin-bottom: 8px; cursor: pointer;">Main Color</label>
      <input type="color" value="#0000ff" style="width: 40px; height: 40px; border: 3px solid #ecf0f1; border-radius: 8px; cursor: pointer; transition: all 0.2s ease;" />
    </div>
    
<!-- Shared Color Circles in Honeycomb Pattern -->
<div style="display: flex; flex-direction: column; align-items: center; gap: 4px;">
  <!-- Top row: 5 circles -->
  <div style="display: flex; gap: 6px;">
    <div class="color-disk" data-color="#0000ff" style="background: #0000ff;"></div>
    <div class="color-disk" data-color="#ff0000" style="background: #ff0000;"></div>
    <div class="color-disk" data-color="#00b300" style="background: #00b300;"></div>
    <div class="color-disk" data-color="#ffff00" style="background: #ffff00;"></div>
    <div class="color-disk" data-color="#ff7300" style="background: #ff7300;"></div>
  </div>
  
  <!-- Bottom row: 4 circles, offset -->
  <div style="display: flex; gap: 6px; margin-left: 13px;">
    <div class="color-disk" data-color="#d400ff" style="background: #d400ff;"></div>
    <div class="color-disk" data-color="#00fbff" style="background: #00fbff;"></div>
    <div class="color-disk" data-color="#00ff00" style="background: #00ff00;"></div>
    <div class="color-disk" data-color="#ffd500" style="background: #ffd500;"></div>
  </div>
</div>
    
    <!-- Second Color Section -->
    <div style="display: flex; flex-direction: column; align-items: center;">
      <label id="secondColorLabel" style="color: #ecf0f1; font-family: inherit; font-weight: 500; font-size: 13px; margin-bottom: 8px; cursor: pointer;">Second Color</label>
      <input type="color" value="#ff0000" style="width: 40px; height: 40px; border: 3px solid #ecf0f1; border-radius: 8px; cursor: pointer; transition: all 0.2s ease;" />
    </div>
  </div>
</div>







<!-- Hidden background select for theme management -->
<select id="backgroundSelect" style="display:none;">
  <option value="paper-white" selected >Paper White</option>
  <option value="dark">Dark</option>
  <option value="sandstone">Sandstone</option>
  <option value="mist-blue">Mist Blue</option>
  <option value="warm-light">Warm Light</option>
  <option value="light" >Contrast</option>
  
  
</select>




<!-- About Modal -->
<div id="aboutModal" style="display: none; position: fixed; top: 0; left: 0; 
     width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 2000; 
     align-items: center; justify-content: center;">
  <div style="background: white; border-radius: 12px; padding: 32px; max-width: 700px; 
       width: 90%; max-height: 85vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(0,0,0,0.3); 
       position: relative; line-height: 1.6;">
    
    <!-- Close Button -->
    <button id="closeAboutModal" style="position: absolute; top: 16px; right: 16px; 
            background: none; border: none; font-size: 28px; cursor: pointer; color: #666; 
            padding: 0; width: 32px; height: 32px; line-height: 28px; border-radius: 4px;
            transition: all 0.2s;">√ó</button>
    
    <!-- About Content -->
    <h2 style="margin: 0 0 8px 0; font-size: 28px; color: #333; font-weight: 600;">About GridLab</h2>
    
    <div style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 12px 16px; margin: 0 0 20px 0; border-radius: 4px;">
      <p style="margin: 0; color: #856404; font-size: 14px; font-weight: 500;">
        ‚ö†Ô∏è GridLab v1.0 is work in progress. Expect quirks.
      </p>
    </div>
    
    <p style="color: #555; font-size: 15px; margin: 0 0 24px 0;">
      GridLab is an interactive 2D/3D playground for grid graphs. It lets you generate, visualize, 
      and reconfigure Hamiltonian paths and cycles on rectangular and cuboid grids.
    </p>
    
    <h3 style="font-size: 18px; color: #333; margin: 24px 0 12px 0; font-weight: 600;">What you can do</h3>
    <ul style="color: #555; font-size: 14px; margin: 0 0 20px 0; padding-left: 24px;">
      <li style="margin-bottom: 8px;"><strong>Generate</strong> Hamiltonian paths/cycles; check "Hamiltonian?"; color by gradient; show arrows.</li>
      <li style="margin-bottom: 8px;"><strong>Reconfigure</strong> using Switch and Backbite moves.</li>
      <li style="margin-bottom: 8px;"><strong>See components:</strong> after a switch, if a cycle splits, GridLab colors components separately.</li>
      <li style="margin-bottom: 8px;"><strong>Edit/Build grids:</strong> add/remove vertices, edges, cubes, layers; duplicate grids; per-grid notes.</li>
      <li style="margin-bottom: 8px;"><strong>View/Navigation:</strong> toggle grid/axes, sync view across grids, grid dimmer, light/dark themes, show all vertices.</li>
      <li style="margin-bottom: 8px;"><strong>2D Grids:</strong> special camera mode for grids with one dimension = 1 (pan/zoom without rotation).</li>
      <li style="margin-bottom: 8px;"><strong>Persist:</strong> Save/Load grids including active subgraph(s), colors, and UI state.</li>
    </ul>
    
    <h3 style="font-size: 18px; color: #333; margin: 24px 0 12px 0; font-weight: 600;">Panels (quick map)</h3>
    <ul style="color: #555; font-size: 14px; margin: 0 0 20px 0; padding-left: 24px;">
      <li style="margin-bottom: 6px;"><strong>Generate:</strong> Gen Path ‚Ä¢ Gen Cycle ‚Ä¢ Hamiltonian? ‚Ä¢ Backbite ‚Ä¢ Switch ‚Ä¢ Double-Switch ‚Ä¢ Gradient</li>
      <li style="margin-bottom: 6px;"><strong>Build:</strong> Add/Remove Vertices ‚Ä¢ Edges ‚Ä¢ Decorationss ‚Ä¢ Arrows ‚Ä¢ Add/Remove Layer</li>
      <li style="margin-bottom: 6px;"><strong>View:</strong> Toggle Grid ‚Ä¢ Coordinate Axis ‚Ä¢ Sync View ‚Ä¢ Grid Dimmer ‚Ä¢ Theme</li>
      <li style="margin-bottom: 6px;"><strong>Grids:</strong> Dimensions W,H,D ‚Ä¢ Add Grid ‚Ä¢ Duplicate Grid</li>
      <li style="margin-bottom: 6px;"><strong>Save/Load:</strong> Save Grids ‚Ä¢ Load Grids ‚Ä¢ Grid Notes</li>
    </ul>
    
    <h3 style="font-size: 18px; color: #333; margin: 24px 0 12px 0; font-weight: 600;">Performance tips</h3>
    <ul style="color: #555; font-size: 14px; margin: 0 0 20px 0; padding-left: 24px;">
      <li style="margin-bottom: 8px;">Generation time grows as <strong>N¬≤</strong> where N = x√óy√óz (grid size)</li>
      <li style="margin-bottom: 8px;">Small grids (5√ó5√ó5) generate instantly; large grids (50√ó50√ó50) may take 20+ minutes</li>
      <li style="margin-bottom: 8px;">Press <strong>ESC</strong> during generation to stop the process at any time</li>
      <li style="margin-bottom: 8px;">Very large generations trigger a time estimate; consider reducing grid dimensions if needed</li>
    </ul>
    
<h3 style="font-size: 18px; color: #333; margin: 24px 0 12px 0; font-weight: 600;">Quick reference</h3>

<ul style="color: #555; font-size: 14px; margin: 0 0 20px 0; padding-left: 24px;">
  <!-- Keyboard: global toggles -->
  <li style="margin-bottom: 6px;">
    <strong>Keyboard Shortcuts:</strong> <kbd style="background:#f5f5f5; padding: 2px 6px; border-radius:4px; border:1px solid #ddd; font-family:monospace;">Shift + ?</kbd>
  </li>

  <!-- Camera controls -->
  <li style="margin-bottom: 6px;">
    <strong>Camera:</strong>
    Rotate ‚Ä¢ Zoom ‚Ä¢ Pan
    (<strong>Left-drag</strong> / <strong>Wheel</strong> / <strong>Right-drag</strong>).
    For 2D grids (one dimension = 1), rotation is disabled by default for easier navigation.
  </li>

  <!-- Editing: edges & decorations -->
  <li style="margin-bottom: 6px;">
    <strong>Editing:</strong>
    Add/remove edge = <kbd style="background:#f5f5f5; padding: 2px 6px; border-radius:4px; border:1px solid #ddd; font-family:monospace;">E</kbd> ‚Ä¢
    Add/remove edge decorate = <kbd style="background:#f5f5f5; padding: 2px 6px; border-radius:4px; border:1px solid #ddd; font-family:monospace;">Shift + E</kbd> 

  </li>
</ul>

    
    <h3 style="font-size: 18px; color: #333; margin: 24px 0 12px 0; font-weight: 600;">Save/Load details</h3>
    <p style="color: #555; font-size: 14px; margin: 0 0 12px 0;">Saves include:</p>
    <ul style="color: #555; font-size: 14px; margin: 0 0 20px 0; padding-left: 24px;">
      <li style="margin-bottom: 6px;">Visual state (theme, dimmer, arrows, etc. ).</li>
      <li style="margin-bottom: 6px;">Active subgraph (colored vertices, edges, decos).</li>
      <li style="margin-bottom: 6px;">Per-grid notes.</li>
    </ul>
    
    <h3 style="font-size: 18px; color: #333; margin: 24px 0 12px 0; font-weight: 600;">Limits</h3>
    <ul style="color: #555; font-size: 14px; margin: 0 0 20px 0; padding-left: 24px;">
      <li style="margin-bottom: 8px;">Large grids (‚â≥20k vertices) may take minutes to generate; estimates are shown.</li>
    </ul>
    
    <div style="background: #e8f4fd; border-left: 4px solid #3b82f6; padding: 16px 20px; margin: 24px 0 0 0; border-radius: 4px;">
      <h3 style="font-size: 16px; color: #1e40af; margin: 0 0 8px 0; font-weight: 600;">üìÑ License & Copyright</h3>
      <p style="color: #1e40af; font-size: 14px; margin: 0 0 12px 0;">
        <strong>GridLab v1.0.0</strong> ‚Ä¢ Copyright ¬© 2025 Albi
      </p>
      <p style="color: #1e40af; font-size: 13px; margin: 0 0 8px 0;">
        Licensed under <a href="https://polyformproject.org/licenses/noncommercial/1.0.0" target="_blank" 
        style="color: #2563eb; text-decoration: underline;">PolyForm Noncommercial License 1.0.0</a>
      </p>
      <p style="color: #1e40af; font-size: 13px; margin: 0 0 8px 0;">
        ‚úÖ <strong>Free</strong> for research, education, personal use<br>
        ‚ùå <strong>Commercial use requires a separate license</strong>
      </p>
      <p style="color: #1e40af; font-size: 13px; margin: 0;">
        For commercial licensing inquiries: <a href="mailto:albijuventus@yahoo.com" 
        style="color: #2563eb;">albijuventus@yahoo.com</a>
      </p>
    </div>
    
  </div>
</div>


<!-- Keyboard Shortcuts Modal -->
<div id="keyboardShortcutsModal" style="display: none; position: fixed; top: 0; left: 0; 
     width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 2000; 
     align-items: center; justify-content: center;">
  <div style="background: white; border-radius: 12px; padding: 32px; max-width: 800px; 
       width: 90%; max-height: 85vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(0,0,0,0.3); position: relative;">
    
    <!-- Close Button -->
    <button id="closeShortcutsModal" style="position: absolute; top: 16px; right: 16px; 
            background: none; border: none; font-size: 28px; cursor: pointer; color: #666; 
            padding: 0; width: 32px; height: 32px; line-height: 28px; border-radius: 4px;
            transition: all 0.2s;">√ó</button>
    
    <!-- Title -->
    <h2 style="margin: 0 0 24px 0; font-size: 24px; color: #333; font-weight: 600;">Keyboard Shortcuts</h2>
    
    <!-- Shortcuts Grid -->
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 32px;">
      
      <!-- Left Column -->
      <div>
        <!-- File Operations -->
        <div style="margin-bottom: 28px;">
          <h3 style="font-size: 16px; color: #666; margin: 0 0 12px 0; font-weight: 600;">File Operations</h3>
          <div style="display: flex; flex-direction: column; gap: 10px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Save grid</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                   border: 1px solid #ddd; font-family: monospace; font-size: 13px;">Ctrl + S</kbd>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Load grid</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                   border: 1px solid #ddd; font-family: monospace; font-size: 13px;">Ctrl + L</kbd>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Stop generation</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                   border: 1px solid #ddd; font-family: monospace; font-size: 13px;">ESC</kbd>
            </div>
          </div>
        </div>
        
        <!-- Edit Operations -->
        <div style="margin-bottom: 28px;">
          <h3 style="font-size: 16px; color: #666; margin: 0 0 12px 0; font-weight: 600;">Edit Operations</h3>
          <div style="display: flex; flex-direction: column; gap: 10px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Undo</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                   border: 1px solid #ddd; font-family: monospace; font-size: 13px;">Ctrl + Z</kbd>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Redo</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                   border: 1px solid #ddd; font-family: monospace; font-size: 13px;">Ctrl + Y</kbd>
            </div>
          </div>
        </div>
        
        <!-- Notes -->
        <div style="margin-bottom: 28px;">
          <h3 style="font-size: 16px; color: #666; margin: 0 0 12px 0; font-weight: 600;">Notes</h3>
          <div style="display: flex; flex-direction: column; gap: 10px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Toggle notes window</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                   border: 1px solid #ddd; font-family: monospace; font-size: 13px;">Ctrl + M</kbd>
            </div>
          </div>
        </div>
        
        <!-- Mode Toggles -->
        <div>
          <h3 style="font-size: 16px; color: #666; margin: 0 0 12px 0; font-weight: 600;">Graph Editing</h3>
          <div style="display: flex; flex-direction: column; gap: 10px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Add/remove vertex</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                   border: 1px solid #ddd; font-family: monospace; font-size: 13px;">V</kbd>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Add/remove vertex deco</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                   border: 1px solid #ddd; font-family: monospace; font-size: 13px;">Shift + V</kbd>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Add/remove edge</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                   border: 1px solid #ddd; font-family: monospace; font-size: 13px;">E</kbd>
            </div>
			<div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Add/remove edge deco</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                   border: 1px solid #ddd; font-family: monospace; font-size: 13px;">Shift + E</kbd>
            </div>		
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Add/remove arrows</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                   border: 1px solid #ddd; font-family: monospace; font-size: 13px;">A</kbd>
            </div>
          </div>
        </div>
      </div>
      
<!-- Right Column -->
      <div>
        <!-- Backbite Mode -->
        <div>
          <h3 style="font-size: 16px; color: #666; margin: 0 0 12px 0; font-weight: 600;">Backbite Mode</h3>
          <div style="display: flex; flex-direction: column; gap: 10px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Toggle active endpoint</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                   border: 1px solid #ddd; font-family: monospace; font-size: 13px;">T</kbd>
            </div>
            <div style="margin-top: 8px; padding-top: 12px; border-top: 1px solid #eee;">
              <div style="color: #666; font-size: 13px; margin-bottom: 10px; font-style: italic;">Navigation:</div>
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <span style="color: #333;">Move up (Y-axis)</span>
                <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                     border: 1px solid #ddd; font-family: monospace; font-size: 13px;">‚Üë</kbd>
              </div>
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <span style="color: #333;">Move down (Y-axis)</span>
                <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                     border: 1px solid #ddd; font-family: monospace; font-size: 13px;">‚Üì</kbd>
              </div>
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <span style="color: #333;">Move left (X-axis)</span>
                <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                     border: 1px solid #ddd; font-family: monospace; font-size: 13px;">‚Üê</kbd>
              </div>
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <span style="color: #333;">Move right (X-axis)</span>
                <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                     border: 1px solid #ddd; font-family: monospace; font-size: 13px;">‚Üí</kbd>
              </div>
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <span style="color: #333;">Move up (Z-axis)</span>
                <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                     border: 1px solid #ddd; font-family: monospace; font-size: 13px;">Page Up</kbd>
              </div>
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <span style="color: #333;">Move down (Z-axis)</span>
                <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                     border: 1px solid #ddd; font-family: monospace; font-size: 13px;">Page Down</kbd>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Help & View -->
        <div style="margin-top: 28px;">
          <h3 style="font-size: 16px; color: #666; margin: 0 0 12px 0; font-weight: 600;">Help & View</h3>
          <div style="display: flex; flex-direction: column; gap: 10px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Sync view</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                  border: 1px solid #ddd; font-family: monospace; font-size: 13px;">S</kbd>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Show preferences</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                  border: 1px solid #ddd; font-family: monospace; font-size: 13px;">Shift + P</kbd>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Show keyboard shortcuts</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                  border: 1px solid #ddd; font-family: monospace; font-size: 13px;">Shift + ?</kbd>
            </div>
          </div>
        </div>
        
        <!-- Camera Control -->
        <div style="margin-top: 28px;">
          <h3 style="font-size: 16px; color: #666; margin: 0 0 12px 0; font-weight: 600;">Camera Control</h3>
          <div style="display: flex; flex-direction: column; gap: 10px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Decrease sensitivity</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                  border: 1px solid #ddd; font-family: monospace; font-size: 13px;">Shift + &lt;</kbd>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Increase sensitivity</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                  border: 1px solid #ddd; font-family: monospace; font-size: 13px;">Shift + &gt;</kbd>
            </div>
          </div>
        </div>
        
      </div>  <!-- This closes the right column -->
      
    </div>
  </div>
</div>


<!-- Minimized Notes Button (hidden - using sidebar button instead) -->
<div id="notesMinimized" style="display: none;"></div>

<!-- Notes Window -->
<div id="notesWindow" style="position: fixed; top: 250px; left: 50%; transform: translateX(-50%); width: 600px; height: 400px; background: linear-gradient(145deg, #f0f0f0, #e0e0e0); border: 1px solid #ccc; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); z-index: 100; display: none; resize: both; overflow: hidden; min-width: 300px; min-height: 200px;">
  <div id="notesHeader" style="background: linear-gradient(145deg, #FFD966, #FFEB99); color: #333; padding: 8px 12px; font-size: 14px; font-weight: 500; cursor: move; border-radius: 8px 8px 0 0; user-select: none;">
    Notes - <span id="notesGridName">No Grid</span>
    <span id="notesMinimize" style="float: right; cursor: pointer; font-size: 16px; line-height: 1;">&minus;</span>
  </div>
  <div id="notesEditor" style="height: calc(100% - 42px); background: white; border-radius: 0 0 8px 8px;"></div>
</div>


<!-- Matrix-style Progress Display -->
<div id="progressOverlay" style="
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 9999;
  width: 300px;
  background: #0a0f0a;
  color: #b7f774;
  border: 1px solid #1d2a1d;
  border-radius: 8px;
  padding: 10px 12px;
  font: 12.5px/1.2 'Cascadia Mono', 'Consolas', 'Courier New', monospace;
  display: none;
  opacity: 0;
  transition: opacity 0.3s ease;
">
  <div>grid: <span id="progressGrid">‚Äî</span></div>
  <div style="margin-top: 2px;">progress: <span id="progressPercent">0%</span></div>
  <div style="margin-top: 2px;">time: <span id="progressTime"></span></div>
</div>






<!-- Preferences Modal -->
<div id="preferencesModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10000; justify-content: center; align-items: center;">
  <div style="background: white; border-radius: 12px; width: 500px; max-height: 80vh; overflow-y: auto; padding: 30px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); position: relative;">
    
    <!-- Header -->
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; border-bottom: 2px solid #3498db; padding-bottom: 10px;">
      <h2 style="margin: 0; color: #2c3e50; font-size: 24px;">
        Preferences
      </h2>
      <button id="closePreferencesBtn" style="background: none; border: none; font-size: 28px; color: #666; cursor: pointer; padding: 0; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; transition: color 0.2s;">√ó</button>
    </div>
    
    <!-- Preferences List -->
    <div style="margin-bottom: 30px;">
      
      <!-- Switch Mode Section -->
      <h3 style="font-size: 16px; color: #666; margin: 20px 0 12px 0; font-weight: 600; border-bottom: 1px solid #e0e0e0; padding-bottom: 8px;">Switch Mode</h3>
      
      <!-- Box Highlighting Preference -->
      <div style="display: flex; align-items: center; padding: 12px; border-radius: 6px; transition: background 0.2s; margin-bottom: 10px;">
        <input type="checkbox" id="boxHighlightingCheckbox" checked style="width: 20px; height: 20px; cursor: pointer; margin-right: 15px;">
        <label for="boxHighlightingCheckbox" style="cursor: pointer; font-size: 14px; color: #333; flex: 1; user-select: none;">
          Highlight switchable boxes at component borders
        </label>
      </div>
      
      <!-- Component Coloring Preference -->
      <div style="display: flex; align-items: center; padding: 12px; border-radius: 6px; transition: background 0.2s; margin-bottom: 10px;">
        <input type="checkbox" id="componentColoringCheckbox" checked style="width: 20px; height: 20px; cursor: pointer; margin-right: 15px;">
        <label for="componentColoringCheckbox" style="cursor: pointer; font-size: 14px; color: #333; flex: 1; user-select: none;">
          Color last disconnected component with second color
        </label>
      </div>
      
      <!-- Coordinate Hover Section -->
      <h3 style="font-size: 16px; color: #666; margin: 20px 0 12px 0; font-weight: 600; border-bottom: 1px solid #e0e0e0; padding-bottom: 8px;">Coordinate Hover</h3>
      
      <!-- Coordinate Hover - Vertices Preference -->
      <div style="display: flex; align-items: center; padding: 12px; border-radius: 6px; transition: background 0.2s; margin-bottom: 10px;">
        <input type="checkbox" id="hoverVerticesCheckbox" checked style="width: 20px; height: 20px; cursor: pointer; margin-right: 15px;">
        <label for="hoverVerticesCheckbox" style="cursor: pointer; font-size: 14px; color: #333; flex: 1; user-select: none;">
          Show vertex coordinates
        </label>
      </div>
      
      <!-- Coordinate Hover - Edges Preference -->
      <div style="display: flex; align-items: center; padding: 12px; border-radius: 6px; transition: background 0.2s; margin-bottom: 10px;">
        <input type="checkbox" id="hoverEdgesCheckbox" checked style="width: 20px; height: 20px; cursor: pointer; margin-right: 15px;">
        <label for="hoverEdgesCheckbox" style="cursor: pointer; font-size: 14px; color: #333; flex: 1; user-select: none;">
          Show edge coordinates
        </label>
      </div>
      
      <!-- Vertex Settings Section -->
      <h3 style="font-size: 16px; color: #666; margin: 20px 0 12px 0; font-weight: 600; border-bottom: 1px solid #e0e0e0; padding-bottom: 8px;">Vertex Settings</h3>
      
      <!-- Show All Vertices Preference -->
      <div style="display: flex; align-items: center; padding: 12px; border-radius: 6px; transition: background 0.2s; margin-bottom: 10px;">
        <input type="checkbox" id="showAllVerticesCheckbox" style="width: 20px; height: 20px; cursor: pointer; margin-right: 15px;">
        <label for="showAllVerticesCheckbox" style="cursor: pointer; font-size: 14px; color: #333; flex: 1; user-select: none;">
          Show all grid vertices as gray spheres
        </label>
      </div>
      
      <!-- Edge Settings Section -->
      <h3 style="font-size: 16px; color: #666; margin: 20px 0 12px 0; font-weight: 600; border-bottom: 1px solid #e0e0e0; padding-bottom: 8px;">Edge Settings</h3>
      
      <div style="padding: 12px;">
        <label style="font-size: 14px; color: #333; display: block; margin-bottom: 8px;">Edge Click Radius:</label>
        <div style="display: flex; align-items: center; gap: 10px;">
          <input type="range" id="edgeCollisionRadiusSlider" min="0.02" max="0.15" step="0.01" value="0.08" style="flex: 1;">
          <span id="edgeCollisionRadiusValue" style="font-size: 14px; color: #333; min-width: 40px;">0.08</span>
        </div>
      </div>
      
      <!-- Display Section -->
      <h3 style="font-size: 16px; color: #666; margin: 20px 0 12px 0; font-weight: 600; border-bottom: 1px solid #e0e0e0; padding-bottom: 8px;">Display</h3>
      
      <!-- Theme Selection -->
      <div style="display: flex; align-items: center; padding: 12px; border-radius: 6px; transition: background 0.2s;">
        <label for="themeSelect" style="font-size: 14px; color: #333; margin-right: 20px;">Theme:</label>
        <select id="themeSelect" style="padding: 8px 16px; border: 2px solid #ddd; border-radius: 8px; cursor: pointer; font-size: 14px; background: white; color: #333; min-width: 180px;">
          <option value="paper-white">üìÑ Paper White</option>
          <option value="dark">üåô Dark</option>
          <option value="sandstone">üèúÔ∏è Sandstone</option>
          <option value="mist-blue">üåä Mist Blue</option>
          <option value="warm-light">üîÜ Warm Light</option>
          <option value="light"> Contrast 1</option>
        </select>
      </div>
      
      <!-- Background Override Selection -->
      <div style="display: flex; align-items: center; padding: 12px; border-radius: 6px; transition: background 0.2s; margin-top: 10px;">
        <label for="backgroundOverrideSelect" style="font-size: 14px; color: #333; margin-right: 20px;">Background:</label>
        <select id="backgroundOverrideSelect" style="padding: 8px 16px; border: 2px solid #ddd; border-radius: 8px; cursor: pointer; font-size: 14px; background: white; color: #333; min-width: 180px;">
          <option value="theme-default">Theme Default</option>
          <option value="beige">Beige</option>
          <option value="light-gradient">Light Gradient</option>
          <option value="warm-gradient">Warm Gradient</option>
          <option value="mist-gradient">Mist Gradient</option>
          <option value="white">White</option>
          <option value="black">Black</option>
          <option value="custom">Custom Color...</option>
        </select>
      </div>
      
      <!-- Custom Background Color Picker (hidden by default) -->
      <div id="customBackgroundPicker" style="display: none; padding: 12px; margin-top: 10px;">
        <label for="customBgColor" style="font-size: 14px; color: #333; margin-right: 10px;">Custom Color:</label>
        <input type="color" id="customBgColor" value="#f7f5e9" style="width: 60px; height: 40px; border: 2px solid #ddd; border-radius: 6px; cursor: pointer;">
      </div>
      
      <!-- Camera Section -->
      <h3 style="font-size: 16px; color: #666; margin: 20px 0 12px 0; font-weight: 600; border-bottom: 1px solid #e0e0e0; padding-bottom: 8px;">Camera</h3>
      
      <!-- Camera Mouse Sensitivity -->
      <div style="padding: 12px; border-radius: 6px;">
        <label for="cameraSensitivitySlider" style="font-size: 14px; color: #333; display: block; margin-bottom: 8px;">Camera Mouse Sensitivity:</label>
        <div style="display: flex; align-items: center; gap: 10px;">
          <input type="range" id="cameraSensitivitySlider" min="0.1" max="2.0" step="0.1" value="1.0" style="flex: 1;">
          <span id="cameraSensitivityValue" style="font-size: 14px; color: #333; min-width: 30px;">1.0</span>
        </div>
      </div>
      
      <!-- Show Camera Sensitivity in Main Screen -->
      <div style="display: flex; align-items: center; padding: 12px; border-radius: 6px; transition: background 0.2s; margin-bottom: 10px;">
        <input type="checkbox" id="showCameraSensitivityCheckbox" style="width: 20px; height: 20px; cursor: pointer; margin-right: 15px;">
        <label for="showCameraSensitivityCheckbox" style="cursor: pointer; font-size: 14px; color: #333; flex: 1; user-select: none;">
          Show camera sensitivity slider in main screen
        </label>
      </div>
      
      <!-- Use 2D Camera Mode -->
      <div style="display: flex; align-items: center; padding: 12px; border-radius: 6px; transition: background 0.2s; margin-bottom: 10px;">
        <input type="checkbox" id="use2DCameraModeCheckbox" checked style="width: 20px; height: 20px; cursor: pointer; margin-right: 15px;">
        <label for="use2DCameraModeCheckbox" style="cursor: pointer; font-size: 14px; color: #333; flex: 1; user-select: none;">
          Use 2D camera mode (for grids with one dimension = 1)
        </label>
      </div>
      
    </div>
    
    <!-- Footer Buttons -->
    <div style="display: flex; gap: 10px; justify-content: flex-end;">
      <button id="savePreferencesBtn" style="padding: 10px 20px; background: #3498db; color: white; border: none; border-radius: 6px; cursor: pointer; font-family: inherit; font-size: 14px; font-weight: 500; transition: background 0.2s;">
        Save & Close
      </button>
    </div>
    
  </div>
</div>






<!-- README Modal -->
<div id="readmeModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10000; justify-content: center; align-items: center;">
  <div style="background: white; border-radius: 12px; max-width: 900px; max-height: 85vh; overflow-y: auto; padding: 40px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); position: relative;">
    
    <!-- Close Button -->
    <button id="closeReadmeModal" style="position: absolute; top: 16px; right: 16px; background: white; border: 2px solid #ddd; border-radius: 6px; width: 36px; height: 36px; cursor: pointer; font-size: 20px; color: #666; display: flex; align-items: center; justify-content: center; transition: all 0.2s;">√ó</button>
    
    <!-- README Content -->
    <div style="color: #333; line-height: 1.6;">
      
      <h1 style="margin-top: 0; color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px;">GridLab v1.0</h1>
      
      <p style="font-size: 16px; color: #555; margin-bottom: 30px;"><strong>GridLab</strong> is an interactive 3D visualization and editing tool for exploring Hamiltonian paths and cycles on grid graphs. Built with Three.js, it provides an environment for studying graph theory, particularly the properties of paths and cycles on rectangular lattice structures.</p>
      
      <hr style="border: none; border-top: 2px solid #eee; margin: 30px 0;">
      
      <h2 style="color: #2c3e50; margin-top: 30px;">Overview</h2>
      <p>GridLab enables researchers and enthusiasts to:</p>
      <ul style="margin-left: 20px;">
        <li>Generate and visualize Hamiltonian paths and cycles on 2D and 3D grid graphs</li>
        <li>Perform backbite moves (both automated and manual) to explore the space of Hamiltonian paths</li>
        <li>Apply switch moves to modify cycles and paths</li>
        <li>Color edges with gradients and add directional arrows</li>
        <li>Work with multiple grids simultaneously</li>
        <li>Add vertex and edge decorations for marking special structures</li>
        <li>Display all grid vertices for structural visualization</li>
        <li>Save and load complete project states</li>
      </ul>
      
      <h2 style="color: #2c3e50; margin-top: 30px;">Core Concepts</h2>
      
      <h3 style="color: #34495e; margin-top: 20px;">Grid Graphs</h3>
      <p>A grid graph is a rectangular lattice of vertices connected by edges. GridLab supports grids of arbitrary dimensions (width √ó height √ó depth), allowing exploration of everything from 2D planar grids to complex 3D structures.</p>
      
      <h3 style="color: #34495e; margin-top: 20px;">Hamiltonian Paths and Cycles</h3>
      <ul style="margin-left: 20px;">
        <li><strong>Hamiltonian Path:</strong> A path that visits every vertex in the graph exactly once</li>
        <li><strong>Hamiltonian Cycle:</strong> A path that visits every vertex exactly once and returns to the starting vertex</li>
      </ul>
      
      <h3 style="color: #34495e; margin-top: 20px;">Backbite Moves</h3>
      <p>A backbite move is a local transformation that reconfigures a Hamiltonian path into a new one. This is a key operation for exploring the space of all Hamiltonian paths on a given grid.</p>
      
      <h3 style="color: #34495e; margin-top: 20px;">Switch Moves</h3>
      <p>switch move operates on a "switchable box" - a 2√ó2 square where exactly two parallel edges are in the path/cycle/subgraph. The move swaps which pair is included. If we start with a Hamiltonian cycle in 3D, the move either produces a new Hamiltonian cycle or it produce a cover of the grid with two cycles. Switching any boundary box between those two cycles produces a new Hamiltonian cycle.</p>
      
      <h2 style="color: #2c3e50; margin-top: 30px;">Getting Started</h2>
      
      <h3 style="color: #34495e; margin-top: 20px;">Creating Your First Grid</h3>
      <ol style="margin-left: 20px;">
        <li>Set dimensions using the <strong>Grid Dimensions</strong> controls (top right)</li>
        <li>Click <strong>Add Grid</strong> to create a new grid</li>
        <li>The grid appears in the 3D viewport with a button in the grid list at the bottom</li>
      </ol>
      
      <h3 style="color: #34495e; margin-top: 20px;">Navigation</h3>
      <ul style="margin-left: 20px;">
        <li><strong>Rotate:</strong> Left-click and drag (disabled for 2D grids)</li>
        <li><strong>Pan:</strong> Right-click and drag (or Shift + left-click and drag)</li>
        <li><strong>Zoom:</strong> Scroll wheel</li>
        <li><strong>2D Grids:</strong> Grids with one dimension = 1 use special camera mode (pan/zoom only, no rotation) for easier navigation. This can be toggled in Preferences.</li>
      </ul>
      
      <h2 style="color: #2c3e50; margin-top: 30px;">Performance & Complexity</h2>
      
      <p>Path generation uses a backbite algorithm with computational complexity:</p>
      
      <div style="background: #f0f7ff; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #3498db;">
        <p style="margin: 0; font-family: monospace; font-size: 16px; color: #2c3e50;"><strong>Running time ‚âà 9cN¬≤</strong></p>
        <p style="margin: 10px 0 0 0; color: #555;">Where <strong>N = x √ó y √ó z</strong> (total vertices) and <strong>c</strong> is the backbite multiplier (default c = 10)</p>
      </div>
      
      <table style="width: 100%; border-collapse: collapse; margin: 20px 0; font-size: 14px;">
        <thead>
          <tr style="background: #ecf0f1;">
            <th style="padding: 10px; border: 1px solid #bdc3c7; text-align: left;">Grid Size</th>
            <th style="padding: 10px; border: 1px solid #bdc3c7; text-align: right;">N (vertices)</th>
            <th style="padding: 10px; border: 1px solid #bdc3c7; text-align: right;">Backbites</th>
            <th style="padding: 10px; border: 1px solid #bdc3c7; text-align: right;">Operations</th>
            <th style="padding: 10px; border: 1px solid #bdc3c7; text-align: right;">Est. Time</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td style="padding: 10px; border: 1px solid #bdc3c7;">5√ó5√ó5</td>
            <td style="padding: 10px; border: 1px solid #bdc3c7; text-align: right;">125</td>
            <td style="padding: 10px; border: 1px solid #bdc3c7; text-align: right;">1,250</td>
            <td style="padding: 10px; border: 1px solid #bdc3c7; text-align: right;">~140K</td>
            <td style="padding: 10px; border: 1px solid #bdc3c7; text-align: right;">&lt;1 sec</td>
          </tr>
          <tr style="background: #f9f9f9;">
            <td style="padding: 10px; border: 1px solid #bdc3c7;">10√ó10√ó10</td>
            <td style="padding: 10px; border: 1px solid #bdc3c7; text-align: right;">1,000</td>
            <td style="padding: 10px; border: 1px solid #bdc3c7; text-align: right;">10,000</td>
            <td style="padding: 10px; border: 1px solid #bdc3c7; text-align: right;">~9M</td>
            <td style="padding: 10px; border: 1px solid #bdc3c7; text-align: right;">~1 sec</td>
          </tr>
          <tr>
            <td style="padding: 10px; border: 1px solid #bdc3c7;">20√ó20√ó20</td>
            <td style="padding: 10px; border: 1px solid #bdc3c7; text-align: right;">8,000</td>
            <td style="padding: 10px; border: 1px solid #bdc3c7; text-align: right;">80,000</td>
            <td style="padding: 10px; border: 1px solid #bdc3c7; text-align: right;">~576M</td>
            <td style="padding: 10px; border: 1px solid #bdc3c7; text-align: right;">~10 sec</td>
          </tr>
          <tr style="background: #f9f9f9;">
            <td style="padding: 10px; border: 1px solid #bdc3c7;">30√ó30√ó30</td>
            <td style="padding: 10px; border: 1px solid #bdc3c7; text-align: right;">27,000</td>
            <td style="padding: 10px; border: 1px solid #bdc3c7; text-align: right;">270,000</td>
            <td style="padding: 10px; border: 1px solid #bdc3c7; text-align: right;">~6.6B</td>
            <td style="padding: 10px; border: 1px solid #bdc3c7; text-align: right;">~90 sec</td>
          </tr>
          <tr>
            <td style="padding: 10px; border: 1px solid #bdc3c7;">50√ó50√ó50</td>
            <td style="padding: 10px; border: 1px solid #bdc3c7; text-align: right;">125,000</td>
            <td style="padding: 10px; border: 1px solid #bdc3c7; text-align: right;">1,250,000</td>
            <td style="padding: 10px; border: 1px solid #bdc3c7; text-align: right;">~141B</td>
            <td style="padding: 10px; border: 1px solid #bdc3c7; text-align: right;">~25 min</td>
          </tr>
        </tbody>
      </table>
      
      <p style="color: #555;"><strong>Note:</strong> Press <kbd style="background: #f5f5f5; padding: 2px 6px; border-radius: 4px; border: 1px solid #ddd; font-family: monospace;">ESC</kbd> during generation to stop the process at any time.</p>
      
      <h2 style="color: #2c3e50; margin-top: 30px;">Key Features</h2>
      
      <h3 style="color: #34495e; margin-top: 20px;">Path Generation</h3>
      <ul style="margin-left: 20px;">
        <li><strong>Generate Path:</strong> Creates a random Hamiltonian path with colored endpoints (green = start, red = end)</li>
        <li><strong>Generate Cycle:</strong> Creates a random Hamiltonian cycle</li>
        <li><strong>Check Hamiltonian:</strong> Verifies if the current structure is Hamiltonian</li>
      </ul>
      
      <h3 style="color: #34495e; margin-top: 20px;">Interactive Modes</h3>
      <ul style="margin-left: 20px;">
        <li><strong>Backbite Mode:</strong> Manual or automated backbite transformations. Use arrow keys, PgUp, and PgDn for manual control, T key to reverse path direction</li>
        <li><strong>Switch Mode:</strong> Click on 2√ó2 switchable boxes to perform switch moves</li>
        <li><strong>Add Edge:</strong> Click edges to toggle their colors</li>
        <li><strong>Arrows:</strong> Show directional arrows along an edge or generated Hamiltonian path or cycle</li>
        <li><strong>Gradient Mode:</strong> Apply smooth color gradients along generated Hamiltonian paths or cycles</li>
      </ul>
      
      <h3 style="color: #34495e; margin-top: 20px;">Decorations</h3>
      <ul style="margin-left: 20px;">
        <li><strong>Decorate Edge:</strong> Add small cubes to mark specific edges</li>
        <li><strong>Add Vertex:</strong> Place colored spheres at vertices</li>
        <li><strong>Decorate Vertex:</strong> Add three orthogonal great circles as a secondary vertex marker</li>
        <li><strong>BB Distance Coloring:</strong> Color all vertices at a specific backbite distance from a reference vertex</li>
      </ul>
      
      <h3 style="color: #34495e; margin-top: 20px;">Grid Management</h3>
      <ul style="margin-left: 20px;">
        <li><strong>Multiple Grids:</strong> Work with multiple grids simultaneously using the grid list at the bottom of the screen</li>
        <li><strong>Drag to Reorder:</strong> Click and drag grid tabs to rearrange their order</li>
        <li><strong>Duplicate:</strong> Create copies of grids to preserve configurations before modifications</li>
        <li><strong>Per-Grid Notes:</strong> Attach rich-text notes to individual grids (draggable window)</li>
        <li><strong>Sync View:</strong> Align camera position across all grids for easy comparison</li>
      </ul>
      
      <h3 style="color: #34495e; margin-top: 20px;">Preferences</h3>
      <p>Access via <strong>Preferences</strong> button (or <kbd style="background: #f5f5f5; padding: 2px 6px; border-radius: 4px; border: 1px solid #ddd; font-family: monospace;">Shift+P</kbd>) to customize:</p>
      <ul style="margin-left: 20px;">
        <li><strong>Switch Mode:</strong> Enable/disable box highlighting and component coloring</li>
        <li><strong>Coordinate Hover:</strong> Toggle vertex/edge coordinate display on hover</li>
        <li><strong>Vertex Settings:</strong> Show all grid vertices as gray spheres for structure visualization</li>
        <li><strong>Edge Settings:</strong> Adjust edge click radius for easier selection</li>
        <li><strong>Display:</strong> Choose from 6 themes (Paper White, Dark, Sandstone, Mist Blue, Warm Light, Contrast) and custom backgrounds</li>
        <li><strong>Camera:</strong> Adjust mouse sensitivity, toggle 2D camera mode for grids with one dimension = 1, show/hide sensitivity slider</li>
      </ul>
      
      <h2 style="color: #2c3e50; margin-top: 30px;">Keyboard Shortcuts</h2>
      
      <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
        <h4 style="color: #2c3e50;">File Operations</h4>
        <ul style="margin-left: 20px; margin-bottom: 15px;">
          <li><strong>Ctrl+S:</strong> Save all grids</li>
          <li><strong>Ctrl+L:</strong> Load grids from file</li>
          <li><strong>Ctrl+M:</strong> Toggle notes window</li>
          <li><strong>Esc:</strong> Stop path/cycle generation in progress</li>
        </ul>
        
        <h4 style="color: #2c3e50;">Undo/Redo</h4>
        <ul style="margin-left: 20px; margin-bottom: 15px;">
          <li><strong>Ctrl+Z:</strong> Undo</li>
          <li><strong>Ctrl+Y:</strong> Redo</li>
        </ul>
        
        <h4 style="color: #2c3e50;">Mode Toggles</h4>
        <ul style="margin-left: 20px; margin-bottom: 15px;">
          <li><strong>E:</strong> Toggle edge coloring mode</li>
          <li><strong>Shift+E:</strong> Toggle edge decoration mode</li>
          <li><strong>A:</strong> Toggle arrows</li>
          <li><strong>V:</strong> Toggle vertex mode</li>
          <li><strong>Shift+V:</strong> Toggle vertex decoration mode</li>
        </ul>
        
        <h4 style="color: #2c3e50;">Backbite Mode</h4>
        <ul style="margin-left: 20px;">
          <li><strong>Arrow Keys:</strong> Move in X-Y plane</li>
          <li><strong>Page Up/Down:</strong> Move in Z direction</li>
          <li><strong>T:</strong> Reverse path direction</li>
        </ul>
      </div>
      
      <h2 style="color: #2c3e50; margin-top: 30px;">Use Cases</h2>
      
      <ul style="margin-left: 20px;">
        <li><strong>Research:</strong> Hamiltonian path/cycle reconfiguration, grid graph structure analysis.</li>
        <li><strong>Education:</strong> Graph theory teaching, algorithm visualization, 3D spatial reasoning</li>
        <li><strong>Art:</strong> Generative patterns, color studies, aesthetic exploration</li>
      </ul>
      
      <h2 style="color: #2c3e50; margin-top: 30px;">Tips</h2>
      
      <ul style="margin-left: 20px;">
        <li>Use <strong>Toggle Grid</strong> to hide uncolored edges on large grids</li>
        <li>Enable <strong>Plane Controls</strong> to highlight cross-sections of 3D grids</li>
        <li>Use <strong>gradient mode</strong> to visualize position along long paths</li>
        <li>Add <strong>vertex markers</strong> at key positions for reference</li>
        <li>In Preferences, enable <strong>"Show all grid vertices"</strong> to visualize the complete grid structure with gray spheres</li>
        <li>For 2D grids, the camera defaults to 2D mode (pan/zoom only). This can be changed in Preferences ‚Üí Camera</li>
        <li><strong>Duplicate</strong> grids before major changes to preserve configurations</li>
      </ul>
      
      <hr style="border: none; border-top: 2px solid #eee; margin: 30px 0;">
      
      <p style="text-align: center; color: #7f8c8d; font-style: italic; margin-top: 40px;">GridLab - Explore the space of Hamiltonian paths</p>
      
    </div>
  </div>
</div>





<!-- Three.js core (v0.134.0) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.134.0/build/three.min.js"></script>

<!-- OrbitControls for Three.js v0.134.0 -->
<script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.min.js"></script>

<!-- Quill.js CSS and JS -->
<link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
<script src="https://cdn.quilljs.com/1.3.6/quill.min.js"></script>

</body>
</html>
  <script>
    // ============================================================================
    // GridLab - Core Application Code
    // Build: GL-2025-11A7B91F3E-YORK
    // Dev: ALBI.YORK.RGH.2024
    // ============================================================================
    
    // === DISTINCTIVE CONSTANTS (Fingerprint markers) ===
    const VERTEX_SPHERE_RADIUS = 0.12; // Unique sphere radius for vertices
    const ENDPOINT_MARKER_RADIUS = 0.18; // Unique endpoint marker size
    const SWITCH_HIGHLIGHT_PULSE_SPEED = 0.002; // Distinctive pulse timing
    const ARROW_CONE_RADIUS = 0.06; // Unique arrow geometry
    const ARROW_CONE_HEIGHT = 0.15; // Unique arrow geometry
    const BACKBITE_ANIMATION_EPSILON = 0.000001; // Signature epsilon value
    
    // Dev note: GL.SIGNATURE.RECT_GRID_HAMILTON_PATH_CYCLE_RECONFIG
    const _buildMeta = "GL-2025-11A7B91F3E-YORK"; // Hidden build signature
    
    const raycaster = new THREE.Raycaster();
	//raycaster.params.Line.threshold = 0.2;  // Increase click tolerance for thin edges
    const mouse = new THREE.Vector2();
    let mode = "default";
	const UNCOLORED_COLOR = 0x888888;
	let selectedColor = 0x0000ff; // default blue
    let gridCounter = 0;
    let currentGrid = null;
	// === Set your grid dimensions here ===
		let GRID_WIDTH = 6;
		let GRID_HEIGHT = 6;
		let GRID_DEPTH = 6;
    const allGrids = new Map();
	let lastHighlighted = null;
	let gridVisible = true;
	let edgeClickEnabled = false;
	let currentPath = [];
	let highlightedBoxes = [];
	let switchMode = false; // Whether switch highlighting is active
	let boxHighlightingEnabled = true; // NEW: Toggle for highlighting switchable boxes (instanced only)
	
	let componentColoringEnabled = true; // NEW: Toggle for component coloring after switches
	let hoverVertices = true; // Coordinate hover shows vertices
	let hoverEdges = true; // Coordinate hover shows edges
	let cameraSensitivity = 1.0; // Camera mouse sensitivity
	let showCameraSensitivityInMain = false; // Whether to show camera sensitivity in main UI
	let use2DCameraMode = true; // Whether to use 2D camera mode for grids with one dimension = 1
	let showAllVertices = false; // Whether to show all grid vertices as gray spheres
	let isGenerating = false; // Track if generation is in progress
	let shouldStopGeneration = false; // Flag to stop generation
	let boxHighlightHelpers = [];
	let selectedColor2 = 0xff0000; // default red
	let arrowMode = false;
	let gradientMode = false; // Controls gradient coloring
	let batchMode = false; // Add this global variable
	let arrowReverse = false;
	
	// Track unsaved changes for beforeunload protection
	let hasUnsavedChanges = false;
	let lastSaveTime = null;
	
	// Notes functionality
	let isDraggingNotes = false;
	let notesOffset = { x: 0, y: 0 };
	
	let decorationEnabled = false; // Controls whether decoration cycle is active
	let selectedDecorationColor = 0xffff00; // Default yellow for decorations
	
	let coordinateHoverMode = false;
	
	let quillEditor = null;
	let isQuillInitialized = false;
	
	let useInstancedRendering = true; // Toggle for new rendering system
	
	
let activeColorTarget = 'main'; // 'main' or 'second'
// Add these global variables at the top
let mouseDownTarget = null;
let mouseDownType = null; // 'edge', 'vertex', 'box'


let edgeCollisionRadius = 0.065; // Default: slightly larger than thick edges (0.05)



	
	
//     ====================================================================================================================
// 											   1. GRID CREATION FUNCTIONS
//     ====================================================================================================================

function addVertex(grid, x, y, z = 0) {
  const key = vertexKey(x, y, z);
  if (!grid.vertices.has(key)) {
    grid.vertices.set(key, { coords: [x, y, z], neighbors: new Set() });
    
    // Create invisible collision helper for vertex clicking
    const collisionGeometry = new THREE.SphereGeometry(0.4, 8, 8);
    const collisionMaterial = new THREE.MeshBasicMaterial({ 
      transparent: true,
      opacity: 0,
      visible: false
    });
    const collisionHelper = new THREE.Mesh(collisionGeometry, collisionMaterial);
    collisionHelper.position.set(x, y, z);
    collisionHelper.userData.vertexKey = key;
    collisionHelper.userData.isVertexHelper = true;
    
    grid.group.add(collisionHelper);
    grid.vertices.get(key).collisionHelper = collisionHelper;
  }
}



function addEdge(grid, a, b) {
  const vKey1 = vertexKey(...a);
  const vKey2 = vertexKey(...b);
  const eKey = edgeKey(a, b);
  if (!grid.edges.has(eKey)) {
    const start = new THREE.Vector3(...a);
    const end = new THREE.Vector3(...b);
    const direction = new THREE.Vector3().subVectors(end, start);
    const length = direction.length();
    const midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
    const axis = new THREE.Vector3(0, 1, 0);
    
    // Only create individual meshes if NOT using instanced rendering
    let cylinder = null;
    let collisionHelper = null;
    
    if (!useInstancedRendering) {
      // Visual mesh
      const material = new THREE.MeshBasicMaterial({ color: 0x888888 });
      const geometry = new THREE.CylinderGeometry(0.015, 0.015, length, 8);
      cylinder = new THREE.Mesh(geometry, material);
      cylinder.quaternion.setFromUnitVectors(axis, direction.clone().normalize());
      cylinder.position.copy(midpoint);
      grid.group.add(cylinder);
      
      // Invisible collision helper (larger radius for easier clicking)
      const collisionGeometry = new THREE.CylinderGeometry(0.05, 0.05, length, 8);
      const collisionMaterial = new THREE.MeshBasicMaterial({ 
        transparent: true, 
        opacity: 0,
        visible: false
      });
      collisionHelper = new THREE.Mesh(collisionGeometry, collisionMaterial);
      collisionHelper.quaternion.setFromUnitVectors(axis, direction.clone().normalize());
      collisionHelper.position.copy(midpoint);
      collisionHelper.userData.parentEdge = eKey;
      grid.group.add(collisionHelper);
    }
    
    grid.edges.set(eKey, { 
      vertices: [vKey1, vKey2], 
      color: 0x888888, 
      mesh: cylinder,
      collisionHelper: collisionHelper,
      arrowDirection: 0,
      blockCube: null
    });
    
    grid.vertices.get(vKey1).neighbors.add(vKey2);
    grid.vertices.get(vKey2).neighbors.add(vKey1);
  }
}


function vertexKey(x, y, z = 0) { return `${x},${y},${z}`; }

function edgeKey(a, b) { const [aStr, bStr] = [a.join(), b.join()].sort(); return `${aStr}-${bStr}`; }
	
	

function createEmptyGridData() {
  return {
    vertices: new Map(),
    edges: new Map(),
    boxesXY: new Map(),
    boxesXZ: new Map(),
    boxesYZ: new Map(),
    group: new THREE.Group(),
    ringBoxes: [],
    ringBands: { XY: {}, XZ: {}, YZ: {} },
    highlightedBoxHelpers: [],
    cameraPosition: null,
    cameraTarget: null,
    highlightOverlay: null,
    vertexSpheres: new Map(),
    vertexHighlight: null,
    notes: "",
    customPlanes: [],  // <-- Changed from customPlane to customPlanes array
    undoStack: [],
    redoStack: [],
    maxUndoSteps: 200,
    isInstanced: false  // Track if this grid uses instanced rendering
  };
}


function addGrid() {
 if (currentGrid) scene.remove(currentGrid.group); // Do NOT clear markers!
 
 // Read dimensions from inputs automatically
 const w = parseInt(document.getElementById("widthInput").value) || 6;
 const h = parseInt(document.getElementById("heightInput").value) || 6;
 const d = parseInt(document.getElementById("depthInput").value) || 6;
 
 if (w <= 0 || h <= 0 || d <= 0) {
   alert("All dimensions must be positive integers.");
   return;
 }
 
 // Set global dimensions
 GRID_WIDTH = w;
 GRID_HEIGHT = h;
 GRID_DEPTH = d;
 
 const id = `Grid ${++gridCounter}`;
 const grid = createEmptyGridData();
 grid.width = GRID_WIDTH;
 grid.height = GRID_HEIGHT;
 grid.depth = GRID_DEPTH;
 
 // Distinctive initialization with signature epsilon for 3x3x3 grids
 // (Research-standard coordinate adjustment)
 if (GRID_WIDTH === 3 && GRID_HEIGHT === 3 && GRID_DEPTH === 3) {
   const epsilon = BACKBITE_ANIMATION_EPSILON;
   // Apply infinitesimal offset for build fingerprinting
   grid.signatureOffset = epsilon;
 }
 
 grid.path = null;
 grid.startMarker = null;
 grid.endMarker = null;
 grid.activeBoxHelpers = [];
 
 // Only initialize camera state if it's a fresh grid
 grid.cameraPosition = camera.position.clone();
 grid.cameraTarget = controls.target.clone();
 allGrids.set(id, grid);
 
 // Create button with rename functionality
 const button = document.createElement("div");
 button.className = "grid-btn";

 const textSpan = document.createElement("span");
 textSpan.textContent = id;
 textSpan.style.cursor = "text";
 textSpan.onclick = (e) => {
   e.stopPropagation();
   startGridRename(id, textSpan, button);
 };

 // Add grid info (dimensions only - all grids use instanced rendering now)
 const infoSpan = document.createElement("div");
 infoSpan.className = "grid-info";
 infoSpan.textContent = `${grid.width}√ó${grid.height}√ó${grid.depth}`;

const close = document.createElement("span");
close.className = "close";
close.innerHTML = "&times;";
close.onclick = e => {
  e.stopPropagation();
  
  // Confirm deletion before proceeding
  if (!confirm("Delete this grid? This cannot be undone.")) {
    return; // User cancelled, do nothing
  }
  
  if (currentGrid === grid) {
    clearEndpointMarkers(grid);
    scene.remove(grid.group);
    currentGrid = null;
  }
  allGrids.delete(id);
  button.remove();
};

 button.appendChild(textSpan);
 button.appendChild(infoSpan);
 button.appendChild(close);
 button.onclick = () => switchToGrid(id);
 document.getElementById("gridList").appendChild(button);

 buildGridContent(grid);
 switchToGrid(id);

 // Automatically reposition camera based on grid size
 const maxDim = Math.max(grid.width, grid.height, grid.depth);
 
 // Check if this is a 2D grid (any dimension is 1)
 const is2D = grid.width === 1 || grid.height === 1 || grid.depth === 1;
 

 if (is2D && use2DCameraMode) {
   // Fixed overhead position for 2D grids (only if preference is enabled)
   const centerX = (grid.width - 1) / 2;
   const centerY = (grid.height - 1) / 2;
   const centerZ = (grid.depth - 1) / 2;
   
   // Calculate the grid's actual size in world units
   const gridWorldWidth = Math.max(grid.width - 1, grid.height - 1, grid.depth - 1);
   
   // Calculate available screen height (leave space for bottom UI)
   const bottomUISpace = 200; // pixels for grid tabs and controls
   const availableScreenHeight = window.innerHeight - bottomUISpace;
   
   // Calculate camera distance to fill the available screen height
   const fov = camera.fov * (Math.PI / 180);
   const distance = (gridWorldWidth / 2) / Math.tan(fov / 2) * (window.innerHeight / availableScreenHeight);
   
   // Position camera directly above the grid center
   camera.position.set(centerX, centerY, distance);
   camera.lookAt(centerX, centerY, centerZ);
   
   // Rotate camera 90 degrees around Z-axis
   camera.rotateZ(Math.PI / 2);
   
   // Clear any previous view offset
   camera.clearViewOffset();
   
   if (typeof controls !== "undefined") {
     controls.target.set(centerX, centerY, centerZ);
     controls.enabled = true; // Keep controls enabled for 2D grids
     
     // Configure controls for 2D mode: allow panning and zooming, disable rotation
     controls.enableRotate = false; // Disable rotation
     controls.enablePan = true;     // Enable panning (strafing)
     controls.enableZoom = true;    // Enable zooming
     controls.screenSpacePanning = true; // Enable screen space panning for better 2D feel
     
     controls.update();
   }
 } else {
   // Standard 3D positioning
   camera.position.set(maxDim * 1.5, maxDim * 1.5, maxDim * 1.5);
   camera.lookAt(0, 0, 0);
   
   if (typeof controls !== "undefined") {
     controls.target.set(0, 0, 0);
     controls.enabled = true; // Re-enable orbital controls for 3D grids
     
     // Re-enable rotation for 3D mode
     controls.enableRotate = true;
     controls.enablePan = true;
     controls.enableZoom = true;
     controls.screenSpacePanning = false; // Standard 3D panning
     
     controls.update();
   }
 }

 console.log(`Grid created with dimensions ${w}√ó${h}√ó${d}`);
}



function switchToGrid(id) {
  console.log(`switchToGrid called with id: ${id}`);
  console.log(`allGrids has this id:`, allGrids.has(id));
  
  // Clean up previous grid
  if (currentGrid) {
    console.log("Cleaning up previous grid");
    // Save camera
    currentGrid.cameraPosition = camera.position.clone();
    currentGrid.cameraTarget = controls.target.clone();

    // Remove previous group's mesh
    scene.remove(currentGrid.group);

    // Remove previous highlights from scene
    if (currentGrid.highlightedBoxHelpers && currentGrid.highlightedBoxHelpers.length) {
      for (const helper of currentGrid.highlightedBoxHelpers) {
        scene.remove(helper);
      }
    }
  }

  // Switch to new grid
  const grid = allGrids.get(id);
  console.log("Retrieved grid:", grid);
  currentGrid = grid;

  // Check if new grid is 2D
  const is2D = grid.width === 1 || grid.height === 1 || grid.depth === 1;
  
  // Configure controls based on grid type and user preference
  if (typeof controls !== "undefined") {
    controls.enabled = true; // Always keep controls enabled
    
    if (is2D && use2DCameraMode) {
      // 2D mode (if preference enabled): allow pan and zoom, disable rotation
      controls.enableRotate = false;
      controls.enablePan = true;
      controls.enableZoom = true;
      controls.screenSpacePanning = true;
    } else {
      // 3D mode (or 2D with preference disabled): enable all controls
      controls.enableRotate = true;
      controls.enablePan = true;
      controls.enableZoom = true;
      controls.screenSpacePanning = false;
    }
  }

  // Restore camera
  if (grid.cameraPosition && grid.cameraTarget) {
    camera.position.copy(grid.cameraPosition);
    controls.target.copy(grid.cameraTarget);
    controls.update();
  }

  // Reattach endpoint markers
  if (grid.startMarker && !grid.group.children.includes(grid.startMarker)) {
    grid.group.add(grid.startMarker);
  }
  if (grid.endMarker && !grid.group.children.includes(grid.endMarker)) {
    grid.group.add(grid.endMarker);
  }

  // Re-add this grid's highlights
  if (grid.highlightedBoxHelpers && grid.highlightedBoxHelpers.length) {
    for (const helper of grid.highlightedBoxHelpers) {
      scene.add(helper);
    }
  }

  console.log("Adding grid.group to scene:", grid.group);
  console.log("Grid group children count:", grid.group.children.length);
  
  // Verify grid has content
  if (grid.group.children.length === 0) {
    console.error('[switchToGrid] WARNING: Grid group has no children! Grid may be invisible.');
    console.error('[switchToGrid] Grid properties:', {
      isInstanced: grid.isInstanced,
      edgesCount: grid.edges?.size || 0,
      boxesXY: grid.boxesXY?.size || 0,
      boxesXZ: grid.boxesXZ?.size || 0,
      boxesYZ: grid.boxesYZ?.size || 0,
      hasInstancedEdgesThin: !!grid.instancedEdgesThin,
      hasInstancedEdgesThick: !!grid.instancedEdgesThick,
      hasInstancedBoxesXY: !!grid.instancedBoxesXY
    });
  }
  
  scene.add(grid.group);
  // Add this section to your existing switchToGrid function, after the scene.add(grid.group) line:

	// Ensure clipping is enabled if grid has custom planes
	if (grid.customPlanes && grid.customPlanes.length > 0) {
	  renderer.localClippingEnabled = true;
	}
		
  console.log("Scene children after add:", scene.children.length);

  // Update button highlighting - moved to the end with delay
  requestAnimationFrame(() => {
    // Remove active class from all grid buttons
    const allGridButtons = document.querySelectorAll('.grid-btn');
    allGridButtons.forEach(btn => btn.classList.remove('active'));
    
    // Add active class to the current grid's button
    const gridButtons = document.querySelectorAll('.grid-btn');
    for (const button of gridButtons) {
      const textSpan = button.querySelector('span');
      if (textSpan) {
        const fullName = textSpan.getAttribute('data-fullname') || textSpan.textContent;
        if (fullName === id) {
          button.classList.add('active');
          break;
        }
      }
    }
  });
  // Update notes window if it's open
	if (document.getElementById('notesWindow').style.display === 'block') {
	  updateNotesForCurrentGrid();
	}
	updateBBDistanceMaxValues();
	
	// Refresh axes if they're currently visible to show only relevant dimensions
	if (scene.userData.coordGroup && scene.userData.coordGroup.visible) {
	  toggleCoordinateAxes(); // Turn off
	  toggleCoordinateAxes(); // Turn back on with new grid's dimensions
	}
}


function buildGridContent(grid) {
  const W = grid.width;
  const H = grid.height;
  const D = grid.depth;
  for (let z = 0; z < D; z++) {
    // Add vertices at this layer
    for (let x = 0; x < W; x++) {
      for (let y = 0; y < H; y++) {
        addVertex(grid, x, y, z);
      }
    }
    // Add XY plane edges (horizontal and vertical)
    for (let x = 0; x < W - 1; x++) {
      for (let y = 0; y < H; y++) {
        addEdge(grid, [x, y, z], [x + 1, y, z]);
      }
    }
    for (let x = 0; x < W; x++) {
      for (let y = 0; y < H - 1; y++) {
        addEdge(grid, [x, y, z], [x, y + 1, z]);
      }
    }
    // Add XY-plane boxes at this layer
    for (let x = 0; x < W - 1; x++) {
      for (let y = 0; y < H - 1; y++) {
        addXYBox(grid, x, y, z);
      }
    }
    // Add Z-direction vertical edges and XZ/YZ boxes between layers
    if (z + 1 < D) {
      for (let x = 0; x < W; x++) {
        for (let y = 0; y < H; y++) {
          addVertex(grid, x, y, z + 1);
          addEdge(grid, [x, y, z], [x, y, z + 1]);
        }
      }
      // Add XZ boxes (fixed y)
      for (let x = 0; x < W - 1; x++) {
        for (let y = 0; y < H; y++) {
          addXZBox(grid, x, y, z);
        }
      }
      // Add YZ boxes (fixed x)
      for (let y = 0; y < H - 1; y++) {
        for (let x = 0; x < W; x++) {
          addYZBox(grid, x, y, z);
        }
      }
    }
  }
  
  // Set initial opacity for all uncolored edges based on background
  for (const [edgeKey, edge] of grid.edges.entries()) {
    if (edge.color === UNCOLORED_COLOR && edge.mesh) {
      // Check current background color
      const backgroundHex = scene.background.getHex();
      const opacity = backgroundHex === 0x000000 ? 0.3 : 1.0;
      
      const grayValue = Math.floor(0x88 * opacity);
      const simulatedColor = (grayValue << 16) | (grayValue << 8) | grayValue;
      edge.mesh.material.color.setHex(simulatedColor);
      edge.mesh.material.needsUpdate = true;
    }
  }
  
  // Initialize instanced rendering mode
  if (useInstancedRendering) {
  console.log('[buildGridContent] Initializing instanced rendering...');
  console.log(`[buildGridContent] Grid has ${grid.edges.size} edges, ${grid.boxesXY.size + grid.boxesXZ.size + grid.boxesYZ.size} boxes`);
  
  try {
    grid.isInstanced = true;  // Mark this grid as instanced
    
    initializeInstancedGridEdges(grid);
    console.log('[buildGridContent] ‚úì Edges initialized');
    console.log('[buildGridContent] Grid group now has', grid.group.children.length, 'children');
    
    initializeInstancedBoxes(grid);
    console.log('[buildGridContent] ‚úì Boxes initialized');
    console.log('[buildGridContent] Grid group now has', grid.group.children.length, 'children');
    
    initializeInstancedArrows(grid);
    console.log('[buildGridContent] ‚úì Arrows initialized');
    console.log('[buildGridContent] Grid group now has', grid.group.children.length, 'children');
    
    initializeInstancedVertexSpheres(grid);
    console.log('[buildGridContent] ‚úì Vertex spheres initialized');
    console.log('[buildGridContent] Grid group now has', grid.group.children.length, 'children');
    
    // Verify meshes were added
    if (!grid.instancedEdgesThin || !grid.instancedEdgesThick) {
      console.error('[buildGridContent] ERROR: Edge meshes not created!');
    }
    if (!grid.instancedBoxesXY || !grid.instancedBoxesXZ || !grid.instancedBoxesYZ) {
      console.error('[buildGridContent] ERROR: Box meshes not created!');
    }
    if (!grid.instancedVertexSpheres || !grid.instancedVertexCollisionHelpers) {
      console.error('[buildGridContent] ERROR: Vertex meshes not created!');
    }
    
  } catch (error) {
    console.error('[buildGridContent] FATAL ERROR during instanced initialization:', error);
    console.error('[buildGridContent] Stack:', error.stack);
    // Fall back to marking as non-instanced
    grid.isInstanced = false;
  }
}
}




function addXYBox(grid, x, y, z = 0) {
  const boxKey = vertexKey(x, y, z);
  const v = [[x, y, z], [x + 1, y, z], [x + 1, y + 1, z], [x, y + 1, z] ];
  const eKeys = [edgeKey(v[0], v[1]), edgeKey(v[1], v[2]), edgeKey(v[2], v[3]), edgeKey(v[3], v[0]) ];

  const box = {coords: [x, y, z], plane: "XY", edges: eKeys, z: z, mesh: null  };

  // Only create mesh if NOT using instanced rendering
  if (!useInstancedRendering) {
    const geometry = new THREE.PlaneGeometry(1, 1);
    geometry.rotateX(0);
    geometry.translate(x + 0.5, y + 0.5, z);
    const material = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0, side: THREE.DoubleSide });

    const mesh = new THREE.Mesh(geometry, material);
    mesh.userData.box = box;
    box.mesh = mesh;
    grid.group.add(mesh);
  }

  grid.boxesXY.set(boxKey, box);
}

function addXZBox(grid, x, y, z = 0) {
  const boxKey = vertexKey(x, y, z);
  const v = [[x, y, z], [x + 1, y, z], [x + 1, y, z + 1], [x, y, z + 1]];
  const eKeys = [edgeKey(v[0], v[1]), edgeKey(v[1], v[2]), edgeKey(v[2], v[3]), edgeKey(v[3], v[0])];

  const box = { coords: [x, y, z], plane: "XZ", edges: eKeys, mesh: null };

  // Only create mesh if NOT using instanced rendering
  if (!useInstancedRendering) {
    const geometry = new THREE.PlaneGeometry(1, 1);
    geometry.rotateX(Math.PI / 2);
    geometry.translate(x + 0.5, y, z + 0.5);

    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0, side: THREE.DoubleSide });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.userData.box = box;
    box.mesh = mesh;
    grid.group.add(mesh);
  }

  grid.boxesXZ.set(boxKey, box);
}

function addYZBox(grid, x, y, z = 0) {
  const boxKey = vertexKey(x, y, z);
  const v = [[x, y, z], [x, y + 1, z], [x, y + 1, z + 1], [x, y, z + 1]];
  const eKeys = [edgeKey(v[0], v[1]), edgeKey(v[1], v[2]), edgeKey(v[2], v[3]), edgeKey(v[3], v[0])];

  const box = { coords: [x, y, z], plane: "YZ", edges: eKeys, mesh: null };

  // Only create mesh if NOT using instanced rendering
  if (!useInstancedRendering) {
    const geometry = new THREE.PlaneGeometry(1, 1);
    geometry.rotateY(Math.PI / 2);
    geometry.translate(x, y + 0.5, z + 0.5);

    const material = new THREE.MeshBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 0, side: THREE.DoubleSide });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.userData.box = box;
    box.mesh = mesh;
    grid.group.add(mesh);
  }

  grid.boxesYZ.set(boxKey, box);
}

class Subgraph {
  constructor(grid) {
    this.grid = grid;
    this.edges = new Set();         // Set of edge keys
    this.vertices = new Set();      // Set of vertex keys
  }

  addEdge(a, b) {
    const eKey = edgeKey(a, b);
    if (this.edges.has(eKey)) return;

    // Add edge
    this.edges.add(eKey);

    // Add vertices
    this.vertices.add(vertexKey(...a));
    this.vertices.add(vertexKey(...b));

    // Visually color
    colorEdge(this.grid, a, b, selectedColor, 0.05);
  }

  removeEdge(a, b) {
    const eKey = edgeKey(a, b);
    if (!this.edges.has(eKey)) return;

    this.edges.delete(eKey);

    // Recolor visually
    colorEdge(this.grid, a, b, UNCOLORED_COLOR, 0.015);

    // Possibly remove isolated vertices
    const v1 = vertexKey(...a);
    const v2 = vertexKey(...b);

    if (this.getNeighbors(v1).length === 0) {
      this.vertices.delete(v1);
    }
    if (this.getNeighbors(v2).length === 0) {
      this.vertices.delete(v2);
    }
  }

  hasEdge(a, b) {
    return this.edges.has(edgeKey(a, b));
  }

  hasVertex(v) {
    return this.vertices.has(vertexKey(...v));
  }

  getNeighbors(vKey) {
    const neighbors = [];
    for (const eKey of this.edges) {
      const [aStr, bStr] = eKey.split("-");
      if (aStr === vKey) neighbors.push(bStr);
      else if (bStr === vKey) neighbors.push(aStr);
    }
    return neighbors;
  }

  edgeCount() {
    return this.edges.size;
  }

  vertexCount() {
    return this.vertices.size;
  }

  clear() {
    // Remove all edges and recolor
    for (const eKey of this.edges) {
      const [aStr, bStr] = eKey.split("-");
      const a = aStr.split(",").map(Number);
      const b = bStr.split(",").map(Number);
      colorEdge(this.grid, a, b, UNCOLORED_COLOR, 0.015);
    }
    this.edges.clear();
    this.vertices.clear();
  }

  getEdgeKeys() {
    return [...this.edges];
  }

  getVertexKeys() {
    return [...this.vertices];
  }
  
static fromEdgeKeys(grid, edgeKeys) {
  const sg = new Subgraph(grid);
  for (const eKey of edgeKeys) {
    const [aStr, bStr] = eKey.split("-");
    const a = aStr.split(",").map(Number);
    const b = bStr.split(",").map(Number);
    sg.addEdge(a, b);
  }
  return sg;
}
  
}


 //  ==============================    I.E.R. FUNCTIONS   ===========================  \\

function initializeInstancedGridEdges(grid) {
  const totalEdges = grid.edges.size;
  
  // Safety check: ensure we have edges to render
  if (totalEdges === 0) {
    console.warn('[initializeInstancedGridEdges] Grid has 0 edges, skipping instanced edge initialization');
    // Initialize empty structures so the rest of the code doesn't break
    grid.instancedEdgesThin = null;
    grid.instancedEdgesThick = null;
    grid.instancedEdgesCollision = null;
    grid.instancedBlockCubes = null;
    grid.edgeToInstanceMap = new Map();
    grid.instanceSlots = {
      thin: { nextAvailable: 0, freeSlots: [] },
      thick: { nextAvailable: 0, freeSlots: [] }
    };
    return;
  }
  
  console.log(`[initializeInstancedGridEdges] Creating instanced meshes for ${totalEdges} edges`);
  
  // Create thin mesh (pre-allocated for all edges)
  const thinGeometry = new THREE.CylinderGeometry(0.015, 0.015, 1, 8);
  const thinMaterial = new THREE.MeshBasicMaterial();
  grid.instancedEdgesThin = new THREE.InstancedMesh(thinGeometry, thinMaterial, totalEdges);
  grid.instancedEdgesThin.instanceColor = new THREE.InstancedBufferAttribute(
    new Float32Array(totalEdges * 3), 3
  );
  
  // Create thick mesh (pre-allocated for all edges, starts empty)
  const thickGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
  const thickMaterial = new THREE.MeshBasicMaterial();
  grid.instancedEdgesThick = new THREE.InstancedMesh(thickGeometry, thickMaterial, totalEdges);
  grid.instancedEdgesThick.instanceColor = new THREE.InstancedBufferAttribute(
    new Float32Array(totalEdges * 3), 3
  );
  
  // Create collision mesh (invisible, fat cylinders for easy clicking)
  const collisionGeometry = new THREE.CylinderGeometry(edgeCollisionRadius, edgeCollisionRadius, 1, 8);
  const collisionMaterial = new THREE.MeshBasicMaterial({ 
    transparent: true, opacity: 0, depthTest: true, depthWrite: false // Invisible but still raycastable
  });
  grid.instancedEdgesCollision = new THREE.InstancedMesh(collisionGeometry, collisionMaterial, totalEdges);
  
  // Initialize tracking structures
  grid.edgeToInstanceMap = new Map();
  grid.instanceSlots = {
    thin: { nextAvailable: 0, freeSlots: [] },
    thick: { nextAvailable: 0, freeSlots: [] }
  };
  
  // Populate ALL edges into thin mesh initially
  const matrix = new THREE.Matrix4();
  const quaternion = new THREE.Quaternion();
  const up = new THREE.Vector3(0, 1, 0);
  
  // Apply dimming based on current background color
  const backgroundHex = scene.background.getHex();
  const opacity = backgroundHex === 0x000000 ? 0.3 : 1.0;
  const grayValue = Math.floor(0x88 * opacity);
  const simulatedColor = (grayValue << 16) | (grayValue << 8) | grayValue;
  const grayColor = new THREE.Color(simulatedColor);
  
  const zeroMatrix = new THREE.Matrix4().makeScale(0, 0, 0);
  
  let edgeIndex = 0;
  for (const [eKey, edge] of grid.edges.entries()) {
    const [aStr, bStr] = eKey.split("-");
    const a = aStr.split(",").map(Number);
    const b = bStr.split(",").map(Number);
    
    const start = new THREE.Vector3(...a);
    const end = new THREE.Vector3(...b);
    const direction = new THREE.Vector3().subVectors(end, start);
    const length = direction.length();
    const midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
    
    // Build transform matrix
    matrix.makeScale(1, length, 1);
    quaternion.setFromUnitVectors(up, direction.normalize());
    const rotationMatrix = new THREE.Matrix4().makeRotationFromQuaternion(quaternion);
    matrix.premultiply(rotationMatrix);
    matrix.setPosition(midpoint);
    
    // Always initialize edges as visible (Toggle Grid button will control visibility later)
    grid.instancedEdgesThin.setMatrixAt(edgeIndex, matrix);
    grid.instancedEdgesThin.setColorAt(edgeIndex, grayColor);
    
    // Set thick mesh slot to zero (hidden) - use SAME index
    grid.instancedEdgesThick.setMatrixAt(edgeIndex, zeroMatrix);
    grid.instancedEdgesThick.setColorAt(edgeIndex, grayColor);
    
    // Set collision mesh to SAME transform as thin (always active for clicking)
    grid.instancedEdgesCollision.setMatrixAt(edgeIndex, matrix);
    
    // Map all three meshes to the same index
    grid.edgeToInstanceMap.set(eKey, { 
      thin: edgeIndex, 
      thick: edgeIndex,
      collision: edgeIndex 
    });
    
    edgeIndex++;
  }
  
  grid.instanceSlots.thin.nextAvailable = totalEdges;
  grid.instanceSlots.thick.nextAvailable = totalEdges;
  
  grid.instancedEdgesThin.instanceMatrix.needsUpdate = true;
  grid.instancedEdgesThin.instanceColor.needsUpdate = true;
  grid.instancedEdgesThick.instanceMatrix.needsUpdate = true;
  grid.instancedEdgesThick.instanceColor.needsUpdate = true;
  grid.instancedEdgesCollision.instanceMatrix.needsUpdate = true;
  
  grid.group.add(grid.instancedEdgesThin);
  grid.group.add(grid.instancedEdgesThick);
  grid.group.add(grid.instancedEdgesCollision); // Add collision mesh to scene
  
  // Create instanced mesh for block cubes (pre-allocated for all edges)
  const cubeGeometry = new THREE.BoxGeometry(0.15, 0.15, 0.15);
  const cubeMaterial = new THREE.MeshBasicMaterial();
  grid.instancedBlockCubes = new THREE.InstancedMesh(cubeGeometry, cubeMaterial, totalEdges);
  grid.instancedBlockCubes.instanceColor = new THREE.InstancedBufferAttribute(
    new Float32Array(totalEdges * 3), 3
  );
  
  // Initialize all cube slots to zero (hidden)
  const cubeZeroMatrix = new THREE.Matrix4().makeScale(0, 0, 0);
  for (let i = 0; i < totalEdges; i++) {
    grid.instancedBlockCubes.setMatrixAt(i, cubeZeroMatrix);
  }
  
  grid.instancedBlockCubes.instanceMatrix.needsUpdate = true;
  grid.group.add(grid.instancedBlockCubes);
  
  console.log(`[initializeInstancedGridEdges] ‚úì Successfully created and added instanced meshes`);
  console.log(`[initializeInstancedGridEdges] - Thin edges: ${grid.instancedEdgesThin ? 'created' : 'FAILED'}`);
  console.log(`[initializeInstancedGridEdges] - Thick edges: ${grid.instancedEdgesThick ? 'created' : 'FAILED'}`);
  console.log(`[initializeInstancedGridEdges] - Collision edges: ${grid.instancedEdgesCollision ? 'created' : 'FAILED'}`);
  console.log(`[initializeInstancedGridEdges] - Block cubes: ${grid.instancedBlockCubes ? 'created' : 'FAILED'}`);
  console.log(`[initializeInstancedGridEdges] - Grid group children: ${grid.group.children.length}`);
}


function colorEdgeInstanced(grid, a, b, color, width) {
  const eKey = edgeKey(a, b);
  const mapping = grid.edgeToInstanceMap.get(eKey);
  if (!mapping) return;
  
  const edge = grid.edges.get(eKey);
  if (!edge) return;
  
  // Apply dimming for uncolored edges
  let threeColor;
  if (color === UNCOLORED_COLOR) {
    // Read actual slider value
    const opacity = parseFloat(document.getElementById("gridOpacitySlider").value);
    const grayValue = Math.floor(0x88 * opacity);
    const simulatedColor = (grayValue << 16) | (grayValue << 8) | grayValue;
    threeColor = new THREE.Color(simulatedColor);
  } else {
    threeColor = new THREE.Color(color);
  }
  
  const isThick = (width >= 0.04);
  
  // Update edge data
  edge.color = color;
  
  const start = new THREE.Vector3(...a);
  const end = new THREE.Vector3(...b);
  const direction = new THREE.Vector3().subVectors(end, start);
  const length = direction.length();
  const midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
  
  const matrix = new THREE.Matrix4();
  const quaternion = new THREE.Quaternion();
  const up = new THREE.Vector3(0, 1, 0);
  
  matrix.makeScale(1, length, 1);
  quaternion.setFromUnitVectors(up, direction.normalize());
  const rotationMatrix = new THREE.Matrix4().makeRotationFromQuaternion(quaternion);
  matrix.premultiply(rotationMatrix);
  matrix.setPosition(midpoint);
  
  const zeroMatrix = new THREE.Matrix4().makeScale(0, 0, 0);
  
  if (isThick) {
    // Show thick, hide thin
    grid.instancedEdgesThick.setMatrixAt(mapping.thick, matrix);
    grid.instancedEdgesThick.setColorAt(mapping.thick, threeColor);
    grid.instancedEdgesThin.setMatrixAt(mapping.thin, zeroMatrix);
  } else {
    // Show thin, hide thick
    grid.instancedEdgesThin.setMatrixAt(mapping.thin, matrix);
    grid.instancedEdgesThin.setColorAt(mapping.thin, threeColor);
    grid.instancedEdgesThick.setMatrixAt(mapping.thick, zeroMatrix);
  }
  
  // CRITICAL: Update collision mesh to match active visual mesh
  grid.instancedEdgesCollision.setMatrixAt(mapping.collision, matrix);
  
  grid.instancedEdgesThin.instanceMatrix.needsUpdate = true;
  grid.instancedEdgesThin.instanceColor.needsUpdate = true;
  grid.instancedEdgesThick.instanceMatrix.needsUpdate = true;
  grid.instancedEdgesThick.instanceColor.needsUpdate = true;
  grid.instancedEdgesCollision.instanceMatrix.needsUpdate = true;
}



function addBlockCubeInstanced(grid, edge, eKey) {
  const mapping = grid.edgeToInstanceMap.get(eKey);
  if (!mapping) return;
  
  const [aStr, bStr] = eKey.split("-");
  const a = aStr.split(",").map(Number);
  const b = bStr.split(",").map(Number);
  
  const start = new THREE.Vector3(...a);
  const end = new THREE.Vector3(...b);
  const midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
  
  const cubeMatrix = new THREE.Matrix4();
  cubeMatrix.setPosition(midpoint);
  
  grid.instancedBlockCubes.setMatrixAt(mapping.thin, cubeMatrix);
  
  // Set cube color to secondary color
  const cubeColor = new THREE.Color(selectedColor2);
  grid.instancedBlockCubes.setColorAt(mapping.thin, cubeColor);
  
  grid.instancedBlockCubes.instanceMatrix.needsUpdate = true;
  grid.instancedBlockCubes.instanceColor.needsUpdate = true;
  
  edge.blockCube = true; // Mark as having a cube
}

function removeBlockCubeInstanced(grid, edge, eKey) {
  const mapping = grid.edgeToInstanceMap.get(eKey);
  if (!mapping) return;
  
  const cubeZeroMatrix = new THREE.Matrix4().makeScale(0, 0, 0);
  grid.instancedBlockCubes.setMatrixAt(mapping.thin, cubeZeroMatrix);
  grid.instancedBlockCubes.instanceMatrix.needsUpdate = true;
  
  edge.blockCube = false; // Mark as not having a cube
}

function initializeInstancedBoxes(grid) {
  const totalXY = grid.boxesXY.size;
  const totalXZ = grid.boxesXZ.size;
  const totalYZ = grid.boxesYZ.size;
  
  console.log(`[initializeInstancedBoxes] Creating instanced meshes for ${totalXY} XY, ${totalXZ} XZ, ${totalYZ} YZ boxes`);

  // Geometries & materials (double-sided, transparent)
  const geoXY = new THREE.PlaneGeometry(1, 1);
  const matXY = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, side: THREE.DoubleSide });

  const geoXZ = new THREE.PlaneGeometry(1, 1);
  geoXZ.rotateX(Math.PI / 2);
  const matXZ = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, side: THREE.DoubleSide });

  const geoYZ = new THREE.PlaneGeometry(1, 1);
  geoYZ.rotateY(Math.PI / 2);
  const matYZ = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, side: THREE.DoubleSide });

  grid.instancedBoxesXY = new THREE.InstancedMesh(geoXY, matXY, totalXY);
  grid.instancedBoxesXZ = new THREE.InstancedMesh(geoXZ, matXZ, totalXZ);
  grid.instancedBoxesYZ = new THREE.InstancedMesh(geoYZ, matYZ, totalYZ);

  // Canonical per-type arrays (index == instanceId) and reverse map
  grid.instancesXY = new Array(totalXY);
  grid.instancesXZ = new Array(totalXZ);
  grid.instancesYZ = new Array(totalYZ);

  grid.instanceIdFromBoxKey = new Map(); // boxKey -> {type, index}

  const M = new THREE.Matrix4();

  // ‚Äî‚Äî XY ‚Äî‚Äî
  let i = 0;
  for (const [boxKey, box] of grid.boxesXY) {
    const [x, y, z] = box.coords;
    M.makeTranslation(x + 0.5, y + 0.5, z);
    grid.instancedBoxesXY.setMatrixAt(i, M);

    grid.instancesXY[i] = box;               // index ‚Üî box
    grid.instanceIdFromBoxKey.set(boxKey, { type: 'XY', index: i });

    box.instanceType = 'XY';
    box.instanceId   = i;
    i++;
  }
  grid.instancedBoxesXY.instanceMatrix.needsUpdate = true;

  // ‚Äî‚Äî XZ ‚Äî‚Äî
  i = 0;
  for (const [boxKey, box] of grid.boxesXZ) {
    const [x, y, z] = box.coords;
    M.makeTranslation(x + 0.5, y, z + 0.5);
    grid.instancedBoxesXZ.setMatrixAt(i, M);

    grid.instancesXZ[i] = box;
    grid.instanceIdFromBoxKey.set(boxKey, { type: 'XZ', index: i });

    box.instanceType = 'XZ';
    box.instanceId   = i;
    i++;
  }
  grid.instancedBoxesXZ.instanceMatrix.needsUpdate = true;

  // ‚Äî‚Äî YZ ‚Äî‚Äî
  i = 0;
  for (const [boxKey, box] of grid.boxesYZ) {
    const [x, y, z] = box.coords;
    M.makeTranslation(x, y + 0.5, z + 0.5);
    grid.instancedBoxesYZ.setMatrixAt(i, M);

    grid.instancesYZ[i] = box;
    grid.instanceIdFromBoxKey.set(boxKey, { type: 'YZ', index: i });

    box.instanceType = 'YZ';
    box.instanceId   = i;
    i++;
  }
  grid.instancedBoxesYZ.instanceMatrix.needsUpdate = true;

  grid.group.add(grid.instancedBoxesXY, grid.instancedBoxesXZ, grid.instancedBoxesYZ);
  
  console.log(`[initializeInstancedBoxes] ‚úì Successfully created and added instanced box meshes`);
  console.log(`[initializeInstancedBoxes] - XY boxes: ${grid.instancedBoxesXY ? 'created' : 'FAILED'}`);
  console.log(`[initializeInstancedBoxes] - XZ boxes: ${grid.instancedBoxesXZ ? 'created' : 'FAILED'}`);
  console.log(`[initializeInstancedBoxes] - YZ boxes: ${grid.instancedBoxesYZ ? 'created' : 'FAILED'}`);
}


function initializeInstancedArrows(grid) {
  const totalEdges = grid.edges.size;
  
  // Safety check: ensure we have edges
  if (totalEdges === 0) {
    console.warn('[initializeInstancedArrows] Grid has 0 edges, skipping instanced arrow initialization');
    grid.instancedArrowsForward = null;
    grid.instancedArrowsBackward = null;
    grid.edgeToArrowInstanceMap = new Map();
    grid.arrowInstanceSlots = {
      forward: { nextAvailable: 0, freeSlots: [] },
      backward: { nextAvailable: 0, freeSlots: [] }
    };
    return;
  }
  
  console.log(`[initializeInstancedArrows] Creating instanced arrow meshes for ${totalEdges} edges`);
  
  // Create arrow texture for forward direction
  const textureForward = createArrowTexture(1);
  textureForward.wrapS = THREE.ClampToEdgeWrapping;
  textureForward.wrapT = THREE.RepeatWrapping;
  textureForward.center.set(0.5, 0.5);
  textureForward.rotation = Math.PI / 2;
  textureForward.repeat.set(1, 3);
  
  // Create arrow texture for backward direction
  const textureBackward = createArrowTexture(-1);
  textureBackward.wrapS = THREE.ClampToEdgeWrapping;
  textureBackward.wrapT = THREE.RepeatWrapping;
  textureBackward.center.set(0.5, 0.5);
  textureBackward.rotation = Math.PI / 2;
  textureBackward.repeat.set(1, 3);
  
  // Forward arrows instanced mesh
  const forwardGeometry = new THREE.CylinderGeometry(0.051, 0.051, 1, 6, 1, true);
  const forwardMaterial = new THREE.MeshBasicMaterial({
    map: textureForward,
    transparent: true,
    depthTest: false
  });
  grid.instancedArrowsForward = new THREE.InstancedMesh(forwardGeometry, forwardMaterial, totalEdges);
  
  // Backward arrows instanced mesh
  const backwardGeometry = new THREE.CylinderGeometry(0.051, 0.051, 1, 6, 1, true);
  const backwardMaterial = new THREE.MeshBasicMaterial({
    map: textureBackward,
    transparent: true,
    depthTest: false
  });
  grid.instancedArrowsBackward = new THREE.InstancedMesh(backwardGeometry, backwardMaterial, totalEdges);
  
  // Initialize tracking
  grid.edgeToArrowInstanceMap = new Map(); // edgeKey -> {direction: 1/-1, index: number}
  grid.arrowInstanceSlots = {
    forward: { nextAvailable: 0, freeSlots: [] },
    backward: { nextAvailable: 0, freeSlots: [] }
  };
  
  // Initialize all arrows as hidden (zero matrix)
  const zeroMatrix = new THREE.Matrix4().makeScale(0, 0, 0);
  for (let i = 0; i < totalEdges; i++) {
    grid.instancedArrowsForward.setMatrixAt(i, zeroMatrix);
    grid.instancedArrowsBackward.setMatrixAt(i, zeroMatrix);
  }
  
  grid.instancedArrowsForward.instanceMatrix.needsUpdate = true;
  grid.instancedArrowsBackward.instanceMatrix.needsUpdate = true;
  
  // Disable raycasting for arrows
  grid.instancedArrowsForward.raycast = () => {};
  grid.instancedArrowsBackward.raycast = () => {};
  
  grid.group.add(grid.instancedArrowsForward);
  grid.group.add(grid.instancedArrowsBackward);
  
  console.log(`[initializeInstancedArrows] ‚úì Successfully created and added instanced arrow meshes`);
  console.log(`[initializeInstancedArrows] - Forward arrows: ${grid.instancedArrowsForward ? 'created' : 'FAILED'}`);
  console.log(`[initializeInstancedArrows] - Backward arrows: ${grid.instancedArrowsBackward ? 'created' : 'FAILED'}`);
}



function initializeInstancedVertexSpheres(grid) {
  const totalVertices = grid.vertices.size;
  
  if (totalVertices === 0) {
    console.warn('[initializeInstancedVertexSpheres] Grid has 0 vertices');
    grid.instancedVertexSpheres = null;
    grid.instancedVertexCollisionHelpers = null;
    grid.vertexToInstanceMap = new Map();
    return;
  }
  
  console.log(`[initializeInstancedVertexSpheres] Creating instanced meshes for ${totalVertices} vertices`);
  
  // Visual spheres (0.12 radius)
  const sphereGeometry = new THREE.SphereGeometry(0.12, 16, 16);
  const sphereMaterial = new THREE.MeshBasicMaterial();
  grid.instancedVertexSpheres = new THREE.InstancedMesh(sphereGeometry, sphereMaterial, totalVertices);
  grid.instancedVertexSpheres.instanceColor = new THREE.InstancedBufferAttribute(
    new Float32Array(totalVertices * 3), 3
  );
  
  // Collision helpers (0.2 radius, invisible)
  const collisionGeometry = new THREE.SphereGeometry(0.3, 8, 8);
  const collisionMaterial = new THREE.MeshBasicMaterial({ 
    transparent: true,
    opacity: 0,
    visible: false
  });
  grid.instancedVertexCollisionHelpers = new THREE.InstancedMesh(
    collisionGeometry, collisionMaterial, totalVertices
  );
  
  // Initialize mapping
  grid.vertexToInstanceMap = new Map();
  
  // CRITICAL FIX: Visual spheres hidden, but collision helpers at vertex positions
  const zeroMatrix = new THREE.Matrix4().makeScale(0, 0, 0);
  const collisionMatrix = new THREE.Matrix4(); // Identity matrix at vertex position
  
  let instanceIndex = 0;
  for (const [vKey, vertexData] of grid.vertices.entries()) {
    // Hide visual sphere
    grid.instancedVertexSpheres.setMatrixAt(instanceIndex, zeroMatrix);
    
    // Show collision helper at vertex position (for raycasting)
    const [x, y, z] = vKey.split(',').map(Number);
    collisionMatrix.setPosition(x, y, z);
    grid.instancedVertexCollisionHelpers.setMatrixAt(instanceIndex, collisionMatrix);
    
    // Create mapping
    grid.vertexToInstanceMap.set(vKey, instanceIndex);
    instanceIndex++;
  }
  
  grid.instancedVertexSpheres.instanceMatrix.needsUpdate = true;
  grid.instancedVertexCollisionHelpers.instanceMatrix.needsUpdate = true;
  
  grid.group.add(grid.instancedVertexSpheres);
  grid.group.add(grid.instancedVertexCollisionHelpers);
  
  console.log('[initializeInstancedVertexSpheres] ‚úì Successfully created vertex meshes');
  console.log(`[initializeInstancedVertexSpheres] - Visual spheres: ${grid.instancedVertexSpheres ? 'created' : 'FAILED'}`);
  console.log(`[initializeInstancedVertexSpheres] - Collision helpers: ${grid.instancedVertexCollisionHelpers ? 'created' : 'FAILED'}`);
}


function addArrowInstanced(grid, edge, direction, from, to) {
  const eKey = edgeKey(from, to);  // Canonical key
  
  // Remove existing arrow if present
  if (grid.edgeToArrowInstanceMap.has(eKey)) {
    removeArrowInstanced(grid, edge, eKey);  // Pass key to avoid rescan
  }
  
  // Determine which mesh to use
  const isForward = direction === 1;
  const instancedMesh = isForward ? grid.instancedArrowsForward : grid.instancedArrowsBackward;
  const slots = isForward ? grid.arrowInstanceSlots.forward : grid.arrowInstanceSlots.backward;
  
  // Get or allocate instance slot
  let instanceIndex;
  if (slots.freeSlots.length > 0) {
    instanceIndex = slots.freeSlots.pop();
  } else {
    instanceIndex = slots.nextAvailable++;
  }
  
  // Calculate transform matrix
  const startPos = new THREE.Vector3(from[0], from[1], from[2] ?? 0);
  const endPos = new THREE.Vector3(to[0], to[1], to[2] ?? 0);
  const edgeLength = startPos.distanceTo(endPos);
  const midpoint = new THREE.Vector3().addVectors(startPos, endPos).multiplyScalar(0.5);
  
  // Determine radius based on edge color
  const edgeRadius = (edge.color !== UNCOLORED_COLOR) ? 0.05 : 0.015;
  const arrowRadius = edgeRadius * 1.02;
  
  // Build matrix
  const matrix = new THREE.Matrix4();
  const quaternion = new THREE.Quaternion();
  const up = new THREE.Vector3(0, 1, 0);
  
  // Scale to match edge length and radius
  matrix.makeScale(arrowRadius / 0.051, edgeLength, arrowRadius / 0.051);
  
  // Rotate to align with edge direction
  const dir = new THREE.Vector3().subVectors(endPos, startPos);
  if (dir.lengthSq() > 0) {
    dir.normalize();
    quaternion.setFromUnitVectors(up, dir);
    const rotationMatrix = new THREE.Matrix4().makeRotationFromQuaternion(quaternion);
    matrix.premultiply(rotationMatrix);
  }
  
  // Position at midpoint
  matrix.setPosition(midpoint);
  
  // Update instance
  instancedMesh.setMatrixAt(instanceIndex, matrix);
  instancedMesh.instanceMatrix.needsUpdate = true;
  
  // FIX 3: Ensure instance count covers this index
  instancedMesh.count = Math.max(instancedMesh.count, instanceIndex + 1);
  
  // Store mapping with CANONICAL key
  grid.edgeToArrowInstanceMap.set(eKey, {
    direction: direction,
    index: instanceIndex
  });
  
  // Update edge data
  edge.arrowDirection = direction;
  edge.arrows = 'instanced';
}

function removeArrowInstanced(grid, edge, providedKey = null) {
  // Use provided key or find it
  let eKey = providedKey;
  if (!eKey) {
    for (const [key, e] of grid.edges.entries()) {
      if (e === edge) {
        eKey = key;
        break;
      }
    }
  }
  
  if (!eKey || !grid.edgeToArrowInstanceMap.has(eKey)) return;
  
  const mapping = grid.edgeToArrowInstanceMap.get(eKey);
  const isForward = mapping.direction === 1;
  const instancedMesh = isForward ? grid.instancedArrowsForward : grid.instancedArrowsBackward;
  const slots = isForward ? grid.arrowInstanceSlots.forward : grid.arrowInstanceSlots.backward;
  
  // Hide the arrow by setting zero matrix
  const zeroMatrix = new THREE.Matrix4().makeScale(0, 0, 0);
  instancedMesh.setMatrixAt(mapping.index, zeroMatrix);
  instancedMesh.instanceMatrix.needsUpdate = true;
  
  // Free the slot
  slots.freeSlots.push(mapping.index);
  
  // Remove mapping
  grid.edgeToArrowInstanceMap.delete(eKey);
  
  // Clear edge data
  edge.arrows = null;
  edge.arrowDirection = undefined;
}



//     ====================================================================================================================
// 											   11. Ctrl+Z, Ctrl+R 
//     ====================================================================================================================


// Core undo/redo system
function recordAction(actionType, actionData) {
  if (!currentGrid) return;
  
  const action = {
    type: actionType,
    data: actionData,
    timestamp: Date.now()
  };
  
  currentGrid.undoStack.push(action);
  currentGrid.redoStack = []; // Clear redo stack on new action
  
  // Limit undo stack size
  if (currentGrid.undoStack.length > currentGrid.maxUndoSteps) {
    currentGrid.undoStack.shift();
  }
}


function performUndo() {
  if (!currentGrid || currentGrid.undoStack.length === 0) {
    console.log("Nothing to undo");
    return;
  }
  
  const action = currentGrid.undoStack.pop();
  
  // Execute the undo operation
  switch (action.type) {
    case 'VERTEX_SPHERE':
      undoVertexSphere(action.data);
      break;
    case 'VERTEX_DECORATION':
      undoVertexDecoration(action.data);
      break;
    case 'EDGE_STATE':
      undoEdgeState(action.data);
      break;
    case 'LAYER_OPERATION':
      undoLayerOperation(action.data);
      break;
    case 'BB_DISTANCE_BATCH':           // <-- ADD THIS
      undoBBDistanceBatch(action.data);  // <-- ADD THIS
      break;
	case 'CLEAR_ALL_VERTICES':
	  undoClearAllVertices(action.data);
	  break;// <-- ADD THIS
	case 'BACKBITE':  // ADD THIS
      undoBackbite(action.data);
      break;
    case 'SWITCH':  // ADD THIS
      undoSwitch(action.data);
      break;  
    default:
      console.warn('Unknown action type:', action.type);
  }
  
  currentGrid.redoStack.push(action);
}

function performRedo() {
  if (!currentGrid || currentGrid.redoStack.length === 0) {
    console.log("Nothing to redo");
    return;
  }
  
  const action = currentGrid.redoStack.pop();
  
  // Execute the redo operation (same as original action)
  switch (action.type) {
    case 'VERTEX_SPHERE':
      redoVertexSphere(action.data);
      break;
    case 'VERTEX_DECORATION':
      redoVertexDecoration(action.data);
      break;
    case 'EDGE_STATE':
      redoEdgeState(action.data);
      break;
    case 'LAYER_OPERATION':
      redoLayerOperation(action.data);
      break;
    case 'BB_DISTANCE_BATCH':           // <-- ADD THIS
      redoBBDistanceBatch(action.data);  // <-- ADD THIS
      break;                             // <-- ADD THIS
    case 'CLEAR_ALL_VERTICES':
      redoClearAllVertices(action.data);
      break;
	case 'BACKBITE':  // ADD THIS
      redoBackbite(action.data);
      break;
    case 'SWITCH':  // ADD THIS
      redoSwitch(action.data);
      break;  
	default:
      console.warn('Unknown action type:', action.type);
  }
  
  currentGrid.undoStack.push(action);
}


// Vertex sphere undo/redo functions
function undoVertexSphere(actionData) {
  const { vertexKey, beforeState } = actionData;
  
  if (beforeState === null) {
    // Sphere was added, so remove it
    removeVertexSphere(currentGrid, vertexKey);
  } else {
    // Sphere was removed or changed, so restore it
    if (currentGrid.vertexSpheres.has(vertexKey)) {
      removeVertexSphere(currentGrid, vertexKey);
    }
    
    createVertexSphere(currentGrid, vertexKey, beforeState.color);
    
    if (beforeState.hasDecoration) {
      addVertexDecoration(currentGrid, vertexKey, beforeState.decorationColor);
    }
  }
}

function redoVertexSphere(actionData) {
  const { vertexKey, afterState } = actionData;
  
  if (afterState === null) {
    // Remove the sphere
    removeVertexSphere(currentGrid, vertexKey);
  } else {
    // Add or modify the sphere
    if (currentGrid.vertexSpheres.has(vertexKey)) {
      removeVertexSphere(currentGrid, vertexKey);
    }
    
    createVertexSphere(currentGrid, vertexKey, afterState.color);
    
    if (afterState.hasDecoration) {
      addVertexDecoration(currentGrid, vertexKey, afterState.decorationColor);
    }
  }
}

// Vertex decoration undo/redo functions
function undoVertexDecoration(actionData) {
  const { vertexKey, beforeState } = actionData;
  
  if (!currentGrid.vertexSpheres.has(vertexKey)) return;
  
  const sphereData = currentGrid.vertexSpheres.get(vertexKey);
  
  // Remove current decoration if exists
  if (sphereData.decoration) {
    currentGrid.group.remove(sphereData.decoration);
    if (sphereData.decoration.children) {
      sphereData.decoration.children.forEach(child => {
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
      });
    }
    sphereData.decoration = null;
  }
  
  // Restore previous decoration state
  if (beforeState && beforeState.hasDecoration) {
    addVertexDecoration(currentGrid, vertexKey, beforeState.decorationColor);
  }
}

function redoVertexDecoration(actionData) {
  const { vertexKey, afterState } = actionData;
  
  if (!currentGrid.vertexSpheres.has(vertexKey)) return;
  
  const sphereData = currentGrid.vertexSpheres.get(vertexKey);
  
  // Remove current decoration if exists
  if (sphereData.decoration) {
    currentGrid.group.remove(sphereData.decoration);
    if (sphereData.decoration.children) {
      sphereData.decoration.children.forEach(child => {
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
      });
    }
    sphereData.decoration = null;
  }
  
  // Apply new decoration state
  if (afterState && afterState.hasDecoration) {
    addVertexDecoration(currentGrid, vertexKey, afterState.decorationColor);
  }
}



// Add a new action type for BB Distance batch operations
function recordBBDistanceBatch(vertexKeys, refVertexKey) {
  if (!currentGrid) return;
  
  const action = {
    type: 'BB_DISTANCE_BATCH',
    data: {
      vertexKeys: [...vertexKeys], // All vertices colored at distance
      refVertexKey: refVertexKey,   // The v* vertex
      mainColor: selectedColor,
      secondColor: selectedColor2
    },
    timestamp: Date.now()
  };
  
  currentGrid.undoStack.push(action);
  currentGrid.redoStack = [];
  
  if (currentGrid.undoStack.length > currentGrid.maxUndoSteps) {
    currentGrid.undoStack.shift();
  }
}

// Undo/redo functions for BB Distance batches
function undoBBDistanceBatch(actionData) {
  const { vertexKeys, refVertexKey } = actionData;
  
  // Remove all colored vertices
  for (const vKey of vertexKeys) {
    removeVertexSphere(currentGrid, vKey);
  }
  
  // Remove the reference vertex
  removeVertexSphere(currentGrid, refVertexKey);
}

function redoBBDistanceBatch(actionData) {
  const { vertexKeys, refVertexKey, mainColor, secondColor } = actionData;
  
  // Restore reference vertex with second color
  createVertexSphere(currentGrid, refVertexKey, secondColor);
  
  // Restore all distance vertices with main color
  for (const vKey of vertexKeys) {
    createVertexSphere(currentGrid, vKey, mainColor);
  }
}


function undoClearAllVertices(actionData) {
  const { clearedVertices } = actionData;
  
  // Restore all cleared vertices
  for (const vertexData of clearedVertices) {
    createVertexSphere(currentGrid, vertexData.vertexKey, vertexData.color);
    // Note: decorations aren't restored (they're created separately via decoration tool)
  }
  
  console.log(`Restored ${clearedVertices.length} vertex spheres`);
}

function redoClearAllVertices(actionData) {
  const { clearedVertices } = actionData;
  
  // Clear them all again
  for (const vertexData of clearedVertices) {
    removeVertexSphere(currentGrid, vertexData.vertexKey);
  }
  
  console.log(`Re-cleared ${clearedVertices.length} vertex spheres`);
}




// Edge state undo/redo functions
function undoEdgeState(actionData) {
  const { edgeKey, beforeState } = actionData;
  const [aStr, bStr] = edgeKey.split("-");
  const a = aStr.split(",").map(Number);
  const b = bStr.split(",").map(Number);
  
  const edge = currentGrid.edges.get(edgeKey);
  if (!edge) return;
  
  // Remove current arrows
  if (edge.arrows) {
    removeArrowsFromEdge(edge);
  }
  
  // Remove current block cube
  if (edge.blockCube) {
    if (currentGrid.isInstanced) {
      removeBlockCubeInstanced(currentGrid, edge, edgeKey);
    } else {
      removeBlockCube(edge);
    }
  }
  
  // Restore previous state
  colorEdge(currentGrid, a, b, beforeState.color, beforeState.color === UNCOLORED_COLOR ? 0.015 : 0.05);
  
  if (beforeState.hasArrows && beforeState.arrowDirection) {
    addArrowsToEdge(edge, beforeState.arrowDirection);
  }
  
  if (beforeState.hasBlockCube) {
    if (currentGrid.isInstanced) {
      addBlockCubeInstanced(grid, edge, edgeKey);
    } else {
      addBlockCube(edge);
    }
  }
}

function redoEdgeState(actionData) {
  const { edgeKey, afterState } = actionData;
  const [aStr, bStr] = edgeKey.split("-");
  const a = aStr.split(",").map(Number);
  const b = bStr.split(",").map(Number);
  
  const edge = currentGrid.edges.get(edgeKey);
  if (!edge) return;
  
  // Remove current arrows
  if (edge.arrows) {
    removeArrowsFromEdge(edge);
  }
  
  // Remove current block cube
  if (edge.blockCube) {
    if (currentGrid.isInstanced) {
      removeBlockCubeInstanced(currentGrid, edge, edgeKey);
    } else {
      removeBlockCube(edge);
    }
  }
  
  // Apply new state
  colorEdge(currentGrid, a, b, afterState.color, afterState.color === UNCOLORED_COLOR ? 0.015 : 0.05);
  
  if (afterState.hasArrows && afterState.arrowDirection) {
    addArrowsToEdge(edge, afterState.arrowDirection);
  }
  
  if (afterState.hasBlockCube) {
    if (currentGrid.isInstanced) {
      addBlockCubeInstanced(grid, edge, edgeKey);
    } else {
      addBlockCube(edge);
    }
  }
}

// Layer operation undo/redo functions
function undoLayerOperation(actionData) {
  const { beforeState } = actionData;
  
  // Save current camera state
  const currentCameraPos = camera.position.clone();
  const currentCameraTarget = controls.target.clone();
  
  // Clear current grid contents
  clearCurrentGridContents();
  
  // Restore from complete state snapshot
  restoreGridFromSnapshot(beforeState);
  
  // Restore camera
  camera.position.copy(currentCameraPos);
  controls.target.copy(currentCameraTarget);
  controls.update();
}

function redoLayerOperation(actionData) {
  const { afterState } = actionData;
  
  // Save current camera state
  const currentCameraPos = camera.position.clone();
  const currentCameraTarget = controls.target.clone();
  
  // Clear current grid contents
  clearCurrentGridContents();
  
  // Restore from complete state snapshot
  restoreGridFromSnapshot(afterState);
  
  // Restore camera
  camera.position.copy(currentCameraPos);
  controls.target.copy(currentCameraTarget);
  controls.update();
}

function restoreGridFromSnapshot(snapshot) {
  // Update global dimensions
  GRID_WIDTH = snapshot.dimensions.width;
  GRID_HEIGHT = snapshot.dimensions.height;
  GRID_DEPTH = snapshot.dimensions.depth;
  
  // Update grid properties
  currentGrid.width = snapshot.dimensions.width;
  currentGrid.height = snapshot.dimensions.height;
  currentGrid.depth = snapshot.dimensions.depth;
  
  // Rebuild basic structure
  buildGridContent(currentGrid);
  
  // Restore all states using existing restoration logic
  restoreEdgeStatesFromSnapshot(snapshot);
  restoreVertexStatesFromSnapshot(snapshot);
  restorePathFromSnapshot(snapshot);
  
  // Update dimension UI
  document.getElementById("widthInput").value = snapshot.dimensions.width;
  document.getElementById("heightInput").value = snapshot.dimensions.height;
  document.getElementById("depthInput").value = snapshot.dimensions.depth;
}



// Backbite undo/redo handlers
function undoBackbite(data) {
  currentGrid.path = [...data.oldPath];
  currentPath = currentGrid.path;
  
  // Rebuild subgraph
  currentGrid.activeSubgraph.clear();
  for (let i = 0; i < currentGrid.path.length - 1; i++) {
    const a = currentGrid.path[i].split(',').map(Number);
    const b = currentGrid.path[i + 1].split(',').map(Number);
    currentGrid.activeSubgraph.addEdge(a, b);
  }
  
  // Update visuals
  if (gradientMode) {
    applyGradientToPath();
  } else {
    updateEdgeMeshesFromSubgraph(currentGrid, currentGrid.activeSubgraph);
  }
  
  updateEndpointMarkers();
  
  if (arrowMode && currentGrid.path) {
    // Remove all arrows first
    for (const [key, edge] of currentGrid.edges.entries()) {
      removeArrowsFromEdge(edge);
    }
    addDirectionalArrowsToPath(currentGrid.path);
  }
  
  console.log("Backbite undone");
}

function redoBackbite(data) {
  currentGrid.path = [...data.newPath];
  currentPath = currentGrid.path;
  
  // Rebuild subgraph
  currentGrid.activeSubgraph.clear();
  for (let i = 0; i < currentGrid.path.length - 1; i++) {
    const a = currentGrid.path[i].split(',').map(Number);
    const b = currentGrid.path[i + 1].split(',').map(Number);
    currentGrid.activeSubgraph.addEdge(a, b);
  }
  
  // Update visuals
  if (gradientMode) {
    applyGradientToPath();
  } else {
    updateEdgeMeshesFromSubgraph(currentGrid, currentGrid.activeSubgraph);
  }
  
  updateEndpointMarkers();
  
  if (arrowMode && currentGrid.path) {
    // Remove all arrows first
    for (const [key, edge] of currentGrid.edges.entries()) {
      removeArrowsFromEdge(edge);
    }
    addDirectionalArrowsToPath(currentGrid.path);
  }
  
  console.log("Backbite redone");
}



// Switch undo/redo handlers (EFFICIENT VERSION)
function undoSwitch(data) {
  // Restore old path
  currentGrid.path = [...data.oldPath];
  currentPath = currentGrid.path;
  
  // Update subgraph: remove what was added, add back what was removed
  for (const eKey of data.edgesAdded) {
    currentGrid.activeSubgraph.edges.delete(eKey);
    const [aStr, bStr] = eKey.split("-");
    const v1 = aStr;
    const v2 = bStr;
    // Check if vertices should be removed
    if (currentGrid.activeSubgraph.getNeighbors(v1).length === 0) {
      currentGrid.activeSubgraph.vertices.delete(v1);
    }
    if (currentGrid.activeSubgraph.getNeighbors(v2).length === 0) {
      currentGrid.activeSubgraph.vertices.delete(v2);
    }
  }
  
  for (const eKey of data.edgesRemoved) {
    currentGrid.activeSubgraph.edges.add(eKey);
    const [aStr, bStr] = eKey.split("-");
    currentGrid.activeSubgraph.vertices.add(aStr);
    currentGrid.activeSubgraph.vertices.add(bStr);
  }
  
  // Update only the 4 edges that changed (not all edges)
  const changedEdges = [...data.edgesAdded, ...data.edgesRemoved];
  for (const eKey of changedEdges) {
    const edge = currentGrid.edges.get(eKey);
    if (!edge) continue;
    
    // Check if this edge is now in the subgraph
    const isInSubgraph = currentGrid.activeSubgraph.edges.has(eKey);
    const color = isInSubgraph ? selectedColor : UNCOLORED_COLOR;
    const width = isInSubgraph ? 0.05 : 0.015;
    
    edge.color = color;
    
    const [aStr, bStr] = eKey.split("-");
    const a = aStr.split(",").map(Number);
    const b = bStr.split(",").map(Number);
    
    if (currentGrid.isInstanced) {
      colorEdgeInstanced(currentGrid, a, b, color, width);
    } else {
      if (edge.mesh) {
        currentGrid.group.remove(edge.mesh);
        edge.mesh.geometry.dispose();
        edge.mesh.material.dispose();
      }
      const newMesh = makeEdgeMesh(a, b, color, width);
      edge.mesh = newMesh;
      currentGrid.group.add(newMesh);
    }
  }
  
  // Update cycle reference
  currentGrid.cycle = currentGrid.activeSubgraph;
  
  // Update endpoint markers (only for paths, not cycles)
  const totalVertices = currentGrid.width * currentGrid.height * currentGrid.depth;
  const totalEdges = currentGrid.activeSubgraph.edges.size;
  const isCycle = (totalEdges === totalVertices);
  
  if (isCycle) {
    clearEndpointMarkers(currentGrid);
  } else {
    updateEndpointMarkers(currentGrid);
  }
  
  // Reapply gradient if active
  if (gradientMode) {
    applyGradientToPath();
  }
  
  // Update arrows if active
  if (arrowMode && currentGrid.path) {
    for (const [key, edge] of currentGrid.edges.entries()) {
      removeArrowsFromEdge(edge);
    }
    addDirectionalArrowsToPath(currentGrid.path);
  }
  
  // Component coloring (if enabled)
  if (componentColoringEnabled) {
    const adj = buildAdjacencyFromEdgeSet(currentGrid, currentGrid.activeSubgraph.getEdgeKeys());
    const vertexComponent = labelComponents(adj);
    const numComponents = new Set(vertexComponent.values()).size;
    
    if (numComponents >= 2) {
      // Multiple components - color by component
      const componentColors = [selectedColor, selectedColor2];
      
      for (const eKey of currentGrid.activeSubgraph.getEdgeKeys()) {
        const [aStr, bStr] = eKey.split("-");
        const a = aStr.split(",").map(Number);
        const b = bStr.split(",").map(Number);
        
        const componentId = vertexComponent.get(aStr);
        const color = componentColors[componentId % componentColors.length];
        
        if (currentGrid.isInstanced) {
          colorEdgeInstanced(currentGrid, a, b, color, 0.05);
        } else {
          colorEdge(currentGrid, a, b, color, 0.05);
        }
      }
    } else {
      // Single component - restore uniform coloring
      for (const eKey of currentGrid.activeSubgraph.getEdgeKeys()) {
        const [aStr, bStr] = eKey.split("-");
        const a = aStr.split(",").map(Number);
        const b = bStr.split(",").map(Number);
        
        if (currentGrid.isInstanced) {
          colorEdgeInstanced(currentGrid, a, b, selectedColor, 0.05);
        } else {
          colorEdge(currentGrid, a, b, selectedColor, 0.05);
        }
      }
    }
  }
  
  // Box highlighting (if enabled)
  if (boxHighlightingEnabled && currentGrid.isInstanced) {
    if (currentGrid.highlightDebounceTimer) clearTimeout(currentGrid.highlightDebounceTimer);
    
    currentGrid.highlightDebounceTimer = setTimeout(() => {
      clearBoxHighlights();
      
      const adj = buildAdjacencyFromEdgeSet(currentGrid, currentGrid.activeSubgraph.getEdgeKeys());
      const vertexComponent = labelComponents(adj);
      const numComponents = new Set(vertexComponent.values()).size;
      
      if (numComponents >= 2) {
        const borderBoxes = getGeneralBorderBoxes(currentGrid, vertexComponent, currentGrid.activeSubgraph);
        if (borderBoxes.length > 0) {
          highlightBoxes(borderBoxes, 0xffff00);
          currentGrid.highlightedBoxes = borderBoxes;
        }
      } else {
        clearBoxHighlights();
      }
    }, 150);
  }
  
  console.log("Switch undone");
}

function redoSwitch(data) {
  // Restore new path
  currentGrid.path = [...data.newPath];
  currentPath = currentGrid.path;
  
  // Update subgraph: add what was added, remove what was removed
  for (const eKey of data.edgesRemoved) {
    currentGrid.activeSubgraph.edges.delete(eKey);
    const [aStr, bStr] = eKey.split("-");
    const v1 = aStr;
    const v2 = bStr;
    // Check if vertices should be removed
    if (currentGrid.activeSubgraph.getNeighbors(v1).length === 0) {
      currentGrid.activeSubgraph.vertices.delete(v1);
    }
    if (currentGrid.activeSubgraph.getNeighbors(v2).length === 0) {
      currentGrid.activeSubgraph.vertices.delete(v2);
    }
  }
  
  for (const eKey of data.edgesAdded) {
    currentGrid.activeSubgraph.edges.add(eKey);
    const [aStr, bStr] = eKey.split("-");
    currentGrid.activeSubgraph.vertices.add(aStr);
    currentGrid.activeSubgraph.vertices.add(bStr);
  }
  
  // Update only the 4 edges that changed (not all edges)
  const changedEdges = [...data.edgesAdded, ...data.edgesRemoved];
  for (const eKey of changedEdges) {
    const edge = currentGrid.edges.get(eKey);
    if (!edge) continue;
    
    // Check if this edge is now in the subgraph
    const isInSubgraph = currentGrid.activeSubgraph.edges.has(eKey);
    const color = isInSubgraph ? selectedColor : UNCOLORED_COLOR;
    const width = isInSubgraph ? 0.05 : 0.015;
    
    edge.color = color;
    
    const [aStr, bStr] = eKey.split("-");
    const a = aStr.split(",").map(Number);
    const b = bStr.split(",").map(Number);
    
    if (currentGrid.isInstanced) {
      colorEdgeInstanced(currentGrid, a, b, color, width);
    } else {
      if (edge.mesh) {
        currentGrid.group.remove(edge.mesh);
        edge.mesh.geometry.dispose();
        edge.mesh.material.dispose();
      }
      const newMesh = makeEdgeMesh(a, b, color, width);
      edge.mesh = newMesh;
      currentGrid.group.add(newMesh);
    }
  }
  
  // Update cycle reference
  currentGrid.cycle = currentGrid.activeSubgraph;
  
  // Update endpoint markers (only for paths, not cycles)
  const totalVertices = currentGrid.width * currentGrid.height * currentGrid.depth;
  const totalEdges = currentGrid.activeSubgraph.edges.size;
  const isCycle = (totalEdges === totalVertices);
  
  if (isCycle) {
    clearEndpointMarkers(currentGrid);
  } else {
    updateEndpointMarkers(currentGrid);
  }
  
  // Reapply gradient if active
  if (gradientMode) {
    applyGradientToPath();
  }
  
  // Update arrows if active
  if (arrowMode && currentGrid.path) {
    for (const [key, edge] of currentGrid.edges.entries()) {
      removeArrowsFromEdge(edge);
    }
    addDirectionalArrowsToPath(currentGrid.path);
  }
  
  // Component coloring (if enabled)
  if (componentColoringEnabled) {
    const adj = buildAdjacencyFromEdgeSet(currentGrid, currentGrid.activeSubgraph.getEdgeKeys());
    const vertexComponent = labelComponents(adj);
    const numComponents = new Set(vertexComponent.values()).size;
    
    if (numComponents >= 2) {
      // Multiple components - color by component
      const componentColors = [selectedColor, selectedColor2];
      
      for (const eKey of currentGrid.activeSubgraph.getEdgeKeys()) {
        const [aStr, bStr] = eKey.split("-");
        const a = aStr.split(",").map(Number);
        const b = bStr.split(",").map(Number);
        
        const componentId = vertexComponent.get(aStr);
        const color = componentColors[componentId % componentColors.length];
        
        if (currentGrid.isInstanced) {
          colorEdgeInstanced(currentGrid, a, b, color, 0.05);
        } else {
          colorEdge(currentGrid, a, b, color, 0.05);
        }
      }
    } else {
      // Single component - restore uniform coloring
      for (const eKey of currentGrid.activeSubgraph.getEdgeKeys()) {
        const [aStr, bStr] = eKey.split("-");
        const a = aStr.split(",").map(Number);
        const b = bStr.split(",").map(Number);
        
        if (currentGrid.isInstanced) {
          colorEdgeInstanced(currentGrid, a, b, selectedColor, 0.05);
        } else {
          colorEdge(currentGrid, a, b, selectedColor, 0.05);
        }
      }
    }
  }
  
  // Box highlighting (if enabled)
  if (boxHighlightingEnabled && currentGrid.isInstanced) {
    if (currentGrid.highlightDebounceTimer) clearTimeout(currentGrid.highlightDebounceTimer);
    
    currentGrid.highlightDebounceTimer = setTimeout(() => {
      clearBoxHighlights();
      
      const adj = buildAdjacencyFromEdgeSet(currentGrid, currentGrid.activeSubgraph.getEdgeKeys());
      const vertexComponent = labelComponents(adj);
      const numComponents = new Set(vertexComponent.values()).size;
      
      if (numComponents >= 2) {
        const borderBoxes = getGeneralBorderBoxes(currentGrid, vertexComponent, currentGrid.activeSubgraph);
        if (borderBoxes.length > 0) {
          highlightBoxes(borderBoxes, 0xffff00);
          currentGrid.highlightedBoxes = borderBoxes;
        }
      } else {
        clearBoxHighlights();
      }
    }, 150);
  }
  
  console.log("Switch redone");
}



// State capture helper functions
function captureVertexSphereState(vertexKey) {
  if (!currentGrid.vertexSpheres.has(vertexKey)) {
    return null;
  }
  
  const sphereData = currentGrid.vertexSpheres.get(vertexKey);
  
  // Get color (works for both instanced and individual mode)
  const color = currentGrid.isInstanced 
    ? sphereData.color 
    : sphereData.sphere.material.color.getHex();
  
  const state = {
    color: color,
    hasDecoration: !!sphereData.decoration
  };
  
  if (state.hasDecoration && sphereData.decoration) {
    if (sphereData.decoration.children && sphereData.decoration.children.length > 0) {
      state.decorationColor = sphereData.decoration.children[0].material.color.getHex();
    }
  }
  
  return state;
}

function captureEdgeState(edgeKey) {
  const edge = currentGrid.edges.get(edgeKey);
  if (!edge) return null;
  
  return {
    color: edge.color,
    hasArrows: !!edge.arrows,
    arrowDirection: edge.arrowDirection || 0,
    hasBlockCube: !!edge.blockCube
  };
}

function captureCompleteGridState() {
  return {
    dimensions: {
      width: currentGrid.width,
      height: currentGrid.height,
      depth: currentGrid.depth
    },
    edges: captureAllEdgeStates(),
    vertices: captureAllVertexStates(),
    path: currentGrid.path ? [...currentGrid.path] : null
  };
}

function captureAllEdgeStates() {
  const edgeStates = {};
  for (const [edgeKey, edge] of currentGrid.edges.entries()) {
    const needsSaving = edge.color !== UNCOLORED_COLOR || 
                       edge.arrows || 
                       edge.blockCube;
    
    if (needsSaving) {
      edgeStates[edgeKey] = captureEdgeState(edgeKey);
    }
  }
  return edgeStates;
}

function captureAllVertexStates() {
  const vertexStates = {};
  if (currentGrid.vertexSpheres) {
    for (const [vertexKey, sphereData] of currentGrid.vertexSpheres.entries()) {
      vertexStates[vertexKey] = captureVertexSphereState(vertexKey);
    }
  }
  return vertexStates;
}


// State restoration helper functions
function restoreEdgeStatesFromSnapshot(snapshot) {
  for (const [edgeKey, edgeState] of Object.entries(snapshot.edges)) {
    const [aStr, bStr] = edgeKey.split("-");
    const a = aStr.split(",").map(Number);
    const b = bStr.split(",").map(Number);
    
    if (currentGrid.edges.has(edgeKey)) {
      colorEdge(currentGrid, a, b, edgeState.color, edgeState.color === UNCOLORED_COLOR ? 0.015 : 0.05);
      
      const edge = currentGrid.edges.get(edgeKey);
      
      if (edgeState.hasBlockCube) {
		if (currentGrid.isInstanced) {
			addBlockCubeInstanced(currentGrid, edge, edgeKey);
		} else {
			addBlockCube(edge);
		}
	}
      
      if (edgeState.hasArrows && edgeState.arrowDirection) {
        addArrowsToEdge(edge, edgeState.arrowDirection);
      }
    }
  }
}

function restoreVertexStatesFromSnapshot(snapshot) {
  for (const [vertexKey, vertexState] of Object.entries(snapshot.vertices)) {
    createVertexSphere(currentGrid, vertexKey, vertexState.color);
    
    if (vertexState.hasDecoration && vertexState.decorationColor) {
      addVertexDecoration(currentGrid, vertexKey, vertexState.decorationColor);
    }
  }
}

function restorePathFromSnapshot(snapshot) {
  if (snapshot.path && snapshot.path.length > 0) {
    currentGrid.path = [...snapshot.path];
    
    // Rebuild activeSubgraph from path
    currentGrid.activeSubgraph = new Subgraph(currentGrid);
    for (let i = 0; i < snapshot.path.length - 1; i++) {
      const a = snapshot.path[i].split(',').map(Number);
      const b = snapshot.path[i + 1].split(',').map(Number);
      currentGrid.activeSubgraph.edges.add(edgeKey(a, b));
      currentGrid.activeSubgraph.vertices.add(snapshot.path[i]);
      currentGrid.activeSubgraph.vertices.add(snapshot.path[i + 1]);
    }
    
    // Check if this was a cycle and handle endpoint markers
    const totalVertices = currentGrid.width * currentGrid.height * currentGrid.depth;
    const isCycle = snapshot.path.length === totalVertices;
    
    if (!isCycle && snapshot.path.length >= 2) {
      updateEndpointMarkers(currentGrid);
    }
  }
}
















//     ====================================================================================================================
// 											   2. GRID LAYER EXPANSION/REMOVAL
//     ====================================================================================================================



//     =======================================
// 		*** 2.1 Layer Expansion functions ***
//     =======================================

function expandCurrentGrid(direction) {
  if (!currentGrid) {
    alert("No grid to expand");
    return;
  }
  
  // Use the existing serialization method that we know works
  const savedSubgraph = serializeCurrentSubgraph();
  const savedCameraPos = camera.position.clone();
  const savedCameraTarget = controls.target.clone();
  
  // Capture complete state AFTER serialization but BEFORE any changes
  const beforeState = captureCompleteGridState();
  
  // Calculate new dimensions and translation
  const { newDims, coordTranslation } = calculateExpansion(direction);
  
  // Store current grid ID for UI preservation
  const currentGridId = getCurrentGridId();
  
  // Rebuild grid structure
  rebuildGridWithDimensions(newDims);
  
  // Restore translated subgraph using the working method
  restoreTranslatedSubgraph(savedSubgraph, coordTranslation);
  
  // Update camera proportionally
  updateCameraForNewDimensions(savedCameraPos, savedCameraTarget, newDims);
  
  // Capture state after expansion and record action
  const afterState = captureCompleteGridState();
  recordAction('LAYER_OPERATION', { beforeState, afterState });
  
  console.log(`Grid expanded ${direction}: ${newDims.width}√ó${newDims.height}√ó${newDims.depth}`);
}

function calculateExpansion(direction) {
  const oldDims = {
    width: currentGrid.width,
    height: currentGrid.height, 
    depth: currentGrid.depth
  };
  
  const newDims = { ...oldDims };
  const coordTranslation = { x: 0, y: 0, z: 0 };
  
  switch(direction) {
    case "x+": // Far X
      newDims.width += 1;
      break;
    case "x-": // Near X  
      newDims.width += 1;
      coordTranslation.x = 1;
      break;
    case "y+": // Far Y
      newDims.height += 1;
      break;
    case "y-": // Near Y
      newDims.height += 1;
      coordTranslation.y = 1;
      break;
    case "z+": // Far Z
      newDims.depth += 1;
      break;
    case "z-": // Near Z
      newDims.depth += 1;
      coordTranslation.z = 1;
      break;
    default:
      throw new Error(`Invalid direction: ${direction}`);
  }
  
  return { newDims, coordTranslation };
}

function serializeCurrentSubgraph() {
  if (!currentGrid || !currentGrid.edges) return null;
  
  const subgraphData = {
    coloredEdges: [],
    vertexSpheres: new Map(),
    path: currentGrid.path ? [...currentGrid.path] : null,
    hasActiveSubgraph: !!currentGrid.activeSubgraph
  };
  
  // Save all edges that need saving (colored OR have block cubes OR have arrows)
  for (const [edgeKey, edge] of currentGrid.edges.entries()) {
    const needsSaving = edge.color !== UNCOLORED_COLOR || 
                       !!edge.blockCube || 
                       !!edge.arrows;
    
    if (needsSaving) {
      subgraphData.coloredEdges.push({
        key: edgeKey,
        color: edge.color,
        arrowDirection: edge.arrowDirection || 0,
        hasArrows: !!edge.arrows,
        hasBlockCube: !!edge.blockCube
      });
    }
  }
  
  // Save vertex spheres - FIXED to handle new format
  if (currentGrid.vertexSpheres) {
    for (const [vertexKey, sphereData] of currentGrid.vertexSpheres.entries()) {
      // Handle both old format (direct sphere) and new format (sphere/decoration object)
      let sphere, decoration, color;
      if (sphereData.sphere) {
        // New format
        sphere = sphereData.sphere;
        decoration = sphereData.decoration;
        
        // Get color (works for both instanced and individual mode)
        if (currentGrid.isInstanced) {
          color = sphereData.color;
        } else {
          color = sphere.material.color.getHex();
        }
      } else {
        // Old format - sphereData is the sphere itself
        sphere = sphereData;
        decoration = null;
        color = sphere.material.color.getHex();
      }
      
      const vertexInfo = {
        color: color
      };
      
      if (decoration) {
        vertexInfo.hasDecoration = true;
        if (decoration.children && decoration.children.length > 0) {
          vertexInfo.decorationColor = decoration.children[0].material.color.getHex();
        }
      }
      
      subgraphData.vertexSpheres.set(vertexKey, vertexInfo);
    }
  }
  
  return subgraphData;
}

function rebuildGridWithDimensions(newDims) {
  // Clear current grid visuals but preserve the grid slot
  clearCurrentGridContents();
  
  // Update global dimensions for rebuilding
  GRID_WIDTH = newDims.width;
  GRID_HEIGHT = newDims.height; 
  GRID_DEPTH = newDims.depth;
  
  // Update grid properties
  currentGrid.width = newDims.width;
  currentGrid.height = newDims.height;
  currentGrid.depth = newDims.depth;
  
  // Rebuild grid structure
  buildGridContent(currentGrid);
  
  // Update dimension UI
  document.getElementById("widthInput").value = newDims.width;
  document.getElementById("heightInput").value = newDims.height;
  document.getElementById("depthInput").value = newDims.depth;
}

function clearCurrentGridContents() {
  // Preserve endpoint markers while clearing everything else
  const childrenToRemove = [];
  currentGrid.group.traverse((child) => {
    if (child !== currentGrid.startMarker && child !== currentGrid.endMarker && child !== currentGrid.group) {
      childrenToRemove.push(child);
    }
  });
  
  childrenToRemove.forEach(child => {
    if (child.parent) child.parent.remove(child);
    if (child.geometry) child.geometry.dispose();
    if (child.material) {
      if (Array.isArray(child.material)) {
        child.material.forEach(mat => mat.dispose());
      } else {
        child.material.dispose();
      }
    }
  });
  
  // Clear data structures and references
  currentGrid.vertices.clear();
  currentGrid.edges.clear();
  currentGrid.boxesXY.clear();
  currentGrid.boxesXZ.clear();
  currentGrid.boxesYZ.clear();
  currentGrid.vertexSpheres.clear(); // This clears the map but meshes were already removed above
  currentGrid.path = null;
  currentGrid.activeSubgraph = null;
  
  // Clear UI/hover artifacts
  currentGrid.highlightOverlay = null;
  if (window.highlightedEdge) {
    window.highlightedEdge = null;
  }
}

function restoreTranslatedSubgraph(savedSubgraph, coordTranslation) {
  if (!savedSubgraph || !savedSubgraph.coloredEdges) return;
  
  // Create new activeSubgraph if needed
  if (savedSubgraph.hasActiveSubgraph) {
    currentGrid.activeSubgraph = new Subgraph(currentGrid);
  }
  
  // Restore each colored edge with translation
  for (const edgeData of savedSubgraph.coloredEdges) {
    const translatedKey = translateEdgeKey(edgeData.key, coordTranslation);
    const [aStr, bStr] = translatedKey.split("-");
    const a = aStr.split(",").map(Number);
    const b = bStr.split(",").map(Number);
    
    // Validate that translated edge exists in new grid
    if (currentGrid.edges.has(translatedKey)) {
      const edge = currentGrid.edges.get(translatedKey);
      
      // Only color the edge if it was actually colored (not just had a block cube)
      if (edgeData.color !== UNCOLORED_COLOR) {
        colorEdge(currentGrid, a, b, edgeData.color, 0.05);
        
        // Add to activeSubgraph if it existed
        if (currentGrid.activeSubgraph) {
          currentGrid.activeSubgraph.edges.add(translatedKey);
          currentGrid.activeSubgraph.vertices.add(aStr);
          currentGrid.activeSubgraph.vertices.add(bStr);
        }
      }
      
      // Restore block cubes (regardless of edge color)
      if (edgeData.hasBlockCube && edge) {
        if (currentGrid.isInstanced) {
		// Use instanced block cubes
		addBlockCubeInstanced(currentGrid, edge, translatedKey);
		} else {
          // Use individual meshes
          const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
          const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
          const cube = new THREE.Mesh(geometry, material);
          cube.position.copy(edge.mesh.position);
          cube.raycast = () => {};
          edge.blockCube = cube;
          currentGrid.group.add(cube);
        }
      }
      
      // Restore arrows if they existed
      if (edgeData.hasArrows && edgeData.arrowDirection) {
        if (edge && arrowMode) {
          addArrowsToEdge(edge, edgeData.arrowDirection);
        } else if (edge) {
          edge.arrowDirection = edgeData.arrowDirection;
        }
      }
    } else {
      console.warn(`Translated edge ${translatedKey} does not exist in new grid`);
    }
  }
  
  // Restore vertex spheres with translation and bounds checking
  if (savedSubgraph.vertexSpheres) {
    for (const [vertexKey, sphereData] of savedSubgraph.vertexSpheres.entries()) {
      const translatedVertexKey = translateVertexKey(vertexKey, coordTranslation);
      const [x, y, z] = translatedVertexKey.split(',').map(Number);
      
      // Only restore if vertex exists AND is within new grid bounds
      if (currentGrid.vertices.has(translatedVertexKey) && 
          x >= 0 && x < currentGrid.width &&
          y >= 0 && y < currentGrid.height &&
          z >= 0 && z < currentGrid.depth) {
        
        // Create vertex sphere using the new function (creates proper format)
        createVertexSphere(currentGrid, translatedVertexKey, sphereData.color);
        
        // Add decoration if it existed
        if (sphereData.hasDecoration && sphereData.decorationColor) {
          addVertexDecoration(currentGrid, translatedVertexKey, sphereData.decorationColor);
        }
      }
    }
  }
  
  // Restore path with translation
  if (savedSubgraph.path) {
    currentGrid.path = savedSubgraph.path.map(vertexKey => 
      translateVertexKey(vertexKey, coordTranslation)
    );
    
    // Restore endpoint markers if it's a path (not cycle)
    const totalVertices = currentGrid.width * currentGrid.height * currentGrid.depth;
    const isPath = savedSubgraph.path.length < totalVertices;
    if (isPath && currentGrid.path && currentGrid.path.length >= 2) {
      updateEndpointMarkers(currentGrid);
    }
  }
  
  // Apply gradient if mode is active
  if (gradientMode && currentGrid.path && currentGrid.path.length > 1) {
    applyGradientToPath();
  }
}

function translateEdgeKey(edgeKey, coordTranslation) {
  const [aStr, bStr] = edgeKey.split("-");
  const newAStr = translateVertexKey(aStr, coordTranslation);
  const newBStr = translateVertexKey(bStr, coordTranslation);
  
  // Maintain edge key ordering
  const [sortedA, sortedB] = [newAStr, newBStr].sort();
  return `${sortedA}-${sortedB}`;
}

function translateVertexKey(vertexKey, coordTranslation) {
  const [x, y, z] = vertexKey.split(',').map(Number);
  return `${x + coordTranslation.x},${y + coordTranslation.y},${z + coordTranslation.z}`;
}

function updateCameraForNewDimensions(oldPos, oldTarget, newDims) {
  // Scale camera position proportionally with grid growth
  const maxDim = Math.max(newDims.width, newDims.height, newDims.depth);
  
  // Check if this is a 2D grid
  const is2D = newDims.width === 1 || newDims.height === 1 || newDims.depth === 1;
  
  if (is2D) {
    // Fixed overhead position for 2D grids
    const centerX = (newDims.width - 1) / 2;
    const centerY = (newDims.height - 1) / 2; 
    const centerZ = (newDims.depth - 1) / 2;
    
    camera.position.set(centerX, centerY, Math.max(newDims.width, newDims.height, newDims.depth) * 2 + centerZ);
    camera.lookAt(centerX, centerY, centerZ);
    camera.rotateZ(Math.PI / 2);
    
    controls.target.set(centerX, centerY, centerZ);
    controls.enabled = false;
  } else {
    // For 3D grids, maintain relative camera position
    const scaleX = newDims.width / (currentGrid.width || 1);
    const scaleY = newDims.height / (currentGrid.height || 1);
    const scaleZ = newDims.depth / (currentGrid.depth || 1);
    
    camera.position.set(
      oldPos.x * scaleX,
      oldPos.y * scaleY, 
      oldPos.z * scaleZ
    );
    
    controls.target.set(
      oldTarget.x * scaleX,
      oldTarget.y * scaleY,
      oldTarget.z * scaleZ
    );
    controls.enabled = true;
  }
  
  controls.update();
}


//     =====================================
// 		*** 2.2 Layer Removal functions ***
//     =====================================

function canRemoveLayer(direction) {
  if (!currentGrid) return false;
  
  // Check if removal would make any dimension zero
  const { newDims } = calculateContraction(direction);
  if (newDims.width <= 0 || newDims.height <= 0 || newDims.depth <= 0) {
    return false;
  }
  
  // Check for colored edges on the boundary
  for (const [edgeKey, edge] of currentGrid.edges.entries()) {
    if (edge.color !== UNCOLORED_COLOR) {
      const [aStr, bStr] = edgeKey.split("-");
      const [ax, ay, az] = aStr.split(",").map(Number);
      const [bx, by, bz] = bStr.split(",").map(Number);
      
      switch(direction) {
        case "x-": if (ax === 0 || bx === 0) return false; break;
        case "x+": if (ax === currentGrid.width - 1 || bx === currentGrid.width - 1) return false; break;
        case "y-": if (ay === 0 || by === 0) return false; break;
        case "y+": if (ay === currentGrid.height - 1 || by === currentGrid.height - 1) return false; break;
        case "z-": if (az === 0 || bz === 0) return false; break;
        case "z+": if (az === currentGrid.depth - 1 || bz === currentGrid.depth - 1) return false; break;
      }
    }
  }
  
  // Check for block cubes on the boundary
  for (const [edgeKey, edge] of currentGrid.edges.entries()) {
    if (edge.blockCube) {
      const [aStr, bStr] = edgeKey.split("-");
      const [ax, ay, az] = aStr.split(",").map(Number);
      const [bx, by, bz] = bStr.split(",").map(Number);
      
      switch(direction) {
        case "x-": if (ax === 0 || bx === 0) return false; break;
        case "x+": if (ax === currentGrid.width - 1 || bx === currentGrid.width - 1) return false; break;
        case "y-": if (ay === 0 || by === 0) return false; break;
        case "y+": if (ay === currentGrid.height - 1 || by === currentGrid.height - 1) return false; break;
        case "z-": if (az === 0 || bz === 0) return false; break;
        case "z+": if (az === currentGrid.depth - 1 || bz === currentGrid.depth - 1) return false; break;
      }
    }
  }
  
  // Check for vertex spheres on the boundary
  if (currentGrid.vertexSpheres) {
    for (const vertexKey of currentGrid.vertexSpheres.keys()) {
      const [x, y, z] = vertexKey.split(',').map(Number);
      
      switch(direction) {
        case "x-": if (x === 0) return false; break;
        case "x+": if (x === currentGrid.width - 1) return false; break;
        case "y-": if (y === 0) return false; break;
        case "y+": if (y === currentGrid.height - 1) return false; break;
        case "z-": if (z === 0) return false; break;
        case "z+": if (z === currentGrid.depth - 1) return false; break;
      }
    }
  }
  
  return true;
}

function calculateContraction(direction) {
  const oldDims = {
    width: currentGrid.width,
    height: currentGrid.height,
    depth: currentGrid.depth
  };
  
  const newDims = { ...oldDims };
  const coordTranslation = { x: 0, y: 0, z: 0 };
  
  switch(direction) {
    case "x+": // Remove far X layer
      newDims.width -= 1;
      break;
    case "x-": // Remove near X layer - shift everything left
      newDims.width -= 1;
      coordTranslation.x = -1;
      break;
    case "y+": // Remove far Y layer
      newDims.height -= 1;
      break;
    case "y-": // Remove near Y layer - shift everything down
      newDims.height -= 1;
      coordTranslation.y = -1;
      break;
    case "z+": // Remove far Z layer
      newDims.depth -= 1;
      break;
    case "z-": // Remove near Z layer - shift everything back
      newDims.depth -= 1;
      coordTranslation.z = -1;
      break;
  }
  
  return { newDims, coordTranslation };
}

function removeLayer(direction) {
  if (!canRemoveLayer(direction)) {
    alert("Cannot remove layer: contains colored edges");
    return;
  }
  
  // Capture complete state before removal
  const beforeState = captureCompleteGridState();
  
  // Use same logic as expansion but with contraction calculations
  const savedSubgraph = serializeCurrentSubgraph();
  const savedCameraPos = camera.position.clone();
  const savedCameraTarget = controls.target.clone();
  
  const { newDims, coordTranslation } = calculateContraction(direction);
  
  rebuildGridWithDimensions(newDims);
  restoreTranslatedSubgraph(savedSubgraph, coordTranslation);
  updateCameraForNewDimensions(savedCameraPos, savedCameraTarget, newDims);
  
  // Capture state after removal and record action
  const afterState = captureCompleteGridState();
  recordAction('LAYER_OPERATION', { beforeState, afterState });
  
  console.log(`Grid contracted ${direction}: ${newDims.width}√ó${newDims.height}√ó${newDims.depth}`);
}




//     ====================================================================================================================
// 								    3. HAMILTONIAN PATH/CYCLE GENERATORS AND RELATED FUNCTIONS
//     ====================================================================================================================


//     ============================================
// 		*** 3.1. Generator and Backbite Logic  ***
//     ============================================

async function generatePath() {
  if (!currentGrid) {
    addGrid();
  }
  
  const totalVertices = currentGrid.width * currentGrid.height * currentGrid.depth;
  
  // Check vertex count and show warnings
  if (totalVertices > 125000) {
    alert("Too many vertices. Grid dimensions not supported for generation.");
    return;
  } else if (totalVertices > 30000) {
    if (!confirm("This may take a long long time. Proceed with generation anyway?")) {
      return;
    }
  } else if (totalVertices > 10000) {
    if (!confirm("This may take a few minutes. Proceed with generation anyway?")) {
      return;
    }
  }
  
  // Set generation flags
  isGenerating = true;
  shouldStopGeneration = false;
  
  duplicateCurrentGrid();
  
  const width = currentGrid.width;
  const height = currentGrid.height;
  const depth = currentGrid.depth;
  
  // Calculate backbite moves based on grid type and size
  let backbiteMoves;
  const is2D = (depth === 1);
  
  if (is2D) {
    // 2D grids use higher multipliers for larger sizes
    if (totalVertices > 15000) {
      backbiteMoves = 60 * totalVertices;  // MULTIPLIER: Change 60 for grids > 15000 vertices
    } else if (totalVertices > 5000) {
      backbiteMoves = 40 * totalVertices;  // MULTIPLIER: Change 40 for grids > 5000 vertices
    } else if (totalVertices > 1000) {
      backbiteMoves = 20 * totalVertices;  // MULTIPLIER: Change 20 for grids > 1000 vertices
    } else {
      backbiteMoves = 10 * totalVertices;  // MULTIPLIER: Change 10 for small 2D grids
    }
  } else {
    // 3D grids always use 10x
    backbiteMoves = 10 * totalVertices;    // MULTIPLIER: Change 10 for all 3D grids
  }
  
  // Show progress overlay
  ProgressOverlay.show('path', `${width}√ó${height}√ó${depth}`);
  
  // Give browser time to render the overlay
  await new Promise(resolve => setTimeout(resolve, 50));
  
  const tStart = performance.now();
  
  // Clear any existing path/subgraph first
  if (currentGrid.activeSubgraph) currentGrid.activeSubgraph.clear();
  
  // Clear any existing arrows
  for (const [key, edge] of currentGrid.edges.entries()) {
    removeArrowsFromEdge(edge);
  }
  
  clearEndpointMarkers(currentGrid);
  
  // Enable batch mode BEFORE creating snakey path to prevent visual updates
  batchMode = true;
  
  makeSnakeyPath();
  
  // IMMEDIATELY clear visual meshes so snakey path doesn't show
  currentGrid.activeSubgraph.clear();
  for (const [key, edge] of currentGrid.edges.entries()) {
    if (edge.mesh) {
      edge.mesh.visible = false;
    }
  }
  
  console.log(`Performing backbite ${backbiteMoves} times...`);
  
  // Initialize adjacency tracking
  let adjacencyCount = 0;
  let adjacencyHistory = [];
  let lastReportedPercent = 0;
  
  const tBackbiteStart = performance.now();
  
  // Chunk size for yielding to browser (update every N moves)
  const chunkSize = Math.max(100, Math.floor(backbiteMoves / 100));
  
  for (let i = 0; i < backbiteMoves; i++) {
    // Check if user wants to stop
    if (shouldStopGeneration) {
      console.log("Generation stopped by user");
      batchMode = false;
      isGenerating = false;
      ProgressOverlay.hide();
      return;
    }
    
    performBackbite();
    
    // Check if endpoints are adjacent after this backbite
    if (areEndpointsAdjacent()) {
      adjacencyCount++;
      adjacencyHistory.push(i);
    }
    
    // Update progress and yield to browser every chunk
    if (i % chunkSize === 0 || i === backbiteMoves - 1) {
      const currentPercent = Math.floor(((i + 1) / backbiteMoves) * 100);
      if (currentPercent > lastReportedPercent || i === backbiteMoves - 1) {
        lastReportedPercent = currentPercent;
        ProgressOverlay.update(currentPercent, `${width}√ó${height}√ó${depth}`);
        
        // Yield to browser to repaint
        await new Promise(resolve => setTimeout(resolve, 0));
      }
    }
  }
  
  const tBackbiteEnd = performance.now();
  
  // Disable batch mode and do final visual update
  batchMode = false;
  
  // Rebuild visual representation once at the end
  currentGrid.activeSubgraph.clear();
  for (let i = 0; i < currentGrid.path.length - 1; i++) {
    const a = currentGrid.path[i].split(',').map(Number);
    const b = currentGrid.path[i + 1].split(',').map(Number);
    currentGrid.activeSubgraph.addEdge(a, b);
  }
  
  if (gradientMode) applyGradientToPath();
  clearEndpointMarkers(currentGrid);
  decoratePathEndpoints(currentGrid.path[0], currentGrid.path[currentGrid.path.length - 1]);
  
  // Add directional arrows if arrow mode is active
  if (arrowMode) {
    addDirectionalArrowsToPath(currentGrid.path);
  }
  
  const tEnd = performance.now();
  const totalMs = tEnd - tStart;
  const backbiteMs = tBackbiteEnd - tBackbiteStart;
  const perMoveMs = backbiteMs / backbiteMoves;
  const timeInSeconds = (totalMs / 1000).toFixed(2);
  
  // Clear generation flag
  isGenerating = false;
  
  // Show completion message
ProgressOverlay.complete(timeInSeconds);

  console.log(
    `Generated Hamiltonian path.\n` +
    `%cTotal time: ${totalMs.toFixed(2)} ms%c\n` +
    `Backbite phase: ${backbiteMs.toFixed(2)} ms for ${backbiteMoves} moves\n` +
    `%cAvg per backbite: ${perMoveMs.toFixed(4)} ms/move%c\n` +
    `Endpoint adjacencies: ${adjacencyCount} times (${(adjacencyCount/backbiteMoves*100).toFixed(2)}%)\n` +
    `Adjacent at moves: ${adjacencyHistory.slice(0, 10).join(', ')}${adjacencyHistory.length > 10 ? '...' : ''}`,
    "color: blue;", "", // Total time
    "color: blue;", ""  // Avg per backbite
  );
  
  // Check final state
  if (areEndpointsAdjacent()) {
    console.log("Path ends with adjacent endpoints - could be closed into a cycle!");
  }
}


function makeSnakeyPath() {
  const grid = currentGrid;
  const { width: W, height: H, depth: D } = grid;
  const path = new Subgraph(grid);
  
  // Generate snake path for each layer independently
  for (let z = 0; z < D; z++) {
    const layerPoints = generateLayerSnake(W, H, z);
    
    // Add edges within this layer
    for (let i = 0; i < layerPoints.length - 1; i++) {
      path.addEdge(layerPoints[i], layerPoints[i + 1]);
    }
  }
  
  // Add vertical connections between layers
  const isWidthEven = W % 2 === 0;
  
  if (isWidthEven) {
    // For even width: alternate between (0,0) and (W-1,0)
    for (let z = 0; z < D - 1; z++) {
      if (z % 2 === 0) {
        // Connect (0,0,z) to (0,0,z+1)
        path.addEdge([0, 0, z], [0, 0, z + 1]);
      } else {
        // Connect (W-1,0,z) to (W-1,0,z+1)
        path.addEdge([W - 1, 0, z], [W - 1, 0, z + 1]);
      }
    }
  } else {
    // For odd width: alternate between (0,0) and (W-1,H-1)
    for (let z = 0; z < D - 1; z++) {
      if (z % 2 === 0) {
        // Connect (0,0,z) to (0,0,z+1)
        path.addEdge([0, 0, z], [0, 0, z + 1]);
      } else {
        // Connect (W-1,H-1,z) to (W-1,H-1,z+1)
        path.addEdge([W - 1, H - 1, z], [W - 1, H - 1, z + 1]);
      }
    }
  }
  
  // Extract the path vertex sequence
  const pathVertices = extractPathFromSubgraph(path);
  
  // Store the path sequence
  grid.path = pathVertices;
  currentPath = pathVertices;
  
  // Add endpoint decorations
  if (pathVertices.length >= 2) {
    clearEndpointMarkers(grid);
    decoratePathEndpoints(pathVertices[0], pathVertices[pathVertices.length - 1]);
  }
  
  grid.activeSubgraph = path;
  updateEdgeMeshesFromSubgraph(grid, path);
  return path;
}

function generateLayerSnake(W, H, z) {
  const points = [];
  
  for (let x = 0; x < W; x++) {
    if (x % 2 === 0) {
      // Even columns: go up (y = 0 to H-1)
      for (let y = 0; y < H; y++) {
        points.push([x, y, z]);
      }
    } else {
      // Odd columns: go down (y = H-1 to 0)
      for (let y = H - 1; y >= 0; y--) {
        points.push([x, y, z]);
      }
    }
  }
  
  return points;
}


function extractPathFromSubgraph(subgraph, startVertex = null) {
  if (!subgraph || subgraph.vertexCount() === 0) return [];
  
  // Build adjacency list ONCE - O(E) instead of O(V*E)
  const adj = new Map();
  for (const vKey of subgraph.vertices) {
    adj.set(vKey, []);
  }
  for (const eKey of subgraph.getEdgeKeys()) {
    const [aStr, bStr] = eKey.split("-");
    adj.get(aStr).push(bStr);
    adj.get(bStr).push(aStr);
  }
  
  const visited = new Set();
  const path = [];
  
  // Find start vertex
  if (!startVertex) {
    for (const vKey of subgraph.vertices) {
      const neighbors = adj.get(vKey);
      if (neighbors.length === 1) {
        startVertex = vKey;
        break;
      }
    }
    if (!startVertex) {
      startVertex = [...subgraph.vertices][0];
    }
  }
  
  let current = startVertex;
  let prev = null;
  
  while (current && !visited.has(current)) {
    path.push(current);
    visited.add(current);
    
    const neighbors = adj.get(current).filter(v => v !== prev);
    if (neighbors.length === 0) break;
    
    prev = current;
    current = neighbors[0];
  }
  
  return path;
}


function updateEdgeMeshesFromSubgraph(grid, subgraph, color = selectedColor) {
  for (const eKey of subgraph.getEdgeKeys()) {
    const [aStr, bStr] = eKey.split("-");
    const a = aStr.split(",").map(Number);
    const b = bStr.split(",").map(Number);
    colorEdge(grid, a, b, color, 0.05);
  }
}


/*
 * PERFORMANCE ANALYSIS OF performBackbite()
 * 
 * This function is called thousands to millions of times during path/cycle generation.
 * Analysis of computational costs (ordered from most to least expensive):
 * 
 * 1. **Array reversal (.reverse())** - O(n) where n is path length
 *    Lines 5919, 5923: path.slice(0, idx).reverse() and path.slice(idx + 1).reverse()
 *    - For large grids (e.g., 50√ó50√ó50 = 125,000 vertices), reversing can involve 
 *      reversing arrays of 60,000+ elements
 *    - This is the PRIMARY BOTTLENECK, happening twice per backbite in worst case
 *    - Cost: O(path.length) per backbite = O(W√óH√óD)
 * 
 * 2. **Array spreading and concatenation** - O(n)
 *    Lines 5921, 5925: [...newHead, ...newTail]
 *    - Creating new arrays and copying all elements
 *    - Cost: O(path.length) = O(W√óH√óD)
 * 
 * 3. **Visual updates (when not in batch mode)** - O(n)
 *    Lines 5935-5949: Rebuilding activeSubgraph, gradient, endpoint markers
 *    - Only happens when batchMode = false
 *    - Avoided during generation by setting batchMode = true
 *    - Cost: O(path.length) but ONLY when batchMode = false
 * 
 * 4. **path.indexOf() calls** - O(n)
 *    Lines 5904, 5914: Finding neighbor index in path
 *    - Linear search through entire path
 *    - Cost: O(path.length) = O(W√óH√óD)
 * 
 * 5. **Neighbor filtering** - O(1) to O(6)
 *    Lines 5894-5909: Generate and filter 6 neighbors
 *    - Constant time (always checks 6 neighbors)
 *    - Very cheap compared to other operations
 * 
 * TOTAL COST PER BACKBITE: O(3n) ‚âà O(n) where n = W√óH√óD
 * 
 * For a 50√ó50√ó50 grid performing 1.25M backbites (10√ó vertices):
 * - Each backbite processes ~125k elements in arrays
 * - Total operations: 1.25M √ó 125k = 156 billion array operations
 * 
 * OPTIMIZATION OPPORTUNITIES:
 * 1. Use doubly-linked list instead of array for path storage
 *    - Would reduce reversal from O(n) to O(1) pointer swaps
 *    - Would eliminate array spreading/copying
 * 2. Maintain neighbor-to-index map to eliminate indexOf() calls
 * 3. The visual update skipping (batchMode) is already implemented ‚úì
 * 
 * CONFIRMED: Array reversal (.reverse()) is the primary bottleneck
 */
function performBackbite() {
  if (!currentGrid.path || currentGrid.path.length < 2) return;
  if (!currentGrid.activeSubgraph) return;
  
  const path = currentGrid.path;
  const isHead = Math.random() < 0.5;
  const endpoint = isHead ? path[0] : path[path.length - 1];
  const [x, y, z] = endpoint.split(',').map(Number);
  
  const neighborCoords = [
    [x + 1, y, z], [x - 1, y, z],
    [x, y + 1, z], [x, y - 1, z],
    [x, y, z + 1], [x, y, z - 1]
  ];
  
  const neighbors = neighborCoords
    .map(c => c.join(','))
    .filter(n => {
      if (!currentGrid.vertices.has(n)) return false;
      const idx = path.indexOf(n);
      if (idx === -1) return false;
      if (isHead && idx === 1) return false;
      if (!isHead && idx === path.length - 2) return false;
      return true;
    });
    
  if (neighbors.length === 0) return;
  
  const neighbor = neighbors[Math.floor(Math.random() * neighbors.length)];
  const idx = path.indexOf(neighbor);
  
  // Reconfigure path
  let newPath;
  if (isHead) {
    const newHead = path.slice(0, idx).reverse();
    const newTail = path.slice(idx);
    newPath = [...newHead, ...newTail];
  } else {
    const newTail = path.slice(idx + 1).reverse();
    const newHead = path.slice(0, idx + 1);
    newPath = [...newHead, ...newTail];
  }
  
  // Update path references
  currentGrid.path = newPath;
  currentPath = newPath;
  
  // Skip expensive visual updates in batch mode
  if (!batchMode) {
    // Rebuild the activeSubgraph to match the new path
    currentGrid.activeSubgraph.clear();
    for (let i = 0; i < newPath.length - 1; i++) {
      const a = newPath[i].split(',').map(Number);
      const b = newPath[i + 1].split(',').map(Number);
      currentGrid.activeSubgraph.addEdge(a, b);
    }
    
    // Reapply gradient if gradient mode is active
    if (gradientMode) {
      applyGradientToPath();
    }
    
    // Update endpoint markers
    clearEndpointMarkers(currentGrid);
    decoratePathEndpoints(newPath[0], newPath[newPath.length - 1]);
  }
}


async function generateCycleFromPath() {
  if (!currentGrid) {
    addGrid();
  }
  
  const totalVertices = currentGrid.width * currentGrid.height * currentGrid.depth;
  
  // Check vertex count and show warnings
  if (totalVertices > 125000) {
    alert("Too many vertices. Grid dimensions not supported for generation.");
    return;
  } else if (totalVertices > 30000) {
    if (!confirm("This may take a long long time. Proceed with generation anyway?")) {
      return;
    }
  } else if (totalVertices > 10000) {
    if (!confirm("This may take a few minutes. Proceed with generation anyway?")) {
      return;
    }
  }
  
  // Check if Hamiltonian cycles are impossible (all dimensions odd)
  if (currentGrid.width % 2 === 1 && 
      currentGrid.height % 2 === 1 && 
      currentGrid.depth % 2 === 1) {
    alert("This grid has no Hamiltonian cycles (all dimensions are odd).");
    return;
  }
  
  // Set generation flags
  isGenerating = true;
  shouldStopGeneration = false;
  
  duplicateCurrentGrid();
  
  const width = currentGrid.width;
  const height = currentGrid.height;
  const depth = currentGrid.depth;
  
  // Calculate backbite moves based on grid type and size (same as generatePath)
  let baseMultiplier;
  const is2D = (depth === 1);
  
  if (is2D) {
    // 2D grids use higher multipliers for larger sizes
    if (totalVertices > 15000) {
      baseMultiplier = 60;  // MULTIPLIER: Change 60 for grids > 15000 vertices
    } else if (totalVertices > 5000) {
      baseMultiplier = 40;  // MULTIPLIER: Change 40 for grids > 5000 vertices
    } else if (totalVertices > 1000) {
      baseMultiplier = 20;  // MULTIPLIER: Change 20 for grids > 1000 vertices
    } else {
      baseMultiplier = 10;  // MULTIPLIER: Change 10 for small 2D grids
    }
  } else {
    // 3D grids always use 10x
    baseMultiplier = 10;    // MULTIPLIER: Change 10 for all 3D grids
  }
  
  const minimumMoves = baseMultiplier * totalVertices;
  const searchMoves = baseMultiplier * totalVertices;
  const totalMoves = minimumMoves + searchMoves;
  
  // Show progress overlay
  ProgressOverlay.show('cycle', `${width}√ó${height}√ó${depth}`);
  
  // Give browser time to render the overlay
  await new Promise(resolve => setTimeout(resolve, 50));
  
  const tStart = performance.now();
  
  // Clear any existing path/subgraph first
  if (currentGrid.activeSubgraph) currentGrid.activeSubgraph.clear();
  
  // Clear any existing arrows
  for (const [key, edge] of currentGrid.edges.entries()) {
    removeArrowsFromEdge(edge);
  }
  
  clearEndpointMarkers(currentGrid);
  
  // Enable batch mode BEFORE creating snakey path to prevent visual updates
  batchMode = true;
  
  makeSnakeyPath();
  
  // IMMEDIATELY clear visual meshes so snakey path doesn't show
  currentGrid.activeSubgraph.clear();
  for (const [key, edge] of currentGrid.edges.entries()) {
    if (edge.mesh) {
      edge.mesh.visible = false;
    }
  }
  
  console.log(`Performing ${minimumMoves} scrambling moves, then searching for cycle...`);
  
  // Initialize tracking
  let adjacencyCount = 0;
  let movesPerformed = 0;
  let cycleFound = false;
  let lastReportedPercent = 0;
  
  const tBackbiteStart = performance.now();
  
  // Chunk size for yielding to browser
  const chunkSize = Math.max(100, Math.floor(totalMoves / 100));
  
  // Phase 1: Do the full scrambling without looking for cycles
  for (let i = 0; i < minimumMoves; i++) {
    // Check if user wants to stop
    if (shouldStopGeneration) {
      console.log("Generation stopped by user during Phase 1");
      batchMode = false;
      isGenerating = false;
      ProgressOverlay.hide();
      return;
    }
    
    performBackbite();
    movesPerformed++;
    
    // Update progress and yield to browser every chunk
    if (movesPerformed % chunkSize === 0) {
      const currentPercent = Math.floor((movesPerformed / totalMoves) * 100);
      if (currentPercent > lastReportedPercent) {
        lastReportedPercent = currentPercent;
        ProgressOverlay.update(currentPercent, `${width}√ó${height}√ó${depth}`);
        
        // Yield to browser to repaint
        await new Promise(resolve => setTimeout(resolve, 0));
      }
    }
  }
  
  console.log(`Scrambling complete. Now searching for cycle opportunity...`);
  
  // Phase 2: Look for cycle opportunities
  for (let i = 0; i < searchMoves; i++) {
    // Check if user wants to stop
    if (shouldStopGeneration) {
      console.log("Generation stopped by user during Phase 2");
      batchMode = false;
      isGenerating = false;
      ProgressOverlay.hide();
      return;
    }
    
    performBackbite();
    movesPerformed++;
    
    // Update progress and yield to browser every chunk
    if (movesPerformed % chunkSize === 0) {
      const currentPercent = Math.floor((movesPerformed / totalMoves) * 100);
      if (currentPercent > lastReportedPercent) {
        lastReportedPercent = currentPercent;
        ProgressOverlay.update(currentPercent, `${width}√ó${height}√ó${depth}`);
        
        // Yield to browser to repaint
        await new Promise(resolve => setTimeout(resolve, 0));
      }
    }
    
    // Check if endpoints are adjacent
    if (areEndpointsAdjacent()) {
      adjacencyCount++;
      cycleFound = true;
      console.log(`Found cycle opportunity at move ${movesPerformed}!`);
      break;
    }
  }
  
  const tBackbiteEnd = performance.now();
  
  // Disable batch mode
  batchMode = false;
  
  if (cycleFound) {
    // Convert path to actual cycle
    const start = currentGrid.path[0].split(',').map(Number);
    const end = currentGrid.path[currentGrid.path.length - 1].split(',').map(Number);
    
    // Add the end vertex to the beginning to close the cycle
    const cycleVertices = [...currentGrid.path, currentGrid.path[0]];
    currentGrid.path = cycleVertices;
    currentPath = cycleVertices;
    
    // Rebuild activeSubgraph with all edges including the closing edge
    currentGrid.activeSubgraph.clear();
    for (let i = 0; i < cycleVertices.length - 1; i++) {
      const a = cycleVertices[i].split(',').map(Number);
      const b = cycleVertices[i + 1].split(',').map(Number);
      currentGrid.activeSubgraph.addEdge(a, b);
    }
    
    // Mark as cycle
    currentGrid.cycle = currentGrid.activeSubgraph;
    
    // Visual updates for cycle
    updateEdgeMeshesFromSubgraph(currentGrid, currentGrid.activeSubgraph);
    
    if (gradientMode) applyGradientToPath();
    
    // No endpoint markers for cycles
    clearEndpointMarkers(currentGrid);
    
    // Add directional arrows if arrow mode is active
    if (arrowMode) {
      addDirectionalArrowsToPath(currentGrid.path, true); // closed=true for cycle
    }
    
  } else {
    // No cycle found - show alert and return path
    alert("Bad luck, just a path this time!");
    console.log("No cycle found within search limit, creating regular path");
    
    currentGrid.activeSubgraph.clear();
    for (let i = 0; i < currentGrid.path.length - 1; i++) {
      const a = currentGrid.path[i].split(',').map(Number);
      const b = currentGrid.path[i + 1].split(',').map(Number);
      currentGrid.activeSubgraph.addEdge(a, b);
    }
    
    if (gradientMode) applyGradientToPath();
    clearEndpointMarkers(currentGrid);
    decoratePathEndpoints(currentGrid.path[0], currentGrid.path[currentGrid.path.length - 1]);
    
    if (arrowMode) {
      addDirectionalArrowsToPath(currentGrid.path, false);
    }
  }
  
  const tEnd = performance.now();
  const totalMs = tEnd - tStart;
  const backbiteMs = tBackbiteEnd - tBackbiteStart;
  const perMoveMs = backbiteMs / movesPerformed;
  const timeInSeconds = (totalMs / 1000).toFixed(2);
  
  // Clear generation flag
  isGenerating = false;
  
  // Show completion message
ProgressOverlay.complete(timeInSeconds);
  
  console.log(
    `Generated Hamiltonian ${cycleFound ? 'CYCLE' : 'path'}.\n` +
    `%cTotal time: ${totalMs.toFixed(2)} ms%c\n` +
    `Backbite phase: ${backbiteMs.toFixed(2)} ms for ${movesPerformed} moves\n` +
    `%cAvg per backbite: ${perMoveMs.toFixed(4)} ms/move%c\n` +
    `${cycleFound ? 'Cycle found!' : 'No cycle found within limit'}`,
    "color: blue;", "", // Total time
    "color: blue;", ""  // Avg per backbite
  );
}


function areEndpointsAdjacent() {
 if (!currentGrid.path || currentGrid.path.length < 2) return false;
 
 const start = currentGrid.path[0];
 const end = currentGrid.path[currentGrid.path.length - 1];
 
 const [x1, y1, z1] = start.split(',').map(Number);
 const [x2, y2, z2] = end.split(',').map(Number);
 
 // Check if they're unit distance apart (adjacent)
 const dx = Math.abs(x1 - x2);
 const dy = Math.abs(y1 - y2);
 const dz = Math.abs(z1 - z2);
 
 return (dx + dy + dz === 1);
}




//     ================================
// 		*** 3.2. Endpoint Markers  ***
//     ================================
 
function updateEndpointMarkers(grid = currentGrid) {
  if (!grid || !grid.path || grid.path.length < 2) return;
  
  const path = grid.path;
  const startKey = path[0];
  const endKey = path[path.length - 1];
  
  // Clear existing markers
  clearEndpointMarkers(grid);
  
  // Parse coordinates
  const [sx, sy, sz] = startKey.split(',').map(Number);
  const [ex, ey, ez] = endKey.split(',').map(Number);
  
  // Create markers with green for active, red for inactive
  const startColor = activeEndpoint === 'start' ? 0x00ff00 : 0xff0000;
  const endColor = activeEndpoint === 'end' ? 0x00ff00 : 0xff0000;
  
  const startSphere = new THREE.Mesh(
    new THREE.SphereGeometry(0.15, 16, 16),
    new THREE.MeshBasicMaterial({ color: startColor })
  );
  startSphere.position.set(sx, sy, sz);
  grid.group.add(startSphere);
  grid.startMarker = startSphere;
  
  const endSphere = new THREE.Mesh(
    new THREE.SphereGeometry(0.15, 16, 16),
    new THREE.MeshBasicMaterial({ color: endColor })
  );
  endSphere.position.set(ex, ey, ez);
  grid.group.add(endSphere);
  grid.endMarker = endSphere;
}

function decoratePathEndpoints(startKey, endKey) {
  // Set default active endpoint to start when creating new path
  activeEndpoint = 'start';
  updateEndpointMarkers();
}

function clearEndpointMarkers(grid) {
  if (grid.startMarker) {
    grid.group.remove(grid.startMarker);
    grid.startMarker = null;
  }
  if (grid.endMarker) {
    grid.group.remove(grid.endMarker);
    grid.endMarker = null;
  }
}



//     =======================================
// 		*** 3.3. Arrow Related functions  ***
//     =======================================

function createArrowTexture(direction = 1) {
  const canvas = document.createElement('canvas');
  canvas.width = 128;
  canvas.height = 32;
  const ctx = canvas.getContext('2d');
  
  // Clear canvas
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fillRect(0, 0, 128, 32);
  
  // Draw shorter, fatter arrow with bigger head
  ctx.fillStyle = 'black';
  ctx.beginPath();
  
  if (direction === 1) {
    // Arrow pointing forward - shorter and fatter
    ctx.moveTo(95, 16);   // Arrow tip (moved closer to center)
    ctx.lineTo(70, 4);    // Top of bigger arrowhead (wider)
    ctx.lineTo(70, 10);   // Top of fatter shaft
    ctx.lineTo(35, 10);   // Shorter shaft top
    ctx.lineTo(35, 22);   // Fatter shaft bottom
    ctx.lineTo(70, 22);   // Bottom of fatter shaft
    ctx.lineTo(70, 28);   // Bottom of bigger arrowhead (wider)
  } else {
    // Arrow pointing backward - shorter and fatter
    ctx.moveTo(33, 16);   // Arrow tip (moved closer to center)
    ctx.lineTo(58, 4);    // Top of bigger arrowhead (wider)
    ctx.lineTo(58, 10);   // Top of fatter shaft
    ctx.lineTo(93, 10);   // Shorter shaft top
    ctx.lineTo(93, 22);   // Fatter shaft bottom
    ctx.lineTo(58, 22);   // Bottom of fatter shaft
    ctx.lineTo(58, 28);   // Bottom of bigger arrowhead (wider)
  }
  
  ctx.closePath();
  ctx.fill();
  
  return new THREE.CanvasTexture(canvas);
}


function addArrowsToEdge(edge, direction = 1, from = null, to = null) {
  if (edge.arrows) removeArrowsFromEdge(edge);

  // Get edge coordinates - either from parameters or derive from edge key in currentGrid
  let edgeLength, edgeRadius, startPos, endPos;
  
  if (from && to) {
    // Calculate from provided coordinates
    startPos = new THREE.Vector3(from[0], from[1], (from[2] ?? 0));
    endPos = new THREE.Vector3(to[0], to[1], (to[2] ?? 0));
    edgeLength = startPos.distanceTo(endPos);
  } else if (edge.mesh) {
    // Individual mesh mode - use existing mesh properties
    edgeLength = edge.mesh.geometry.parameters.height;
    edgeRadius = edge.mesh.geometry.parameters.radiusTop;
    startPos = edge.mesh.position.clone();
    endPos = edge.mesh.position.clone();
  } else {
    // Instanced mode - find coordinates from edge data in grid
    // Search for this edge in the grid to get its coordinates
    let foundKey = null;
    for (const [key, e] of currentGrid.edges.entries()) {
      if (e === edge) {
        foundKey = key;
        break;
      }
    }
    
    if (!foundKey) {
      console.error("Cannot add arrows: edge not found in grid");
      return;
    }
    
    const [aStr, bStr] = foundKey.split("-");
    from = aStr.split(",").map(Number);
    to = bStr.split(",").map(Number);
    
    startPos = new THREE.Vector3(from[0], from[1], (from[2] ?? 0));
    endPos = new THREE.Vector3(to[0], to[1], (to[2] ?? 0));
    edgeLength = startPos.distanceTo(endPos);
  }
  
  // Use instanced rendering if enabled
  if (currentGrid.isInstanced && from && to) {
    addArrowInstanced(currentGrid, edge, direction, from, to);
    return;
  }
  
  // === INDIVIDUAL MESH MODE (existing code) ===
  
  // Determine radius based on whether edge is colored
  if (edgeRadius === undefined) {
    edgeRadius = (edge.color !== UNCOLORED_COLOR) ? 0.05 : 0.015;
  }

  const texture = createArrowTexture(direction);
  texture.wrapS = THREE.ClampToEdgeWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.center.set(0.5, 0.5);
  texture.rotation = Math.PI / 2;
  const arrowsAlongHeight = 3;
  texture.repeat.set(1, arrowsAlongHeight);

  const arrowMaterial = new THREE.MeshBasicMaterial({
    map: texture,
    transparent: true,
    depthTest: false
  });

  const geometry = new THREE.CylinderGeometry(
    edgeRadius * 1.02,
    edgeRadius * 1.02,
    edgeLength,
    6,
    1,
    true
  );

  const arrowMesh = new THREE.Mesh(geometry, arrowMaterial);
  
  // Calculate position and orientation from coordinates
  const midpoint = new THREE.Vector3().addVectors(startPos, endPos).multiplyScalar(0.5);
  arrowMesh.position.copy(midpoint);

  if (from && to) {
    // Align +Y to (to - from)
    const start = new THREE.Vector3(from[0], from[1], (from[2] ?? 0));
    const end   = new THREE.Vector3(to[0],   to[1],   (to[2]   ?? 0));
    const dir = new THREE.Vector3().subVectors(end, start);
    if (dir.lengthSq() > 0) {
      dir.normalize();
      const q = new THREE.Quaternion().setFromUnitVectors(
        new THREE.Vector3(0, 1, 0), dir
      );
      arrowMesh.quaternion.copy(q);
    } else if (edge.mesh) {
      // Degenerate safety: fall back to base edge orientation if available
      arrowMesh.quaternion.copy(edge.mesh.quaternion);
    }
  } else if (edge.mesh) {
    // Back-compat for existing callers (copy edge's orientation)
    arrowMesh.quaternion.copy(edge.mesh.quaternion);
  }

  // Ignore raycasting so clicks hit the base edge
  arrowMesh.raycast = () => {};

  edge.arrows = arrowMesh;
  edge.arrowDirection = direction;
  currentGrid.group.add(arrowMesh);
}


function removeArrowsFromEdge(edge) {
  if (!edge.arrows) return;
  
  if (currentGrid.isInstanced && edge.arrows === 'instanced') {
    // Instanced mode
    removeArrowInstanced(currentGrid, edge);
    // Clear visual marker but PRESERVE direction for toggle
    edge.arrows = null;
    // edge.arrowDirection stays set!
  } else {
    // Individual mesh mode
    if (edge.arrows && edge.arrows !== 'instanced') {
      currentGrid.group.remove(edge.arrows);
    }
    edge.arrows = null;
    // edge.arrowDirection stays set!
  }
}


function addDirectionalArrowsToPath(path, closed = false) {
  if (!arrowMode || !currentGrid || !Array.isArray(path) || path.length < 2) return;

  // Determine base direction (respect arrowReverse toggle)
  const baseDirection = arrowReverse ? -1 : 1;
  
  // Do not mutate the original path
  const ordered = arrowReverse ? [...path].reverse() : path;

  const limit = closed ? ordered.length : (ordered.length - 1);
  for (let i = 0; i < limit; i++) {
    const aStr = ordered[i];
    const bStr = closed
      ? ordered[(i + 1) % ordered.length]
      : ordered[i + 1];

    const a = aStr.split(',').map(Number);
    const b = bStr.split(',').map(Number);

    const eKey = edgeKey(a, b);
    const edge = currentGrid.edges.get(eKey);
    if (edge) {
      // Always use current traversal direction (don't preserve old direction)
      addArrowsToEdge(edge, baseDirection, a, b);
    }
  }
}


//     ========================================
// 		*** 3.4.Manual Backbite Functions  ***
//     ========================================

function getValidBackbiteEdges(endpointKey) {
  if (!currentGrid.path || currentGrid.path.length < 3) return [];
  
  const path = currentGrid.path;
  const isStart = path[0] === endpointKey;
  const isEnd = path[path.length - 1] === endpointKey;
  
  // Only proceed if this is the active endpoint
  const isActiveEndpoint = (activeEndpoint === 'start' && isStart) || 
                          (activeEndpoint === 'end' && isEnd);
  
  if (!isActiveEndpoint) return [];
  
  const [x, y, z] = endpointKey.split(',').map(Number);
  const neighborCoords = [
    [x + 1, y, z], [x - 1, y, z],
    [x, y + 1, z], [x, y - 1, z],
    [x, y, z + 1], [x, y, z - 1]
  ];

  const validEdges = [];
  
  for (const coord of neighborCoords) {
    const neighborKey = coord.join(',');
    
    // Check if neighbor exists in grid
    if (!currentGrid.vertices.has(neighborKey)) continue;
    
    // Check if neighbor is in the path
    const idx = path.indexOf(neighborKey);
    if (idx === -1) continue;
    
    // For start: can't connect to the adjacent vertex (path[1])
    // For end: can't connect to the adjacent vertex (path[path.length - 2])
    if (isStart && idx === 1) continue;
    if (isEnd && idx === path.length - 2) continue;
    
    // This is a valid backbite edge
    const eKey = edgeKey([x, y, z], coord);
    validEdges.push({
      edgeKey: eKey,
      neighborKey,
      neighborIndex: idx,
      isHead: isStart
    });
  }
  
  return validEdges;
}

let activeEndpoint = 'start'; // 'start' or 'end'



function toggleActiveEndpoint() {
  if (!currentGrid || !currentGrid.path || currentGrid.path.length < 2) {
    console.warn("No valid path to toggle endpoints");
    return;
  }
  
  // DON'T toggle activeEndpoint - let the path reversal handle it
  // activeEndpoint = activeEndpoint === 'start' ? 'end' : 'start';
  
  // Reverse the entire path array
  currentGrid.path.reverse();
  currentPath = currentGrid.path; // Keep currentPath in sync
  
  // Update visual markers - green at path[0], red at path[path.length-1]
  updateEndpointMarkers();
  
  // If arrows are enabled, redraw them (they'll automatically point in the reversed direction)
  if (arrowMode && currentGrid && currentGrid.path && currentGrid.path.length > 1) {
    // Remove all arrows
    for (const [key, edge] of currentGrid.edges.entries()) {
      removeArrowsFromEdge(edge);
    }
    // Redraw arrows in the new path direction
    addDirectionalArrowsToPath(currentGrid.path);
  }
  
  // Reapply gradient if active
  if (gradientMode) {
    applyGradientToPath();
  }
  
  console.log(`Path reversed, active endpoint remains: ${activeEndpoint}`);
}



function performManualBackbite(clickedEdgeKey) {
  if (!currentGrid.path || currentGrid.path.length < 2) return false;
  if (!currentGrid.activeSubgraph) return false;

  const path = currentGrid.path;
  const activeEndpointKey = activeEndpoint === 'start' ? path[0] : path[path.length - 1];
  
  const validEdges = getValidBackbiteEdges(activeEndpointKey);
  const matchingEdge = validEdges.find(edge => edge.edgeKey === clickedEdgeKey);
  
  if (!matchingEdge) {
    console.warn("Invalid backbite edge selected for active endpoint");
    return false;
  }
  
  // SAVE OLD PATH FOR UNDO
  const oldPath = [...currentGrid.path];
  
  const isHead = matchingEdge.isHead;
  const idx = matchingEdge.neighborIndex;
  
  // Reconfigure path
  let newPath;
  if (isHead) {
    const newHead = path.slice(0, idx).reverse();
    const newTail = path.slice(idx);
    newPath = [...newHead, ...newTail];
  } else {
    const newTail = path.slice(idx + 1).reverse();
    const newHead = path.slice(0, idx + 1);
    newPath = [...newHead, ...newTail];
  }

  // Update path references
  currentGrid.path = newPath;
  currentPath = newPath;
  
  // RECORD UNDO ACTION
  recordAction('BACKBITE', {
    oldPath: oldPath,
    newPath: [...newPath]
  });
  
  // Clear redo stack
  currentGrid.redoStack = [];

  // Rebuild the activeSubgraph to match the new path
  currentGrid.activeSubgraph.clear();
  for (let i = 0; i < newPath.length - 1; i++) {
    const a = newPath[i].split(',').map(Number);
    const b = newPath[i + 1].split(',').map(Number);
    currentGrid.activeSubgraph.addEdge(a, b);
  }

  // Reapply gradient if gradient mode is active
  if (gradientMode) {
    applyGradientToPath();
  }

  // Update endpoint markers
  updateEndpointMarkers();
  
  // Add arrows if arrow mode is active
  if (arrowMode && currentGrid.path) {
    addDirectionalArrowsToPath(currentGrid.path);
  }
  
  console.log(`Manual backbite completed on ${activeEndpoint} endpoint`);
  return true;
}


//     =================================
// 		*** 3.5.Gradient Functions  ***
//     =================================

function hexToRgb(hex) {
  const r = (hex >> 16) & 255;
  const g = (hex >> 8) & 255;
  const b = hex & 255;
  return { r, g, b };
}

function rgbToHex(r, g, b) {
  return (r << 16) | (g << 8) | b;
}

function interpolateColor(color1, color2, factor) {
  factor = Math.max(0, Math.min(1, factor));
  
  // Curve that rushes through the muddy middle
  factor = factor < 0.5 ? 2 * factor * factor : 1 - 2 * (1 - factor) * (1 - factor);
  
  const rgb1 = hexToRgb(color1);
  const rgb2 = hexToRgb(color2);
  
  const r = Math.round(rgb1.r + (rgb2.r - rgb1.r) * factor);
  const g = Math.round(rgb1.g + (rgb2.g - rgb1.g) * factor);
  const b = Math.round(rgb1.b + (rgb2.b - rgb1.b) * factor);
  
  return rgbToHex(r, g, b);
}

function colorEdgeWithColor(grid, a, b, color, radius = 0.05) {
  if (grid.isInstanced) {
    colorEdgeInstanced(grid, a, b, color, radius);
  } else {
    const eKey = edgeKey(a, b);
    const edge = grid.edges.get(eKey);
    if (!edge) return;
    
    // ALWAYS remove arrows when coloring (they'll be re-added if needed)
    if (edge.arrows) {
      removeArrowsFromEdge(edge);
    }
    
    grid.group.remove(edge.mesh);
    
    const start = new THREE.Vector3(...a);
    const end = new THREE.Vector3(...b);
    const direction = new THREE.Vector3().subVectors(end, start);
    const length = direction.length();
    const midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
    const axis = new THREE.Vector3(0, 1, 0);
    
    const material = new THREE.MeshBasicMaterial({ color });
    const geometry = new THREE.CylinderGeometry(radius, radius, length, 8);
    const mesh = new THREE.Mesh(geometry, material);
    mesh.quaternion.setFromUnitVectors(axis, direction.clone().normalize());
    mesh.position.copy(midpoint);
    
    edge.mesh = mesh;
    edge.color = color;
    grid.group.add(mesh);
  }
}

function applyGradientToPath() {
  if (!currentGrid || !currentGrid.path || currentGrid.path.length < 2) return;
  
  const path = currentGrid.path;
  const pathLength = path.length - 1;
  const color1 = selectedColor;
  const color2 = selectedColor2;
  
  // Calculate the mix color (50% blend)
  const colorMix = interpolateColor(color1, color2, 0.5);
  
  // Store arrow information BEFORE coloring
  const arrowInfo = new Map();
  for (let i = 0; i < pathLength; i++) {
    const a = path[i].split(',').map(Number);
    const b = path[i + 1].split(',').map(Number);
    const eKey = edgeKey(a, b);
    const edge = currentGrid.edges.get(eKey);
    
    if (edge && edge.arrows) {
      arrowInfo.set(eKey, {
        direction: edge.arrows.direction,
        a: a,
        b: b
      });
    }
  }
  
  // Apply gradient colors
  for (let i = 0; i < pathLength; i++) {
    const factor = pathLength > 1 ? i / (pathLength - 1) : 0;
    
    let edgeColor;
    if (factor < 0.5) {
      // First half: color1 to colorMix
      edgeColor = interpolateColor(color1, colorMix, factor * 2);
    } else {
      // Second half: colorMix to color2
      edgeColor = interpolateColor(colorMix, color2, (factor - 0.5) * 2);
    }
    
    const a = path[i].split(',').map(Number);
    const b = path[i + 1].split(',').map(Number);
    
    colorEdgeWithColor(currentGrid, a, b, edgeColor, 0.05);
  }
  
  // Re-add arrows AFTER coloring
  for (const [eKey, info] of arrowInfo.entries()) {
    const edge = currentGrid.edges.get(eKey);
    if (edge) {
      addArrowsToEdge(edge, info.direction, info.a, info.b);
    }
  }
}


Subgraph.prototype.addEdgeWithGradient = function(a, b, pathIndex, totalEdges) {
  const eKey = edgeKey(a, b);
  if (this.edges.has(eKey)) return;

  this.edges.add(eKey);
  this.vertices.add(vertexKey(...a));
  this.vertices.add(vertexKey(...b));

  const factor = totalEdges > 1 ? pathIndex / (totalEdges - 1) : 0;
  const color1 = selectedColor;
  const color2 = selectedColor2;
  const colorMix = interpolateColor(color1, color2, 0.5);
  
  let edgeColor;
  if (factor < 0.5) {
    edgeColor = interpolateColor(color1, colorMix, factor * 2);
  } else {
    edgeColor = interpolateColor(colorMix, color2, (factor - 0.5) * 2);
  }

  colorEdgeWithColor(this.grid, a, b, edgeColor, 0.05);
};



//     ============================================
// 		*** 3.6.Hamiltonian Path/Cycle Checker ***
//     ============================================

function buildColoredEdgeAdjacency() {
  const adj = new Map();
  for (const [key, edge] of currentGrid.edges.entries()) {
    if (edge.color !== UNCOLORED_COLOR) {
      const [aStr, bStr] = key.split("-");
      if (!adj.has(aStr)) adj.set(aStr, []);
      if (!adj.has(bStr)) adj.set(bStr, []);
      adj.get(aStr).push(bStr);
      adj.get(bStr).push(aStr);
    }
  }
  return adj;
}

function checkConnectivity(adj, totalVertices) {
  if (adj.size === 0) return false;
  
  const visited = new Set();
  const stack = [adj.keys().next().value];
  
  while (stack.length > 0) {
    const v = stack.pop();
    if (visited.has(v)) continue;
    visited.add(v);
    for (const nbr of adj.get(v) || []) {
      if (!visited.has(nbr)) stack.push(nbr);
    }
  }
  
  return visited.size === totalVertices;
}

function checkHamiltonianCycle() {
  if (!currentGrid) {
    alert("No grid selected.");
    return;
  }
  
  const adj = buildColoredEdgeAdjacency();
  const totalVertices = currentGrid.vertices.size;
  
  // Check if any colored edges exist
  if (adj.size === 0) {
    alert("‚ùå The colored subgraph is not a Hamiltonian cycle. ");
    console.log("No colored edges found.");
    return;
  }
  
  // Check degree condition (each vertex must have degree 2)
  for (const v of currentGrid.vertices.keys()) {
    const deg = adj.get(v)?.length || 0;
    if (deg !== 2) {
      alert("‚ùå The colored subgraph is not a Hamiltonian cycle.");
      console.log(`Failing vertex: ${v} (degree: ${deg})`);
      return;
    }
  }
  
  // Check connectivity
  if (!checkConnectivity(adj, totalVertices)) {
    alert("‚ùå The colored subgraph is not a Hamiltonian cycle.");
    console.log("Graph is not connected.");
    return;
  }
  
  alert("‚úÖ The colored subgraph is a Hamiltonian cycle.");
}

function isHamiltonianPath() {
  if (!currentGrid) return false;
  
  const adj = buildColoredEdgeAdjacency();
  const totalVertices = currentGrid.vertices.size;
  
  // Check if any colored edges exist
  if (adj.size === 0) {
    console.log("No colored edges found.");
    return false;
  }
  
  // Check degree counts - must have exactly 2 endpoints (degree 1) and rest degree 2
  const endpoints = [];
  for (const [v, neighbors] of adj.entries()) {
    const deg = neighbors.length;
    if (deg === 1) {
      endpoints.push(v);
    } else if (deg !== 2) {
      console.log(`Failing vertex: ${v} (degree: ${deg})`);
      return false;
    }
  }
  
  if (endpoints.length !== 2) {
    console.log(`Expected 2 endpoints, found: ${endpoints.length}`);
    return false;
  }
  
  // Check connectivity by walking the path
  const visited = new Set();
  const path = [];
  let current = endpoints[0];
  let prev = null;
  
  while (current) {
    path.push(current);
    visited.add(current);
    const neighbors = adj.get(current) || [];
    const next = neighbors.find(v => v !== prev && !visited.has(v));
    prev = current;
    current = next;
  }
  
  if (path.length !== totalVertices) {
    console.log(`Path incomplete: covers ${path.length}/${totalVertices} vertices`);
    return false;
  }
  
  currentPath = path; // Save it globally
  return true;
}

function checkHamiltonianCombined() {
  if (!currentGrid) return;
  
  // First try to check if it's a Hamiltonian path
  if (isHamiltonianPath()) {
    alert(" ‚úÖ The colored subgraph is a Hamiltonian path. ");
  } else {
    // If not a path, check for Hamiltonian cycle
    checkHamiltonianCycle();
  }
}




//     ====================================================================================================================
// 						      4. EDGE COLORING, EDGE MESH FUNCTIONS, AND ISSWITCHABLE FUNCTIONS
//     ====================================================================================================================

// I.E.R. UPDATED
function colorEdge(grid, a, b, color = selectedColor, radius = 0.05) {
  if (grid.isInstanced) {
    colorEdgeInstanced(grid, a, b, color, radius);
  } else {
    colorEdgeIndividual(grid, a, b, color, radius);
  }
}

// I.E.R. ADDED FUNCTION

function colorEdgeIndividual(grid, a, b, color, radius) {
  const eKey = edgeKey(a, b);
  const edge = grid.edges.get(eKey);
  if (!edge) return;

  // ALWAYS remove arrows when coloring (they'll be re-added if needed)
  if (edge.arrows) {
    removeArrowsFromEdge(edge);
  }

  grid.group.remove(edge.mesh);

  const start = new THREE.Vector3(...a);
  const end = new THREE.Vector3(...b);
  const direction = new THREE.Vector3().subVectors(end, start);
  const length = direction.length();
  const midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
  const axis = new THREE.Vector3(0, 1, 0);

  const material = new THREE.MeshBasicMaterial({ color });
  const geometry = new THREE.CylinderGeometry(radius, radius, length, 8);
  const mesh = new THREE.Mesh(geometry, material);
  mesh.quaternion.setFromUnitVectors(axis, direction.clone().normalize());
  mesh.position.copy(midpoint);

  // Apply current grid opacity if uncoloring
  if (color === UNCOLORED_COLOR) {
    // Read actual slider value
    const opacity = parseFloat(document.getElementById("gridOpacitySlider").value);
    
    const grayValue = Math.floor(0x88 * opacity);
    const simulatedColor = (grayValue << 16) | (grayValue << 8) | grayValue;
    mesh.material.color.setHex(simulatedColor);
    mesh.material.needsUpdate = true;
    
    // Hide if grid is not visible
    if (!gridVisible) {
      mesh.visible = false;
    }
  }

  edge.mesh = mesh;
  edge.color = color;
  grid.group.add(mesh);
}


function makeEdgeMesh(a, b, color, radius) {
  const start = new THREE.Vector3(...a);
  const end = new THREE.Vector3(...b);
  const direction = new THREE.Vector3().subVectors(end, start);
  const length = direction.length();
  const midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
  const axis = new THREE.Vector3(0, 1, 0);
  const geometry = new THREE.CylinderGeometry(radius, radius, length, 8);
  const material = new THREE.MeshBasicMaterial({ color });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.quaternion.setFromUnitVectors(axis, direction.clone().normalize());
  mesh.position.copy(midpoint);
  
  // Apply grid visibility to uncolored edges
  if (color === UNCOLORED_COLOR && !gridVisible) {
    mesh.visible = false;
  }
  
  return mesh;
}

function isSwitchable(box) {
  if (!box || !box.edges || box.edges.length !== 4) return false;

  // Step 1: Filter colored edges
  const sgEdges = box.edges.filter(eKey => {
    const edge = currentGrid.edges.get(eKey);
    return edge && edge.color !== UNCOLORED_COLOR;
  });

  if (sgEdges.length !== 2) return false;

  // Step 2: Compute direction vectors
  const dirs = sgEdges.map(eKey => {
    const [aStr, bStr] = eKey.split("-");
    const a = aStr.split(",").map(Number);
    const b = bStr.split(",").map(Number);
    return [
      Math.abs(a[0] - b[0]),
      Math.abs(a[1] - b[1]),
      Math.abs(a[2] - b[2])
    ]; // direction vector as absolute axis difference
  });

  // Step 3: Check if both directions match and are axis-aligned
  const [d1, d2] = dirs;

  const sameDirection = d1[0] === d2[0] && d1[1] === d2[1] && d1[2] === d2[2];
  const axisAligned = (d1[0] + d1[1] + d1[2]) === 1;

  return sameDirection && axisAligned;
}




//     ====================================================================================================================
// 										      5. GRID EDITING AND RELATED FUNCTIONS
//     ====================================================================================================================

//     ==========================================
// 		*** 5.1. Grid Duplication Functions  ***
//     ==========================================
function duplicateCurrentGrid() {
  if (!currentGrid) {
    alert("No grid to duplicate");
    return;
  }
  
  // Store reference to source grid for copying
  const sourceGrid = currentGrid;
  
  // Capture the current camera state from the source grid
  const sourceCameraPosition = camera.position.clone();
  const sourceCameraTarget = controls.target.clone();
  
  // Find the original grid's name, ID, and position in DOM
  let originalId = null;
  let originalButton = null;
  for (const [id, grid] of allGrids.entries()) {
    if (grid === sourceGrid) {
      originalId = id;
      // Find the corresponding button in the DOM
      const gridButtons = document.querySelectorAll('.grid-btn');
      for (const button of gridButtons) {
        const textSpan = button.querySelector('span');
        if (textSpan) {
          const fullName = textSpan.getAttribute('data-fullname') || textSpan.textContent;
          if (fullName === id) {
            originalButton = button;
            break;
          }
        }
      }
      break;
    }
  }
  
  if (!originalId || !originalButton) {
    console.error("Could not find original grid ID or button");
    return;
  }
  
  // Generate unique duplicate ID
  let duplicateId = originalId + "'";
  while (allGrids.has(duplicateId)) {
    duplicateId = duplicateId + "'";
  }
  
  // Create new grid data structure
  const duplicateGrid = createEmptyGridData();
  duplicateGrid.width = sourceGrid.width;
  duplicateGrid.height = sourceGrid.height;
  duplicateGrid.depth = sourceGrid.depth;
  
  // Build the basic grid structure
  buildGridContent(duplicateGrid);
  
  // Set camera position for the duplicate
  duplicateGrid.cameraPosition = sourceCameraPosition;
  duplicateGrid.cameraTarget = sourceCameraTarget;
  
  // Add to grids collection
  allGrids.set(duplicateId, duplicateGrid);
  
  // Create UI button and insert it AFTER the original button
  const newButton = createGridButtonElement(duplicateId);
  const gridList = document.getElementById("gridList");
  
  // Insert after the original button
  if (originalButton.nextSibling) {
    gridList.insertBefore(newButton, originalButton.nextSibling);
  } else {
    gridList.appendChild(newButton);
  }
  
  // Switch to the duplicate
  switchToGrid(duplicateId);
  
  // Copy states to the duplicate
  copyEdgeStatesDelayed(sourceGrid, duplicateGrid);
  copySubgraphData(sourceGrid, duplicateGrid);
  
  console.log(`Grid duplicated: ${originalId} -> ${duplicateId}`);
}



// Drag and drop handlers for grid buttons
let draggedButton = null;

function handleDragStart(e) {
  draggedButton = this;
  this.classList.add('dragging');
  e.dataTransfer.effectAllowed = 'move';
  e.dataTransfer.setData('text/html', this.innerHTML);
}

function handleDragEnd(e) {
  this.classList.remove('dragging');
  
  // Remove drag-over class from all buttons
  document.querySelectorAll('.grid-btn').forEach(btn => {
    btn.classList.remove('drag-over');
  });
  
  draggedButton = null;
}

function handleDragOver(e) {
  if (e.preventDefault) {
    e.preventDefault();
  }
  e.dataTransfer.dropEffect = 'move';
  return false;
}

function handleDrop(e) {
  if (e.stopPropagation) {
    e.stopPropagation();
  }
  
  if (draggedButton !== this) {
    // Get parent container
    const gridList = document.getElementById('gridList');
    const allButtons = [...gridList.children];
    
    const draggedIndex = allButtons.indexOf(draggedButton);
    const targetIndex = allButtons.indexOf(this);
    
    // Reorder in DOM
    if (draggedIndex < targetIndex) {
      this.parentNode.insertBefore(draggedButton, this.nextSibling);
    } else {
      this.parentNode.insertBefore(draggedButton, this);
    }
  }
  
  this.classList.remove('drag-over');
  return false;
}



function handleDragLeave(e) {
  this.classList.remove('drag-over');
}

// Automatically attach drag handlers whenever a grid button is added to the DOM
const gridListObserver = new MutationObserver((mutations) => {
  mutations.forEach((mutation) => {
    mutation.addedNodes.forEach((node) => {
      if (node.classList && node.classList.contains('grid-btn')) {
        attachGridButtonDnD(node);
      }
    });
  });
});

// Start observing #gridList
const gridList = document.getElementById('gridList');
if (gridList) {
  gridListObserver.observe(gridList, { childList: true });
}

// Also run once immediately for any existing buttons
document.querySelectorAll('.grid-btn').forEach(btn => {
  attachGridButtonDnD(btn);
});

// Helper function to attach drag-and-drop handlers to grid buttons
function attachGridButtonDnD(btn) {
  btn.draggable = true;
  btn.addEventListener('dragstart', handleDragStart);
  btn.addEventListener('dragend', handleDragEnd);
  btn.addEventListener('dragover', handleDragOver);
  btn.addEventListener('drop', handleDrop);
  btn.addEventListener('dragleave', handleDragLeave);
}

function createGridButtonElement(gridId) {
  const button = document.createElement("div");
  button.className = "grid-btn";
  button.dataset.gridId = gridId;
  
  const grid = allGrids.get(gridId);
  
  const textSpan = document.createElement("span");
  textSpan.style.pointerEvents = "none";
  
  // Show only first word, store full name in data attribute
  const displayName = gridId.split(' ')[0];
  textSpan.textContent = displayName;
  textSpan.setAttribute('data-fullname', gridId);
  
  // Add hover tooltip
  button.title = gridId;
  
  // Add grid info (dimensions only - all grids use instanced rendering now)
  const infoSpan = document.createElement("div");
  infoSpan.className = "grid-info";
  infoSpan.style.pointerEvents = "none";
  infoSpan.textContent = `${grid.width}√ó${grid.height}√ó${grid.depth}`;
  
  const close = document.createElement("span");
  close.className = "close";
  close.innerHTML = "&times;";
  close.onclick = e => {
    e.stopPropagation();
    
    // Confirm deletion before proceeding
    if (!confirm("Delete this grid? This cannot be undone.")) {
      return; // User cancelled, do nothing
    }
    
    const grid = allGrids.get(gridId);
    if (currentGrid === grid) {
      clearEndpointMarkers(grid);
      scene.remove(grid.group);
      currentGrid = null;
    }
    allGrids.delete(gridId);
    button.remove();
  };
  
  button.appendChild(textSpan);
  button.appendChild(infoSpan);
  button.appendChild(close);
  
  button.onclick = (e) => {
    if (e.target !== close) {
      switchToGrid(gridId);
    }
  };
  
  // Double-click to rename
  button.ondblclick = (e) => {
    e.stopPropagation();
    textSpan.style.pointerEvents = "auto";
    textSpan.style.cursor = "text";
    textSpan.textContent = gridId;
    startGridRename(gridId, textSpan, button);
  };
  
  // Attach drag-and-drop handlers
  attachGridButtonDnD(button);
  
  return button;
}





// Update existing grid buttons to be draggable
(function updateExistingButtons() {
  document.querySelectorAll('.grid-btn').forEach(btn => {
    if (!btn.draggable) {
      btn.draggable = true;
      btn.addEventListener('dragstart', handleDragStart);
      btn.addEventListener('dragend', handleDragEnd);
      btn.addEventListener('dragover', handleDragOver);
      btn.addEventListener('drop', handleDrop);
      btn.addEventListener('dragleave', handleDragLeave);
    }
  });
})();

// Also run after a short delay to catch any buttons created during initialization
setTimeout(() => {
  document.querySelectorAll('.grid-btn').forEach(btn => {
    if (!btn.draggable) {
      btn.draggable = true;
      btn.addEventListener('dragstart', handleDragStart);
      btn.addEventListener('dragend', handleDragEnd);
      btn.addEventListener('dragover', handleDragOver);
      btn.addEventListener('drop', handleDrop);
      btn.addEventListener('dragleave', handleDragLeave);
    }
  });
}, 500);


function copyEdgeStatesDelayed(sourceGrid, targetGrid) {
  // Copy edge colors and block cubes
  for (const [edgeKey, sourceEdge] of sourceGrid.edges.entries()) {
    if (sourceEdge.color !== UNCOLORED_COLOR) {
      const [aStr, bStr] = edgeKey.split("-");
      const a = aStr.split(",").map(Number);
      const b = bStr.split(",").map(Number);
      colorEdge(targetGrid, a, b, sourceEdge.color, 0.05);
    }
    
    // Copy block cubes
    if (sourceEdge.blockCube) {
      const targetEdge = targetGrid.edges.get(edgeKey);
      if (targetEdge) {
        if (targetGrid.isInstanced) {
  addBlockCubeInstanced(targetGrid, targetEdge, edgeKey);
} else {
  addBlockCube(targetEdge);
}
      }
    }
  }

  // Copy vertex spheres
  if (sourceGrid.vertexSpheres) {
    for (const [vertexKey, sphereData] of sourceGrid.vertexSpheres.entries()) {
      // Handle both old format (direct sphere) and new format (sphere/decoration object)
      let sphere, decoration, color;
      if (sphereData.sphere) {
        // New format
        sphere = sphereData.sphere;
        decoration = sphereData.decoration;
        
        // Get color (works for both instanced and individual mode)
        if (sourceGrid.isInstanced) {
          color = sphereData.color;
        } else {
          color = sphere.material.color.getHex();
        }
      } else {
        // Old format - sphereData is the sphere itself
        sphere = sphereData;
        decoration = null;
        color = sphere.material.color.getHex();
      }
      
      createVertexSphere(targetGrid, vertexKey, color);
      
      // Copy decoration if it exists
      if (decoration) {
        // Extract decoration color from the decoration
        let decorationColor;
        if (decoration.children && decoration.children.length > 0) {
          decorationColor = decoration.children[0].material.color.getHex();
        } else if (decoration.material) {
          decorationColor = decoration.material.color.getHex();
        }
        
        if (decorationColor !== undefined) {
          addVertexDecoration(targetGrid, vertexKey, decorationColor);
        }
      }
    }
  }

  // Copy arrows after a brief delay to ensure edges are ready
  setTimeout(() => {
    for (const [edgeKey, sourceEdge] of sourceGrid.edges.entries()) {
      if (sourceEdge.arrows && sourceEdge.arrowDirection) {
        const targetEdge = targetGrid.edges.get(edgeKey);
        if (targetEdge) {
          addArrowsToEdge(targetEdge, sourceEdge.arrowDirection);
        }
      }
    }
  }, 100);
}
  



function copyEdgeStates(sourceGrid, targetGrid) {
  for (const [edgeKey, sourceEdge] of sourceGrid.edges.entries()) {
    const targetEdge = targetGrid.edges.get(edgeKey);
    if (!targetEdge) continue;

    // Copy color if different from default
    if (sourceEdge.color !== UNCOLORED_COLOR) {
      const [aStr, bStr] = edgeKey.split("-");
      const a = aStr.split(",").map(Number);
      const b = bStr.split(",").map(Number);
      
      // Determine radius based on color
      const radius = sourceEdge.color === UNCOLORED_COLOR ? 0.015 : 0.05;
      colorEdge(targetGrid, a, b, sourceEdge.color, radius);
    }

    // Copy arrow states if they exist - do this AFTER coloring the edge
    if (sourceEdge.arrows && sourceEdge.arrowDirection) {
      // Get the updated target edge after coloring
      const updatedTargetEdge = targetGrid.edges.get(edgeKey);
      addArrowsToEdge(updatedTargetEdge, sourceEdge.arrowDirection);
    }
  }
}

function copySubgraphData(sourceGrid, targetGrid) {
  if (!sourceGrid.activeSubgraph) return;

  // Create new subgraph for target
  const newSubgraph = new Subgraph(targetGrid);

  // Copy all edges from source subgraph
  for (const edgeKey of sourceGrid.activeSubgraph.getEdgeKeys()) {
    const [aStr, bStr] = edgeKey.split("-");
    const a = aStr.split(",").map(Number);
    const b = bStr.split(",").map(Number);
    
    // Add edge to new subgraph (this will also handle coloring)
    newSubgraph.edges.add(edgeKey);
    newSubgraph.vertices.add(aStr);
    newSubgraph.vertices.add(bStr);
  }

  targetGrid.activeSubgraph = newSubgraph;

  // Copy path data if it exists
  if (sourceGrid.path) {
    targetGrid.path = [...sourceGrid.path]; // Create a copy of the array
    
    // Recreate endpoint markers properly
    if (targetGrid.path.length >= 2) {
      const startKey = targetGrid.path[0];
      const endKey = targetGrid.path[targetGrid.path.length - 1];
      
      // Clear any existing markers first
      clearEndpointMarkers(targetGrid);
      
      // Parse coordinates and create markers
      const [sx, sy, sz] = startKey.split(',').map(Number);
      const [ex, ey, ez] = endKey.split(',').map(Number);
      
      // Create start marker (green for active, red for inactive)
      const startColor = activeEndpoint === 'start' ? 0x00ff00 : 0xff0000;
      const startSphere = new THREE.Mesh(
        new THREE.SphereGeometry(0.15, 16, 16),
        new THREE.MeshBasicMaterial({ color: startColor })
      );
      startSphere.position.set(sx, sy, sz);
      targetGrid.group.add(startSphere);
      targetGrid.startMarker = startSphere;
      
      // Create end marker
      const endColor = activeEndpoint === 'end' ? 0x00ff00 : 0xff0000;
      const endSphere = new THREE.Mesh(
        new THREE.SphereGeometry(0.15, 16, 16),
        new THREE.MeshBasicMaterial({ color: endColor })
      );
      endSphere.position.set(ex, ey, ez);
      targetGrid.group.add(endSphere);
      targetGrid.endMarker = endSphere;
    }
  }
}


//     =============================================
// 		*** 5.2. Grid Tabs and Naming Functions ***
//     =============================================
function createGridButton(gridId) {
  const button = createGridButtonElement(gridId);
  document.getElementById("gridList").appendChild(button);
  
  if (currentGrid && allGrids.get(gridId) === currentGrid) {
    button.classList.add('active');
  }
}

function startGridRename(oldId, textSpan, button) {
  const input = document.createElement("input");
  input.type = "text";
  input.value = oldId;
  input.style.width = "80px";
  input.style.fontSize = "14px";
  input.style.border = "1px solid #ccc";
  input.style.borderRadius = "3px";
  input.style.padding = "2px 4px";
  
  let isFinishing = false; // Prevent multiple calls
  
  const finishRename = () => {
    if (isFinishing || !input.parentNode) return; // Already processing or removed
    isFinishing = true;
    
    const newId = input.value.trim();
    if (newId && newId !== oldId && !allGrids.has(newId)) {
      // Update grid collection
      const grid = allGrids.get(oldId);
      allGrids.delete(oldId);
      allGrids.set(newId, grid);
      
      // Update current grid reference if needed
      if (currentGrid === grid) {
        button.onclick = () => switchToGrid(newId);
      }
      
      // Update display: show up to second space
      const getDisplayName = (fullName) => {
        const parts = fullName.split(' ');
        return parts.length <= 2 ? fullName : parts.slice(0, 2).join(' ');
      };
      
      const displayName = getDisplayName(newId);
      textSpan.textContent = displayName;
      textSpan.setAttribute('data-fullname', newId);
      button.title = newId;
      textSpan.onclick = (e) => {
        e.stopPropagation();
        textSpan.textContent = newId;
        startGridRename(newId, textSpan, button);
      };
    } else {
      // Revert to display name if invalid
      const getDisplayName = (fullName) => {
        const parts = fullName.split(' ');
        return parts.length <= 2 ? fullName : parts.slice(0, 2).join(' ');
      };
      const displayName = getDisplayName(oldId);
      textSpan.textContent = displayName;
    }
    
    textSpan.style.display = "inline";
    if (input.parentNode) input.remove();
  };
  
  input.onblur = finishRename;
  input.onkeydown = (e) => {
    if (e.key === "Enter") finishRename();
    if (e.key === "Escape") {
      if (isFinishing) return;
      isFinishing = true;
      
      const getDisplayName = (fullName) => {
        const parts = fullName.split(' ');
        return parts.length <= 2 ? fullName : parts.slice(0, 2).join(' ');
      };
      const displayName = getDisplayName(oldId);
      textSpan.textContent = displayName;
      textSpan.style.display = "inline";
      if (input.parentNode) input.remove();
    }
  };
  
  textSpan.style.display = "none";
  button.insertBefore(input, textSpan);
  input.focus();
  input.select();
}




//     ===================================================
// 		*** 5.3. Add/Remove Edge/Cube/Arrow Functions ***
//     ===================================================


function handleEdgeClick(intersects) {
  const clicked = intersects[0].object;
  
  // Check if we clicked on a collision helper first
  if (clicked.userData.parentEdge) {
    const eKey = clicked.userData.parentEdge;
    const edge = currentGrid.edges.get(eKey);
    
    if (!edge) return;
    
    const [aStr, bStr] = eKey.split("-");
    const a = aStr.split(",").map(Number);
    const b = bStr.split(",").map(Number);
    
    const beforeState = captureEdgeState(eKey);
    
    // ARROW MODE GETS PRIORITY
    if (arrowMode) {
      if (edge.arrowDirection === 0 || edge.arrowDirection === undefined) {
        edge.arrowDirection = 1;
        colorEdge(currentGrid, a, b, selectedColor, 0.05);
        addArrowsToEdge(edge, 1);
        
        if (!currentGrid.activeSubgraph) {
          currentGrid.activeSubgraph = new Subgraph(currentGrid);
        }
        currentGrid.activeSubgraph.addEdge(a, b);
      } else if (edge.arrowDirection === 1) {
        edge.arrowDirection = -1;
        addArrowsToEdge(edge, -1);
      } else if (edge.arrowDirection === -1) {
        edge.arrowDirection = 0;
        removeArrowsFromEdge(edge);
        colorEdge(currentGrid, a, b, UNCOLORED_COLOR, 0.015);
        
        if (currentGrid.activeSubgraph) {
          currentGrid.activeSubgraph.removeEdge(a, b);
        }
      }
      
      const afterState = captureEdgeState(eKey);
      recordAction('EDGE_STATE', { edgeKey: eKey, beforeState, afterState });
      return;
    }
    
    // Simple toggle: uncolored <-> colored (no cube logic)
    const isColored = edge.color !== UNCOLORED_COLOR;
    if (isColored) {
      colorEdge(currentGrid, a, b, UNCOLORED_COLOR, 0.015);
      if (currentGrid.activeSubgraph) {
        currentGrid.activeSubgraph.removeEdge(a, b);
      }
    } else {
      colorEdge(currentGrid, a, b, selectedColor, 0.05);
      if (!currentGrid.activeSubgraph) {
        currentGrid.activeSubgraph = new Subgraph(currentGrid);
      }
      currentGrid.activeSubgraph.addEdge(a, b);
    }
    
    const afterState = captureEdgeState(eKey);
    recordAction('EDGE_STATE', { edgeKey: eKey, beforeState, afterState });
    return;
  }
  
  // Direct mesh clicks (same logic as above)
  for (const [key, edge] of currentGrid.edges.entries()) {
    if (edge.mesh === clicked) {
      const [aStr, bStr] = key.split("-");
      const a = aStr.split(",").map(Number);
      const b = bStr.split(",").map(Number);
      
      const beforeState = captureEdgeState(key);
      
      // ARROW MODE GETS PRIORITY
      if (arrowMode) {
        if (edge.arrowDirection === 0 || edge.arrowDirection === undefined) {
          edge.arrowDirection = 1;
          colorEdge(currentGrid, a, b, selectedColor, 0.05);
          addArrowsToEdge(edge, 1);
          
          if (!currentGrid.activeSubgraph) {
            currentGrid.activeSubgraph = new Subgraph(currentGrid);
          }
          currentGrid.activeSubgraph.addEdge(a, b);
        } else if (edge.arrowDirection === 1) {
          edge.arrowDirection = -1;
          addArrowsToEdge(edge, -1);
        } else if (edge.arrowDirection === -1) {
          edge.arrowDirection = 0;
          removeArrowsFromEdge(edge);
          colorEdge(currentGrid, a, b, UNCOLORED_COLOR, 0.015);
          
          if (currentGrid.activeSubgraph) {
            currentGrid.activeSubgraph.removeEdge(a, b);
          }
        }
        
        const afterState = captureEdgeState(key);
        recordAction('EDGE_STATE', { edgeKey: key, beforeState, afterState });
        return;
      }
      
      // Simple toggle: uncolored <-> colored (no cube logic)
      const isColored = edge.color !== UNCOLORED_COLOR;
      if (isColored) {
        colorEdge(currentGrid, a, b, UNCOLORED_COLOR, 0.015);
        if (currentGrid.activeSubgraph) {
          currentGrid.activeSubgraph.removeEdge(a, b);
        }
      } else {
        colorEdge(currentGrid, a, b, selectedColor, 0.05);
        if (!currentGrid.activeSubgraph) {
          currentGrid.activeSubgraph = new Subgraph(currentGrid);
        }
        currentGrid.activeSubgraph.addEdge(a, b);
      }
      
      const afterState = captureEdgeState(key);
      recordAction('EDGE_STATE', { edgeKey: key, beforeState, afterState });
      break;
    }
  }
}


function handleCubeClick() {
  const edgeMeshes = Array.from(currentGrid.edges.values()).map(e => e.mesh).filter(m => m);
  const intersects = raycaster.intersectObjects(edgeMeshes);
  
  if (intersects.length > 0) {
    const clicked = intersects[0].object;
    
    // Find the edge
    let targetEdge = null;
    let targetEdgeKey = null;
    
    // Check collision helper first
    if (clicked.userData.parentEdge) {
      targetEdgeKey = clicked.userData.parentEdge;
      targetEdge = currentGrid.edges.get(targetEdgeKey);
    } else {
      // Direct mesh click
      for (const [key, edge] of currentGrid.edges.entries()) {
        if (edge.mesh === clicked) {
          targetEdgeKey = key;
          targetEdge = edge;
          break;
        }
      }
    }
    
    if (targetEdge && targetEdgeKey) {
      const beforeState = captureEdgeState(targetEdgeKey);
      
      // Toggle cube
      if (targetEdge.blockCube) {
        removeBlockCube(targetEdge);
      } else {
        addBlockCube(targetEdge);
      }
      
      const afterState = captureEdgeState(targetEdgeKey);
      recordAction('EDGE_STATE', { edgeKey: targetEdgeKey, beforeState, afterState });
    }
  }
}

function addBlockCube(edge) {
  if (edge.blockCube) return; // Already has one
  
  const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
  const material = new THREE.MeshBasicMaterial({ color: selectedColor2 }); // Use second color
  const cube = new THREE.Mesh(geometry, material);
  
  // Position at edge midpoint
  cube.position.copy(edge.mesh.position);
  cube.raycast = () => {}; // Ignore raycasting
  
  edge.blockCube = cube;
  currentGrid.group.add(cube);
}

function removeBlockCube(edge) {
  if (!edge.blockCube) return;
  
  currentGrid.group.remove(edge.blockCube);
  edge.blockCube.geometry.dispose();
  edge.blockCube.material.dispose();
  edge.blockCube = null;
}


//     ===============================================
// 		*** 5.4. Add/Remove Vertex/Decorate Functions ***
//     ===============================================
function toggleVertexSphere(vertexKey) {
  const hasDecoration = decorationEnabled;
  const beforeState = captureVertexSphereState(vertexKey);
  
  if (!currentGrid.vertexSpheres.has(vertexKey)) {
    // First click: create uncolored sphere
    createVertexSphere(currentGrid, vertexKey, 0x888888);
    const afterState = captureVertexSphereState(vertexKey);
    recordAction('VERTEX_SPHERE', { vertexKey, beforeState, afterState });
  } else {
    const sphereData = currentGrid.vertexSpheres.get(vertexKey);
    const sphere = sphereData.sphere;
    const decoration = sphereData.decoration;
    
    // Get current color (works for both instanced and individual mode)
    const currentColor = currentGrid.isInstanced 
      ? sphereData.color 
      : sphere.material.color.getHex();
    
    if (currentColor === 0x888888 && !decoration) {
      // Second click: color with selected color
      if (currentGrid.isInstanced) {
        createVertexSphere(currentGrid, vertexKey, selectedColor);
      } else {
        sphere.material.color.setHex(selectedColor);
      }
      const afterState = captureVertexSphereState(vertexKey);
      recordAction('VERTEX_SPHERE', { vertexKey, beforeState, afterState });
    } else if (currentColor !== 0x888888 && !decoration && hasDecoration) {
      // Third click (if decorations enabled): add decoration
      addVertexDecoration(currentGrid, vertexKey, selectedColor2);
      const afterState = captureVertexSphereState(vertexKey);
      recordAction('VERTEX_DECORATION', { vertexKey, beforeState, afterState });
    } else {
      // Final click: remove sphere (and decoration if present)
      removeVertexSphere(currentGrid, vertexKey);
      const afterState = null;
      recordAction('VERTEX_SPHERE', { vertexKey, beforeState, afterState });
    }
  }
}


function createVertexSphereInstanced(grid, vertexKey, color) {
  const instanceIndex = grid.vertexToInstanceMap.get(vertexKey);
  if (instanceIndex === undefined) return;
  
  const [x, y, z] = vertexKey.split(',').map(Number);
  const position = new THREE.Vector3(x, y, z);
  
  // Create transform matrix (identity scale at position)
  const matrix = new THREE.Matrix4().setPosition(position);
  
  // Set visual sphere
  grid.instancedVertexSpheres.setMatrixAt(instanceIndex, matrix);
  grid.instancedVertexSpheres.setColorAt(instanceIndex, new THREE.Color(color));
  grid.instancedVertexSpheres.instanceMatrix.needsUpdate = true;
  grid.instancedVertexSpheres.instanceColor.needsUpdate = true;
  
  // Set collision helper
  grid.instancedVertexCollisionHelpers.setMatrixAt(instanceIndex, matrix);
  grid.instancedVertexCollisionHelpers.instanceMatrix.needsUpdate = true;
  
  // Store in vertexSpheres map for compatibility
  if (!grid.vertexSpheres.has(vertexKey)) {
    grid.vertexSpheres.set(vertexKey, {
      sphere: 'instanced',  // Marker
      decoration: null,
      collisionHelper: 'instanced',  // Marker
      color: color
    });
  } else {
    const sphereData = grid.vertexSpheres.get(vertexKey);
    sphereData.color = color;
  }
}

function removeVertexSphereInstanced(grid, vertexKey) {
  const instanceIndex = grid.vertexToInstanceMap.get(vertexKey);
  if (instanceIndex === undefined) return;
  
  // Hide by scaling to zero
  const zeroMatrix = new THREE.Matrix4().makeScale(0, 0, 0);
  
  grid.instancedVertexSpheres.setMatrixAt(instanceIndex, zeroMatrix);
  grid.instancedVertexSpheres.instanceMatrix.needsUpdate = true;
  
  grid.instancedVertexCollisionHelpers.setMatrixAt(instanceIndex, zeroMatrix);
  grid.instancedVertexCollisionHelpers.instanceMatrix.needsUpdate = true;
  
  // Remove decoration if present (keep individual)
  const sphereData = grid.vertexSpheres.get(vertexKey);
  if (sphereData && sphereData.decoration) {
    grid.group.remove(sphereData.decoration);
    if (sphereData.decoration.children) {
      sphereData.decoration.children.forEach(child => {
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
      });
    } else {
      if (sphereData.decoration.geometry) sphereData.decoration.geometry.dispose();
      if (sphereData.decoration.material) sphereData.decoration.material.dispose();
    }
  }
  
  grid.vertexSpheres.delete(vertexKey);
}

function createVertexSphere(grid, vertexKey, color) {
  // Remove existing sphere if present
  if (grid.vertexSpheres.has(vertexKey)) {
    removeVertexSphere(grid, vertexKey);
  }
  
  // Dispatch to instanced or individual mode
  if (grid.isInstanced) {
    createVertexSphereInstanced(grid, vertexKey, color);
    return;
  }
  
  // Individual mode (original code)
  const [x, y, z] = vertexKey.split(',').map(Number);
  
  const geometry = new THREE.SphereGeometry(0.12, 16, 16);
  const material = new THREE.MeshBasicMaterial({ color });
  const sphere = new THREE.Mesh(geometry, material);
  sphere.position.set(x, y, z);
  
  grid.group.add(sphere);
  
  const existingCollisionHelper = grid.vertices.get(vertexKey)?.collisionHelper;
  
  grid.vertexSpheres.set(vertexKey, {
    sphere: sphere,
    decoration: null,
    collisionHelper: existingCollisionHelper
  });
  
  return sphere;
}


function addVertexDecoration(grid, vertexKey, decorationColor) {
  // Auto-create vertex sphere if it doesn't exist
  if (!grid.vertexSpheres.has(vertexKey)) {
    const [x, y, z] = vertexKey.split(',').map(Number);
    addVertex(grid, x, y, z);
  }

  const sphereData = grid.vertexSpheres.get(vertexKey);
  if (sphereData.decoration) return; // Already has decoration
  
  const [x, y, z] = vertexKey.split(',').map(Number);
  const sphereRadius = 0.12;
  
  const decorationGroup = new THREE.Group();
  decorationGroup.position.set(x, y, z);
  
  const segments = 32;
  
  // === Equatorial band (unchanged) ===
  const equatorGeometry = new THREE.SphereGeometry(
    sphereRadius * 1.01,
    segments, segments,
    0, Math.PI * 2,                    // full phi range
    Math.PI/2 - 0.15, 0.3              // thin theta band around equator
  );
  const equatorMaterial = new THREE.MeshBasicMaterial({
    color: decorationColor,
    transparent: true,
    opacity: 0.8,
    depthTest: false,
    depthWrite: false
  });
  const equatorBand = new THREE.Mesh(equatorGeometry, equatorMaterial);
  equatorBand.renderOrder = 10;
  decorationGroup.add(equatorBand);
  
  // === Second band (rotated around Z-axis) ===
  const band2Geometry = new THREE.SphereGeometry(
    sphereRadius * 1.01,
    segments, segments,
    0, Math.PI * 2,                    // full phi range
    Math.PI/2 - 0.15, 0.3              // thin theta band around equator
  );
  const band2Material = new THREE.MeshBasicMaterial({
    color: decorationColor,
    transparent: true,
    opacity: 0.8,
    depthTest: false,
    depthWrite: false
  });
  const band2 = new THREE.Mesh(band2Geometry, band2Material);
  band2.rotation.z = Math.PI / 2;  // Rotate 90 degrees around Z-axis
  band2.renderOrder = 10;
  decorationGroup.add(band2);
  
  // === Third band (rotated around X-axis) ===
  const band3Geometry = new THREE.SphereGeometry(
    sphereRadius * 1.01,
    segments, segments,
    0, Math.PI * 2,                    // full phi range
    Math.PI/2 - 0.15, 0.3              // thin theta band around equator
  );
  const band3Material = new THREE.MeshBasicMaterial({
    color: decorationColor,
    transparent: true,
    opacity: 0.8,
    depthTest: false,
    depthWrite: false
  });
  const band3 = new THREE.Mesh(band3Geometry, band3Material);
  band3.rotation.x = Math.PI / 2;  // Rotate 90 degrees around X-axis
  band3.renderOrder = 10;
  decorationGroup.add(band3);
  
  grid.group.add(decorationGroup);
  sphereData.decoration = decorationGroup;
}

function removeVertexSphere(grid, vertexKey) {
  if (!grid.vertexSpheres.has(vertexKey)) return;
  
  // Dispatch to instanced or individual mode
  if (grid.isInstanced) {
    removeVertexSphereInstanced(grid, vertexKey);
    return;
  }
  
  // Individual mode (original code)
  const sphereData = grid.vertexSpheres.get(vertexKey);
  
  grid.group.remove(sphereData.sphere);
  sphereData.sphere.geometry.dispose();
  sphereData.sphere.material.dispose();
  
  if (sphereData.decoration) {
    grid.group.remove(sphereData.decoration);
    if (sphereData.decoration.children) {
      sphereData.decoration.children.forEach(child => {
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
      });
    } else {
      if (sphereData.decoration.geometry) sphereData.decoration.geometry.dispose();
      if (sphereData.decoration.material) sphereData.decoration.material.dispose();
    }
  }
  
  grid.vertexSpheres.delete(vertexKey);
}





//     ===============================================
// 		*** 5.4.¬Ω. Add/Remove Vertex/Decorate Functions ***
//     ===============================================

// Backbite distance calculation
function calculateBackbiteDistance(x1, y1, z1, x2, y2, z2) {
  return 0.5 * (Math.abs(x1 - x2) + Math.abs(y1 - y2) + Math.abs(z1 - z2));
}


// Updated colorVerticesAtBBDistance function with undo support
function colorVerticesAtBBDistance(refX, refY, refZ, targetDistance) {
  if (!currentGrid) {
    alert("No active grid to color vertices on");
    return;
  }
  
  const refVertexKey = vertexKey(refX, refY, refZ);
  const coloredVertices = [];
  
  // First, color the reference vertex v^* with the Second Color
  createVertexSphere(currentGrid, refVertexKey, selectedColor2);
  
  // Collect all vertices at target distance
  for (const [vertexKey, vertexData] of currentGrid.vertices.entries()) {
    const [x, y, z] = vertexData.coords;
    const distance = calculateBackbiteDistance(refX, refY, refZ, x, y, z);
    
    if (Math.abs(distance - targetDistance) < 0.001) {
      if (Math.abs(distance - Math.round(distance)) < 0.001) {
        createVertexSphere(currentGrid, vertexKey, selectedColor);
        coloredVertices.push(vertexKey);
      }
    }
  }
  
  // Record the batch action for undo/redo
  recordBBDistanceBatch(coloredVertices, refVertexKey);
  
  console.log(`Colored v^* at (${refX},${refY},${refZ}) with Second Color`);
  console.log(`Colored ${coloredVertices.length} vertices at backbite distance ${targetDistance} from v^*`);
  return coloredVertices.length;
}

// Clear all vertex spheres from current grid
function clearAllVertexSpheres() {
  if (!currentGrid || !currentGrid.vertexSpheres) {
    console.log("No vertex spheres to clear");
    return;
  }
  
  // Capture state BEFORE clearing
  const clearedVertices = [];
  for (const [vertexKey, sphereData] of currentGrid.vertexSpheres.entries()) {
    // Get color (works for both instanced and individual mode)
    const color = currentGrid.isInstanced 
      ? sphereData.color 
      : sphereData.sphere.material.color.getHex();
    
    clearedVertices.push({
      vertexKey: vertexKey,
      color: color,
      hasDecoration: !!sphereData.decoration
    });
  }
  
  // Record action for undo
  if (clearedVertices.length > 0) {
    recordAction('CLEAR_ALL_VERTICES', { clearedVertices });
  }
  
  // Now clear them
  let clearedCount = 0;
  const vertexKeys = [...currentGrid.vertexSpheres.keys()];
  
  for (const vertexKey of vertexKeys) {
    removeVertexSphere(currentGrid, vertexKey);
    clearedCount++;
  }
  
  console.log(`Cleared ${clearedCount} vertex spheres`);
}

// Validate backbite distance inputs
function validateBBDistanceInputs(refX, refY, refZ, distance) {
  if (!currentGrid) {
    console.error("[GridLab::ERR-001] No current grid available for validation");
    return false;
  }
  
  // Check if reference vertex is within grid bounds
  if (refX < 0 || refX >= currentGrid.width ||
      refY < 0 || refY >= currentGrid.height ||
      refZ < 0 || refZ >= currentGrid.depth) {
    console.error("[GridLab::ERR-002] Reference vertex out of bounds:", {refX, refY, refZ});
    alert(`Reference vertex (${refX},${refY},${refZ}) is outside grid bounds`);
    return false;
  }
  
  // Check if reference vertex exists in grid
  const refKey = vertexKey(refX, refY, refZ);
  if (!currentGrid.vertices.has(refKey)) {
    console.error("[GridLab::ERR-003] Reference vertex not found in grid:", refKey);
    alert(`Reference vertex (${refX},${refY},${refZ}) does not exist in current grid`);
    return false;
  }
  
  // Check if distance is non-negative
  if (distance < 0) {
    console.error("[GridLab::ERR-004] Invalid distance value:", distance);
    alert("Distance must be non-negative");
    return false;
  }
  
  return true;
}





//     ========================================
// 		*** 5.5. Coorinate Hover Functions ***
//     ========================================
function showCoordinateTooltip(event, text) {
  // Remove existing tooltip
  const existingTooltip = document.getElementById('coordinateTooltip');
  if (existingTooltip) existingTooltip.remove();
  
  if (!text) return;
  
  // Create new tooltip
  const tooltip = document.createElement('div');
  tooltip.id = 'coordinateTooltip';
  tooltip.textContent = text;
  tooltip.style.cssText = `
    position: absolute;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    font-family: monospace;
    pointer-events: none;
    z-index: 1000;
    white-space: nowrap;
  `;
  
  // Position near cursor with offset
  tooltip.style.left = (event.clientX + 10) + 'px';
  tooltip.style.top = (event.clientY - 25) + 'px';
  
  document.body.appendChild(tooltip);
}

function hideCoordinateTooltip() {
  const tooltip = document.getElementById('coordinateTooltip');
  if (tooltip) {
    tooltip.style.display = 'none';
  }
}


function handleCoordinateHover(event) {
  let tooltipText = null;
  let hasHighlight = false;
  
  let edgeHit = null;
  let vertexHit = null;
  let edgeDistance = Infinity;
  let vertexDistance = Infinity;
  
  // STEP 1: Raycast edges (if enabled)
  if (hoverEdges) {
    if (currentGrid.isInstanced) {
      const collisionHits = raycaster.intersectObject(currentGrid.instancedEdgesCollision, false);
      if (collisionHits.length > 0) {
        edgeHit = collisionHits[0];
        edgeDistance = edgeHit.distance;
      }
    } else {
      const edgeMeshes = Array.from(currentGrid.edges.values()).map(e => e.mesh).filter(m => m);
      const intersects = raycaster.intersectObjects(edgeMeshes);
      if (intersects.length > 0) {
        edgeHit = intersects[0];
        edgeDistance = edgeHit.distance;
      }
    }
  }
  
  // STEP 2: Raycast vertices (if enabled)
  if (hoverVertices) {
    if (currentGrid.isInstanced) {
      const vertexCollisionHits = raycaster.intersectObject(currentGrid.instancedVertexCollisionHelpers);
      if (vertexCollisionHits.length > 0) {
        vertexHit = vertexCollisionHits[0];
        vertexDistance = vertexHit.distance;
      }
    } else {
      const vertexHelpers = [];
      for (const [vKey, vertexData] of currentGrid.vertices.entries()) {
        if (vertexData.collisionHelper) {
          vertexHelpers.push(vertexData.collisionHelper);
        }
      }
      const vertexIntersects = raycaster.intersectObjects(vertexHelpers);
      if (vertexIntersects.length > 0) {
        vertexHit = vertexIntersects[0];
        vertexDistance = vertexHit.distance;
      }
    }
  }
  
  // STEP 3: Pick the closest hit
  const showVertex = vertexHit && vertexDistance < edgeDistance;
  
  if (showVertex) {
    // SHOW VERTEX
    if (currentGrid.isInstanced) {
      const instanceId = vertexHit.instanceId;
      let vertexKey = null;
      for (const [vKey, instanceIdx] of currentGrid.vertexToInstanceMap.entries()) {
        if (instanceIdx === instanceId) {
          vertexKey = vKey;
          break;
        }
      }
      
      if (vertexKey) {
        const [x, y, z] = vertexKey.split(',').map(Number);
        tooltipText = `Vertex: ${formatCoordinates(x, y, z)}`;
        
        const highlightGeometry = new THREE.SphereGeometry(0.12, 16, 16);
        const highlightMaterial = new THREE.MeshBasicMaterial({ 
          color: 0x00ffff,
          transparent: true, 
          opacity: 0.6,
          depthTest: false
        });
        currentGrid.vertexHighlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
        currentGrid.vertexHighlight.position.set(x, y, z);
        currentGrid.group.add(currentGrid.vertexHighlight);
        hasHighlight = true;
      }
    } else {
      const hoveredHelper = vertexHit.object;
      const vertexKey = hoveredHelper.userData.vertexKey;
      const [x, y, z] = vertexKey.split(',').map(Number);
      tooltipText = `Vertex: ${formatCoordinates(x, y, z)}`;
      
      const highlightGeometry = new THREE.SphereGeometry(0.12, 16, 16);
      const highlightMaterial = new THREE.MeshBasicMaterial({ 
        color: 0x00ffff,
        transparent: true, 
        opacity: 0.6,
        depthTest: false
      });
      currentGrid.vertexHighlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
      currentGrid.vertexHighlight.position.set(x, y, z);
      currentGrid.group.add(currentGrid.vertexHighlight);
      hasHighlight = true;
    }
  } else if (edgeHit) {
    // SHOW EDGE
    if (currentGrid.isInstanced) {
      const instanceId = edgeHit.instanceId;
      
      let edgeKey = null;
      for (const [eKey, mapping] of currentGrid.edgeToInstanceMap.entries()) {
        if (mapping.collision === instanceId) {
          edgeKey = eKey;
          break;
        }
      }
      
      if (edgeKey) {
        const [aStr, bStr] = edgeKey.split("-");
        const [ax, ay, az] = aStr.split(",").map(Number);
        const [bx, by, bz] = bStr.split(",").map(Number);
        tooltipText = `${formatEdgeCoordinates(ax, ay, az, bx, by, bz)}`;
        
        const edge = currentGrid.edges.get(edgeKey);
        
        if (edge) {
          if (!currentGrid.highlightOverlay) {
            const highlightGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
            const highlightMaterial = new THREE.MeshBasicMaterial({ 
              color: 0x00ffff,
              transparent: true, 
              opacity: 0.5,
              depthTest: false
            });
            currentGrid.highlightOverlay = new THREE.Mesh(highlightGeometry, highlightMaterial);
            currentGrid.group.add(currentGrid.highlightOverlay);
          }
          
          const matrix = new THREE.Matrix4();
          const isThick = (edge.color !== UNCOLORED_COLOR);
          
          if (isThick) {
            currentGrid.instancedEdgesThick.getMatrixAt(instanceId, matrix);
          } else {
            currentGrid.instancedEdgesThin.getMatrixAt(instanceId, matrix);
          }
          
          const position = new THREE.Vector3();
          const quaternion = new THREE.Quaternion();
          const scale = new THREE.Vector3();
          matrix.decompose(position, quaternion, scale);
          
          currentGrid.highlightOverlay.position.copy(position);
          currentGrid.highlightOverlay.quaternion.copy(quaternion);
          currentGrid.highlightOverlay.scale.y = scale.y;
          
          const cameraDirection = new THREE.Vector3();
          camera.getWorldDirection(cameraDirection);
          currentGrid.highlightOverlay.position.add(cameraDirection.multiplyScalar(-0.001));
          
          currentGrid.highlightOverlay.visible = true;
          hasHighlight = true;
        }
      }
    } else {
      const hoveredMesh = edgeHit.object;
      
      for (const [key, edge] of currentGrid.edges.entries()) {
        if (edge.mesh === hoveredMesh) {
          const [aStr, bStr] = key.split("-");
          const [ax, ay, az] = aStr.split(",").map(Number);
          const [bx, by, bz] = bStr.split(",").map(Number);
          tooltipText = `${formatEdgeCoordinates(ax, ay, az, bx, by, bz)}`;
          
          if (edge.color === UNCOLORED_COLOR) {
            if (!currentGrid.highlightOverlay) {
              const highlightGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
              const highlightMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff,
                transparent: true, 
                opacity: 0.5,
                depthTest: false
              });
              currentGrid.highlightOverlay = new THREE.Mesh(highlightGeometry, highlightMaterial);
              currentGrid.group.add(currentGrid.highlightOverlay);
            }
            
            const length = hoveredMesh.geometry.parameters.height;
            currentGrid.highlightOverlay.scale.y = length;
            currentGrid.highlightOverlay.position.copy(hoveredMesh.position);
            currentGrid.highlightOverlay.quaternion.copy(hoveredMesh.quaternion);
            
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            currentGrid.highlightOverlay.position.add(cameraDirection.multiplyScalar(-0.001));
            currentGrid.highlightOverlay.visible = true;
            hasHighlight = true;
          } else {
            hoveredMesh.userData.originalColor = hoveredMesh.material.color.getHex();
            hoveredMesh.userData.originalOpacity = hoveredMesh.material.opacity;
            hoveredMesh.material.color.setHex(0x00ffff);
            hoveredMesh.material.opacity = 1;
            window.highlightedEdge = hoveredMesh;
            hasHighlight = true;
          }
          break;
        }
      }
    }
  }
  
  // Show/hide tooltip
  showCoordinateTooltip(event, tooltipText);
  
  if (hasHighlight) {
    document.body.style.cursor = 'pointer';
  }
}


function formatCoordinates(x, y, z) {
  const relativeMode = document.getElementById("relativeCoordinatesCheckbox")?.checked || false;
  
  if (relativeMode) {
    const k = parseInt(document.getElementById("refK").value) || 0;
    const l = parseInt(document.getElementById("refL").value) || 0; 
    const h = parseInt(document.getElementById("refH").value) || 0;
    
    const offsetX = x - k;
    const offsetY = y - l;
    const offsetZ = z - h;
    
    // Format each coordinate with k,‚Ñì,h notation
    const formatOffset = (base, offset) => {
      if (offset === 0) return base;
      if (offset > 0) return `${base}+${offset}`;
      return `${base}${offset}`;
    };
    
    const xStr = formatOffset('k', offsetX);
    const yStr = formatOffset('‚Ñì', offsetY);
    const zStr = formatOffset('h', offsetZ);
    
    return `v(${xStr},${yStr},${zStr})`;
  }
  
  return `v(${x},${y},${z})`;
}

function formatEdgeCoordinates(x1, y1, z1, x2, y2, z2) {
  const relativeMode = document.getElementById("relativeCoordinatesCheckbox")?.checked || false;
  
  if (relativeMode) {
    const k = parseInt(document.getElementById("refK").value) || 0;
    const l = parseInt(document.getElementById("refL").value) || 0; 
    const h = parseInt(document.getElementById("refH").value) || 0;
    
    const formatOffset = (base, offset) => {
      if (offset === 0) return base;
      if (offset > 0) return `${base}+${offset}`;
      return `${base}${offset}`;
    };
    
    const x1Str = formatOffset('k', x1 - k);
    const y1Str = formatOffset('‚Ñì', y1 - l);
    const z1Str = formatOffset('h', z1 - h);
    const x2Str = formatOffset('k', x2 - k);
    const y2Str = formatOffset('‚Ñì', y2 - l);
    const z2Str = formatOffset('h', z2 - h);
    
    // Determine which coordinate differs
    if (x1 !== x2) {
      return `e(${x1Str},${x2Str};${y1Str};${z1Str})`;
    } else if (y1 !== y2) {
      return `e(${x1Str};${y1Str},${y2Str};${z1Str})`;
    } else if (z1 !== z2) {
      return `e(${x1Str};${y1Str};${z1Str},${z2Str})`;
    } else {
      return `e(${x1Str};${y1Str};${z1Str})`;
    }
  }
  
  // Non-relative mode
  if (x1 !== x2) {
    return `e(${x1},${x2};${y1};${z1})`;
  } else if (y1 !== y2) {
    return `e(${x1};${y1},${y2};${z1})`;
  } else if (z1 !== z2) {
    return `e(${x1};${y1};${z1},${z2})`;
  } else {
    return `e(${x1};${y1};${z1})`;
  }
}


//     =======================================================================
// 		*** 5.6. Toggle Underlying Grid, Toggle Coordinate Axis Functions ***
//     =======================================================================
function toggleUnderlyingGrid() {
  // Toggle the global state first
  gridVisible = !gridVisible;
  
  // Apply to all grids
  for (const [gridId, grid] of allGrids.entries()) {
    if (!grid || !grid.edges) continue;
    
    if (grid.isInstanced) {
      // Instanced rendering mode
      const zeroMatrix = new THREE.Matrix4().makeScale(0, 0, 0);
      
      for (const [eKey, edge] of grid.edges.entries()) {
        if (edge.color === UNCOLORED_COLOR) {
          const mapping = grid.edgeToInstanceMap.get(eKey);
          if (!mapping) continue;
          
          if (gridVisible) {
            // Show the edge - restore its proper transform
            const [aStr, bStr] = eKey.split("-");
            const a = aStr.split(",").map(Number);
            const b = bStr.split(",").map(Number);
            const aVec = new THREE.Vector3(...a);
            const bVec = new THREE.Vector3(...b);
            const direction = new THREE.Vector3().subVectors(bVec, aVec);
            const length = direction.length();
            const midpoint = new THREE.Vector3().addVectors(aVec, bVec).multiplyScalar(0.5);
            
            const matrix = new THREE.Matrix4();
            const quaternion = new THREE.Quaternion();
            const up = new THREE.Vector3(0, 1, 0);
            
            matrix.makeScale(1, length, 1);
            quaternion.setFromUnitVectors(up, direction.normalize());
            const rotationMatrix = new THREE.Matrix4().makeRotationFromQuaternion(quaternion);
            matrix.premultiply(rotationMatrix);
            matrix.setPosition(midpoint);
            
            grid.instancedEdgesThin.setMatrixAt(mapping.thin, matrix);
          } else {
            // Hide the edge
            grid.instancedEdgesThin.setMatrixAt(mapping.thin, zeroMatrix);
          }
        }
      }
      
      grid.instancedEdgesThin.instanceMatrix.needsUpdate = true;
      
    } else {
      // Individual mesh mode
      grid.edges.forEach(edge => {
        const isColored = edge.color !== UNCOLORED_COLOR;
        if (!isColored && edge.mesh) {
          edge.mesh.visible = gridVisible;
        }
      });
    }
  }
}

function formatAxisLabel(coordinate, axisType) {
  const relativeMode = document.getElementById("relativeCoordinatesCheckbox")?.checked || false;
  
  if (relativeMode) {
    const k = parseInt(document.getElementById("refK").value) || 0;
    const l = parseInt(document.getElementById("refL").value) || 0;
    const h = parseInt(document.getElementById("refH").value) || 0;
    
    let refValue, baseLetter;
    if (axisType === 'x') {
      refValue = k;
      baseLetter = 'k';
    } else if (axisType === 'y') {
      refValue = l;
      baseLetter = '‚Ñì';  // Changed to ‚Ñì
    } else {
      refValue = h;
      baseLetter = 'h';
    }
    
    const offset = coordinate - refValue;
    if (offset === 0) return baseLetter;
    if (offset > 0) return `${baseLetter}+${offset}`;
    return `${baseLetter}${offset}`;
  }
  
  return `${coordinate}`;
}


function toggleCoordinateAxes() {
 // Create a persistent holder the first time it's called
 if (!scene.userData.coordGroup) {
   scene.userData.coordGroup = new THREE.Group();
   scene.userData.coordGroup.visible = false; // Initialize as hidden
   scene.add(scene.userData.coordGroup);
 }
 const group = scene.userData.coordGroup;
 
 // If already visible, hide it
 if (group.visible) {
   group.visible = false;
   console.log("Coordinate axes hidden.");
   return;
 }
 
 // Clear existing children and recreate them (this ensures labels update)
 while (group.children.length > 0) {
   const child = group.children[0];
   group.remove(child);
   if (child.material && child.material.map) {
     child.material.map.dispose();
   }
   if (child.material) {
     child.material.dispose();
   }
   if (child.geometry) {
     child.geometry.dispose();
   }
 }
 
 // Use fallback values when no grid is present
 const width = currentGrid ? currentGrid.width : 6;
 const height = currentGrid ? currentGrid.height : 6;
 const depth = currentGrid ? currentGrid.depth : 6;
 
 // Determine which axes to show based on grid dimensions
 const showX = width > 1;
 const showY = height > 1;
 const showZ = depth > 1;
 
 // If all dimensions are 1, don't show any axes
 if (!showX && !showY && !showZ) {
   console.log("Grid is 1√ó1√ó1 - no axes to display.");
   return;
 }
 
 const axisLength = Math.max(width, height, depth) + 2;
 
 // Label helper function - updated to handle background color
 function makeLabel(text, position, color = null) {
   // Auto-select text color based on background if no color specified
   if (!color) {
     const bgColor = scene.background.getHex();
     color = bgColor < 0x808080 ? 'rgba(200,200,200,0.8)' : 'rgba(50,50,50,0.8)';
   }
   
   const canvas = document.createElement('canvas');
   canvas.width = 128;
   canvas.height = 64;
   const ctx = canvas.getContext('2d');
   ctx.fillStyle = color;
   ctx.font = '24px sans-serif';
   ctx.textAlign = 'center';
   ctx.textBaseline = 'middle';
   ctx.fillText(text, 64, 32);
   const texture = new THREE.CanvasTexture(canvas);
   const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
   const sprite = new THREE.Sprite(material);
   sprite.scale.set(1.5, 0.75, 1);
   sprite.position.copy(position);
   group.add(sprite);
 }
 
 // X-axis (Red) - only if width > 1
 if (showX) {
   const xGeometry = new THREE.BufferGeometry().setFromPoints([
     new THREE.Vector3(0, 0, 0),
     new THREE.Vector3(axisLength, 0, 0)
   ]);
   const xMaterial = new THREE.LineBasicMaterial({ 
     color: 0xff0000,
     depthTest: false,
     transparent: true,
     opacity: 0.7
   });
   const xAxis = new THREE.Line(xGeometry, xMaterial);
   group.add(xAxis);
   
   // X coordinate labels
   const offset = 0.3;
   for (let x = 0; x <= width; x++) {
     makeLabel(formatAxisLabel(x, 'x'), new THREE.Vector3(x, -offset, -offset));
   }
   
   // X axis label at end
   const endOffset = 0.5;
   makeLabel('X', new THREE.Vector3(axisLength + endOffset, 0, 0), 'red');
 }
 
 // Y-axis (Green) - only if height > 1
 if (showY) {
   const yGeometry = new THREE.BufferGeometry().setFromPoints([
     new THREE.Vector3(0, 0, 0),
     new THREE.Vector3(0, axisLength, 0)
   ]);
   const yMaterial = new THREE.LineBasicMaterial({ 
     color: 0x00ff00,
     depthTest: false,
     transparent: true,
     opacity: 0.7
   });
   const yAxis = new THREE.Line(yGeometry, yMaterial);
   group.add(yAxis);
   
   // Y coordinate labels
   const offset = 0.3;
   for (let y = 0; y <= height; y++) {
     makeLabel(formatAxisLabel(y, 'y'), new THREE.Vector3(-offset, y, -offset));
   }
   
   // Y axis label at end
   const endOffset = 0.5;
   makeLabel('Y', new THREE.Vector3(0, axisLength + endOffset, 0), 'lime');
 }
 
 // Z-axis (Blue) - only if depth > 1
 if (showZ) {
   const zGeometry = new THREE.BufferGeometry().setFromPoints([
     new THREE.Vector3(0, 0, 0),
     new THREE.Vector3(0, 0, axisLength)
   ]);
   const zMaterial = new THREE.LineBasicMaterial({ 
     color: 0x0000ff,
     depthTest: false,
     transparent: true,
     opacity: 0.7
   });
   const zAxis = new THREE.Line(zGeometry, zMaterial);
   group.add(zAxis);
   
   // Z coordinate labels
   const offset = 0.3;
   for (let z = 0; z <= depth; z++) {
     makeLabel(formatAxisLabel(z, 'z'), new THREE.Vector3(-offset, -offset, z));
   }
   
   // Z axis label at end
   const endOffset = 0.5;
   makeLabel('Z', new THREE.Vector3(0, 0, axisLength + endOffset), 'blue');
 }
 
 group.visible = true;
 console.log(`Coordinate axes shown (X:${showX}, Y:${showY}, Z:${showZ}).`);
}

function adjustCoordinateLabelColors(backgroundColor) {
  // Check if background is dark or light
  const isDarkBackground = backgroundColor < 0x808080; // Threshold for dark vs light
  
  // If coordinate axes are visible, update them with appropriate colors
  if (scene.userData.coordGroup && scene.userData.coordGroup.visible) {
    // Hide current axes and recreate with appropriate colors
    scene.userData.coordGroup.visible = false;
    scene.userData.coordGroup.children.length = 0; // Clear children
    
    // Force recreation with new colors on next toggle
    toggleCoordinateAxes();
    toggleCoordinateAxes(); // Show them again
  }
}


//     ==========================================
// 		*** 5.6. Transparent plane Functions ***
//     ==========================================
function addTransparentPlane(a, b, c, d, color = selectedColor, opacity = 0.05) {
  if (!currentGrid) {
    console.warn("No current grid to add plane to");
    return;
  }
  
  // Grid boundaries
  const minX = 0, maxX = currentGrid.width - 1;
  const minY = 0, maxY = currentGrid.height - 1;
  const minZ = 0, maxZ = currentGrid.depth - 1;
  
  // Normalize plane equation
  const normal = new THREE.Vector3(a, b, c);
  const normalLength = normal.length();
  
  if (normalLength === 0) {
    console.error("Invalid plane equation: normal vector cannot be zero");
    return;
  }
  
  normal.normalize();
  const distance = d / normalLength;
  
  // Find intersection points with grid edges
  const intersectionPoints = [];
  
  // Check all 12 edges of the grid bounding box
  const edges = [
    // Bottom face edges
    [[minX, minY, minZ], [maxX, minY, minZ]],
    [[maxX, minY, minZ], [maxX, maxY, minZ]],
    [[maxX, maxY, minZ], [minX, maxY, minZ]],
    [[minX, maxY, minZ], [minX, minY, minZ]],
    // Top face edges
    [[minX, minY, maxZ], [maxX, minY, maxZ]],
    [[maxX, minY, maxZ], [maxX, maxY, maxZ]],
    [[maxX, maxY, maxZ], [minX, maxY, maxZ]],
    [[minX, maxY, maxZ], [minX, minY, maxZ]],
    // Vertical edges
    [[minX, minY, minZ], [minX, minY, maxZ]],
    [[maxX, minY, minZ], [maxX, minY, maxZ]],
    [[maxX, maxY, minZ], [maxX, maxY, maxZ]],
    [[minX, maxY, minZ], [minX, maxY, maxZ]]
  ];
  
  // Find intersections with each edge
  for (const [start, end] of edges) {
    const startVec = new THREE.Vector3(...start);
    const endVec = new THREE.Vector3(...end);
    const direction = new THREE.Vector3().subVectors(endVec, startVec);
    
    // Check if line intersects plane
    const denominator = normal.dot(direction);
    if (Math.abs(denominator) > 1e-6) { // Not parallel
      const t = (distance - normal.dot(startVec)) / denominator;
      if (t >= 0 && t <= 1) { // Intersection within edge
        const intersection = startVec.clone().add(direction.multiplyScalar(t));
        intersectionPoints.push(intersection);
      }
    }
  }
  
  if (intersectionPoints.length < 3) {
    console.warn("Plane does not intersect grid boundaries sufficiently");
    return;
  }
  
  // More robust duplicate removal
  const uniquePoints = [];
  const tolerance = 1e-4;
  for (const point of intersectionPoints) {
    if (!uniquePoints.some(p => p.distanceTo(point) < tolerance)) {
      uniquePoints.push(point);
    }
  }
  
  if (uniquePoints.length < 3) {
    console.warn("Not enough unique intersection points");
    return;
  }
  
  // Project points onto plane for 2D sorting
  const center = uniquePoints.reduce((acc, p) => acc.add(p), new THREE.Vector3()).divideScalar(uniquePoints.length);
  
  // Create two orthogonal vectors in the plane
  const planeNormal = normal.clone();
  const tempVec = Math.abs(planeNormal.x) < 0.9 ? new THREE.Vector3(1, 0, 0) : new THREE.Vector3(0, 1, 0);
  const u = new THREE.Vector3().crossVectors(planeNormal, tempVec).normalize();
  const v = new THREE.Vector3().crossVectors(planeNormal, u).normalize();
  
  // Convert to 2D coordinates and sort by angle
  const points2D = uniquePoints.map(p => {
    const relative = new THREE.Vector3().subVectors(p, center);
    return {
      point: p,
      u: relative.dot(u),
      v: relative.dot(v),
      angle: Math.atan2(relative.dot(v), relative.dot(u))
    };
  });
  
  points2D.sort((a, b) => a.angle - b.angle);
  const sortedPoints = points2D.map(p => p.point);
  
  // Create simple polygon (no triangulation issues)
  const vertices = [];
  const indices = [];
  
  // Add center point
  vertices.push(center.x, center.y, center.z);
  
  // Add sorted perimeter points
  for (const point of sortedPoints) {
    vertices.push(point.x, point.y, point.z);
  }
  
  // Create triangles from center to each edge
  for (let i = 0; i < sortedPoints.length; i++) {
    const next = (i + 1) % sortedPoints.length;
    indices.push(0, i + 1, next + 1);
  }
  
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setIndex(indices);
  geometry.computeVertexNormals();
  
  const material = new THREE.MeshBasicMaterial({
    color: typeof color === 'number' ? color : 0x0000ff,
    transparent: true,
    opacity: opacity,
    side: THREE.DoubleSide,
    depthWrite: false,
    depthTest: false
  });
  
  const plane = new THREE.Mesh(geometry, material);
  plane.renderOrder = -1;
  plane.raycast = () => {};
  
  // Store plane data for management
  const planeData = {
    mesh: plane,
    equation: { a, b, c, d },
    color: color,
    opacity: opacity,
    id: Date.now() // Simple unique ID
  };
  
  currentGrid.customPlanes.push(planeData);
  currentGrid.group.add(plane);
  
  // Update plane list UI
  updatePlaneListUI();
  
  console.log(`Added bounded cutting plane: ${a}x + ${b}y + ${c}z = ${d}`);
  return planeData;
}

function removeTransparentPlane(planeId) {
  if (!currentGrid || !currentGrid.customPlanes.length) {
    console.warn("No planes to remove");
    return;
  }
  
  // If no planeId provided, remove all (backward compatibility)
  if (planeId === undefined) {
    while (currentGrid.customPlanes.length > 0) {
      const planeData = currentGrid.customPlanes[0];
      removeTransparentPlane(planeData.id);
    }
    return;
  }
  
  const planeIndex = currentGrid.customPlanes.findIndex(p => p.id === planeId);
  if (planeIndex === -1) {
    console.warn("Plane not found");
    return;
  }
  
  const planeData = currentGrid.customPlanes[planeIndex];
  currentGrid.group.remove(planeData.mesh);
  planeData.mesh.geometry.dispose();
  planeData.mesh.material.dispose();
  
  currentGrid.customPlanes.splice(planeIndex, 1);
  updatePlaneListUI();
  
  console.log("Removed transparent plane");
}

function updatePlaneListUI() {
  if (!currentGrid) return;
  
  // Remove existing list
  const existingList = document.getElementById('planeList');
  if (existingList) existingList.remove();
  
  if (!currentGrid.customPlanes || currentGrid.customPlanes.length === 0) return;
  
  // Create plane list
  const list = document.createElement('div');
  list.id = 'planeList';
  list.style.cssText = `
    margin-top: 8px;
    border-top: 1px solid #556677;
    padding-top: 8px;
    max-height: 120px;
    overflow-y: auto;
  `;
  
  currentGrid.customPlanes.forEach((planeData, index) => {
    const item = document.createElement('div');
    item.className = 'plane-item';
    item.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 4px;
      margin: 2px 0;
      background: rgba(0,0,0,0.2);
      border-radius: 4px;
      font-size: 11px;
      color: #ecf0f1;
    `;
    
    const label = document.createElement('span');
    label.textContent = `${planeData.equation.a}x + ${planeData.equation.b}y + ${planeData.equation.c}z = ${planeData.equation.d}`;
    
    const controls = document.createElement('div');
    controls.style.cssText = 'display: flex; gap: 4px;';
    
    // Visibility toggle
    const visBtn = document.createElement('button');
    visBtn.textContent = planeData.mesh.visible ? 'üëÅ' : 'üëÅ‚Äçüó®';
    visBtn.style.cssText = `
      background: transparent;
      border: none;
      cursor: pointer;
      font-size: 14px;
      padding: 0 4px;
    `;
    visBtn.onclick = () => {
      planeData.mesh.visible = !planeData.mesh.visible;
      updatePlaneListUI();
    };
    
    // Remove button
    const removeBtn = document.createElement('button');
    removeBtn.textContent = '√ó';
    removeBtn.style.cssText = `
      background: #e74c3c;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      padding: 0 6px;
      font-size: 16px;
    `;
    removeBtn.onclick = () => removeTransparentPlane(planeData.id);
    
    controls.appendChild(visBtn);
    controls.appendChild(removeBtn);
    
    item.appendChild(label);
    item.appendChild(controls);
    list.appendChild(item);
  });
  
  // Add to plane controls panel (now in right sidebar)
  const planeBody = document.getElementById('planeBody');
  if (planeBody) {
    planeBody.appendChild(list);
  }
}




//     ====================================================================================================================
// 										  6. DOUBLESWITCH, CANONICAL FORMS, AND RELATED FUNCTIONS
//     ====================================================================================================================

function colorSubgraphComponent(grid, vertexComponent, targetCompId, color = 0x005500) {
  const vertices = new Set();
  for (const [v, c] of vertexComponent.entries()) {
    if (c === targetCompId) vertices.add(v);
  }

  const subgraph = grid.activeSubgraph;
  if (!subgraph) return;

  for (const edgeKey of subgraph.getEdgeKeys()) {
    const [a, b] = edgeKey.split("-");
    if (vertices.has(a) && vertices.has(b)) {
      const edge = grid.edges.get(edgeKey);
      if (!edge) continue;

      grid.group.remove(edge.mesh);

      const newMesh = makeEdgeMesh(
        a.split(",").map(Number),
        b.split(",").map(Number),
        color,
        0.05
      );

      grid.edges.set(edgeKey, { ...edge, color, mesh: newMesh });
      grid.group.add(newMesh);
    }
  }
}


function restoreEdgeColor() {
  if (currentGrid.isInstanced) {
    // For instanced mode, nothing to restore - edges maintain their own state
    return;
  }
  
  // Non-instanced mode only
  for (const [key, edge] of currentGrid.edges.entries()) {
    if (edge.color !== UNCOLORED_COLOR) {
      const [aStr, bStr] = key.split("-");
      const a = aStr.split(",").map(Number);
      const b = bStr.split(",").map(Number);
      currentGrid.group.remove(edge.mesh);
      currentGrid.edges.set(key, {
        ...edge,
        color: selectedColor,
        mesh: makeEdgeMesh(a, b, selectedColor, 0.05)
      });
      currentGrid.group.add(currentGrid.edges.get(key).mesh);
    }
  }
}


function getBorderCandidateBoxes(grid, vertexComponent, subgraph) {
  const allBoxes = [
    ...grid.boxesXY.values(),
    ...grid.boxesXZ.values(),
    ...grid.boxesYZ.values()
  ];

  return allBoxes.filter(box => {
    const includedEdges = box.edges.filter(eKey => subgraph.edges.has(eKey));
    if (includedEdges.length !== 2) return false;

    const [e1, e2] = includedEdges.map(edgeKey => {
      const [a, b] = edgeKey.split("-");
      return [vertexComponent.get(a), vertexComponent.get(b)];
    });

    const components = new Set([...e1, ...e2]);
    return components.size > 1;
  });
}

function getGeneralBorderBoxes(grid, vertexComponent, subgraph) {
  const allBoxes = [
    ...grid.boxesXY.values(),
    ...grid.boxesXZ.values(),
    ...grid.boxesYZ.values()
  ];

  return allBoxes.filter(box => {
    const componentSet = new Set();

    for (const eKey of box.edges) {
      if (!subgraph.edges.has(eKey)) continue;

      const [aStr, bStr] = eKey.split("-");
      componentSet.add(vertexComponent.get(aStr));
      componentSet.add(vertexComponent.get(bStr));
    }

    return componentSet.size > 1;
  });
}

function buildAdjacencyFromEdgeSet(grid, edgeSet) {
  const adj = new Map();
  for (const key of [...edgeSet]) {
    const edge = grid.edges.get(key);
    if (!edge) continue;
    const [aStr, bStr] = key.split("-");
    if (!adj.has(aStr)) adj.set(aStr, []);
    if (!adj.has(bStr)) adj.set(bStr, []);
    adj.get(aStr).push(bStr);
    adj.get(bStr).push(aStr);
  }
  return adj;
}






function getFilteredBoxMeshes() {
  if (!currentGrid) return [];
  
    // INSTRUMENTATION: Check box mesh state
  console.log('[getFilteredBoxMeshes] Box mesh state:', {
    XY_exists: !!currentGrid.instancedBoxesXY,
    XY_visible: currentGrid.instancedBoxesXY?.visible,
    XY_opacity: currentGrid.instancedBoxesXY?.material?.opacity,
    XY_transparent: currentGrid.instancedBoxesXY?.material?.transparent,
    XY_parent: currentGrid.instancedBoxesXY?.parent?.type,
    XZ_exists: !!currentGrid.instancedBoxesXZ,
    XZ_visible: currentGrid.instancedBoxesXZ?.visible,
    XZ_opacity: currentGrid.instancedBoxesXZ?.material?.opacity,
    YZ_exists: !!currentGrid.instancedBoxesYZ,
    YZ_visible: currentGrid.instancedBoxesYZ?.visible,
    YZ_opacity: currentGrid.instancedBoxesYZ?.material?.opacity,
  });
  
  // Get camera direction
  const cameraDirection = new THREE.Vector3();
  camera.getWorldDirection(cameraDirection);
  
  // Determine which axis the camera is most aligned with
  const absX = Math.abs(cameraDirection.x);
  const absY = Math.abs(cameraDirection.y);
  const absZ = Math.abs(cameraDirection.z);
  
  let meshes = [];
  
  if (currentGrid.isInstanced) {
    // Instanced mode - return instanced meshes based on camera direction
    if (absZ > absX && absZ > absY) {
      // Looking mostly in Z direction - include XZ and YZ boxes
      meshes = [currentGrid.instancedBoxesXZ, currentGrid.instancedBoxesYZ].filter(m => m);
    } else if (absY > absX && absY > absZ) {
      // Looking mostly in Y direction - include XY and YZ boxes
      meshes = [currentGrid.instancedBoxesXY, currentGrid.instancedBoxesYZ].filter(m => m);
    } else {
      // Looking mostly in X direction - include XY and XZ boxes
      meshes = [currentGrid.instancedBoxesXY, currentGrid.instancedBoxesXZ].filter(m => m);
    }
  } else {
    // Individual mesh mode
    if (absZ > absX && absZ > absY) {
      // Looking mostly in Z direction - include XZ and YZ boxes (filter out XY)
      meshes = [
        ...Array.from(currentGrid.boxesXZ.values()).map(b => b.mesh),
        ...Array.from(currentGrid.boxesYZ.values()).map(b => b.mesh)
      ].filter(m => m);
    } else if (absY > absX && absY > absZ) {
      // Looking mostly in Y direction - include XY and YZ boxes (filter out XZ)
      meshes = [
        ...Array.from(currentGrid.boxesXY.values()).map(b => b.mesh),
        ...Array.from(currentGrid.boxesYZ.values()).map(b => b.mesh)
      ].filter(m => m);
    } else {
      // Looking mostly in X direction - include XY and XZ boxes (filter out YZ)
      meshes = [
        ...Array.from(currentGrid.boxesXY.values()).map(b => b.mesh),
        ...Array.from(currentGrid.boxesXZ.values()).map(b => b.mesh)
      ].filter(m => m);
    }
  }
  
  return meshes;
}





function highlightBoxes(boxes, color = 0xffff00) {
  console.log('[highlightBoxes] CALLED with', boxes.length, 'boxes');
  
  // Clear any existing highlights
  clearBoxHighlights();
  
  if (boxes.length === 0) return;
  
  // Group boxes by type
  const boxesByType = {
    XY: boxes.filter(b => (b.plane === 'XY' || b.instanceType === 'XY')),
    XZ: boxes.filter(b => (b.plane === 'XZ' || b.instanceType === 'XZ')),
    YZ: boxes.filter(b => (b.plane === 'YZ' || b.instanceType === 'YZ'))
  };
  
  const highlightColor = new THREE.Color(color);
  
  // Create separate instanced meshes for each plane type
  if (boxesByType.XY.length > 0) {
    currentGrid.highlightInstancedBoxesXY = createHighlightInstancedMesh(
      boxesByType.XY, 'XY', highlightColor
    );
    currentGrid.group.add(currentGrid.highlightInstancedBoxesXY);
  }
  
  if (boxesByType.XZ.length > 0) {
    currentGrid.highlightInstancedBoxesXZ = createHighlightInstancedMesh(
      boxesByType.XZ, 'XZ', highlightColor
    );
    currentGrid.group.add(currentGrid.highlightInstancedBoxesXZ);
  }
  
  if (boxesByType.YZ.length > 0) {
    currentGrid.highlightInstancedBoxesYZ = createHighlightInstancedMesh(
      boxesByType.YZ, 'YZ', highlightColor
    );
    currentGrid.group.add(currentGrid.highlightInstancedBoxesYZ);
  }
  
  console.log('[highlightBoxes] Created highlight meshes:', {
    XY: boxesByType.XY.length,
    XZ: boxesByType.XZ.length,
    YZ: boxesByType.YZ.length
  });
}

function createHighlightInstancedMesh(boxes, planeType, color) {
  // Create geometry based on plane type
  let geometry;
  if (planeType === 'XY') {
    geometry = new THREE.BoxGeometry(1, 1, 0.01);
  } else if (planeType === 'XZ') {
    geometry = new THREE.BoxGeometry(1, 0.01, 1);
  } else { // YZ
    geometry = new THREE.BoxGeometry(0.01, 1, 1);
  }
  
  // Create material - yellow, semi-transparent
  const material = new THREE.MeshBasicMaterial({
    color: color,
    opacity: 0.3,
    transparent: true,
    depthTest: false
  });
  
  // Create instanced mesh
  const mesh = new THREE.InstancedMesh(geometry, material, boxes.length);
  
  // Set transforms for each box
  const matrix = new THREE.Matrix4();
  for (let i = 0; i < boxes.length; i++) {
    const box = boxes[i];
    const [x, y, z] = box.coords;
    
    // Position based on plane type
    if (planeType === 'XY') {
      matrix.makeTranslation(x + 0.5, y + 0.5, z);
    } else if (planeType === 'XZ') {
      matrix.makeTranslation(x + 0.5, y, z + 0.5);
    } else { // YZ
      matrix.makeTranslation(x, y + 0.5, z + 0.5);
    }
    
    mesh.setMatrixAt(i, matrix);
  }
  
  mesh.instanceMatrix.needsUpdate = true;
  
  return mesh;
}

function clearBoxHighlights() {
  console.log('[clearBoxHighlights] CALLED');
  
  // Remove and dispose highlight meshes
  if (currentGrid.highlightInstancedBoxesXY) {
    currentGrid.group.remove(currentGrid.highlightInstancedBoxesXY);
    currentGrid.highlightInstancedBoxesXY.geometry.dispose();
    currentGrid.highlightInstancedBoxesXY.material.dispose();
    currentGrid.highlightInstancedBoxesXY = null;
  }
  
  if (currentGrid.highlightInstancedBoxesXZ) {
    currentGrid.group.remove(currentGrid.highlightInstancedBoxesXZ);
    currentGrid.highlightInstancedBoxesXZ.geometry.dispose();
    currentGrid.highlightInstancedBoxesXZ.material.dispose();
    currentGrid.highlightInstancedBoxesXZ = null;
  }
  
  if (currentGrid.highlightInstancedBoxesYZ) {
    currentGrid.group.remove(currentGrid.highlightInstancedBoxesYZ);
    currentGrid.highlightInstancedBoxesYZ.geometry.dispose();
    currentGrid.highlightInstancedBoxesYZ.material.dispose();
    currentGrid.highlightInstancedBoxesYZ = null;
  }
  
  console.log('[clearBoxHighlights] DONE');
}









function labelComponents(adj) {
  const vertexComponent = new Map();
  let compId = 0;
  for (const v of adj.keys()) {
    if (vertexComponent.has(v)) continue;
    const queue = [v];
    vertexComponent.set(v, compId);
    while (queue.length > 0) {
      const u = queue.shift();
      for (const nbr of adj.get(u) || []) {
        if (!vertexComponent.has(nbr)) {
          vertexComponent.set(nbr, compId);
          queue.push(nbr);
        }
      }
    }
    compId++;
  }
  return vertexComponent;
}


function highlightHoveredBox(box) {
  // Reset previous highlight
  clearHoveredBoxHighlight();

  const isHot = isSwitchable(box);

  // Create a temporary highlight mesh
  const [x, y, z] = box.coords;
  let size, center;
  
  if (box.plane === "XY") {
    size = new THREE.Vector3(1, 1, 0.01);
    center = new THREE.Vector3(x + 0.5, y + 0.5, z);
  } else if (box.plane === "XZ") {
    size = new THREE.Vector3(1, 0.01, 1);
    center = new THREE.Vector3(x + 0.5, y, z + 0.5);
  } else if (box.plane === "YZ") {
    size = new THREE.Vector3(0.01, 1, 1);
    center = new THREE.Vector3(x, y + 0.5, z + 0.5);
  }

  const geometry = new THREE.BoxGeometry(size.x, size.y, size.z);
  const material = new THREE.MeshBasicMaterial({
    color: isHot ? 0x00ffff : 0xffff00,
    opacity: 0.8,
    transparent: true,
    depthTest: false
  });

  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.copy(center);
  mesh.userData.box = box;

  currentGrid.group.add(mesh);
  lastHighlighted = mesh;
}

function clearHoveredBoxHighlight() {
  if (lastHighlighted) {
    currentGrid.group.remove(lastHighlighted);
    lastHighlighted.geometry.dispose();
    lastHighlighted.material.dispose();
    lastHighlighted = null;
  }
}


function switchBox(box) {
  const t0 = performance.now();
  
  // Ensure switchMode is synced with global mode
  switchMode = (mode === "switch");
  
  
  // CRITICAL: Cancel any pending async operations to prevent state corruption
  if (currentGrid && currentGrid.highlightDebounceTimer) {
    clearTimeout(currentGrid.highlightDebounceTimer);
    currentGrid.highlightDebounceTimer = null;
  }

  // Step 1: Parse box edges into coords
  const edgePairs = box.edges.map(eKey => {
    const [aStr, bStr] = eKey.split("-");
    const a = aStr.split(",").map(Number);
    const b = bStr.split(",").map(Number);
    return { eKey, a, b };
  });

  // Step 2: Create activeSubgraph if it doesn't exist, or use existing one
  let subgraph = currentGrid.activeSubgraph;
  if (!subgraph) {
    subgraph = new Subgraph(currentGrid);
    for (const [eKey, edge] of currentGrid.edges.entries()) {
      if (edge.color !== UNCOLORED_COLOR) {
        const [aStr, bStr] = eKey.split("-");
        const a = aStr.split(",").map(Number);
        const b = bStr.split(",").map(Number);
        subgraph.edges.add(eKey);
        subgraph.vertices.add(aStr);
        subgraph.vertices.add(bStr);
      }
    }
    currentGrid.activeSubgraph = subgraph;
  }

  const inSubgraph = edgePairs.filter(e => subgraph.hasEdge(e.a, e.b));
  const notInSubgraph = edgePairs.filter(e => !subgraph.hasEdge(e.a, e.b));

  if (inSubgraph.length !== 2 || notInSubgraph.length !== 2) {
    if (!batchMode) console.warn("Box is not switchable ‚Äì requires 2 parallel edges in subgraph.");
    return false;
  }
  
  // SAVE STATE FOR UNDO
  const oldPath = currentGrid.path ? [...currentGrid.path] : [];
  const oldSubgraphEdges = Array.from(subgraph.edges);

  // Step 3: Mutate the subgraph AND sync edge.color immediately
  for (const e of inSubgraph) {
    const eKey = edgeKey(e.a, e.b);
    subgraph.edges.delete(eKey);
    
    const edge = currentGrid.edges.get(eKey);
    if (edge) edge.color = UNCOLORED_COLOR;
    
    const v1 = vertexKey(...e.a);
    const v2 = vertexKey(...e.b);
    if (subgraph.getNeighbors(v1).length === 0) {
      subgraph.vertices.delete(v1);
    }
    if (subgraph.getNeighbors(v2).length === 0) {
      subgraph.vertices.delete(v2);
    }
  }
  
  for (const e of notInSubgraph) {
    const eKey = edgeKey(e.a, e.b);
    subgraph.edges.add(eKey);
    
    const edge = currentGrid.edges.get(eKey);
    if (edge) edge.color = selectedColor;
    
    subgraph.vertices.add(vertexKey(...e.a));
    subgraph.vertices.add(vertexKey(...e.b));
  }

  const t1 = performance.now();
  console.log(`Steps 1-3 (mutation): ${(t1-t0).toFixed(2)}ms`);

  // Skip expensive operations in batch mode
  if (batchMode) {
    const pathVertices = extractPathFromSubgraph(currentGrid.activeSubgraph);
    if (pathVertices.length > 1) {
      currentGrid.path = pathVertices;
      currentPath = pathVertices;
    }
    currentGrid.cycle = currentGrid.activeSubgraph;
    return true;
  }

  // Step 4: Reconstruct path from modified subgraph
  const pathVertices = extractPathFromSubgraph(currentGrid.activeSubgraph);
  if (pathVertices.length > 1) {
    currentGrid.path = pathVertices;
    currentPath = pathVertices;
  }
  
  // RECORD UNDO ACTION
  const newSubgraphEdges = Array.from(subgraph.edges);
  const switchedEdges = box.edges; // All 4 edges of the switch box
  
	// RECORD UNDO ACTION (EFFICIENT VERSION - only store what changed)
	recordAction('SWITCH', {
	  oldPath: oldPath,
	  newPath: currentGrid.path ? [...currentGrid.path] : [],
	  edgesAdded: notInSubgraph.map(e => e.eKey),    // The 2 edges added to subgraph
	  edgesRemoved: inSubgraph.map(e => e.eKey)      // The 2 edges removed from subgraph
	});

	// Clear redo stack
	currentGrid.redoStack = [];


  const t2 = performance.now();
  console.log(`Step 4 (extractPath): ${(t2-t1).toFixed(2)}ms`);

  // Step 5: Apply appropriate coloring
  if (currentGrid.isInstanced) {
    for (const e of edgePairs) {
      const inGraph = subgraph.hasEdge(e.a, e.b);
      const color = inGraph ? selectedColor : UNCOLORED_COLOR;
      const width = inGraph ? 0.05 : 0.015;

      const edge = currentGrid.edges.get(e.eKey);
      if (!edge) continue;
      
      edge.color = color;
      colorEdgeInstanced(currentGrid, e.a, e.b, color, width);
    }
  } else {
    // Individual mesh mode
    for (const e of edgePairs) {
      const inGraph = subgraph.hasEdge(e.a, e.b);
      const color = inGraph ? selectedColor : UNCOLORED_COLOR;
      const width = inGraph ? 0.05 : 0.015;

      const edge = currentGrid.edges.get(e.eKey);
      if (!edge) continue;

      edge.color = color;

      if (edge.mesh) {
        currentGrid.group.remove(edge.mesh);
        edge.mesh.geometry.dispose();
        edge.mesh.material.dispose();
      }
      const newMesh = makeEdgeMesh(e.a, e.b, color, width);
      edge.mesh = newMesh;
      currentGrid.group.add(newMesh);
    }
  }

  const t3 = performance.now();
  console.log(`Step 5 (coloring 4 edges): ${(t3-t2).toFixed(2)}ms`);

  // Step 6: Sync cycle
  currentGrid.cycle = currentGrid.activeSubgraph;


 // Step 7: Update endpoint markers (only for paths, not cycles)
const totalVertices = currentGrid.width * currentGrid.height * currentGrid.depth;
const totalEdges = currentGrid.activeSubgraph.edges.size;

// A cycle has as many edges as vertices, a path has one less
const isCycle = (totalEdges === totalVertices);

if (isCycle) {
  clearEndpointMarkers(currentGrid);
} else {
  updateEndpointMarkers(currentGrid);
}
  
  const t4 = performance.now();
  
  console.log(`Steps 6-7 (cleanup): ${(t4-t3).toFixed(2)}ms`);
  console.log(`Total sync time: ${(t4-t0).toFixed(2)}ms`);


// Step 8: Component coloring (SYNCHRONOUS)
if (componentColoringEnabled) {
  const adj = buildAdjacencyFromEdgeSet(currentGrid, subgraph.getEdgeKeys());
  const vertexComponent = labelComponents(adj);
  const numComponents = new Set(vertexComponent.values()).size;
  
  if (numComponents >= 2) {
    // Multiple components - color by component
    const componentColors = [selectedColor, selectedColor2];
    
    for (const eKey of subgraph.getEdgeKeys()) {
      const [aStr, bStr] = eKey.split("-");
      const a = aStr.split(",").map(Number);
      const b = bStr.split(",").map(Number);
      
      const componentId = vertexComponent.get(aStr);
      const color = componentColors[componentId % componentColors.length];
      
      if (currentGrid.isInstanced) {
        colorEdgeInstanced(currentGrid, a, b, color, 0.05);
      } else {
        colorEdge(currentGrid, a, b, color, 0.05);
      }
    }
    console.log('Component coloring: multiple components');
  } else {
    // Single component - restore uniform coloring
    for (const eKey of subgraph.getEdgeKeys()) {
      const [aStr, bStr] = eKey.split("-");
      const a = aStr.split(",").map(Number);
      const b = bStr.split(",").map(Number);
      
      if (currentGrid.isInstanced) {
        colorEdgeInstanced(currentGrid, a, b, selectedColor, 0.05);
      } else {
        colorEdge(currentGrid, a, b, selectedColor, 0.05);
      }
    }
    console.log('Single component - uniform coloring restored');
  }
}
// Step 9: Box highlighting (ASYNC - only this delayed)
if (boxHighlightingEnabled && currentGrid.isInstanced) {
  if (currentGrid.highlightDebounceTimer) clearTimeout(currentGrid.highlightDebounceTimer);
  
  currentGrid.highlightDebounceTimer = setTimeout(() => {
    clearBoxHighlights();
    
    const adj = buildAdjacencyFromEdgeSet(currentGrid, subgraph.getEdgeKeys());
    const vertexComponent = labelComponents(adj);
    const numComponents = new Set(vertexComponent.values()).size;
    
    if (numComponents >= 2) {
      const borderBoxes = getGeneralBorderBoxes(currentGrid, vertexComponent, subgraph);
      if (borderBoxes.length > 0) {
        highlightBoxes(borderBoxes, 0xffff00);
        currentGrid.highlightedBoxes = borderBoxes;
      }
    } else {
      clearBoxHighlights();
    }
  }, 150);
}


}


function performDoubleSwitch() {
  if (!currentGrid || !currentGrid.activeSubgraph) {
    if (!batchMode) console.warn("No currentGrid or activeSubgraph");
    return false;
  }

  const subgraph = currentGrid.activeSubgraph;

  // Step 1: Collect all boxes
  const allBoxes = [
    ...currentGrid.boxesXY.values(),
    ...currentGrid.boxesXZ.values(),
    ...currentGrid.boxesYZ.values()
  ];

  // Step 2: Choose a random switchable box X
  const switchableBoxes = allBoxes.filter(box => isSwitchable(box, subgraph));
  
  if (switchableBoxes.length === 0) {
    if (!batchMode) console.warn("No switchable boxes found");
    return false;
  }

  const X = switchableBoxes[Math.floor(Math.random() * switchableBoxes.length)];
  switchBox(X);

  // Step 3: Use updated subgraph from switchBox
  const newSubgraph = currentGrid.activeSubgraph;

  // Step 4: Build adjacency and label components (only when needed)
  const adj = buildAdjacencyFromEdgeSet(currentGrid, newSubgraph.edges);
  const vertexComponent = labelComponents(adj);
  const numComponents = new Set(vertexComponent.values()).size;
  
  if (numComponents !== 2) {
    if (!batchMode) console.warn("Not exactly two components after first switch");
    return false;
  }

  // Step 5: Get border candidates
  const borderCandidates = getBorderCandidateBoxes(currentGrid, vertexComponent, newSubgraph);
  
  if (borderCandidates.length === 0) {
    if (!batchMode) console.warn("No border candidate boxes found");
    return false;
  }

  // Step 6: Do second switch
  const Y = borderCandidates[Math.floor(Math.random() * borderCandidates.length)];
  switchBox(Y);

  return true;
}




//     ====================================================================================================================
// 										    6.¬Ω. MODE AND OTHER GENERAL UI HELPER FUNCTIONS
//     ====================================================================================================================


// Mode management helper function
function setMode(newMode) {
  const oldMode = mode;
  mode = newMode;
  
  // Update UI button states
  updateModeButtonStates();
  
  console.log(`Mode changed from "${oldMode}" to "${newMode}"`);
}

// Helper function to disable switch/backbite modes when editing functions are activated
function disableSwitchBackbiteModes() {
  if (mode === "switch") {
    mode = "default";
    switchMode = false;
    clearBoxHighlights();
    
    // Show original box meshes again when leaving switch mode
    if (currentGrid) {
      currentGrid.instancedBoxesXY.visible = true;
      currentGrid.instancedBoxesXZ.visible = true;
      currentGrid.instancedBoxesYZ.visible = true;
    }
    
    // Update switch pill UI
    const switchPill = document.getElementById("switchPill");
    if (switchPill) switchPill.classList.remove("active");
  } else if (mode === "backbite") {
    mode = "default";
    
    // Update backbite pill UI
    const backbitePill = document.getElementById("backbitePill");
    if (backbitePill) backbitePill.classList.remove("active");
  }
  
  updateGlobalUI();
}

// Helper function to disable editing modes when switch/backbite are activated
function disableEditingModes() {
  const editingModes = ["addEdge", "addVertex", "addDecoration", "addCube"];
  if (editingModes.includes(mode)) {
    mode = "default";
    updateModeButtonStates();
  }
}


function updateModeButtonStates() {
  // Remove active class from all mode buttons
  const modeButtons = [
    'toggleClickBtn',   // addEdge
    'verticesBtn',      // addVertex
    'decorationBtn',    // addDecoration
    'switchBtn',        // switch  
    'backbiteBtn',      // backbite
    'cubeBtn'           // addCube - ADD THIS
  ];
  
  modeButtons.forEach(buttonId => {
    const button = document.getElementById(buttonId);
    if (button) button.classList.remove('active');
  });
  
  // Add active class to current mode button
  switch(mode) {
    case 'addEdge':
      document.getElementById('toggleClickBtn')?.classList.add('active');
      break;
    case 'addVertex':
      document.getElementById('verticesBtn')?.classList.add('active');
      break;
    case 'addDecoration':
      document.getElementById('decorationBtn')?.classList.add('active');
      break;
    case 'switch':
      document.getElementById('switchPill')?.classList.add('active');
      break;
    case 'backbite':
      document.getElementById('backbitePill')?.classList.add('active');
      break;
    case 'addCube':  // ADD THIS CASE
      document.getElementById('cubeBtn')?.classList.add('active');
      break;
    default:
      break;
  }
}













//     ====================================================================================================================
// 										    7. EVENT LISTENERS AND SETUP
//     ====================================================================================================================

// Group 1: Path/Cycle Operations
document.getElementById("genPathBtn").addEventListener("click", generatePath);

document.getElementById("genCycleBtn").addEventListener("click", generateCycleFromPath);

document.getElementById("checkHamBtn").onclick = checkHamiltonianCombined;


document.getElementById("gradientCheckbox").addEventListener("change", (e) => {
  gradientMode = e.target.checked;
  
  if (gradientMode && currentGrid && currentGrid.path && currentGrid.path.length > 1) {
    applyGradientToPath();
  } else if (!gradientMode && currentGrid && currentGrid.activeSubgraph && currentGrid.path && currentGrid.path.length > 1) {
    // Store arrow information by going through PATH (not subgraph edges)
    const arrowInfo = [];
    const path = currentGrid.path;
    
    for (let i = 0; i < path.length - 1; i++) {
      const a = path[i].split(',').map(Number);
      const b = path[i + 1].split(',').map(Number);
      const eKey = edgeKey(a, b);
      const edge = currentGrid.edges.get(eKey);
      
      if (edge && edge.arrows) {
        arrowInfo.push({
          a: a,
          b: b,
          direction: edge.arrows.direction,
          eKey: eKey
        });
      }
    }
    
    // Recolor edges to single color
    updateEdgeMeshesFromSubgraph(currentGrid, currentGrid.activeSubgraph);
    
    // Re-add arrows AFTER recoloring - in path order with correct a,b coordinates
    for (const info of arrowInfo) {
      const edge = currentGrid.edges.get(info.eKey);
      if (edge) {
        addArrowsToEdge(edge, info.direction, info.a, info.b);
      }
    }
  }
});

document.getElementById("arrowCheckbox").addEventListener("change", (e) => {
 console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
 console.log('ARROW TOGGLE CLICKED');
 console.log('arrowMode BEFORE toggle:', arrowMode);
 
 arrowMode = e.target.checked;
 
 console.log('arrowMode AFTER toggle:', arrowMode);
 
 if (!currentGrid) {
   console.log('ERROR: No current grid');
   return;
 }
 
 console.log('Grid isInstanced:', currentGrid.isInstanced);
 
 if (arrowMode) {
   console.log('‚Üí TURNING ARROWS ON');
   
   // Use addDirectionalArrowsToPath if we have a path
   if (currentGrid.path && currentGrid.path.length > 1) {
     addDirectionalArrowsToPath(currentGrid.path);
   }
 } else {
   console.log('‚Üí TURNING ARROWS OFF');
   
   // CORRECT way to remove arrows (works for both modes)
   let removedCount = 0;
   for (const [key, edge] of currentGrid.edges.entries()) {
     if (edge.arrows) {
       removeArrowsFromEdge(edge);  // ‚Üê Use the proper removal function!
       removedCount++;
     }
   }
   console.log('Removed', removedCount, 'arrows');
 }
 
 console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
});

// Group 2: Display Options
document.getElementById('toggleGridCheckbox').addEventListener('change', (e) => {
  toggleUnderlyingGrid();
});

document.getElementById("coordCheckbox").addEventListener("change", (e) => {
  toggleCoordinateAxes();
});

document.getElementById("gridOpacitySlider").addEventListener("input", (e) => {
  const opacity = parseFloat(e.target.value);
  document.getElementById("opacityValue").textContent = Math.round(opacity * 100) + "%";
  
  if (!currentGrid) return;
  
  if (currentGrid.isInstanced) {
    // Instanced rendering mode - update colors for all uncolored edges
    const grayValue = opacity < 1 ? Math.floor(0x88 * opacity) : 0x88;
    const simulatedColor = (grayValue << 16) | (grayValue << 8) | grayValue;
    const color = new THREE.Color(simulatedColor);
    
    for (const [eKey, edge] of currentGrid.edges.entries()) {
      if (edge.color === UNCOLORED_COLOR) {
        const mapping = currentGrid.edgeToInstanceMap.get(eKey);
        if (mapping) {
          currentGrid.instancedEdgesThin.setColorAt(mapping.thin, color);
        }
      }
    }
    
    currentGrid.instancedEdgesThin.instanceColor.needsUpdate = true;
    
  } else {
    // Individual mesh mode
    for (const edge of currentGrid.edges.values()) {
      if (edge.color === UNCOLORED_COLOR && edge.mesh) {
        if (opacity < 1) {
          // Create a new material that forces opaque rendering
          const newMaterial = edge.mesh.material.clone();
          newMaterial.transparent = false;  // Lie to Three.js about transparency
          newMaterial.opacity = 1;
          
          // Manually blend the color with background to simulate transparency
          const grayValue = Math.floor(0x88 * opacity);
          const simulatedColor = (grayValue << 16) | (grayValue << 8) | grayValue;
          newMaterial.color.setHex(simulatedColor);
          
          edge.mesh.material = newMaterial;
        } else {
          // Restore original opaque material
          edge.mesh.material.transparent = false;
          edge.mesh.material.opacity = 1;
          edge.mesh.material.color.setHex(0x888888);
        }
        
        edge.mesh.material.needsUpdate = true;
      }
    }
  }
});


document.getElementById("backgroundSelect").addEventListener("change", (e) => {
  const value = e.target.value;
  
  // Check if it's a hex color (old system) or theme name (new system)
  if (value.startsWith('0x')) {
    // Old system: hex color value
    const colorHex = parseInt(value, 16);
    updateTheme(colorHex);
  } else {
    // New system: theme name
    updateTheme(value);
  }
});

// Generate panel collapse/expand functionality
document.addEventListener('DOMContentLoaded', function() {
  const genHeader = document.getElementById('genHeader');
  const genBody = document.getElementById('genBody');
  const genCaret = document.getElementById('genCaret');
  
  if (genHeader && genBody && genCaret) {
    let genOpen = true;
    
    function updateGenPanel() {
      if (genOpen) {
        genBody.classList.remove('collapsed');
        genCaret.textContent = '‚ñ¥';
      } else {
        genBody.classList.add('collapsed');
        genCaret.textContent = '‚ñæ';
      }
    }
    
    genHeader.addEventListener('click', () => {
      genOpen = !genOpen;
      updateGenPanel();
    });
    
    updateGenPanel();
  }
  
  // BB Distance panel collapse/expand functionality
  const bbHeader = document.getElementById('bbHeader');
  const bbBody = document.getElementById('bbBody');
  const bbCaret = document.getElementById('bbCaret');
  
  if (bbHeader && bbBody && bbCaret) {
    let bbOpen = false;
    
    function updateBBPanel() {
      if (bbOpen) {
        bbBody.classList.remove('collapsed');
        bbCaret.textContent = '‚ñ¥';
      } else {
        bbBody.classList.add('collapsed');
        bbCaret.textContent = '‚ñæ';
      }
    }
    
    bbHeader.addEventListener('click', () => {
      bbOpen = !bbOpen;
      updateBBPanel();
    });
    
    updateBBPanel();
  }
  
  // Plane panel collapse/expand functionality for right sidebar
  const planeHeader = document.getElementById('planeHeader');
  const planeBody = document.getElementById('planeBody');
  const planeCaret = document.getElementById('planeCaret');
  
  if (planeHeader && planeBody && planeCaret) {
    let planeOpen = false;
    
    function updatePlanePanel() {
      if (planeOpen) {
        planeBody.classList.remove('collapsed');
        planeCaret.textContent = '‚ñ¥';
      } else {
        planeBody.classList.add('collapsed');
        planeCaret.textContent = '‚ñæ';
      }
    }
    
    planeHeader.addEventListener('click', () => {
      planeOpen = !planeOpen;
      updatePlanePanel();
    });
    
    updatePlanePanel();
  }
  
// Notes button handler
  const notesBtn = document.getElementById('notesBtn');
  if (notesBtn) {
    notesBtn.addEventListener('click', () => {
      const notesWindow = document.getElementById('notesWindow');
      if (notesWindow) {
        if (notesWindow.style.display === 'block') {
          // Close notes
          saveCurrentGridNotes();
          notesWindow.style.display = 'none';
        } else {
          // Open notes
          notesWindow.style.display = 'block';
          initQuillEditor();
          updateNotesForCurrentGrid();
          setTimeout(() => { if (quillEditor) quillEditor.focus(); }, 50);
        }
      }
    });
  }
  
  // Coordinate hover checkbox handler
  const coordHoverCheckbox = document.getElementById('coordinateHoverCheckbox');
  const relativeCoordRow = document.getElementById('relativeCoordRow');
  const relativeCheckbox = document.getElementById('relativeCoordinatesCheckbox');
  
  if (coordHoverCheckbox && relativeCoordRow && relativeCheckbox) {
    coordHoverCheckbox.addEventListener('change', () => {
      if (coordHoverCheckbox.checked) {
        relativeCoordRow.classList.remove('disabled');
        relativeCoordRow.removeAttribute('title');
        relativeCheckbox.disabled = false;
      } else {
        relativeCoordRow.classList.add('disabled');
        relativeCoordRow.setAttribute('title', "Enable 'Coordinate Hover' first to use this feature");
        relativeCheckbox.disabled = true;
        relativeCheckbox.checked = false;
      }
    });
  }
  
  // Sidebar toggle functionality
  const leftSidebar = document.querySelector('.sidebar');
  const rightSidebar = document.querySelector('.sidebar-right');
  const leftToggle = document.getElementById('leftSidebarToggle');
  const rightToggle = document.getElementById('rightSidebarToggle');
  
  if (leftToggle && leftSidebar) {
    leftToggle.addEventListener('click', () => {
      leftSidebar.classList.toggle('collapsed');
      leftToggle.classList.toggle('sidebar-collapsed');
      // Change chevron direction
      const path = leftToggle.querySelector('path');
      if (path) {
        path.setAttribute('d', leftSidebar.classList.contains('collapsed') ? 'M3 6 L8 12 L3 18' : 'M9 6 L4 12 L9 18');
      }
    });
  }
  
  if (rightToggle && rightSidebar) {
    rightToggle.addEventListener('click', () => {
      rightSidebar.classList.toggle('collapsed');
      rightToggle.classList.toggle('sidebar-collapsed');
      // Change chevron direction
      const path = rightToggle.querySelector('path');
      if (path) {
        path.setAttribute('d', rightSidebar.classList.contains('collapsed') ? 'M9 6 L4 12 L9 18' : 'M3 6 L8 12 L3 18');
      }
    });
  }
  
// Color swatch and label click functionality
  const colorDisks = document.querySelectorAll('.color-swatches .color-disk');
  const colorInput = document.getElementById('colorInput');
  const colorInput2 = document.getElementById('colorInput2');
  const colorInput1Wrapper = colorInput?.parentElement;
  const colorInput2Wrapper = colorInput2?.parentElement;
  const mainColorLabel = document.getElementById('mainColorLabel');
  const secondColorLabel = document.getElementById('secondColorLabel');
  
  // Set initial active state
  if (colorInput1Wrapper) {
    colorInput1Wrapper.classList.add('active');
  }
  
  // Label click handlers
  if (mainColorLabel && colorInput1Wrapper && colorInput2Wrapper) {
    mainColorLabel.addEventListener('click', () => {
      activeColorTarget = 'main';
      colorInput1Wrapper.classList.add('active');
      colorInput2Wrapper.classList.remove('active');
    });
  }
  
  if (secondColorLabel && colorInput1Wrapper && colorInput2Wrapper) {
    secondColorLabel.addEventListener('click', () => {
      activeColorTarget = 'second';
      colorInput2Wrapper.classList.add('active');
      colorInput1Wrapper.classList.remove('active');
    });
  }
  
  // Color disk click handlers
  if (colorDisks && colorInput && colorInput2) {
    colorDisks.forEach(disk => {
      disk.addEventListener('click', (e) => {
        const color = e.target.getAttribute('data-color');
        if (color) {
          if (activeColorTarget === 'second') {
            colorInput2.value = color;
            colorInput2.dispatchEvent(new Event('change'));
          } else {
            colorInput.value = color;
            colorInput.dispatchEvent(new Event('change'));
          }
        }
      });
    });
  }
  // Pills are handled by their specific event handlers below
  // (switchPill, backbitePill, gradientPill handlers manage both visual and functional state)
});

// Theme update function for sidebar and topbar
function updateTheme(themeValue, overrideBackground = null) {
  const root = document.documentElement;
  
  // Remove all theme classes
  root.classList.remove('dark-theme', 'warm-light-theme', 'mist-blue-theme', 'paper-white-theme', 'sandstone-theme');
  
  // Determine theme based on value
  let theme = 'light';
  let colorHex = 0xf7f5e9; // default gradient start
  
  if (typeof themeValue === 'string') {
    // New system: theme name
    theme = themeValue;
    switch(themeValue) {
      case 'dark':
        root.classList.add('dark-theme');
        colorHex = 0x000000;
        break;
      case 'warm-light':
        root.classList.add('warm-light-theme');
        colorHex = 0xFFFDF9;
        break;
      case 'mist-blue':
        root.classList.add('mist-blue-theme');
        colorHex = 0xF8FBFF;
        break;
      case 'paper-white':
        root.classList.add('paper-white-theme');
        colorHex = 0xFFFFFF;
        break;
      case 'sandstone':
        root.classList.add('sandstone-theme');
        colorHex = 0xFEFEFD;
        break;
      case 'light':
      default:
        // Contrast 1 theme (no additional class needed)
        colorHex = 0xf7f5e9;
        break;
    }
  } else {
    // Old system: hex color value (for backward compatibility)
    if (themeValue === 0x000000 || themeValue < 0x808080) {
      root.classList.add('dark-theme');
      theme = 'dark';
      colorHex = 0x000000;
    } else {
      theme = 'light';
      colorHex = 0xf7f5e9;
    }
  }
  
  // Apply background override if specified
  if (overrideBackground && overrideBackground !== 'theme-default') {
    switch(overrideBackground) {
      case 'beige':
        colorHex = 0xFAFBFC; // Beige from old minimal-light
        break;
      case 'light-gradient':
        colorHex = 0xf7f5e9;
        break;
      case 'warm-gradient':
        colorHex = 0xFFFDF9;
        break;
      case 'mist-gradient':
        colorHex = 0xF8FBFF;
        break;
      case 'white':
        colorHex = 0xFFFFFF;
        break;
      case 'black':
        colorHex = 0x000000;
        break;
      case 'custom':
        // Custom color will be handled separately
        const customColor = document.getElementById('customBgColor');
        if (customColor) {
          colorHex = parseInt(customColor.value.replace('#', ''), 16);
        }
        break;
    }
  }
  
  // Update scene background
  if (typeof scene !== 'undefined' && scene.background) {
    scene.background = new THREE.Color(colorHex);
  }
  
  // Set grid opacity based on theme
  const opacitySlider = document.getElementById("gridOpacitySlider");
  const opacityValue = document.getElementById("opacityValue");
  
  if (opacitySlider && opacityValue) {
    if (theme === 'dark') {
      opacitySlider.value = "0.3";
      opacityValue.textContent = "30%";
    } else {
      opacitySlider.value = "1.0";
      opacityValue.textContent = "100%";
    }
    opacitySlider.dispatchEvent(new Event('input'));
  }
  
  // Adjust coordinate label visibility
  adjustCoordinateLabelColors(colorHex);
  
  return theme;
}




// Group 4: Grid Management
document.getElementById("addGridBtn").addEventListener("click", addGrid);

function updateAddGridSymbolColor() {
  const symbol = document.getElementById("addGridSymbol");
  if (symbol) {
    const colorHex = "#" + selectedColor.toString(16).padStart(6, '0');
    symbol.style.color = colorHex;
  }
}


document.getElementById("duplicateBtn").addEventListener("click", duplicateCurrentGrid);



// Initialize color interface
function initializeColorInterface() {
  updateColorInterfaceState();
  
  // Main color section click handlers
  document.getElementById('mainColorLabel').addEventListener('click', () => setActiveColor('main'));
  document.getElementById('colorInput').addEventListener('click', () => setActiveColor('main'));
  document.getElementById('colorInput').addEventListener('input', handleColorInputChange);
  
  // Second color section click handlers  
  document.getElementById('secondColorLabel').addEventListener('click', () => setActiveColor('second'));
  document.getElementById('colorInput2').addEventListener('click', () => setActiveColor('second'));
  document.getElementById('colorInput2').addEventListener('input', handleColorInputChange);
  
  // Shared color circles
  document.querySelectorAll('.color-disk').forEach(disk => {
    disk.addEventListener('click', (e) => {
      const color = e.target.getAttribute('data-color');
      const colorHex = parseInt(color.replace("#", "0x"), 16);
      
      if (activeColorTarget === 'main') {
        selectedColor = colorHex;
        document.getElementById("colorInput").value = color;
      } else {
        selectedColor2 = colorHex;
        document.getElementById("colorInput2").value = color;
      }
      
      updateAddGridSymbolColor();
      
      if (gradientMode && currentGrid && currentGrid.path && currentGrid.path.length > 1) {
        applyGradientToPath();
      }
    });
  });
}

function setActiveColor(target) {
  activeColorTarget = target;
  updateColorInterfaceState();
  console.log(`Active color switched to: ${target}`);
}

function updateColorInterfaceState() {
  const mainLabel = document.getElementById('mainColorLabel');
  const secondLabel = document.getElementById('secondColorLabel');
  const mainInput = document.getElementById('colorInput');
  const secondInput = document.getElementById('colorInput2');
  
  if (activeColorTarget === 'main') {
    // Main active
    mainLabel.className = 'color-label-active';
    secondLabel.className = 'color-label-inactive';
    mainInput.className = 'color-input-active';
    secondInput.className = 'color-input-inactive';
  } else {
    // Second active
    mainLabel.className = 'color-label-inactive';
    secondLabel.className = 'color-label-active';
    mainInput.className = 'color-input-inactive';
    secondInput.className = 'color-input-active';
  }
}

function handleColorInputChange(e) {
  const colorHex = parseInt(e.target.value.replace("#", "0x"), 16);
  
  if (e.target.id === 'colorInput') {
    setActiveColor('main');
    selectedColor = colorHex;
  } else if (e.target.id === 'colorInput2') {
    setActiveColor('second');
    selectedColor2 = colorHex;
  }
  
  updateAddGridSymbolColor();
  
  if (gradientMode && currentGrid && currentGrid.path && currentGrid.path.length > 1) {
    applyGradientToPath();
  }
}


// Global Event Listeners
window.addEventListener("click", onClick);
window.addEventListener("mousemove", onMouseMove);

// Add mousedown event listener
window.addEventListener("mousedown", onMouseDown);
window.addEventListener("mouseup", onMouseUp);

// Warn users before closing if they have unsaved work
window.addEventListener("beforeunload", (e) => {
  // Only show warning if:
  // 1. There are grids to save
  // 2. User hasn't just saved (within last 2 seconds)
  const timeSinceLastSave = lastSaveTime ? Date.now() - lastSaveTime : Infinity;
  const justSaved = timeSinceLastSave < 2000; // 2 seconds grace period
  
  if (allGrids.size > 0 && !justSaved) {
    // Modern browsers ignore custom messages, but setting returnValue triggers the dialog
    e.preventDefault();
    e.returnValue = ''; // Required for Chrome
    return ''; // For older browsers
  }
});




// Modes
document.getElementById("toggleClickBtn").addEventListener("click", () => {
  disableSwitchBackbiteModes();
  const newMode = mode === "addEdge" ? "default" : "addEdge";
  setMode(newMode);
});

document.getElementById("verticesBtn").addEventListener("click", () => {
  disableSwitchBackbiteModes();
  const newMode = mode === "addVertex" ? "default" : "addVertex";
  setMode(newMode);
});

document.getElementById("decorationBtn").addEventListener("click", () => {
  disableSwitchBackbiteModes();
  const newMode = mode === "addDecoration" ? "default" : "addDecoration";
  setMode(newMode);
});


document.getElementById("switchPill").addEventListener("click", () => {
  // Disable any active editing modes
  disableEditingModes();
  
  // Auto-disable gradient and backbite if active
  if (gradientMode) {
    gradientMode = false;
    const gradientCheckbox = document.getElementById("gradientCheckbox");
    if (gradientCheckbox) gradientCheckbox.checked = false;
    
    
    if (currentGrid && currentGrid.activeSubgraph) {
      updateEdgeMeshesFromSubgraph(currentGrid, currentGrid.activeSubgraph);
    }
  }
  
  if (mode === "switch") {
    mode = "default";
    switchMode = false;
    clearBoxHighlights();
    
    // Show original box meshes again when leaving switch mode
    if (currentGrid) {
      currentGrid.instancedBoxesXY.visible = true;
      currentGrid.instancedBoxesXZ.visible = true;
      currentGrid.instancedBoxesYZ.visible = true;
    }
  } else {
    mode = "switch";
    switchMode = true;
    
    // Hide original box meshes - they're only for raycasting now
    if (currentGrid) {
      currentGrid.instancedBoxesXY.visible = false;
      currentGrid.instancedBoxesXZ.visible = false;
      currentGrid.instancedBoxesYZ.visible = false;
    }
    
    // Instanced boxes are already created during grid initialization
    // No on-demand creation needed!
    
    if (currentGrid && currentGrid.activeSubgraph) {
      const adj = buildAdjacencyFromEdgeSet(currentGrid, currentGrid.activeSubgraph.getEdgeKeys());
      const vertexComponent = labelComponents(adj);
      const numComponents = new Set(vertexComponent.values()).size;
      if (numComponents >= 2) {
        const borderBoxes = getGeneralBorderBoxes(currentGrid, vertexComponent, currentGrid.activeSubgraph);
        highlightBoxes(borderBoxes, 0xffff00);
        currentGrid.highlightedBoxes = borderBoxes;
      }
    }
  }
  
  updateGlobalUI();
});




document.getElementById("backbitePill").addEventListener("click", () => {
  // Disable any active editing modes
  disableEditingModes();
  
  // Auto-disable switch mode if active
  const newMode = mode === "backbite" ? "default" : "backbite";
  setMode(newMode);
  updateGlobalUI();
});

document.getElementById("cubeBtn").addEventListener("click", () => {
  disableSwitchBackbiteModes();
  const newMode = mode === "addCube" ? "default" : "addCube";
  setMode(newMode);
});


// Add with your other event listeners
document.getElementById("addLayerBtn").addEventListener("click", (event) => {
  disableSwitchBackbiteModes();
  showAddLayerMenu(event);
});
document.getElementById("removeLayerBtn").addEventListener("click", (event) => {
  disableSwitchBackbiteModes();
  showRemoveLayerMenu(event);
});

function showAddLayerMenu(event) {
  const options = [
    { label: "X+ (far)", value: "x+" },
    { label: "X- (near)", value: "x-" },
    { label: "Y+ (far)", value: "y+" }, 
    { label: "Y- (near)", value: "y-" },
    { label: "Z+ (far)", value: "z+" },
    { label: "Z- (near)", value: "z-" }
  ];
  
  showLayerMenu(event, options, expandCurrentGrid);
}

function showRemoveLayerMenu(event) {
  if (!currentGrid) {
    alert("No grid to modify");
    return;
  }
  
  const options = [
    { label: "X+ (far)", value: "x+", enabled: canRemoveLayer("x+") },
    { label: "X- (near)", value: "x-", enabled: canRemoveLayer("x-") },
    { label: "Y+ (far)", value: "y+", enabled: canRemoveLayer("y+") },
    { label: "Y- (near)", value: "y-", enabled: canRemoveLayer("y-") },
    { label: "Z+ (far)", value: "z+", enabled: canRemoveLayer("z+") },
    { label: "Z- (near)", value: "z-", enabled: canRemoveLayer("z-") }
  ];
  
  showLayerMenu(event, options, (direction) => {
    if (canRemoveLayer(direction)) {
      removeLayer(direction);
    } else {
      alert("Cannot remove layer: contains colored edges");
    }
  });
}

function showLayerMenu(event, options, callback) {
  // Remove existing menu
  const existingMenu = document.getElementById('layerMenu');
  if (existingMenu) existingMenu.remove();
  
  // Create menu
  const menu = document.createElement('div');
  menu.id = 'layerMenu';
  menu.style.cssText = `
    position: absolute;
    background: white;
    border: 1px solid #ccc;
    border-radius: 4px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    z-index: 1000;
    min-width: 120px;
  `;
  
  // Position menu near button
  const rect = event.target.getBoundingClientRect();
  menu.style.left = (rect.right + 5) + 'px';
  menu.style.top = rect.top + 'px';
  
  // Add options
  options.forEach(option => {
    const item = document.createElement('div');
    item.textContent = option.label;
    item.style.cssText = `
      padding: 8px 12px;
      cursor: ${option.enabled !== false ? 'pointer' : 'not-allowed'};
      color: ${option.enabled !== false ? '#333' : '#999'};
    `;
    
    if (option.enabled !== false) {
      item.style.cssText += 'hover: background: #f0f0f0;';
      item.addEventListener('click', () => {
        callback(option.value);
        menu.remove();
      });
    }
    
    menu.appendChild(item);
  });
  
  document.body.appendChild(menu);
  
  // Close menu on outside click
  setTimeout(() => {
    document.addEventListener('click', function closeMenu(e) {
      if (!menu.contains(e.target)) {
        menu.remove();
        document.removeEventListener('click', closeMenu);
      }
    });
  }, 10);
}




// Add these with your other event listeners
document.getElementById("saveBtn").addEventListener("click", saveGrid);
document.getElementById("loadBtn").addEventListener("click", loadGridFromDisk);

// Help dropdown functionality
document.getElementById("helpBtn").addEventListener("click", (e) => {
  e.stopPropagation();
  const dropdown = document.getElementById("helpDropdown");
  dropdown.classList.toggle("show");
});

// Help menu item handlers
document.querySelectorAll('.help-menu-item').forEach(item => {
  item.addEventListener('click', (e) => {
    const action = e.target.getAttribute('data-action');
    const dropdown = document.getElementById("helpDropdown");
    dropdown.classList.remove("show");
    
    if (action === 'about') {
      document.getElementById("aboutModal").style.display = "flex";
    } else if (action === 'shortcuts') {
      document.getElementById("keyboardShortcutsModal").style.display = "flex";
    }
    // README is now handled by the second event listener which opens in new tab
  });
});

// Close dropdown when clicking outside
document.addEventListener('click', (e) => {
  const helpDropdown = document.getElementById("helpDropdown");
  const helpBtn = document.getElementById("helpBtn");
  if (helpDropdown && !helpDropdown.contains(e.target) && e.target !== helpBtn) {
    helpDropdown.classList.remove("show");
  }
});


// Preferences Modal handlers
document.getElementById("preferencesBtn").addEventListener("click", () => {
  // Load current preferences into the modal
  document.getElementById("componentColoringCheckbox").checked = componentColoringEnabled;
  document.getElementById("boxHighlightingCheckbox").checked = boxHighlightingEnabled;
  document.getElementById("hoverVerticesCheckbox").checked = hoverVertices;
  document.getElementById("hoverEdgesCheckbox").checked = hoverEdges;
  
  // Load camera sensitivity preferences
  const cameraSensitivitySlider = document.getElementById("cameraSensitivitySlider");
  const cameraSensitivityValue = document.getElementById("cameraSensitivityValue");
  const showCameraSensitivityCheckbox = document.getElementById("showCameraSensitivityCheckbox");
  
  if (cameraSensitivitySlider && cameraSensitivityValue) {
    cameraSensitivitySlider.value = cameraSensitivity;
    cameraSensitivityValue.textContent = cameraSensitivity.toFixed(1);
  }
  
  if (showCameraSensitivityCheckbox) {
    showCameraSensitivityCheckbox.checked = showCameraSensitivityInMain;
  }
  
  // Load 2D camera mode preference
  const use2DCameraModeCheckbox = document.getElementById("use2DCameraModeCheckbox");
  if (use2DCameraModeCheckbox) {
    use2DCameraModeCheckbox.checked = use2DCameraMode;
  }
  
  // Load show all vertices preference
  const showAllVerticesCheckbox = document.getElementById("showAllVerticesCheckbox");
  if (showAllVerticesCheckbox) {
    showAllVerticesCheckbox.checked = showAllVertices;
  }
  
  // Update theme button states
  const backgroundSelect = document.getElementById("backgroundSelect");
  const themeSelect = document.getElementById("themeSelect");
  
  // Get current theme
  let currentTheme = 'paper-white';
  if (backgroundSelect) {
    const value = backgroundSelect.value;
    if (value.startsWith('0x')) {
      // Old system
      currentTheme = (parseInt(value, 16) === 0x000000) ? 'dark' : 'light';
    } else {
      // New system
      currentTheme = value;
    }
  }
  
  // Set dropdown to current theme
  if (themeSelect) {
    themeSelect.value = currentTheme;
  }
  
  // Show modal
  document.getElementById("preferencesModal").style.display = "flex";
  console.log("Preferences modal opened");
});

// Theme dropdown handler
const themeSelect = document.getElementById('themeSelect');
const backgroundOverrideSelect = document.getElementById('backgroundOverrideSelect');
const customBackgroundPicker = document.getElementById('customBackgroundPicker');
const customBgColor = document.getElementById('customBgColor');

if (themeSelect) {
  themeSelect.addEventListener('change', () => {
    const selectedTheme = themeSelect.value;
    const backgroundOverride = backgroundOverrideSelect ? backgroundOverrideSelect.value : 'theme-default';
    
    // Update hidden background select for compatibility
    const backgroundSelect = document.getElementById('backgroundSelect');
    if (backgroundSelect) {
      backgroundSelect.value = selectedTheme;
    }
    
    // Apply theme with background override
    updateTheme(selectedTheme, backgroundOverride);
  });
}

// Background override dropdown handler
if (backgroundOverrideSelect) {
  backgroundOverrideSelect.addEventListener('change', () => {
    const selectedBg = backgroundOverrideSelect.value;
    
    // Show/hide custom color picker
    if (customBackgroundPicker) {
      customBackgroundPicker.style.display = selectedBg === 'custom' ? 'block' : 'none';
    }
    
    // Apply theme with new background
    const currentTheme = themeSelect ? themeSelect.value : 'light';
    updateTheme(currentTheme, selectedBg);
  });
}

// Custom background color picker handler
if (customBgColor) {
  customBgColor.addEventListener('change', () => {
    const currentTheme = themeSelect ? themeSelect.value : 'light';
    updateTheme(currentTheme, 'custom');
  });
}

document.getElementById("savePreferencesBtn").addEventListener("click", () => {
  // Save preferences from checkboxes
  componentColoringEnabled = document.getElementById("componentColoringCheckbox").checked;
  boxHighlightingEnabled = document.getElementById("boxHighlightingCheckbox").checked;
  hoverVertices = document.getElementById("hoverVerticesCheckbox").checked;
  hoverEdges = document.getElementById("hoverEdgesCheckbox").checked;
  
  // Save camera sensitivity preferences
  cameraSensitivity = parseFloat(document.getElementById("cameraSensitivitySlider").value);
  showCameraSensitivityInMain = document.getElementById("showCameraSensitivityCheckbox").checked;
  use2DCameraMode = document.getElementById("use2DCameraModeCheckbox").checked;
  showAllVertices = document.getElementById("showAllVerticesCheckbox").checked;
  
// Update controls rotate speed and zoom speed
  if (typeof controls !== 'undefined') {
    controls.rotateSpeed = cameraSensitivity;
    controls.zoomSpeed = 0.5 * cameraSensitivity;
  }
  
  // Apply 2D camera mode immediately if current grid is 2D
  if (currentGrid) {
    const is2D = currentGrid.width === 1 || currentGrid.height === 1 || currentGrid.depth === 1;
    if (is2D && typeof controls !== 'undefined') {
      if (use2DCameraMode) {
        // Enable 2D mode: pan/zoom only, no rotation
        controls.enableRotate = false;
        controls.enablePan = true;
        controls.enableZoom = true;
        controls.screenSpacePanning = true;
      } else {
        // Treat as 3D: enable all controls
        controls.enableRotate = true;
        controls.enablePan = true;
        controls.enableZoom = true;
        controls.screenSpacePanning = false;
      }
      controls.update();
    }
  }
  
  
  // Show/hide camera sensitivity panel in main UI
  const cameraSensitivityPanel = document.getElementById("cameraSensitivityPanel");
  if (cameraSensitivityPanel) {
    cameraSensitivityPanel.style.display = showCameraSensitivityInMain ? "block" : "none";
  }
  
  // Sync main slider with preference slider
  const mainSlider = document.getElementById("mainCameraSensitivitySlider");
  const mainValue = document.getElementById("mainCameraSensitivityValue");
  if (mainSlider && mainValue) {
    mainSlider.value = cameraSensitivity;
    mainValue.textContent = cameraSensitivity.toFixed(1);
  }
  
  // Close modal
  document.getElementById("preferencesModal").style.display = "none";
  console.log(`Preferences saved - Component coloring: ${componentColoringEnabled ? 'ON' : 'OFF'}, Box highlighting: ${boxHighlightingEnabled ? 'ON' : 'OFF'}`);
  
  // Apply show all vertices preference to all grids
  updateAllVerticesVisibility();
});

// Close preferences with X button (without saving)
document.getElementById("closePreferencesBtn").addEventListener("click", () => {
  document.getElementById("preferencesModal").style.display = "none";
  console.log("Preferences closed without saving");
});



  // Initialize Quill editor
  function initQuillEditor() {
    if (!isQuillInitialized) {
      quillEditor = new Quill('#notesEditor', {
        theme: 'snow',
        placeholder: 'Add notes for this grid...',
        modules: {
          toolbar: [
            ['bold', 'italic', 'underline'],
            [{ 'size': ['small', false, 'large', 'huge'] }],
            [{ 'header': [1, 2, 3, false] }],
            [{ 'color': [] }, { 'background': [] }],
            [{ 'list': 'ordered'}, { 'list': 'bullet' }],
            ['clean']
          ]
        }
      });
      
      // Auto-save on text change
      quillEditor.on('text-change', function() {
        saveCurrentGridNotes();
      });
      
      isQuillInitialized = true;
    }
  }

// Initialize notes system
document.addEventListener('DOMContentLoaded', function() {
  const notesWindow = document.getElementById('notesWindow');
  const notesMinimized = document.getElementById('notesMinimized');
  const notesHeader = document.getElementById('notesHeader');
  const notesMinimize = document.getElementById('notesMinimize');

  // Only set up handlers if all elements exist
  if (notesWindow && notesMinimized && notesHeader && notesMinimize) {
    // Show/hide notes window
    notesMinimized.onclick = () => {
      notesWindow.style.display = 'block';
      notesMinimized.style.display = 'none';
      initQuillEditor();
      updateNotesForCurrentGrid();
      // Focus the editor so cursor is ready
      setTimeout(() => quillEditor.focus(), 50);
    };

    notesMinimize.onclick = () => {
      saveCurrentGridNotes();
      notesWindow.style.display = 'none';
      notesMinimized.style.display = 'flex';
    };

    // Make notes window draggable
    notesHeader.onmousedown = (e) => {
      isDraggingNotes = true;
      notesOffset.x = e.clientX - notesWindow.offsetLeft;
      notesOffset.y = e.clientY - notesWindow.offsetTop;
    };

    document.onmousemove = (e) => {
    if (isDraggingNotes) {
      const newLeft = e.clientX - notesOffset.x;
      const newTop = e.clientY - notesOffset.y;
      
      // Get window dimensions
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      const notesWidth = notesWindow.offsetWidth;
      const notesHeight = notesWindow.offsetHeight;
      
      // Define boundaries (keep at least 100px of the window visible)
      const minTop = 60; // Below topbar
      const maxTop = windowHeight - 100; // Keep bottom visible
      const minLeft = -notesWidth + 100; // Keep right edge visible
      const maxLeft = windowWidth - 100; // Keep left edge visible
      
      // Constrain position within bounds
      const constrainedTop = Math.max(minTop, Math.min(maxTop, newTop));
      const constrainedLeft = Math.max(minLeft, Math.min(maxLeft, newLeft));
      
      notesWindow.style.left = constrainedLeft + 'px';
      notesWindow.style.top = constrainedTop + 'px';
    }
  };
    document.onmouseup = () => {
      isDraggingNotes = false;
    };
  }
});


function updateNotesForCurrentGrid() {
  const notesGridName = document.getElementById('notesGridName');
  
  if (currentGrid && quillEditor) {
    // Find current grid ID
    let currentGridId = 'Unknown Grid';
    for (const [id, grid] of allGrids.entries()) {
      if (grid === currentGrid) {
        currentGridId = id;
        break;
      }
    }
    
    notesGridName.textContent = currentGridId;
    
    // Set the rich text content (HTML)
    const savedContent = currentGrid.notes || '';
    quillEditor.root.innerHTML = savedContent;
  } else {
    notesGridName.textContent = 'No Grid';
    if (quillEditor) {
      quillEditor.root.innerHTML = '';
    }
  }
}

function saveCurrentGridNotes() {
  if (currentGrid && quillEditor) {
    // Save as HTML to preserve formatting
    currentGrid.notes = quillEditor.root.innerHTML;
  }
}



// Add these event listeners with your other UI event listeners  TRANSPARENT PLANE
//document.getElementById("planeControlsHeader").addEventListener("click", () => {
//  const content = document.getElementById("planeControlsContent");
//  const header = document.getElementById("planeControlsHeader");
  
//  if (content.style.display === "none") {
    // Expand
//    content.style.display = "flex";
//    header.style.borderRadius = "12px 12px 0 0";
//  } else {
    // Collapse
//    content.style.display = "none";
//    header.style.borderRadius = "12px";
//  }
//});

document.getElementById("addPlaneBtn").addEventListener("click", () => {
  const a = parseFloat(document.getElementById("planeA").value) || 0;
  const b = parseFloat(document.getElementById("planeB").value) || 0;
  const c = parseFloat(document.getElementById("planeC").value) || 0;
  const d = parseFloat(document.getElementById("planeD").value) || 0;
  const opacity = parseFloat(document.getElementById("planeOpacity").value) || 0.15;
  
  if (a === 0 && b === 0 && c === 0) {
    alert("Invalid plane equation: at least one coefficient must be non-zero");
    return;
  }
  
  addTransparentPlane(a, b, c, d, selectedColor, opacity);
});

document.getElementById("removePlaneBtn").addEventListener("click", () => {
  if (!currentGrid || !currentGrid.customPlanes || currentGrid.customPlanes.length === 0) {
    alert("No planes to remove");
    return;
  }
  
  // Remove all planes
  while (currentGrid.customPlanes.length > 0) {
    const planeData = currentGrid.customPlanes[0];
    removeTransparentPlane(planeData.id);
  }
});

document.getElementById("planeOpacity").addEventListener("input", (e) => {
  const opacity = parseFloat(e.target.value);
  document.getElementById("planeOpacityValue").textContent = Math.round(opacity * 100) + "%";
  
  // Update existing plane if it exists
  if (currentGrid && currentGrid.customPlane) {
    currentGrid.customPlane.material.opacity = opacity;
  }
});


document.getElementById("syncViewBtn").addEventListener("click", () => {
  if (!currentGrid) {
    alert("No active grid to sync from");
    return;
  }
  
  // Get current camera state
  const currentPosition = camera.position.clone();
  const currentTarget = controls.target.clone();
  
  // Apply to all other grids
  let syncedCount = 0;
  for (const [gridId, grid] of allGrids.entries()) {
    if (grid !== currentGrid) {
      grid.cameraPosition = currentPosition.clone();
      grid.cameraTarget = currentTarget.clone();
      syncedCount++;
    }
  }
  
  console.log(`Synced camera view to ${syncedCount} grids`);
  
  // Flash the button green
  const btn = document.getElementById("syncViewBtn");
  btn.style.background = '#4CAF50';
  btn.style.transition = 'background 0.1s ease';
  setTimeout(() => {
    btn.style.background = '';
    btn.style.transition = '';
  }, 150);
});

document.getElementById("coordinateHoverCheckbox").addEventListener("change", (e) => {
  coordinateHoverMode = e.target.checked;
  
  // Clear any existing tooltip when toggling
  const existingTooltip = document.getElementById('coordinateTooltip');
  if (existingTooltip) existingTooltip.remove();
});





// Backbite Distance Vertex Coloring Event Listeners
document.getElementById("colorBBDistanceBtn").addEventListener("click", () => {
  const refX = parseInt(document.getElementById("bbRefX").value) || 0;
  const refY = parseInt(document.getElementById("bbRefY").value) || 0;
  const refZ = parseInt(document.getElementById("bbRefZ").value) || 0;
  const distance = parseInt(document.getElementById("bbDistance").value) || 0;
  
  if (validateBBDistanceInputs(refX, refY, refZ, distance)) {
    const coloredCount = colorVerticesAtBBDistance(refX, refY, refZ, distance);
    
    if (coloredCount === 0) {
      alert(`No vertices found at backbite distance ${distance} from (${refX},${refY},${refZ}). Check that the distance is reachable given the parity constraints.`);
    }
  }
});

document.getElementById("clearBBDistanceBtn").addEventListener("click", () => {
  clearAllVertexSpheres();
});

// Update reference vertex bounds when grid dimensions change
function updateBBDistanceMaxValues() {
  if (!currentGrid) return;
  
  const bbRefX = document.getElementById("bbRefX");
  const bbRefY = document.getElementById("bbRefY");
  const bbRefZ = document.getElementById("bbRefZ");
  
  if (bbRefX) bbRefX.max = currentGrid.width - 1;
  if (bbRefY) bbRefY.max = currentGrid.height - 1;
  if (bbRefZ) bbRefZ.max = currentGrid.depth - 1;
}





// Undo/Redo event listeners
document.getElementById("undoBtn").addEventListener("click", performUndo);
document.getElementById("redoBtn").addEventListener("click", performRedo);

// Keyboard shortcuts

document.addEventListener('keydown', (event) => {

  // Handle Ctrl+M (notes toggle) first - works even when typing
  if ((event.ctrlKey || event.metaKey) && event.key === 'm') {
    event.preventDefault();
    const notesWindow = document.getElementById('notesWindow');
    const notesMinimized = document.getElementById('notesMinimized');
    
    if (notesWindow.style.display === 'block') {
      // Hide notes window
      saveCurrentGridNotes();
      notesWindow.style.display = 'none';
      notesMinimized.style.display = 'flex';
	} else {
	  // Show notes window
	  notesWindow.style.display = 'block';
	  notesMinimized.style.display = 'none';
	  initQuillEditor();
	  updateNotesForCurrentGrid();
	  // Focus the editor so cursor is ready
	  setTimeout(() => quillEditor.focus(), 50);
	}
    console.log("Notes window toggled");
    return;
  }
  
  // Help / Keyboard Shortcuts (Shift + ?)
  if (event.shiftKey && event.key === '?') {
    event.preventDefault();
    document.getElementById('keyboardShortcutsModal').style.display = 'flex';
    console.log("Keyboard shortcuts modal opened via Shift+?");
    return;
  }
  
  // Preferences (Shift + P)
  if (event.shiftKey && (event.key === 'P' || event.key === 'p')) {
    event.preventDefault();
    document.getElementById('preferencesBtn').click();
    console.log("Preferences modal opened via Shift+P");
    return;
  }
  
  // Camera Sensitivity (Shift + < and Shift + >)
  if (event.shiftKey && (event.key === '<' || event.key === ',')) {
    event.preventDefault();
    // Decrease camera sensitivity
    cameraSensitivity = Math.max(0.1, cameraSensitivity - 0.1);
    if (typeof controls !== 'undefined') {
      controls.rotateSpeed = cameraSensitivity;
      controls.zoomSpeed = 0.5 * cameraSensitivity;
    }
    // Update both sliders
    const prefSlider = document.getElementById('cameraSensitivitySlider');
    const prefValue = document.getElementById('cameraSensitivityValue');
    const mainSlider = document.getElementById('mainCameraSensitivitySlider');
    const mainValue = document.getElementById('mainCameraSensitivityValue');
    if (prefSlider && prefValue) {
      prefSlider.value = cameraSensitivity;
      prefValue.textContent = cameraSensitivity.toFixed(1);
    }
    if (mainSlider && mainValue) {
      mainSlider.value = cameraSensitivity;
      mainValue.textContent = cameraSensitivity.toFixed(1);
    }
    console.log(`Camera sensitivity decreased to ${cameraSensitivity.toFixed(1)}`);
    return;
  }
  
  if (event.shiftKey && (event.key === '>' || event.key === '.')) {
    event.preventDefault();
    // Increase camera sensitivity
    cameraSensitivity = Math.min(2.0, cameraSensitivity + 0.1);
    if (typeof controls !== 'undefined') {
      controls.rotateSpeed = cameraSensitivity;
      controls.zoomSpeed = 0.5 * cameraSensitivity;
    }
    // Update both sliders
    const prefSlider = document.getElementById('cameraSensitivitySlider');
    const prefValue = document.getElementById('cameraSensitivityValue');
    const mainSlider = document.getElementById('mainCameraSensitivitySlider');
    const mainValue = document.getElementById('mainCameraSensitivityValue');
    if (prefSlider && prefValue) {
      prefSlider.value = cameraSensitivity;
      prefValue.textContent = cameraSensitivity.toFixed(1);
    }
    if (mainSlider && mainValue) {
      mainSlider.value = cameraSensitivity;
      mainValue.textContent = cameraSensitivity.toFixed(1);
    }
    console.log(`Camera sensitivity increased to ${cameraSensitivity.toFixed(1)}`);
    return;
  }
  
  
  // Check if user is currently typing in an input field, text area, or Quill editor
  const activeElement = document.activeElement;
  const isTyping = activeElement && (
    activeElement.tagName === 'INPUT' || 
    activeElement.tagName === 'TEXTAREA' ||
    activeElement.contentEditable === 'true' ||
    activeElement.closest('.ql-editor') // Add Quill editor check
  );
  
  // If user is typing, don't process any shortcuts
  if (isTyping) {
    return;
  }
  
  // Undo/Redo/Save/Load/Notes shortcuts
  if (event.ctrlKey || event.metaKey) {
	if (event.key === 'y') {
	  // Ctrl+Y: Redo
	  event.preventDefault();
	  performRedo();
	  return;
	} else if (event.key === 'z' && !event.shiftKey) {
      // Ctrl+Z: Undo
      event.preventDefault();
      performUndo();
      return;
    } else if (event.key === 's') {
      event.preventDefault();
      saveGrid();
      return;
    } else if (event.key === 'l') {
      event.preventDefault();
      loadGridFromDisk();
      return;
    } else if (event.key === 'm') {
      // Ctrl+M: Toggle notes window
      event.preventDefault();
      const notesWindow = document.getElementById('notesWindow');
      const notesMinimized = document.getElementById('notesMinimized');
      
      if (notesWindow.style.display === 'block') {
        // Hide notes window
        saveCurrentGridNotes();
        notesWindow.style.display = 'none';
        notesMinimized.style.display = 'flex';
      } else {
        // Show notes window
        notesWindow.style.display = 'block';
        notesMinimized.style.display = 'none';
        if (!isQuillInitialized) {
          initQuillEditor();
        }
        updateNotesForCurrentGrid();
      }
      console.log("Notes window toggled");
      return;
    }
  }
  
  // Existing 'T' key functionality for toggling active endpoint
  if (event.key === 't' || event.key === 'T') {
    console.log("T key detected");
    if (mode === "backbite") {
      console.log("Calling toggleActiveEndpoint");
      toggleActiveEndpoint();
    }
    return;
  }
  
// Mode toggle shortcuts (only when no modifier keys are pressed)
  if (!event.ctrlKey && !event.metaKey && !event.altKey) {
    switch(event.key.toLowerCase()) {
	  case 'v':
	    if (event.shiftKey) {
		// Shift+V: Toggle decoration mode
		document.getElementById("decorationBtn").click();
		console.log(`Decoration mode: ${mode === 'addDecoration' ? 'ON' : 'OFF'}`);
	    } else {
		// V: Toggle vertices mode
		document.getElementById("verticesBtn").click();
		console.log(`Vertices mode: ${mode === 'addVertex' ? 'ON' : 'OFF'}`);
	    }
	    event.preventDefault();
	    return;
        
      case 'e':
        if (event.shiftKey) {
          // Shift+E: Toggle edge decoration mode
          document.getElementById("cubeBtn").click();
          console.log(`Edge decoration mode: ${mode === 'addCube' ? 'ON' : 'OFF'}`);
        } else {
          // E: Toggle edge coloring mode
          document.getElementById("toggleClickBtn").click();
          console.log(`Edge mode: ${edgeClickEnabled ? 'ON' : 'OFF'}`);
        }
        event.preventDefault();
        return;
        
      case 'a':
        // A: Toggle arrow mode
        document.getElementById("arrowBtn").click();
        console.log(`Arrow mode: ${arrowMode ? 'ON' : 'OFF'}`);
        event.preventDefault();
        return;
        
      case 's':
        // S: Sync view
        document.getElementById("syncViewBtn").click();
        console.log("Sync view activated");
        event.preventDefault();
        return;
    }
  }
  // Directional keys for backbite mode
  if (mode === "backbite" && currentGrid && currentGrid.path && currentGrid.path.length >= 2) {
    console.log("In backbite mode with valid path");
    const path = currentGrid.path;
    const activeEndpointKey = activeEndpoint === 'start' ? path[0] : path[path.length - 1];
    console.log(`Active endpoint: ${activeEndpoint}, Key: ${activeEndpointKey}`);
    
    const [x, y, z] = activeEndpointKey.split(',').map(Number);
    let targetCoord = null;
    
    // Map arrow keys and page keys to directions
    switch(event.key) {
      case 'ArrowUp':
        targetCoord = [x, y + 1, z];
        console.log("Arrow Up pressed, target:", targetCoord);
        break;
      case 'ArrowDown':
        targetCoord = [x, y - 1, z];
        console.log("Arrow Down pressed, target:", targetCoord);
        break;
      case 'ArrowLeft':
        targetCoord = [x - 1, y, z];
        console.log("Arrow Left pressed, target:", targetCoord);
        break;
      case 'ArrowRight':
        targetCoord = [x + 1, y, z];
        console.log("Arrow Right pressed, target:", targetCoord);
        break;
      case 'PageUp':
        targetCoord = [x, y, z + 1];
        console.log("Page Up pressed, target:", targetCoord);
        break;
      case 'PageDown':
        targetCoord = [x, y, z - 1];
        console.log("Page Down pressed, target:", targetCoord);
        break;
      default:
        return;
    }
    
    if (targetCoord) {
      const currentCoord = [x, y, z];
      const clickedEdgeKey = edgeKey(currentCoord, targetCoord);
      console.log(`Attempting backbite with edge key: ${clickedEdgeKey}`);
      
      const success = performManualBackbite(clickedEdgeKey);
      console.log(`Backbite result: ${success}`);
      
      event.preventDefault();
    }
  }
});


// Keyboard Shortcuts Modal Functionality
// Help Menu and Modals Functionality
(function() {
  const helpBtn = document.getElementById('helpBtn');
  const helpDropdown = document.getElementById('helpDropdown');
  const aboutModal = document.getElementById('aboutModal');
  const shortcutsModal = document.getElementById('keyboardShortcutsModal');
  const closeAboutBtn = document.getElementById('closeAboutModal');
  const closeShortcutsBtn = document.getElementById('closeShortcutsModal');
  
  // Toggle dropdown menu
  helpBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    const isVisible = helpDropdown.style.display === 'block';
    helpDropdown.style.display = isVisible ? 'none' : 'block';
    console.log(`Help dropdown ${isVisible ? 'closed' : 'opened'}`);
  });
  
  // Close dropdown when clicking outside
  document.addEventListener('click', (e) => {
    if (!helpBtn.contains(e.target) && !helpDropdown.contains(e.target)) {
      helpDropdown.style.display = 'none';
    }
  });
  
  // Handle menu item clicks
  document.querySelectorAll('.help-menu-item').forEach(item => {
    item.addEventListener('click', (e) => {
      const action = item.getAttribute('data-action');
      
      // Close dropdown
      helpDropdown.style.display = 'none';
      
      // Open appropriate modal
      if (action === 'about') {
        aboutModal.style.display = 'flex';
        console.log("About modal opened");
      } else if (action === 'shortcuts') {
        shortcutsModal.style.display = 'flex';
        console.log("Keyboard shortcuts modal opened");
      } else if (action === 'readme') {
        console.log("README - Coming soon");
        // Will be implemented later
      }
    });
  });
  
  // Close About modal
  closeAboutBtn.addEventListener('click', () => {
    aboutModal.style.display = 'none';
    console.log("About modal closed");
  });
  
  // Close Shortcuts modal
  closeShortcutsBtn.addEventListener('click', () => {
    shortcutsModal.style.display = 'none';
    console.log("Keyboard shortcuts modal closed");
  });
  
  // Close modals when clicking outside
  aboutModal.addEventListener('click', (e) => {
    if (e.target === aboutModal) {
      aboutModal.style.display = 'none';
      console.log("About modal closed (clicked outside)");
    }
  });
  
  shortcutsModal.addEventListener('click', (e) => {
    if (e.target === shortcutsModal) {
      shortcutsModal.style.display = 'none';
      console.log("Keyboard shortcuts modal closed (clicked outside)");
    }
  });
  
  // Close modals with Escape key
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      // First priority: if generating, show quit confirmation
      if (isGenerating) {
        e.preventDefault();
        const generationType = currentGrid && currentGrid.path && currentGrid.path.length === (currentGrid.width * currentGrid.height * currentGrid.depth) ? 'cycle' : 'path';
        showQuitGenerationDialog(generationType);
        return;
      }
      
      // Second priority: close preferences without saving
      const preferencesModal = document.getElementById('preferencesModal');
      if (preferencesModal && preferencesModal.style.display === 'flex') {
        preferencesModal.style.display = 'none';
        console.log("Preferences modal closed (Escape key - not saved)");
        return;
      }
      
      // Then handle other modals
      if (aboutModal.style.display === 'flex') {
        aboutModal.style.display = 'none';
        console.log("About modal closed (Escape key)");
      }
      if (shortcutsModal.style.display === 'flex') {
        shortcutsModal.style.display = 'none';
        console.log("Keyboard shortcuts modal closed (Escape key)");
      }
      if (helpDropdown.style.display === 'block') {
        helpDropdown.style.display = 'none';
        console.log("Help dropdown closed (Escape key)");
      }
    }
  });
})();


// Quit generation dialog
function showQuitGenerationDialog(generationType) {
  // Create dialog overlay
  const overlay = document.createElement('div');
  overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    z-index: 10001;
    display: flex;
    align-items: center;
    justify-content: center;
  `;
  
  const dialog = document.createElement('div');
  dialog.style.cssText = `
    background: white;
    border-radius: 12px;
    padding: 30px;
    max-width: 400px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
  `;
  
  dialog.innerHTML = `
    <h3 style="margin: 0 0 20px 0; color: #2c3e50; font-size: 20px;">Stop Generation?</h3>
    <p style="margin: 0 0 25px 0; color: #555; font-size: 14px; line-height: 1.6;">
      Are you sure you want to stop generating a Hamiltonian ${generationType}?
    </p>
    <div style="display: flex; gap: 12px; justify-content: flex-end;">
      <button id="quitGenNo" style="padding: 10px 24px; background: #95a5a6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">No</button>
      <button id="quitGenYes" style="padding: 10px 24px; background: #e74c3c; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">Yes, Stop</button>
    </div>
  `;
  
  overlay.appendChild(dialog);
  document.body.appendChild(overlay);
  
  // Event handlers
  document.getElementById('quitGenNo').addEventListener('click', () => {
    document.body.removeChild(overlay);
  });
  
  document.getElementById('quitGenYes').addEventListener('click', () => {
    shouldStopGeneration = true;
    document.body.removeChild(overlay);
    console.log("User requested to stop generation");
  });
}


// ===========================================INSTANCED RENDERING TOGGLE=========================================  \\

// ===============================================================================================================  \\


// Matrix-style Progress Overlay
const ProgressOverlay = {
  overlay: null,
  gridText: null,
  percentText: null,
  timeText: null, // NEW: Third row for time
  currentTheme: 'light',
  
  init() {
    this.overlay = document.getElementById('progressOverlay');
    this.gridText = document.getElementById('progressGrid');
    this.percentText = document.getElementById('progressPercent');
    this.timeText = document.getElementById('progressTime'); // NEW
    this.updateTheme();
    console.log('ProgressOverlay initialized:', this.overlay !== null);
  },
  
  updateTheme() {
    if (!this.overlay) return;
    
    const bgSelect = document.getElementById('backgroundSelect');
    const isDarkMode = bgSelect && bgSelect.value === '0x000000';
    
    if (isDarkMode) {
      this.overlay.style.background = '#2a2a2a';
      this.overlay.style.color = '#b7f774';
      this.overlay.style.border = '1px solid #3a3a3a';
    } else {
      this.overlay.style.background = '#0a0f0a';
      this.overlay.style.color = '#b7f774';
      this.overlay.style.border = '1px solid #1d2a1d';
    }
  },
  
  show(message, gridDimensions) {
    if (!this.overlay) this.init();
    
    this.updateTheme();
    this.gridText.textContent = gridDimensions || '‚Äî';
    this.percentText.textContent = '0%';
    if (this.timeText) this.timeText.textContent = ''; // Hide time row initially
    
    this.overlay.style.display = 'block';
    this.overlay.offsetHeight;
    this.overlay.style.opacity = '1';
    
    console.log('‚úÖ Progress overlay shown');
  },
  
  update(percentage, gridDimensions) {
    if (!this.overlay || !this.gridText || !this.percentText) {
      console.error('‚ùå Overlay elements not found!');
      return;
    }
    
    if (gridDimensions) {
      this.gridText.textContent = gridDimensions;
    }
    this.percentText.textContent = Math.round(Math.min(100, Math.max(0, percentage))) + '%';
  },
  
  complete(timeInSeconds, duration = 3000) { // NEW: accepts time parameter
    if (!this.overlay) return;
    
    // Show completion
    this.percentText.textContent = '100% ‚úì';
    
    // NEW: Show time in third row
    if (this.timeText) {
      this.timeText.textContent = `${timeInSeconds}s`;
    }
    
    console.log('‚úÖ Generation complete');
    
    setTimeout(() => {
      this.overlay.style.opacity = '0';
      setTimeout(() => {
        this.overlay.style.display = 'none';
      }, 300);
    }, duration);
  },
  
  hide() {
    if (!this.overlay) return;
    
    this.overlay.style.opacity = '0';
    setTimeout(() => {
      this.overlay.style.display = 'none';
    }, 300);
  }
};

window.addEventListener('load', () => ProgressOverlay.init());


// Help menu item click handler
document.querySelectorAll('.help-menu-item').forEach(item => {
  item.addEventListener('click', (e) => {
    const action = e.target.dataset.action;
    
    if (action === 'shortcuts') {
      document.getElementById('keyboardShortcutsModal').style.display = 'flex';
      document.getElementById('helpDropdown').style.display = 'none';
    } else if (action === 'about') {
      document.getElementById('aboutModal').style.display = 'flex';
      document.getElementById('helpDropdown').style.display = 'none';
    } else if (action === 'readme') {
      openReadmeInNewTab();
      document.getElementById('helpDropdown').style.display = 'none';
    }
  });
});



document.getElementById('edgeCollisionRadiusSlider').addEventListener('input', (e) => {
  edgeCollisionRadius = parseFloat(e.target.value);
  document.getElementById('edgeCollisionRadiusValue').textContent = edgeCollisionRadius.toFixed(2);
  
  // Rebuild collision mesh with new radius
  if (currentGrid && currentGrid.instancedEdgesCollision) {
    currentGrid.group.remove(currentGrid.instancedEdgesCollision);
    currentGrid.instancedEdgesCollision.geometry.dispose();
    currentGrid.instancedEdgesCollision.material.dispose();
    
    // Recreate with new radius
    const newGeometry = new THREE.CylinderGeometry(edgeCollisionRadius, edgeCollisionRadius, 1, 8);
    const newMaterial = new THREE.MeshBasicMaterial({ visible: false });
    const newMesh = new THREE.InstancedMesh(newGeometry, newMaterial, currentGrid.edges.size);
    newMesh.userData.isEdgeCollisionMesh = true;
    currentGrid.instancedEdgesCollision = newMesh;
    currentGrid.group.add(newMesh);
    
    // Rebuild instances
    rebuildEdgeCollisionInstances(currentGrid);
  }
});

// Camera sensitivity slider in preferences
document.getElementById('cameraSensitivitySlider').addEventListener('input', (e) => {
  const value = parseFloat(e.target.value);
  document.getElementById('cameraSensitivityValue').textContent = value.toFixed(1);
  // Preview changes immediately
  if (typeof controls !== 'undefined') {
    controls.rotateSpeed = value;
    controls.zoomSpeed = 0.5 * value;
  }
});


// Camera sensitivity slider in main UI
document.getElementById('mainCameraSensitivitySlider').addEventListener('input', (e) => {
  const value = parseFloat(e.target.value);
  cameraSensitivity = value;
  document.getElementById('mainCameraSensitivityValue').textContent = value.toFixed(1);
  
  // Update controls immediately (both rotation and zoom)
  if (typeof controls !== 'undefined') {
    controls.rotateSpeed = cameraSensitivity;
    controls.zoomSpeed = 0.5 * cameraSensitivity;
  }
  
  // Sync with preferences slider
  const prefSlider = document.getElementById('cameraSensitivitySlider');
  const prefValue = document.getElementById('cameraSensitivityValue');
  if (prefSlider && prefValue) {
    prefSlider.value = value;
    prefValue.textContent = value.toFixed(1);
  }
});



function openReadmeInNewTab() {
  const readmeHTML = `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GridLab - README</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 900px;
      margin: 0 auto;
      padding: 40px 20px;
      background: #f8f9fa;
    }
    .container {
      background: white;
      padding: 40px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    h1 {
      color: #2c3e50;
      border-bottom: 3px solid #3498db;
      padding-bottom: 10px;
      margin-top: 0;
    }
    h2 {
      color: #2c3e50;
      margin-top: 30px;
      font-size: 24px;
    }
    h3 {
      color: #34495e;
      margin-top: 20px;
      font-size: 18px;
    }
    h4 {
      color: #2c3e50;
      margin-top: 15px;
      font-size: 16px;
    }
    hr {
      border: none;
      border-top: 2px solid #eee;
      margin: 30px 0;
    }
    ul, ol {
      margin: 10px 0 10px 20px;
    }
    li {
      margin: 5px 0;
    }
    strong {
      color: #2c3e50;
      font-weight: 600;
    }
    .shortcuts-box {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 8px;
      margin: 20px 0;
      border-left: 4px solid #3498db;
    }
    .footer {
      text-align: center;
      color: #7f8c8d;
      font-style: italic;
      margin-top: 40px;
      padding-top: 20px;
      border-top: 2px solid #eee;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>GridLab</h1>
    <p>GridLab is an interactive 3D visualization and editing tool for exploring Hamiltonian paths and cycles on grid graphs. Built with Three.js, it provides an environment for studying graph theory, particularly the properties of Hamiltonian paths and cycles on the 2D and 3D square lattice.</p>

    <h2>Overview</h2>
    <p>GridLab enables users to:</p>
    <ul>
      <li>Generate and visualize Hamiltonian paths and cycles on 2D and 3D grid graphs</li>
      <li>Perform backbite and switch moves to explore the space of Hamiltonian paths</li>
      <li>Color edges with gradients and add directional arrows</li>
      <li>Work with multiple grids simultaneously</li>
      <li>Add vertex and edge decorations for marking special structures</li>
      <li>Save and load complete project states</li>
    </ul>

    <h2>Core Concepts</h2>

    <h3>Grid Graphs</h3>
    <p>A grid graph is a subgraph of the d-dimensional integer grid. GridLab‚Äôs capacity is hardware-dependent. Instanced rendering reduces draw-call overhead. At very large sizes, performance is then limited by how fast the CPU/GPU can move data (memory/cache bandwidth), rather than raw compute.</p>

    <h3>Hamiltonian Paths and Cycles</h3>
    <ul>
      <li><strong>Hamiltonian Path:</strong> A path that visits every vertex in the graph exactly once</li>
      <li><strong>Hamiltonian Cycle:</strong> A path that visits every vertex exactly once and returns to the starting vertex</li>
    </ul>

    <h3>Backbite Moves</h3>
    <p>A backbite move is a local transformation that reconfigures a Hamiltonian path into a new one. This is a key operation for exploring the space of all Hamiltonian paths on a given grid.</p>

    <h3>Switch Moves</h3>
    <p>A switch move operates on a "switchable box" - a 2√ó2 square where exactly two parallel edges are in the path/cycle. The move swaps which pair is included. If we start with a Hamiltonian cycle in 3D, the move either produces a new Hamiltonian cycle or it produce a cover of the grid with two cycles. Switching any boundary box between those two cycles produces a new Hamiltonian cycle.</p>

    <h2>Getting Started</h2>

    <h3>Creating Your First Grid</h3>
    <ol>
      <li>Set dimensions using the Grid Dimensions controls (top right)</li>
      <li>Click <strong>Add Grid</strong> to create a new grid</li>
      <li>The grid appears in the 3D viewport with a button in the grid list at the bottom</li>
    </ol>

    <h3>Navigation</h3>
    <ul>
      <li><strong>Rotate:</strong> Left-click and drag</li>
      <li><strong>Pan:</strong> Right-click and drag (or Shift + left-click and drag)</li>
      <li><strong>Zoom:</strong> Scroll wheel</li>
      <li><strong>2D Camera Mode:</strong> Simpler pan/zoom navigation for 2D grids. 2D grids obtained by setting z=1 offer best view</li>
    </ul>

    <h2>Key Features</h2>

    <h3>Path Generation</h3>
    <ul>
      <li><strong>Generate Path:</strong> Creates a random Hamiltonian path with colored endpoints (green = start, red = end), using b backbite moves where b=10|V| for 3D grids, and |V|=length √ó width √ó height</li>
      <li><strong>Generate Cycle:</strong> Creates a random Hamiltonian cycle, using largely the same algorithm</li>
      <li><strong>Check Hamiltonian:</strong> Verifies if the current structure is Hamiltonian</li>
      <li><strong>Stop Generation:</strong> Press <strong>Esc</strong> to interrupt generation at any time</li>
    </ul>

    <h3>Interactive Modes</h3>
    <ul>
      <li><strong>Backbite Mode:</strong> Manual backbite move. Use arrow keys and PgUp/PgDn for manual control or click on a grid edge incident on an endpoint, T key to reverse path direction</li>
      <li><strong>Switch Mode:</strong> Click on 2√ó2 switch boxes to perform switch moves</li>
      <li><strong>Add Edge Mode:</strong> Click edges to toggle their colors</li>
      <li><strong>Decorate Edge:</strong> Add small cubes to mark specific edges</li>
      <li><strong>Arrows:</strong> Show directional arrows along the path</li>
      <li><strong>Add Vertex:</strong> Place colored spheres at vertices</li>
      <li><strong>Decorate Vertex:</strong> Add three orthogonal great circles to a vertex as a secondary marker</li>
      <li><strong>BB Distance Coloring:</strong> Color all vertices at a specific number of backbite moves away from a reference vertex</li>
      <li><strong>Gradient Mode:</strong> Apply smooth color gradients along paths</li>
    </ul>

    <h3>Visual Options</h3>
    <ul>
      <li><strong>Color Pickers:</strong> Two color pickers for main and second colors. Decorations use the second color.</li>
      <li><strong>Coordinate Axis:</strong> Toggle XYZ axis display</li>
      <li><strong>Toggle Grid:</strong> Show/hide uncolored edges</li>
      <li><strong>Grid Opacity:</strong> Adjust transparency of uncolored edges</li>
      <li><strong>Background Color:</strong> Switch between dark and light backgrounds</li>
      <li><strong>Plane Highlighter:</strong> Highlights cross-sections of 3D grids</li>
      <li><strong>Show All Vertices:</strong> Display all vertices in the grid (use sparingly on large grids for better performance)</li>
      <li><strong>2D Camera:</strong> Toggle between 3D rotation and simpler 2D pan/zoom controls</li>
    </ul>

    <h3>Grid Management</h3>
    <ul>
      <li><strong>Add Layer:</strong> Extend grids</li>
      <li><strong>Remove Layer:</strong> Remove outermost layer</li>
      <li><strong>Duplicate Grid:</strong> Copy current grid completely</li>
      <li><strong>Save Grids:</strong> Export all grids to JSON</li>
      <li><strong>Load Grids:</strong> Import previously saved grids</li>
      <li><strong>Sync View:</strong> Align camera across all grids</li>
    </ul>

    <h3>Notes System</h3>
    <p>Rich text note-taking panel (Ctrl+M to toggle) with per-grid notes that persist in save files.</p>

    <h3>Undo/Redo</h3>
    <p>Complete undo/redo system (Ctrl+Z / Ctrl+Y) tracking backbite moves, switch moves, edge coloring, and more.</p>


    <h2>Performance & Complexity</h2>
    <p>GridLab can handle grids of varying sizes. Generation time scales roughly with the number of backbite operations performed. The runtime per backbite is approximately N/2, where N is the number of vertices in the grid. Generation uses at least 10N backbite moves, so the total run time is approximately of the order N<sup>2</sup></p>
    

    <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
      <thead>
        <tr style="background: #3498db; color: white;">
          <th style="padding: 12px; border: 1px solid #ddd; text-align: left;">Grid Size</th>
          <th style="padding: 12px; border: 1px solid #ddd; text-align: left;">n (vertices)</th>
          <th style="padding: 12px; border: 1px solid #ddd; text-align: left;">Backbites</th>
          <th style="padding: 12px; border: 1px solid #ddd; text-align: left;">Operations</th>
          <th style="padding: 12px; border: 1px solid #ddd; text-align: left;">Time Estimate</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="padding: 10px; border: 1px solid #ddd;">5√ó5√ó5</td>
          <td style="padding: 10px; border: 1px solid #ddd;">125</td>
          <td style="padding: 10px; border: 1px solid #ddd;">1,250</td>
          <td style="padding: 10px; border: 1px solid #ddd;">~156K</td>
          <td style="padding: 10px; border: 1px solid #ddd;">&lt;1 sec</td>
        </tr>
        <tr style="background: #f8f9fa;">
          <td style="padding: 10px; border: 1px solid #ddd;">10√ó10√ó10</td>
          <td style="padding: 10px; border: 1px solid #ddd;">1,000</td>
          <td style="padding: 10px; border: 1px solid #ddd;">10,000</td>
          <td style="padding: 10px; border: 1px solid #ddd;">~10M</td>
          <td style="padding: 10px; border: 1px solid #ddd;">~1 sec</td>
        </tr>
        <tr>
          <td style="padding: 10px; border: 1px solid #ddd;">20√ó20√ó20</td>
          <td style="padding: 10px; border: 1px solid #ddd;">8,000</td>
          <td style="padding: 10px; border: 1px solid #ddd;">80,000</td>
          <td style="padding: 10px; border: 1px solid #ddd;">~640M</td>
          <td style="padding: 10px; border: 1px solid #ddd;">~10 sec</td>
        </tr>
        <tr style="background: #f8f9fa;">
          <td style="padding: 10px; border: 1px solid #ddd;">30√ó30√ó30</td>
          <td style="padding: 10px; border: 1px solid #ddd;">27,000</td>
          <td style="padding: 10px; border: 1px solid #ddd;">270,000</td>
          <td style="padding: 10px; border: 1px solid #ddd;">~7.3B</td>
          <td style="padding: 10px; border: 1px solid #ddd;">~90 sec</td>
        </tr>
        <tr>
          <td style="padding: 10px; border: 1px solid #ddd;">50√ó50√ó50</td>
          <td style="padding: 10px; border: 1px solid #ddd;">125,000</td>
          <td style="padding: 10px; border: 1px solid #ddd;">1,250,000</td>
          <td style="padding: 10px; border: 1px solid #ddd;">~156B</td>
          <td style="padding: 10px; border: 1px solid #ddd;">~25 min</td>
        </tr>
      </tbody>
    </table>

    <h2>Keyboard Shortcuts</h2>

    <h3>File Operations</h3>
    <ul>
      <li><strong>Ctrl+S:</strong> Save all grids</li>
      <li><strong>Ctrl+L:</strong> Load grids from file</li>
      <li><strong>Ctrl+M:</strong> Toggle notes window</li>
    </ul>

    <h3>Undo/Redo</h3>
    <ul>
      <li><strong>Ctrl+Z:</strong> Undo</li>
      <li><strong>Ctrl+Y:</strong> Redo</li>
    </ul>

    <h3>Mode Toggles</h3>
    <ul>
      <li><strong>E:</strong> Toggle edge coloring mode</li>
      <li><strong>Shift+E:</strong> Toggle edge decoration mode</li>
      <li><strong>A:</strong> Toggle arrow mode</li>
      <li><strong>V:</strong> Toggle vertex mode</li>
      <li><strong>Shift+V:</strong> Toggle vertex decoration mode</li>
      <li><strong>S:</strong> Sync view across grids</li>
    </ul>

    <h3>Backbite Mode</h3>
    <ul>
      <li><strong>Arrow Keys:</strong> Move in X-Y plane</li>
      <li><strong>Page Up/Down:</strong> Move in Z direction</li>
      <li><strong>T:</strong> Reverse path direction (swap endpoints and flip all arrows)</li>
    </ul>

    <h3>Other</h3>
    <ul>
      <li><strong>Esc:</strong> Stop path/cycle generation</li>
      <li><strong>Shift+?:</strong> Show keyboard shortcuts reference</li>
    </ul>

    <h2>Use Cases</h2>
    <ul>
      <li><strong>Research:</strong> Hamiltonian path/cycle generation and reconfiguration, grid graph structure analysis</li>
      <li><strong>Education:</strong> Graph theory teaching, algorithm visualization</li>
      <li><strong>Art:</strong> Generative patterns, color studies, aesthetic exploration</li>
    </ul>

    <h2>Tips and Best Practices</h2>
    <ul>
      <li>Use Toggle Grid to hide uncolored edges on large grids for better focus</li>
      <li>Turn on Gradient to visualize position along long paths</li>
      <li>Add vertex markers at key positions for reference points</li>
      <li>Enable Arrows to always see path direction clearly</li>
      <li>Duplicate grids before major changes to preserve current configurations</li>
      <li>Save frequently to preserve your work</li>
      <li>Use Grid Notes to document findings about each grid</li>
      <li>Press Esc if generation is taking too long</li>
      <li>Use 2D Camera mode for simpler navigation, especially on large 2D grids</li>
      <li><strong>Keep tab active during generation:</strong> Browser tabs throttle JavaScript when in the background, making generation 10-100√ó slower. Keep the GridLab tab visible and focused for optimal performance</li>
    </ul>

    <h2>Technical Details</h2>

    <h3>Performance Optimization</h3>
    <p><strong>Instanced Rendering:</strong> GridLab uses instanced rendering by default for improved performance on large grids by rendering all edges of the same type in a single draw call.</p>

    <h3>Save File Format</h3>
    <p>Save files are JSON documents containing complete grid states including dimensions, edge colors, vertex markers, paths, camera positions, and rich text notes.</p>

    <h3>Browser Compatibility</h3>
    <p>GridLab requires a modern browser with WebGL support: Chrome 90+, Firefox 88+, Safari 14+, or Edge 90+.</p>

    <hr>

    <h2>License</h2>
    <p>Copyright ¬© 2025 Albi</p>
    <p>GridLab is licensed under the PolyForm Noncommercial License 1.0.0</p>
    <ul>
      <li>‚úÖ Free for noncommercial use (research, education, personal projects)</li>
      <li>‚ùå Commercial use requires a separate paid license</li>
      <li>üìÑ <a href="#" style="color: #3498db;">View full license</a></li>
    </ul>

    <h3>Commercial Licensing</h3>
    <p>For commercial use inquiries, contact: <a href="mailto:albijuventus@yahoo.com" style="color: #3498db;">albijuventus@yahoo.com</a></p>

    <p style="margin-top: 30px; color: #7f8c8d; font-style: italic;">‚ö†Ô∏è Disclaimer: This software is provided "as is" without warranty of any kind. Use at your own risk.</p>

    <div class="footer">
      <p><strong>GridLab</strong> - Explore the space of Hamiltonian paths and cycle in grid graphs</p>
    </div>
  </div>
</body>
</html>
  `;
  
  const newWindow = window.open();
  newWindow.document.write(readmeHTML);
  newWindow.document.close();
  console.log("README opened in new tab");
}







//     ====================================================================================================================
// 										  8. ONCLICK, ONMOUSEMOVE AND RELATED FUNCTIONS
//     ====================================================================================================================

function onClick(event) {
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  
  if (!currentGrid) return;

  // Edge and vertex clicks are now handled exclusively by mouseDown/mouseUp flow
  // onClick only handles modes that don't use the mouseDown/mouseUp system
  
  switch(mode) {
    case "backbite":
      handleBackbiteClick();
      break;
    // NOTE: switch mode now handled by mouseDown/mouseUp system
    // addEdge, addCube, addVertex, and addDecoration cases removed - handled by mouseDown/mouseUp
    default:
      break;
  }
}


function handleInstancedEdgeClick(hits, meshType) {
  const instanceId = hits[0].instanceId;
  
  // Find edge key by checking all mappings (reverse lookup)
  let clickedEdgeKey = null;
  for (const [eKey, mapping] of currentGrid.edgeToInstanceMap.entries()) {
    if ((meshType === 'thin' && mapping.thin === instanceId) ||
        (meshType === 'thick' && mapping.thick === instanceId)) {
      clickedEdgeKey = eKey;
      break;
    }
  }
  
  if (!clickedEdgeKey) {
    return;
  }
  
  const [aStr, bStr] = clickedEdgeKey.split("-");
  const a = aStr.split(",").map(Number);
  const b = bStr.split(",").map(Number);
  
  const edge = currentGrid.edges.get(clickedEdgeKey);
  
  // Capture state for undo
  const beforeState = captureEdgeState(clickedEdgeKey);
  
  // Toggle color
  const newColor = edge.color === selectedColor ? UNCOLORED_COLOR : selectedColor;
  
  colorEdgeInstanced(currentGrid, a, b, newColor, newColor === UNCOLORED_COLOR ? 0.015 : 0.05);
  
  // Handle activeSubgraph maintenance
  if (newColor !== UNCOLORED_COLOR) {
    if (!currentGrid.activeSubgraph) {
      currentGrid.activeSubgraph = new Subgraph(currentGrid);
    }
    currentGrid.activeSubgraph.addEdge(a, b);
  } else {
    if (currentGrid.activeSubgraph) {
      currentGrid.activeSubgraph.removeEdge(a, b);
    }
  }
  
  const afterState = captureEdgeState(clickedEdgeKey);
  recordAction('EDGE_STATE', { edgeKey: clickedEdgeKey, beforeState, afterState });
  
  // IMPORTANT: If this edge was being hovered, we need to update the visual to match the new color
  // because the hover system may have applied cyan highlight
  if (currentGrid.instancedHoverState && currentGrid.instancedHoverState.edgeKey === clickedEdgeKey) {
    // Force restore the actual new color (removes cyan highlight)
    const mapping = currentGrid.edgeToInstanceMap.get(clickedEdgeKey);
    const isColored = newColor !== UNCOLORED_COLOR;
    const mesh = isColored ? currentGrid.instancedEdgesThick : currentGrid.instancedEdgesThin;
    const instanceIdx = isColored ? mapping.thick : mapping.thin;
    
    const actualColor = new THREE.Color(newColor);
    mesh.setColorAt(instanceIdx, actualColor);
    mesh.instanceColor.needsUpdate = true;
  }
  
  // Clear hover state after click
  if (currentGrid.instancedHoverState) {
    currentGrid.instancedHoverState.edgeKey = null;
    currentGrid.instancedHoverState.originalColor = null;
  }
}



function onMouseDown(event) {
  if (!currentGrid) return;
  
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  
  // Store what was clicked on mousedown based on current mode
  switch(mode) {
    case "addEdge":
    case "addCube":
      // Handle instanced edges separately
      if (currentGrid.isInstanced) {
        // Raycast against collision mesh for easier clicking
        const collisionHits = raycaster.intersectObject(currentGrid.instancedEdgesCollision);
        
        if (collisionHits.length > 0) {
          const instanceId = collisionHits[0].instanceId;
          // Find edge key using collision index
          for (const [eKey, mapping] of currentGrid.edgeToInstanceMap.entries()) {
            if (mapping.collision === instanceId) {
              mouseDownTarget = eKey;
              mouseDownType = 'edge';
              break;
            }
          }
        }
      } else {
        // Individual edge mode - filter out nulls
        const edgeMeshes = Array.from(currentGrid.edges.values())
          .map(e => e.mesh)
          .filter(m => m !== null && m !== undefined);
        const edgeIntersects = raycaster.intersectObjects(edgeMeshes);
        if (edgeIntersects.length > 0) {
          // Find the edge key
          for (const [key, edge] of currentGrid.edges.entries()) {
            if (edge.mesh === edgeIntersects[0].object) {
              mouseDownTarget = key;
              mouseDownType = 'edge';
              break;
            }
          }
        }
      }
      break;
      
    case "addVertex":
    case "addDecoration":
      // Temporarily disable raycasting on ALL edge meshes (both modes)
      const edgeRaycastBackups = [];
      
      if (currentGrid.isInstanced) {
        // Disable instanced meshes (including collision mesh)
        if (currentGrid.instancedEdgesThin) {
          edgeRaycastBackups.push({ obj: currentGrid.instancedEdgesThin, fn: currentGrid.instancedEdgesThin.raycast });
          currentGrid.instancedEdgesThin.raycast = () => {};
        }
        if (currentGrid.instancedEdgesThick) {
          edgeRaycastBackups.push({ obj: currentGrid.instancedEdgesThick, fn: currentGrid.instancedEdgesThick.raycast });
          currentGrid.instancedEdgesThick.raycast = () => {};
        }
        if (currentGrid.instancedEdgesCollision) {
          edgeRaycastBackups.push({ obj: currentGrid.instancedEdgesCollision, fn: currentGrid.instancedEdgesCollision.raycast });
          currentGrid.instancedEdgesCollision.raycast = () => {};
        }
        if (currentGrid.instancedBlockCubes) {
          edgeRaycastBackups.push({ obj: currentGrid.instancedBlockCubes, fn: currentGrid.instancedBlockCubes.raycast });
          currentGrid.instancedBlockCubes.raycast = () => {};
        }
      } else {
        // Disable individual edge meshes
        for (const [eKey, edge] of currentGrid.edges.entries()) {
          if (edge.mesh) {
            edgeRaycastBackups.push({ obj: edge.mesh, fn: edge.mesh.raycast });
            edge.mesh.raycast = () => {};
          }
        }
      }
      
      // Force update world matrices
      currentGrid.group.updateMatrixWorld(true);
      
      const vertexHelpers = [];
      for (const [vKey, vertexData] of currentGrid.vertices.entries()) {
        if (vertexData.collisionHelper) {
          vertexHelpers.push(vertexData.collisionHelper);
        }
      }
      
      // Raycast against collision helpers
      const vertexIntersects = raycaster.intersectObjects(vertexHelpers, false);
      
      // Restore raycasting on all edge meshes
      for (const backup of edgeRaycastBackups) {
        backup.obj.raycast = backup.fn;
      }
      
      if (vertexIntersects.length > 0) {
        mouseDownTarget = vertexIntersects[0].object.userData.vertexKey;
        mouseDownType = 'vertex';
      }
      break;
      
    case "switch":
      const allMeshes = getFilteredBoxMeshes();
      const boxIntersects = raycaster.intersectObjects(allMeshes);
      if (boxIntersects.length > 0) {
        const hit = boxIntersects[0];
        let box = null;
        
        if (currentGrid.isInstanced && hit.instanceId != null) {
          // Instanced mode
          const obj = hit.object;
          if (obj === currentGrid.instancedBoxesXY) box = currentGrid.instancesXY?.[hit.instanceId];
          else if (obj === currentGrid.instancedBoxesXZ) box = currentGrid.instancesXZ?.[hit.instanceId];
          else if (obj === currentGrid.instancedBoxesYZ) box = currentGrid.instancesYZ?.[hit.instanceId];
        } else {
          // Non-instanced: search the Maps
          box = hit.object?.userData?.box;
          if (!box) {
            for (const [key, b] of [...currentGrid.boxesXY, ...currentGrid.boxesXZ, ...currentGrid.boxesYZ]) {
              if (b.mesh === hit.object) {
                box = b;
                if (box) {
                  mouseDownTarget = box;
                  mouseDownType = 'box';
                  console.log('MOUSEDOWN: Captured box', box.coords, box.plane);
                }
                break;
              }
            }
          }
        }
        
        if (box) {
          mouseDownTarget = box;
          mouseDownType = 'box';
        }
      }
      break;
  }
}

function onMouseUp(event) {
  if (!currentGrid || !mouseDownTarget) {
    mouseDownTarget = null;
    mouseDownType = null;
    return;
  }
  
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  
  let mouseUpTarget = null;
  
  // Find what was released on based on the stored type
  switch(mouseDownType) {
    case 'edge':
      // Handle instanced edges separately
      if (currentGrid.isInstanced) {
        // Raycast against collision mesh for easier clicking
        const collisionHits = raycaster.intersectObject(currentGrid.instancedEdgesCollision);
        
        if (collisionHits.length > 0) {
          const instanceId = collisionHits[0].instanceId;
          // Find edge key using collision index
          for (const [eKey, mapping] of currentGrid.edgeToInstanceMap.entries()) {
            if (mapping.collision === instanceId) {
              mouseUpTarget = eKey;
              break;
            }
          }
        }
      } else {
        // Individual edge mode - filter out nulls
        const edgeMeshes = Array.from(currentGrid.edges.values())
          .map(e => e.mesh)
          .filter(m => m !== null && m !== undefined);
        const edgeIntersects = raycaster.intersectObjects(edgeMeshes);
        if (edgeIntersects.length > 0) {
          for (const [key, edge] of currentGrid.edges.entries()) {
            if (edge.mesh === edgeIntersects[0].object) {
              mouseUpTarget = key;
              break;
            }
          }
        }
      }
      break;
      
    case 'vertex':
      const vertexHelpers = [];
      for (const [vKey, vertexData] of currentGrid.vertices.entries()) {
        if (vertexData.collisionHelper) {
          vertexHelpers.push(vertexData.collisionHelper);
        }
      }
      
      const vertexIntersects = raycaster.intersectObjects(vertexHelpers);
      if (vertexIntersects.length > 0) {
        mouseUpTarget = vertexIntersects[0].object.userData.vertexKey;
      }
      break;
      
    case 'box':
      const allMeshes = getFilteredBoxMeshes();
      const boxIntersects = raycaster.intersectObjects(allMeshes);
      if (boxIntersects.length > 0) {
        const hit = boxIntersects[0];
        let box = null;
        
        if (currentGrid.isInstanced && hit.instanceId != null) {
          // Instanced mode
          const obj = hit.object;
          if (obj === currentGrid.instancedBoxesXY) box = currentGrid.instancesXY?.[hit.instanceId];
          else if (obj === currentGrid.instancedBoxesXZ) box = currentGrid.instancesXZ?.[hit.instanceId];
          else if (obj === currentGrid.instancedBoxesYZ) box = currentGrid.instancesYZ?.[hit.instanceId];
        } else {
          // Non-instanced: search the Maps
          box = hit.object?.userData?.box;
          if (!box) {
            for (const [key, b] of [...currentGrid.boxesXY, ...currentGrid.boxesXZ, ...currentGrid.boxesYZ]) {
              if (b.mesh === hit.object) {
                box = b;
                console.log('MOUSEUP: Found box via fallback search', box.coords, box.plane);
                break;
              }
            }
          }
        }
        
        if (box) {
          mouseUpTarget = box;
        }
      }
      break;
  }
  
  // Only perform action if mousedown and mouseup targets match
  if (mouseDownTarget === mouseUpTarget && mouseUpTarget !== null) {
    performAction(mouseUpTarget, mouseDownType);
  }
  
  // Clear stored targets
  mouseDownTarget = null;
  mouseDownType = null;
}



function performAction(target, type) {
  switch(type) {
    case 'edge':
      if (mode === "addEdge") {
        if (currentGrid.isInstanced) {
          // Instanced mode edge handling
          const [aStr, bStr] = target.split("-");
          const a = aStr.split(",").map(Number);
          const b = bStr.split(",").map(Number);
          
          const edge = currentGrid.edges.get(target);
          if (!edge) return;
          
          const beforeState = captureEdgeState(target);
          
          // ARROW MODE GETS PRIORITY
          if (arrowMode) {
            if (edge.arrowDirection === 0 || edge.arrowDirection === undefined) {
              edge.arrowDirection = 1;
              colorEdgeInstanced(currentGrid, a, b, selectedColor, 0.05);
              addArrowsToEdge(edge, 1, a, b);
              
              if (!currentGrid.activeSubgraph) {
                currentGrid.activeSubgraph = new Subgraph(currentGrid);
              }
              currentGrid.activeSubgraph.addEdge(a, b);
            } else if (edge.arrowDirection === 1) {
              edge.arrowDirection = -1;
              addArrowsToEdge(edge, -1, a, b);
            } else if (edge.arrowDirection === -1) {
              edge.arrowDirection = 0;
              removeArrowsFromEdge(edge);
              colorEdgeInstanced(currentGrid, a, b, UNCOLORED_COLOR, 0.015);
              
              if (currentGrid.activeSubgraph) {
                currentGrid.activeSubgraph.removeEdge(a, b);
              }
            }
            
            const afterState = captureEdgeState(target);
            recordAction('EDGE_STATE', { edgeKey: target, beforeState, afterState });
            return;
          }
          
          // Toggle color (no arrow mode)
          const newColor = edge.color === selectedColor ? UNCOLORED_COLOR : selectedColor;
          colorEdgeInstanced(currentGrid, a, b, newColor, newColor === UNCOLORED_COLOR ? 0.015 : 0.05);
          
          // Handle activeSubgraph maintenance
          if (newColor !== UNCOLORED_COLOR) {
            if (!currentGrid.activeSubgraph) {
              currentGrid.activeSubgraph = new Subgraph(currentGrid);
            }
            currentGrid.activeSubgraph.addEdge(a, b);
          } else {
            if (currentGrid.activeSubgraph) {
              currentGrid.activeSubgraph.removeEdge(a, b);
            }
          }
          
          const afterState = captureEdgeState(target);
          recordAction('EDGE_STATE', { edgeKey: target, beforeState, afterState });
        } else {
          // Individual mode - reconstruct intersects array
          const edge = currentGrid.edges.get(target);
          if (edge && edge.mesh) {
            const intersects = [{ object: edge.mesh }];
            handleEdgeClick(intersects);
          }
        }
      } else if (mode === "addCube") {
        const edge = currentGrid.edges.get(target);
        if (edge) {
          const beforeState = captureEdgeState(target);
          
          if (currentGrid.isInstanced) {
            // Instanced mode - pass edge key
            if (edge.blockCube) {
              removeBlockCubeInstanced(currentGrid, edge, target);
            } else {
              addBlockCubeInstanced(currentGrid, edge, target);
            }
          } else {
            // Individual mode
            if (edge.blockCube) {
              removeBlockCube(edge);
            } else {
              addBlockCube(edge);
            }
          }
          
          const afterState = captureEdgeState(target);
          recordAction('EDGE_STATE', { edgeKey: target, beforeState, afterState });
        }
      }
      break;
      
    case 'vertex':
      if (mode === "addVertex") {
        handleVertexSphereClick(target);
      } else if (mode === "addDecoration") {
        handleDecorationClick(target);
      }
      break;
      
	case 'box':
	  console.log('PERFORMACTION: box case', target?.coords, 'switchable?', isSwitchable(target));
	  if (mode === "switch" && isSwitchable(target)) {
		restoreEdgeColor();
		switchBox(target);
	  }
	  break;
}
  }


function handleBackbiteClick() {
  if (!currentGrid.path || currentGrid.path.length < 3) {
    console.warn("No valid Hamiltonian path found for backbite");
    return;
  }
  
  let clickedEdgeKey = null;
  
  if (currentGrid.isInstanced) {
    // Handle instanced edge clicks
    const thinHits = raycaster.intersectObject(currentGrid.instancedEdgesThin);
    const thickHits = raycaster.intersectObject(currentGrid.instancedEdgesThick);
    
    let instanceId = null;
    let meshType = null;
    
    if (thickHits.length > 0) {
      instanceId = thickHits[0].instanceId;
      meshType = 'thick';
    } else if (thinHits.length > 0) {
      instanceId = thinHits[0].instanceId;
      meshType = 'thin';
    }
    
    if (instanceId !== null) {
      // Reverse lookup to find edge key
      for (const [eKey, mapping] of currentGrid.edgeToInstanceMap.entries()) {
        if ((meshType === 'thin' && mapping.thin === instanceId) ||
            (meshType === 'thick' && mapping.thick === instanceId)) {
          clickedEdgeKey = eKey;
          break;
        }
      }
    }
  } else {
    // Handle individual mesh clicks
    const edgeMeshes = Array.from(currentGrid.edges.values())
      .map(e => e.mesh)
      .filter(m => m !== null);
    const intersects = raycaster.intersectObjects(edgeMeshes);
    
    if (intersects.length > 0) {
      const clickedMesh = intersects[0].object;
      for (const [key, edge] of currentGrid.edges.entries()) {
        if (edge.mesh === clickedMesh) {
          clickedEdgeKey = key;
          break;
        }
      }
    }
  }
  
  if (clickedEdgeKey) {
    performManualBackbite(clickedEdgeKey);
  }
}


function handleVerticesClick() {
  console.log(`Vertices mode clicked: ${mode}`);
  
  // Calculate 3D world position from mouse click
  const vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
  vector.unproject(camera);
  const dir = vector.sub(camera.position).normalize();
  
  // Find closest vertex to the ray
  let closestVertex = null;
  let closestDistance = Infinity;
  
  for (const [vKey, vertexData] of currentGrid.vertices.entries()) {
    const vertexPos = new THREE.Vector3(...vertexData.coords);
    
    const rayOrigin = camera.position.clone();
    const toVertex = vertexPos.clone().sub(rayOrigin);
    const projectionLength = toVertex.dot(dir);
    
    if (projectionLength > 0) {
      const projection = dir.clone().multiplyScalar(projectionLength);
      const rejection = toVertex.clone().sub(projection);
      const distanceToRay = rejection.length();
      
      if (distanceToRay < 0.3 && projectionLength < closestDistance) {
        closestDistance = projectionLength;
        closestVertex = vKey;
      }
    }
  }
  
  if (closestVertex) {
    console.log("Clicked vertex:", closestVertex);
    
    // Behavior based on current mode
    if (mode === "addDecoration") {
      handleDecorationClick(closestVertex);
    } else if (mode === "addVertex") {
      handleVertexSphereClick(closestVertex);
    }
  } else {
    console.log("No vertex close enough to click");
  }
}


function handleSwitchClick() {
  const targets = getFilteredBoxMeshes();
  const hits = raycaster.intersectObjects(targets, false);
  if (!hits.length) return;

  const hit = hits[0];
  let box = null;
  let type = null;
  let center = null;

  if (currentGrid.isInstanced && hit.instanceId != null) {
    const obj = hit.object;

    if (obj === currentGrid.instancedBoxesXY) {
      box = currentGrid.instancesXY?.[hit.instanceId];
      type = 'XY';
    } else if (obj === currentGrid.instancedBoxesXZ) {
      box = currentGrid.instancesXZ?.[hit.instanceId];
      type = 'XZ';
    } else if (obj === currentGrid.instancedBoxesYZ) {
      box = currentGrid.instancesYZ?.[hit.instanceId];
      type = 'YZ';
    }

    if (box) {
      const m = new THREE.Matrix4();
      const p = new THREE.Vector3();
      const q = new THREE.Quaternion();
      const s = new THREE.Vector3();
      obj.getMatrixAt(hit.instanceId, m);
      m.decompose(p, q, s);
      center = p;
    }
  } else if (hit.object?.userData?.box) {
    box = hit.object.userData.box;
    type = box?.plane || null;
    if (box) {
      const [x, y, z] = box.coords;
      if (type === 'XY') center = new THREE.Vector3(x + 0.5, y + 0.5, z);
      else if (type === 'XZ') center = new THREE.Vector3(x + 0.5, y, z + 0.5);
      else center = new THREE.Vector3(x, y + 0.5, z + 0.5);
    }
  } else {
    // Non-instanced fallback: search the Maps
    for (const [key, b] of [...currentGrid.boxesXY, ...currentGrid.boxesXZ, ...currentGrid.boxesYZ]) {
      if (b.mesh === hit.object) {
        box = b;
        type = box.plane || null;
        if (box) {
          const [x, y, z] = box.coords;
          if (type === 'XY') center = new THREE.Vector3(x + 0.5, y + 0.5, z);
          else if (type === 'XZ') center = new THREE.Vector3(x + 0.5, y, z + 0.5);
          else center = new THREE.Vector3(x, y + 0.5, z + 0.5);
        }
        console.log('handleSwitchClick: Found box via fallback search', box.coords, box.plane);
        break;
      }
    }
  }

  if (!box) return;

  // expose for downstream logic
  if (center) {
    box.__hitCenter = { x: center.x, y: center.y, z: center.z };
    box.__hitPlane  = type;
  }

  switchBox(box);
}


function handleDefaultClick() {
  // Edge click-to-color mode
  if (!edgeClickEnabled) return;

  const edgeMeshes = Array.from(currentGrid.edges.values()).map(e => e.mesh).filter(m => m);
  const intersects = raycaster.intersectObjects(edgeMeshes);
  if (intersects.length > 0) {
    handleEdgeClick(intersects);
  }
}


// Handle vertex sphere creation/removal only
function handleVertexSphereClick(vertexKey) {
  const beforeState = captureVertexSphereState(vertexKey);
  
  if (!currentGrid.vertexSpheres.has(vertexKey)) {
    // Create new vertex sphere
    createVertexSphere(currentGrid, vertexKey, selectedColor);
  } else {
    // Remove existing vertex sphere
    removeVertexSphere(currentGrid, vertexKey);
  }
  
  const afterState = captureVertexSphereState(vertexKey);
  recordAction('VERTEX_SPHERE', { vertexKey, beforeState, afterState });
}

// Handle decoration addition/removal only
function handleDecorationClick(vertexKey) {
  // Create vertex sphere if it doesn't exist
  if (!currentGrid.vertexSpheres.has(vertexKey)) {
    const [x, y, z] = vertexKey.split(',').map(Number);
    addVertex(currentGrid, x, y, z);
  }

  const beforeState = captureVertexSphereState(vertexKey);
  const sphereData = currentGrid.vertexSpheres.get(vertexKey);
  
  if (sphereData.decoration) {
    // Remove decoration
    currentGrid.group.remove(sphereData.decoration);
    if (sphereData.decoration.children) {
      sphereData.decoration.children.forEach(child => {
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
      });
    }
    sphereData.decoration = null;
  } else {
    // Add decoration
    addVertexDecoration(currentGrid, vertexKey, selectedColor2);
  }
  
  const afterState = captureVertexSphereState(vertexKey);
  recordAction('VERTEX_DECORATION', { vertexKey, beforeState, afterState });
}



function onMouseMove(event) {
  if (!currentGrid) return;
  
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  
  clearAllHighlights();
  
  if (coordinateHoverMode) {
    handleCoordinateHover(event);
  } else {
    // Handle hover based on current mode
    switch(mode) {
      case "addEdge":
      case "addCube":
        handleEdgeHover();
        break;
      case "addVertex":
      case "addDecoration":
        handleVertexHover();
        break;
      case "switch":
        console.log('[onMouseMove] Mode is SWITCH - calling handleBoxHover()');
        handleBoxHover();
        break;
      default:
        // No hover effects in default/backbite modes
        break;
    }
  }
  
  // Set default cursor if no handler changed it
  if (document.body.style.cursor !== 'pointer') {
    document.body.style.cursor = 'default';
  }
}



function clearAllHighlights() {
  // Clear edge highlights
  if (currentGrid.highlightOverlay) {
    currentGrid.highlightOverlay.visible = false;
  }
  if (window.highlightedEdge) {
    const originalColor = window.highlightedEdge.userData.originalColor || 0x888888;
    window.highlightedEdge.material.color.setHex(originalColor);
    window.highlightedEdge.material.opacity = window.highlightedEdge.userData.originalOpacity || 1;
    
    if (window.highlightedEdge.userData.wasHidden) {
      window.highlightedEdge.visible = false;
    }
    window.highlightedEdge = null;
  }
  
  // Clear vertex highlights
  if (currentGrid.vertexHighlight) {
    currentGrid.group.remove(currentGrid.vertexHighlight);
    currentGrid.vertexHighlight = null;
  }
}


function handleEdgeHover() {
  if (currentGrid.isInstanced) {
    handleInstancedEdgeHover();
    return;
  }
  
  // Filter out null meshes before raycasting
  const edgeMeshes = Array.from(currentGrid.edges.values())
    .map(e => e.mesh)
    .filter(m => m !== null);
  
  const intersects = raycaster.intersectObjects(edgeMeshes);
  
  if (intersects.length > 0) {
    const hoveredMesh = intersects[0].object;
    
    // Find edge data
    let edgeData = null;
    for (const [key, edge] of currentGrid.edges.entries()) {
      if (edge.mesh === hoveredMesh) {
        edgeData = edge;
        break;
      }
    }
    
    if (edgeData && edgeData.color === UNCOLORED_COLOR) {
      // Create overlay highlight for uncolored edges
      if (!currentGrid.highlightOverlay) {
        const highlightGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
        const highlightMaterial = new THREE.MeshBasicMaterial({ 
          color: 0x00ffff,
          transparent: true, 
          opacity: 0.5,
          depthTest: false
        });
        currentGrid.highlightOverlay = new THREE.Mesh(highlightGeometry, highlightMaterial);
        currentGrid.group.add(currentGrid.highlightOverlay);
      }
      
      const length = hoveredMesh.geometry.parameters.height;
      currentGrid.highlightOverlay.scale.y = length;
      currentGrid.highlightOverlay.position.copy(hoveredMesh.position);
      currentGrid.highlightOverlay.quaternion.copy(hoveredMesh.quaternion);
      
      // Nudge slightly toward camera to avoid z-fighting
      const cameraDirection = new THREE.Vector3();
      camera.getWorldDirection(cameraDirection);
      currentGrid.highlightOverlay.position.add(cameraDirection.multiplyScalar(-0.001));
      
      currentGrid.highlightOverlay.visible = true;
      
      if (!hoveredMesh.visible) {
        hoveredMesh.visible = true;
        window.highlightedEdge = hoveredMesh;
        window.highlightedEdge.userData.wasHidden = true;
      }
    } else {
      // Color change for colored edges
      hoveredMesh.userData.originalColor = hoveredMesh.material.color.getHex();
      hoveredMesh.userData.originalOpacity = hoveredMesh.material.opacity;
      hoveredMesh.userData.wasHidden = !hoveredMesh.visible;
      
      hoveredMesh.visible = true;
      hoveredMesh.material.color.setHex(0x00ffff);
      hoveredMesh.material.opacity = 1;
      
      window.highlightedEdge = hoveredMesh;
    }
    
    document.body.style.cursor = 'pointer';
  }
}


// =================== I.E.R. FUNCTIONS =================

function handleInstancedEdgeHover() {
  // Raycast against collision mesh for easier hovering
  const collisionHits = raycaster.intersectObject(currentGrid.instancedEdgesCollision);
  
  if (collisionHits.length > 0) {
    const instanceId = collisionHits[0].instanceId;
    
    // Find the edge key
    let edgeKey = null;
    for (const [eKey, mapping] of currentGrid.edgeToInstanceMap.entries()) {
      if (mapping.collision === instanceId) {
        edgeKey = eKey;
        break;
      }
    }
    
    if (edgeKey) {
      const edge = currentGrid.edges.get(edgeKey);
      
      if (edge) {
        // Create highlight overlay if it doesn't exist
        if (!currentGrid.highlightOverlay) {
          const highlightGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
          const highlightMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x00ffff,
            transparent: true, 
            opacity: 0.5,
            depthTest: false
          });
          currentGrid.highlightOverlay = new THREE.Mesh(highlightGeometry, highlightMaterial);
          currentGrid.group.add(currentGrid.highlightOverlay);
        }
        
        // Get edge position from appropriate mesh (thin or thick)
        const matrix = new THREE.Matrix4();
        const isThick = (edge.color !== UNCOLORED_COLOR);
        
        if (isThick) {
          currentGrid.instancedEdgesThick.getMatrixAt(instanceId, matrix);
        } else {
          currentGrid.instancedEdgesThin.getMatrixAt(instanceId, matrix);
        }
        
        const position = new THREE.Vector3();
        const quaternion = new THREE.Quaternion();
        const scale = new THREE.Vector3();
        matrix.decompose(position, quaternion, scale);
        
        // Apply to highlight overlay
        currentGrid.highlightOverlay.position.copy(position);
        currentGrid.highlightOverlay.quaternion.copy(quaternion);
        currentGrid.highlightOverlay.scale.y = scale.y;
        
        // Nudge slightly toward camera to avoid z-fighting
        const cameraDirection = new THREE.Vector3();
        camera.getWorldDirection(cameraDirection);
        currentGrid.highlightOverlay.position.add(cameraDirection.multiplyScalar(-0.001));
        
        currentGrid.highlightOverlay.visible = true;
        
        window.highlightedEdgeKey = edgeKey;
        document.body.style.cursor = 'pointer';
      }
    }
  }
}



function restoreInstancedEdgeColor(edgeKey, storedColor, meshType) {
  const mapping = currentGrid.edgeToInstanceMap.get(edgeKey);
  if (!mapping) return;
  
  const mesh = meshType === 'thin' ? currentGrid.instancedEdgesThin : currentGrid.instancedEdgesThick;
  const instanceIdx = meshType === 'thin' ? mapping.thin : mapping.thick;
  
  // Use the stored color directly (already has correct dimming applied)
  mesh.setColorAt(instanceIdx, storedColor);
  mesh.instanceColor.needsUpdate = true;
}


// =================== I.E.R. FUNCTIONS =================

function handleVertexHover() {
  // Get all vertex collision helpers
  const vertexHelpers = [];
  for (const [vKey, vertexData] of currentGrid.vertices.entries()) {
    if (vertexData.collisionHelper) {
      vertexHelpers.push(vertexData.collisionHelper);
    }
  }
  
  const intersects = raycaster.intersectObjects(vertexHelpers);
  
  if (intersects.length > 0) {
    const hoveredHelper = intersects[0].object;
    const vertexKey = hoveredHelper.userData.vertexKey;
    const [x, y, z] = vertexKey.split(',').map(Number);
    
    // Create highlight sphere
    const highlightGeometry = new THREE.SphereGeometry(0.12, 16, 16);
    const highlightMaterial = new THREE.MeshBasicMaterial({ 
      color: 0x00ffff,
      transparent: true, 
      opacity: 0.6,
      depthTest: false
    });
    currentGrid.vertexHighlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
    currentGrid.vertexHighlight.position.set(x, y, z);
    currentGrid.group.add(currentGrid.vertexHighlight);
    
    document.body.style.cursor = 'pointer';
  }
}



// --- 2) Hover handler that supports both instanced and non-instanced boxes ---
function handleBoxHover() {
  console.log('[handleBoxHover] CALLED');
  
  const meshes = getFilteredBoxMeshes();
  console.log('[handleBoxHover] Filtered meshes:', meshes.length, 'meshes returned');
  
  if (meshes.length > 0) {
    console.log('[handleBoxHover] Mesh details:', meshes.map(m => ({
      type: m.type,
      visible: m.visible,
      opacity: m.material?.opacity,
      transparent: m.material?.transparent,
      parent: m.parent?.type
    })));
  }
  
  const hits = raycaster.intersectObjects(meshes, false);
  console.log('[handleBoxHover] Raycaster hits:', hits.length);
  
  if (!hits.length) { 
    console.log('[handleBoxHover] NO HITS - clearing highlight');
    clearHoveredBoxHighlight?.(); 
    document.body.style.cursor = 'default'; 
    return; 
  }
  
  console.log('[handleBoxHover] HIT DETECTED!');
  const hit = hits[0];
  console.log('[handleBoxHover] Hit details:', {
    instanceId: hit.instanceId,
    object: hit.object.type,
    distance: hit.distance
  });
  
  let obj = hit.object;
  let box = null;
  let type = null;
  
  if (currentGrid.isInstanced && hit.instanceId != null) {
    console.log('[handleBoxHover] Instanced mode - checking instance arrays');
    
    if (obj === currentGrid.instancedBoxesXY) { 
      type = 'XY'; 
      box = currentGrid.instancesXY[hit.instanceId]; 
      console.log('[handleBoxHover] XY box at instanceId', hit.instanceId, ':', box ? 'FOUND' : 'NOT FOUND');
    }
    else if (obj === currentGrid.instancedBoxesXZ) { 
      type = 'XZ'; 
      box = currentGrid.instancesXZ[hit.instanceId]; 
      console.log('[handleBoxHover] XZ box at instanceId', hit.instanceId, ':', box ? 'FOUND' : 'NOT FOUND');
    }
    else if (obj === currentGrid.instancedBoxesYZ) { 
      type = 'YZ'; 
      box = currentGrid.instancesYZ[hit.instanceId]; 
      console.log('[handleBoxHover] YZ box at instanceId', hit.instanceId, ':', box ? 'FOUND' : 'NOT FOUND');
    }
    
    if (box) {
      const m = new THREE.Matrix4(), p = new THREE.Vector3(), q = new THREE.Quaternion(), s = new THREE.Vector3();
      obj.getMatrixAt(hit.instanceId, m);
      m.decompose(p, q, s);
      console.log('[handleBoxHover] Box scale:', s.x, s.y, s.z);
      box.__hitCenter = { x: p.x, y: p.y, z: p.z };
      box.__hitPlane  = type;
    }
  } else {
    console.log('[handleBoxHover] Non-instanced mode');
    // non-instanced mode unchanged
    const mesh = hit.object;
    box = mesh.userData.box;
    type = box?.plane || null;
    if (box) {
      const [x,y,z] = box.coords;
      box.__hitCenter = (type === 'XY') ? {x:x+0.5,y:y+0.5,z:z}
                      : (type === 'XZ') ? {x:x+0.5,y:y,z:z+0.5}
                                        : {x:x,y:y+0.5,z:z+0.5};
      box.__hitPlane  = type;
    }
  }
  
  if (!box) { 
    console.log('[handleBoxHover] Box not found after lookup - clearing highlight');
    clearHoveredBoxHighlight?.(); 
    document.body.style.cursor = 'default'; 
    return; 
  }
  
  console.log('[handleBoxHover] SUCCESS - Box found:', box.coords, 'plane:', type);
  highlightHoveredBox(box);  // consume __hitCenter/__hitPlane
  document.body.style.cursor = 'pointer';
}










//     ====================================================================================================================
// 										  8. LAYOUT FUNCTIONS AND ANIMATE FUNCTIONS
//     ====================================================================================================================


const scene = new THREE.Scene();
scene.background = new THREE.Color(0xf5f5dc);
updateTheme('paper-white'); // Initialize with default light theme
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
const centerX = GRID_WIDTH / 2;
const centerY = GRID_HEIGHT / 2;
const centerZ = GRID_DEPTH / 2;

camera.position.set(centerX+8, centerY+8, centerZ+13); // Zooms out if large
camera.lookAt(centerX, centerY, centerZ);
const renderer = new THREE.WebGLRenderer({ antialias: true });
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.zoomSpeed = 0.5 * cameraSensitivity; // Scaled by sensitivity
controls.dampingFactor = 0.15;
controls.rotateSpeed = cameraSensitivity; // Set initial camera sensitivity
controls.screenSpacePanning = false;
controls.minDistance = 0.5;
controls.maxDistance = 500;
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);



function animate() {
  requestAnimationFrame(animate);
  controls.update();  // required for damping to work
  renderer.render(scene, camera);
}
animate();
initializeColorInterface();
renderer.setSize(window.innerWidth, window.innerHeight);

// Show coordinate axes on page load (after everything is set up)
window.addEventListener('load', () => {
  toggleCoordinateAxes();
});



///     ====================================================================================================================
// 										  9. SAVE AND LOAD FUNCTION
//     ================================================================================================================================

//     =========================================
// 		*** 9.1. Save and related Functions ***
//     =========================================
function serializeGridState() {
  const saveData = {
    version: "1.0",
    app: "3D-Hamilton",
    timestamp: new Date().toISOString(),
    currentGridId: getCurrentGridId(),
    globalSettings: {
      selectedColor: selectedColor,
      selectedColor2: selectedColor2,
      gridVisible: gridVisible,
      gradientMode: gradientMode,
      arrowMode: arrowMode,
      mode: mode,
      activeEndpoint: activeEndpoint,
      edgeClickEnabled: edgeClickEnabled,
      useInstancedRendering: useInstancedRendering // Save rendering mode
    },
    sceneState: {
      coordinatesVisible: scene.userData.coordGroup?.visible || false
    },
    grids: {}
  };

  for (const [id, grid] of allGrids.entries()) {
    saveData.grids[id] = serializeGrid(grid);
  }

  return JSON.stringify(saveData, null, 2);
}

function applyGlobalVisibilitySettings() {
  console.log(`Applying global visibility: gridVisible = ${gridVisible}`);
  
  for (const [gridId, grid] of allGrids.entries()) {
    if (!grid || !grid.edges) {
      console.warn(`Grid ${gridId} has no edges to update visibility`);
      continue;
    }
    
    if (grid.isInstanced) {
      // In instanced mode, visibility is controlled differently
      // For now, we'll skip this - instanced edges are always visible
      console.log(`Skipping visibility update for instanced grid ${gridId}`);
      continue;
    }
    
    let updatedCount = 0;
    for (const [edgeKey, edge] of grid.edges.entries()) {
      if (!edge.mesh) continue;
      
      const isColored = edge.color !== UNCOLORED_COLOR;
      if (!isColored) {
        edge.mesh.visible = gridVisible;
        updatedCount++;
      }
    }
    console.log(`Updated visibility for ${updatedCount} uncolored edges in grid ${gridId}`);
  }
}

function serializeGrid(grid) {
  const gridData = {
    dimensions: {
      width: grid.width,
      height: grid.height,
      depth: grid.depth
    },
    edges: {},
    vertices: {},
    path: null,
    notes: grid.notes || "",
    cameraState: {
      position: grid.cameraPosition ? {
        x: grid.cameraPosition.x,
        y: grid.cameraPosition.y,
        z: grid.cameraPosition.z
      } : null,
      target: grid.cameraTarget ? {
        x: grid.cameraTarget.x,
        y: grid.cameraTarget.y,
        z: grid.cameraTarget.z
      } : null
    }
  };

  // Save ALL edge states including visibility, arrows, and block cubes
  for (const [edgeKey, edge] of grid.edges.entries()) {
    const needsSaving = edge.color !== UNCOLORED_COLOR || 
                       edge.arrows || 
                       edge.blockCube;
    
    if (needsSaving) {
      const edgeState = {
        color: edge.color,
        hasArrows: !!edge.arrows,
        arrowDirection: edge.arrowDirection || 0,
        hasBlockCube: !!edge.blockCube
      };
      
      // Only save visibility if in individual mode (has mesh)
      if (edge.mesh) {
        edgeState.visible = edge.mesh.visible;
      }
      
      gridData.edges[edgeKey] = edgeState;
    }
  }

  // Save vertex spheres
  if (grid.vertexSpheres) {
    for (const [vertexKey, sphereData] of grid.vertexSpheres.entries()) {
      // Get color (works for both instanced and individual mode)
      const color = grid.isInstanced 
        ? sphereData.color 
        : sphereData.sphere.material.color.getHex();
      
      const vertexInfo = {
        color: color
      };
      
      // Save decoration info if present
      if (sphereData.decoration) {
        vertexInfo.hasDecoration = true;
        // Handle both old single-mesh and new group decorations
        if (sphereData.decoration.children && sphereData.decoration.children.length > 0) {
          vertexInfo.decorationColor = sphereData.decoration.children[0].material.color.getHex();
        } else {
          vertexInfo.decorationColor = sphereData.decoration.material.color.getHex();
        }
      }
      
      gridData.vertices[vertexKey] = vertexInfo;
    }
  }

  // Serialize path
  if (Array.isArray(grid.path) && grid.path.length > 0) {
    gridData.path = grid.path.map(v => 
      typeof v === 'string' ? v : `${v[0]},${v[1]},${v[2] || 0}`
    );
  }

  return gridData;
}

function getCurrentGridId() {
  if (!currentGrid) return null;
  
  for (const [id, grid] of allGrids.entries()) {
    if (grid === currentGrid) return id;
  }
  return null;
}

function saveToFile() {
  try {
    // Generate default timestamp-based filename
    const defaultName = `grid-graph-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}`;
    
    // Prompt user for filename with timestamp as default
    const userInput = prompt("Enter filename for save:", defaultName);
    
    // If user cancelled, don't save
    if (userInput === null) {
      console.log('Save cancelled by user');
      return;
    }
    
    // Use user input, but ensure it has .json extension
    let filename = userInput.trim();
    if (filename === '') {
      filename = defaultName; // Fallback to default if empty
    }
    if (!filename.toLowerCase().endsWith('.json')) {
      filename += '.json';
    }
    
    const jsonData = serializeGridState();
    const blob = new Blob([jsonData], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    // Mark that work was just saved
    lastSaveTime = Date.now();
    
    console.log('Grid state saved as:', filename);
  } catch (error) {
    console.error('Error saving grid state:', error);
    alert('Error saving file: ' + error.message);
  }
}

//     =========================================
// 		*** 9.2. Load and related Functions ***
//     =========================================

function loadFromFile(file) {
  const reader = new FileReader();
  
  reader.onload = function(e) {
    try {
      const saveData = JSON.parse(e.target.result);
      loadGridState(saveData);
    } catch (error) {
      console.error('Error loading grid state:', error);
      alert('Error loading file: ' + error.message);
    }
  };
  
  reader.onerror = function() {
    alert('Error reading file');
  };
  
  reader.readAsText(file);
}

function loadGridState(saveData) {
  // Validate save data
  if (!saveData.version || !saveData.grids) {
    throw new Error('Invalid save file format');
  }
  
  // Version check
  if (saveData.version !== '1.0') {
    console.warn('Unknown save version:', saveData.version);
  }

  // Clear existing grids
  clearAllGrids();

  // Restore global settings using nullish coalescing
  if (saveData.globalSettings) {
    const gs = saveData.globalSettings;
    selectedColor = gs.selectedColor ?? selectedColor;
    selectedColor2 = gs.selectedColor2 ?? selectedColor2;
    
    // Restore rendering mode
    
    // DON'T restore gridVisible yet - we'll handle it after loading grids
    const savedGridVisible = gs.gridVisible ?? true; // Store for later use
    gradientMode = gs.gradientMode ?? gradientMode;
    arrowMode = gs.arrowMode ?? arrowMode;
    mode = gs.mode ?? mode;
    activeEndpoint = gs.activeEndpoint ?? activeEndpoint;
    
    // Update UI elements
    updateGlobalUI();
  } else {
    var savedGridVisible = true; // Default if no settings saved
  }

  // Load each grid
  for (const [gridId, gridData] of Object.entries(saveData.grids)) {
    try {
      loadGridData(gridId, gridData);
    } catch (error) {
      console.error(`Error loading grid ${gridId}:`, error);
      continue; // Skip this grid but continue with others
    }
  }

  // Update gridCounter to avoid ID collisions
  const numericIds = Object.keys(saveData.grids)
    .map(id => parseInt(id.replace(/\D/g, ''), 10))
    .filter(n => Number.isFinite(n));
  gridCounter = (numericIds.length ? Math.max(...numericIds) : -1) + 1;

  // Apply grid visibility AFTER all grids are loaded
  gridVisible = savedGridVisible;
  applyGlobalVisibilitySettings();

  // Set current grid after all loading is complete
  requestAnimationFrame(() => {
    if (saveData.currentGridId && allGrids.has(saveData.currentGridId)) {
      switchToGrid(saveData.currentGridId);
    } else if (allGrids.size > 0) {
      switchToGrid(allGrids.keys().next().value);
    }
    
    console.log(`Loaded ${Object.keys(saveData.grids).length} grids successfully`);
  });
}

function loadGridData(gridId, gridData) {
  console.log(`Loading grid: ${gridId}`);
  
  // Set grid dimensions
  GRID_WIDTH = gridData.dimensions.width;
  GRID_HEIGHT = gridData.dimensions.height;
  GRID_DEPTH = gridData.dimensions.depth;

  // Create the grid structure
  const grid = createEmptyGridData();
  grid.width = gridData.dimensions.width;
  grid.height = gridData.dimensions.height;
  grid.depth = gridData.dimensions.depth;

  // Build basic grid content
  buildGridContent(grid);

  // Restore camera state
  if (gridData.cameraState.position) {
    grid.cameraPosition = new THREE.Vector3(
      gridData.cameraState.position.x,
      gridData.cameraState.position.y,
      gridData.cameraState.position.z
    );
  }
  if (gridData.cameraState.target) {
    grid.cameraTarget = new THREE.Vector3(
      gridData.cameraState.target.x,
      gridData.cameraState.target.y,
      gridData.cameraState.target.z
    );
  }

  // Restore edge states
  for (const [edgeKey, edgeState] of Object.entries(gridData.edges)) {
    const [aStr, bStr] = edgeKey.split("-");
    const a = aStr.split(",").map(Number);
    const b = bStr.split(",").map(Number);
    
    const edge = grid.edges.get(edgeKey);
    if (!edge) continue;
    
    // Color the edge
    if (edgeState.color !== UNCOLORED_COLOR) {
      if (grid.isInstanced) {
        colorEdgeInstanced(grid, a, b, edgeState.color, 0.05);
      } else {
        grid.group.remove(edge.mesh);
        const newMesh = makeEdgeMesh(a, b, edgeState.color, 0.05);
        grid.edges.set(edgeKey, {
          ...edge,
          color: edgeState.color,
          mesh: newMesh
        });
        grid.group.add(newMesh);
      }
    }
    
    // Set edge visibility (only for individual mode)
    if (!grid.isInstanced && edge.mesh && edgeState.visible !== undefined) {
      edge.mesh.visible = edgeState.visible;
    }
    
    // Restore block cubes
    if (edgeState.hasBlockCube) {
      if (grid.isInstanced) {
        addBlockCubeInstanced(grid, edge, edgeKey);
      } else {
        // Create block cube manually for individual mode
        const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
        const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const cube = new THREE.Mesh(geometry, material);
        
        if (edge.mesh) {
          cube.position.copy(edge.mesh.position);
        }
        cube.raycast = () => {};
        
        edge.blockCube = cube;
        grid.group.add(cube);
      }
    }
    
    // Add arrows with temporary currentGrid swap
    if (edgeState.hasArrows && edgeState.arrowDirection) {
      if (edge && !edge.arrows) {
        const tempCurrentGrid = currentGrid;
        currentGrid = grid;
        addArrowsToEdge(edge, edgeState.arrowDirection);
        currentGrid = tempCurrentGrid;
      }
    }
  }

  // Restore vertex spheres (handle both old and new formats)
  if (gridData.vertices) {
    for (const [vertexKey, vertexState] of Object.entries(gridData.vertices)) {
      const [x, y, z] = vertexKey.split(',').map(Number);
      const geometry = new THREE.SphereGeometry(0.12, 16, 16);
      const material = new THREE.MeshBasicMaterial({ color: vertexState.color });
      const sphere = new THREE.Mesh(geometry, material);
      sphere.position.set(x, y, z);
      
      grid.group.add(sphere);
      
      // Store in new format (with sphere/decoration structure)
      grid.vertexSpheres.set(vertexKey, {
        sphere: sphere,
        decoration: null
      });
      
      // If the old save had decoration data, restore it
      if (vertexState.hasDecoration && vertexState.decorationColor) {
        addVertexDecoration(grid, vertexKey, vertexState.decorationColor);
      }
    }
  }

  // Restore notes (with backward compatibility)
  if (gridData.notes) {
    // Check if it's HTML (contains tags) or plain text
    const isHtml = /<[a-z][\s\S]*>/i.test(gridData.notes);
    if (isHtml) {
      grid.notes = gridData.notes;
    } else {
      // Convert plain text to HTML
      grid.notes = `<p>${gridData.notes.replace(/\n/g, '</p><p>')}</p>`;
    }
  } else {
    grid.notes = "";
  }

  // Restore path data with proper visual updates
  if (Array.isArray(gridData.path) && gridData.path.length > 0) {
    grid.path = gridData.path.slice(); // Copy array
    
    // Rebuild activeSubgraph from path
    grid.activeSubgraph = new Subgraph(grid);
    for (let i = 0; i < gridData.path.length - 1; i++) {
      const a = gridData.path[i].split(',').map(Number);
      const b = gridData.path[i + 1].split(',').map(Number);
      grid.activeSubgraph.edges.add(edgeKey(a, b));
      grid.activeSubgraph.vertices.add(gridData.path[i]);
      grid.activeSubgraph.vertices.add(gridData.path[i + 1]);
    }
    
    // Check if this was a cycle (path length equals total vertices)
    const isCycle = gridData.path.length === grid.width * grid.height * grid.depth;
    if (isCycle) {
      // Add closing edge to activeSubgraph for cycles
      const lastVertex = gridData.path[gridData.path.length - 1];
      const firstVertex = gridData.path[0];
      const a = lastVertex.split(',').map(Number);
      const b = firstVertex.split(',').map(Number);
      grid.activeSubgraph.edges.add(edgeKey(a, b));
    }
    
    // Restore endpoint markers for paths (not cycles)
    if (!isCycle && gridData.path.length >= 2) {
      updateEndpointMarkers(grid);
    }
  }

  // Add to grids collection and create UI
  allGrids.set(gridId, grid);
  createGridButton(gridId);
  
  console.log(`Grid ${gridId} loaded successfully`);
}


function clearAllGrids() {
  // Remove all grid groups from scene and dispose resources
  for (const [id, grid] of allGrids.entries()) {
    if (grid && grid.group) {
      scene.remove(grid.group);
      // Dispose geometries and materials to prevent memory leaks
      grid.group.traverse((child) => {
        if (child.geometry) child.geometry.dispose();
        if (child.material) {
          if (Array.isArray(child.material)) {
            child.material.forEach(mat => mat.dispose());
          } else {
            child.material.dispose();
          }
        }
      });
    }
  }
  
  // Clear grid list UI
  const gridList = document.getElementById("gridList");
  if (gridList) gridList.innerHTML = "";
  
  // Clear collections
  allGrids.clear();
  currentGrid = null;
  gridCounter = 0;
}

function updateAllVerticesVisibility() {
  // Update vertex visibility for all grids based on showAllVertices preference
  for (const [gridId, grid] of allGrids.entries()) {
    if (!grid || !grid.isInstanced || !grid.instancedVertexSpheres) continue;
    
    const grayColor = new THREE.Color(0x888888);
    const zeroMatrix = new THREE.Matrix4().makeScale(0, 0, 0);
    const identityMatrix = new THREE.Matrix4();
    
    for (const [vKey, instanceIndex] of grid.vertexToInstanceMap.entries()) {
      // Check if this vertex already has a colored sphere
      const vertexData = grid.vertexSpheres?.get(vKey);
      const hasColoredSphere = vertexData && vertexData.sphere;
      
      if (hasColoredSphere) {
        // Don't show gray sphere if there's already a colored one
        grid.instancedVertexSpheres.setMatrixAt(instanceIndex, zeroMatrix);
      } else if (showAllVertices) {
        // Show gray sphere at this vertex
        const [x, y, z] = vKey.split(',').map(Number);
        identityMatrix.setPosition(x, y, z);
        grid.instancedVertexSpheres.setMatrixAt(instanceIndex, identityMatrix);
        grid.instancedVertexSpheres.setColorAt(instanceIndex, grayColor);
      } else {
        // Hide sphere
        grid.instancedVertexSpheres.setMatrixAt(instanceIndex, zeroMatrix);
      }
    }
    
    grid.instancedVertexSpheres.instanceMatrix.needsUpdate = true;
    if (grid.instancedVertexSpheres.instanceColor) {
      grid.instancedVertexSpheres.instanceColor.needsUpdate = true;
    }
  }
  
  console.log(`All vertices visibility updated: ${showAllVertices ? 'shown' : 'hidden'}`);
}

function updateGlobalUI() {
  // Update color pickers with safety checks
  const colorInput = document.getElementById("colorInput");
  const colorInput2 = document.getElementById("colorInput2");
  
  if (colorInput) {
    colorInput.value = "#" + selectedColor.toString(16).padStart(6, '0');
  }
  if (colorInput2) {
    colorInput2.value = "#" + selectedColor2.toString(16).padStart(6, '0');
  }
  
  // Update button states
  const gradientCheckbox = document.getElementById("gradientCheckbox");
  if (gradientCheckbox) {
    gradientCheckbox.checked = gradientMode;
  }
  
  const arrowCheckbox = document.getElementById("arrowCheckbox");
  if (arrowCheckbox) arrowCheckbox.checked = arrowMode;
  
  const switchBtn = document.getElementById("switchPill");
  if (switchBtn) switchBtn.classList.toggle("active", mode === "switch");
  
  const backbiteBtn = document.getElementById("backbitePill");
  if (backbiteBtn) backbiteBtn.classList.toggle("active", mode === "backbite");
}

function applyCameraState(grid) {
  // Guard against undefined camera/controls
  if (typeof camera === 'undefined' || typeof controls === 'undefined') {
    console.warn('Camera or controls not available for state restoration');
    return;
  }
  
  if (!grid) {
    console.warn('No grid provided to applyCameraState');
    return;
  }
  
  if (grid.cameraPosition && grid.cameraTarget) {
    camera.position.copy(grid.cameraPosition);
    controls.target.copy(grid.cameraTarget);
    controls.update();
    console.log("Applied saved camera state");
  } else {
    // Default positioning for loaded grids
    const maxDim = Math.max(grid.width, grid.height, grid.depth);
    camera.position.set(maxDim * 1.5, maxDim * 1.5, maxDim * 1.5);
    camera.lookAt(0, 0, 0);
    controls.target.set(0, 0, 0);
    controls.update();
    console.log("Applied default camera state");
  }
}

function createFileInput() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';
  input.style.display = 'none';
  
  input.addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (file) {
      loadFromFile(file);
    }
    // Reset input to allow loading the same file again
    this.value = '';
  });
  
  return input;
}

const fileInput = createFileInput();
document.body.appendChild(fileInput);

function promptLoadFile() {
  fileInput.click();
}

function saveGrid() {
  if (allGrids.size === 0) {
    alert("No grids to save");
    return;
  }
  saveToFile();
}

function loadGridFromDisk() {
  promptLoadFile();
}

  </script>
</body>
</html>

