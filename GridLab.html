<!DOCTYPE html>
<!--
================================================================================
  GridLab - 3D Grid Graph Visualization & Hamiltonian Path/Cycle Tool
  
  Copyright © 2025 Albi. All rights reserved.
  
  Version: 2.1.0
  Build: GL-2025-11A7B91F3E-YORK
  Author: Albi (York University)
  Contact: albijuventus@yahoo.com
  Website: https://graphsofwrath.com
  
  LICENSED UNDER: PolyForm Noncommercial License 1.0.0
  
  This software implements novel algorithms for Hamiltonian cycle and path
  reconfiguration on rectangular grid graphs, based on doctoral research
  conducted at York University (2024).
  
================================================================================
  
  PolyForm Noncommercial License 1.0.0
  
  https://polyformproject.org/licenses/noncommercial/1.0.0
  
  Acceptance
  
  In order to get any license under these terms, you must agree to them as
  both strict obligations and conditions to all your licenses.
  
  Copyright License
  
  The licensor grants you a copyright license for the software to do
  everything you might do with the software that would otherwise infringe
  the licensor's copyright in it for any permitted purpose. However, you
  may only distribute the software according to Distribution License and
  make changes or new works based on the software according to Changes and
  New Works License.
  
  Distribution License
  
  The licensor grants you an additional copyright license to distribute
  copies of the software. Your license to distribute covers distributing
  the software with changes and new works permitted by Changes and New
  Works License.
  
  Notices
  
  You must ensure that anyone who gets a copy of any part of the software
  from you also gets a copy of these terms or the URL for them above, as
  well as copies of any plain-text lines beginning with Required Notice:
  that the licensor provided with the software. For example:
  
  Required Notice: Copyright © 2025 Albi (https://graphsofwrath.com)
  
  Changes and New Works License
  
  The licensor grants you an additional copyright license to make changes
  and new works based on the software for any permitted purpose.
  
  Patent License
  
  The licensor grants you a patent license for the software that covers
  patent claims the licensor can license, or becomes able to license, that
  you would infringe by using the software.
  
  Noncommercial Purposes
  
  Any noncommercial purpose is a permitted purpose.
  
  Personal Uses
  
  Personal use for research, experiment, and testing for the benefit of
  public knowledge, personal study, private entertainment, hobby projects,
  amateur pursuits, or religious observance, without any anticipated
  commercial application, is use for a permitted purpose.
  
  Noncommercial Organizations
  
  Use by any charitable organization, educational institution, public
  research organization, public safety or health organization,
  environmental protection organization, or government institution is use
  for a permitted purpose regardless of the source of funding or
  obligations resulting from the funding.
  
  Fair Use
  
  You may have "fair use" rights for the software under the law. These
  terms do not limit them.
  
  No Other Rights
  
  These terms do not allow you to sublicense or transfer any of your
  licenses to anyone else, or prevent the licensor from granting licenses
  to anyone else. These terms do not imply any other licenses.
  
  Patent Defense
  
  If you make any written claim that the software infringes or contributes
  to infringement of any patent, your patent license for the software
  granted under these terms ends immediately. If your company makes such a
  claim, your patent license ends immediately for work on behalf of your
  company.
  
  Violations
  
  The first time you are notified in writing that you have violated any of
  these terms, or done anything with the software not covered by your
  licenses, your licenses can nonetheless continue if you come into full
  compliance with these terms, and take practical steps to correct past
  violations, within 32 days of receiving notice. Otherwise, all your
  licenses end immediately.
  
  No Liability
  
  ***As far as the law allows, the software comes as is, without any
  warranty or condition, and the licensor will not be liable to you for any
  damages arising out of these terms or the use or nature of the software,
  under any kind of legal claim.***
  
  Definitions
  
  The "licensor" is the individual or entity offering these terms, and the
  "software" is the software the licensor makes available under these
  terms.
  
  "You" refers to the individual or entity agreeing to these terms.
  
  "Your company" is any legal entity, sole proprietorship, or other kind of
  organization that you work for, plus all organizations that have control
  over, are under the control of, or are under common control with that
  organization. "Control" means ownership of substantially all the assets
  of an entity, or the power to direct its management and policies by vote,
  contract, or otherwise. Control can be direct or indirect.
  
  "Your licenses" are all the licenses granted to you for the software
  under these terms.
  
  "Use" means anything you do with the software requiring one of your
  licenses.
  
================================================================================
  COMMERCIAL LICENSING
  
  For commercial use inquiries, please contact: albijuventus@yahoo.com
================================================================================

  Dev Signature: GL.ALBI.20251116.YORK.RECT_GRID_HAM
-->
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>GridLab - 3D Grid Graph Visualization</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect x='0' y='0' width='100' height='100' rx='16' fill='%23050814'/%3E%3Cg stroke='%23888888' stroke-width='3' fill='none'%3E%3Cline x1='20' y1='20' x2='20' y2='80'/%3E%3Cline x1='50' y1='20' x2='50' y2='80'/%3E%3Cline x1='80' y1='20' x2='80' y2='80'/%3E%3Cline x1='20' y1='20' x2='80' y2='20'/%3E%3Cline x1='20' y1='50' x2='80' y2='50'/%3E%3Cline x1='20' y1='80' x2='80' y2='80'/%3E%3C/g%3E%3Cg fill='%23dfe4ff'%3E%3Ccircle cx='20' cy='80' r='1.8'/%3E%3Ccircle cx='50' cy='80' r='1.8'/%3E%3Ccircle cx='80' cy='80' r='1.8'/%3E%3Ccircle cx='20' cy='50' r='1.8'/%3E%3Ccircle cx='50' cy='50' r='1.8'/%3E%3Ccircle cx='80' cy='50' r='1.8'/%3E%3Ccircle cx='20' cy='20' r='1.8'/%3E%3Ccircle cx='50' cy='20' r='1.8'/%3E%3Ccircle cx='80' cy='20' r='1.8'/%3E%3C/g%3E%3Cpath d='M 50 50 L 80 50 L 80 80 L 20 80 L 20 20 L 80 20' stroke='%2300d9ff' stroke-width='6' stroke-linecap='round' stroke-linejoin='round' fill='none'/%3E%3Crect x='44.5' y='44.5' width='11' height='11' rx='2' fill='%2300d9ff'/%3E%3Crect x='74.5' y='14.5' width='11' height='11' rx='2' fill='%2300d9ff'/%3E%3C/svg%3E" />
<style>
  /* === THEME VARIABLES === */
  :root {
    /* Contrast 1 theme (renamed from Light) */
    --bg-main: linear-gradient(135deg, #f7f5e9 0%, #fefefe 100%);
    --topbar-bg: rgba(240, 240, 240, 0.85);
    --topbar-text: #111827;
    --sidebar-bg: #f8f8f8;
    --sidebar-text: #111827;
    --sidebar-shadow: 4px 0 18px rgba(0, 0, 0, 0.08);
    --button-bg: rgba(2, 6, 23, 0.8);
    --button-hover: rgba(2, 6, 23, 0.95);
    --button-active: rgba(2, 6, 23, 0.7);
    --button-text: #e5e7eb;
    --dropdown-bg: white;
    --dropdown-text: #333;
    --dropdown-border: #ccc;
    --modal-bg: white;
    --modal-text: #2c3e50;
    --modal-border: #e0e0e0;
    --modal-code-text: #333;
    --perf-triangles-color: #9b59b6;
  }

  :root.dark-theme {
    /* Dark theme */
    --bg-main: linear-gradient(135deg, #0c0c0c 0%, #1a1a1a 100%);
    --topbar-bg: rgba(90, 94, 102, 0.85);
    --topbar-text: #f9fafb;
    --sidebar-bg: #5a5e66;
    --sidebar-text: #f9fafb;
    --sidebar-shadow: 4px 0 18px rgba(0, 0, 0, 0.22);
    --button-bg: rgba(30, 41, 59, 0.9);
    --button-hover: rgba(30, 41, 59, 1);
    --button-active: rgba(30, 41, 59, 0.75);
    --button-text: #f9fafb;
    --dropdown-bg: rgba(60, 64, 72, 0.95);
    --dropdown-text: #f9fafb;
    --dropdown-border: #4b5563;
    --modal-bg: #2d3139;
    --modal-text: #e5e7eb;
    --modal-border: #4b5563;
    --modal-code-text: #d1d5db;
    --perf-triangles-color: #fbbf24;
  }

  :root.warm-light-theme {
    /* Warm Light theme */
    --bg-main: linear-gradient(135deg, #f7f5e9 0%, #FFFDF9 100%);
    --topbar-bg: rgba(255, 253, 249, 0.85);
    --topbar-text: #1f2937;
    --sidebar-bg: #FFFCF6;
    --sidebar-text: #1f2937;
    --sidebar-shadow: 4px 0 18px rgba(0, 0, 0, 0.08);
    --button-bg: #FCE8D8;
    --button-hover: #F5DCC5;
    --button-active: #EED0B3;
    --button-text: #4B3A2E;
    --dropdown-bg: white;
    --dropdown-text: #333;
    --dropdown-border: #ccc;
    --modal-bg: white;
    --modal-text: #2c3e50;
    --modal-border: #e0e0e0;
    --modal-code-text: #333;
    --perf-triangles-color: #9b59b6;
  }

  :root.mist-blue-theme {
    /* Mist Blue theme */
    --bg-main: linear-gradient(135deg, #f7f5e9 0%, #F8FBFF 100%);
    --topbar-bg: rgba(248, 251, 255, 0.85);
    --topbar-text: #0f172a;
    --sidebar-bg: #F6FAFF;
    --sidebar-text: #0f172a;
    --sidebar-shadow: 4px 0 18px rgba(0, 0, 0, 0.08);
    --button-bg: #E6F0FF;
    --button-hover: #D5E3F6;
    --button-active: #C9DCED;
    --button-text: #1e293b;
    --dropdown-bg: white;
    --dropdown-text: #333;
    --dropdown-border: #ccc;
    --modal-bg: white;
    --modal-text: #2c3e50;
    --modal-border: #e0e0e0;
    --modal-code-text: #333;
    --perf-triangles-color: #9b59b6;
  }

  :root.paper-white-theme {
    /* Paper White theme - all button text black */
    --bg-main: linear-gradient(135deg, #f7f5e9 0%, #FFFFFF 100%);
    --topbar-bg: rgba(255, 255, 255, 0.85);
    --topbar-text: #111827;
    --sidebar-bg: #FFFFFF;
    --sidebar-text: #111827;
    --sidebar-shadow: 4px 0 18px rgba(0, 0, 0, 0.08);
    --button-bg: #F1F5F9;
    --button-hover: #E2E8F0;
    --button-active: #CBD5E1;
    --button-text: #111827;
    --dropdown-bg: white;
    --dropdown-text: #333;
    --dropdown-border: #ccc;
    --modal-bg: white;
    --modal-text: #2c3e50;
    --modal-border: #e0e0e0;
    --modal-code-text: #333;
    --perf-triangles-color: #9b59b6;
  }

  :root.sandstone-theme {
    /* Sandstone theme - all button text black */
    --bg-main: linear-gradient(135deg, #f7f5e9 0%, #FEFEFD 100%);
    --topbar-bg: rgba(254, 254, 253, 0.85);
    --topbar-text: #1f2937;
    --sidebar-bg: #FBFAF7;
    --sidebar-text: #1f2937;
    --sidebar-shadow: 4px 0 18px rgba(0, 0, 0, 0.08);
    --button-bg: #E9E6E0;
    --button-hover: #DBD8D2;
    --button-active: #CCC9C3;
    --button-text: #374151;
    --dropdown-bg: white;
    --dropdown-text: #333;
    --dropdown-border: #ccc;
    --modal-bg: white;
    --modal-text: #2c3e50;
    --modal-border: #e0e0e0;
    --modal-code-text: #333;
    --perf-triangles-color: #9b59b6;
  }

  /* Text color overrides for better visibility in light themes */
  :root.warm-light-theme .color-label,
  :root.warm-light-theme .grid-dim-label,
  :root.warm-light-theme .grid-dimmer-label,
  :root.warm-light-theme .grid-dimmer-row span,
  :root.warm-light-theme .coord-checkbox-row label,
  :root.warm-light-theme .coord-rel-inputs label,
  :root.warm-light-theme .plane-opacity-label,
  :root.warm-light-theme .plane-opacity-value,
  :root.warm-light-theme .plane-coeff-label,
  :root.warm-light-theme .plane-item,
  :root.mist-blue-theme .color-label,
  :root.mist-blue-theme .grid-dim-label,
  :root.mist-blue-theme .grid-dimmer-label,
  :root.mist-blue-theme .grid-dimmer-row span,
  :root.mist-blue-theme .coord-checkbox-row label,
  :root.mist-blue-theme .coord-rel-inputs label,
  :root.mist-blue-theme .plane-opacity-label,
  :root.mist-blue-theme .plane-opacity-value,
  :root.mist-blue-theme .plane-coeff-label,
  :root.mist-blue-theme .plane-item,
  :root.paper-white-theme .color-label,
  :root.paper-white-theme .grid-dim-label,
  :root.paper-white-theme .grid-dimmer-label,
  :root.paper-white-theme .grid-dimmer-row span,
  :root.paper-white-theme .coord-checkbox-row label,
  :root.paper-white-theme .coord-rel-inputs label,
  :root.paper-white-theme .plane-opacity-label,
  :root.paper-white-theme .plane-opacity-value,
  :root.paper-white-theme .plane-coeff-label,
  :root.paper-white-theme .plane-item,
  :root.sandstone-theme .color-label,
  :root.sandstone-theme .grid-dim-label,
  :root.sandstone-theme .grid-dimmer-label,
  :root.sandstone-theme .grid-dimmer-row span,
  :root.sandstone-theme .coord-checkbox-row label,
  :root.sandstone-theme .coord-rel-inputs label,
  :root.sandstone-theme .plane-opacity-label,
  :root.sandstone-theme .plane-opacity-value,
  :root.sandstone-theme .plane-coeff-label,
  :root.sandstone-theme .plane-item {
    color: #000000 !important;
  }
  
  /* Active color label text should be black in non-dark themes */
  :root.warm-light-theme .color-label-active,
  :root.mist-blue-theme .color-label-active,
  :root.paper-white-theme .color-label-active,
  :root.sandstone-theme .color-label-active {
    color: #000000 !important;
  }
  
  /* Number input boxes should have white background in non-dark themes */
  :root.warm-light-theme .grid-dim-inputs input,
  :root.warm-light-theme .coord-rel-inputs input,
  :root.warm-light-theme .bb-row input[type="number"],
  :root.warm-light-theme .plane-row input[type="number"],
  :root.mist-blue-theme .grid-dim-inputs input,
  :root.mist-blue-theme .coord-rel-inputs input,
  :root.mist-blue-theme .bb-row input[type="number"],
  :root.mist-blue-theme .plane-row input[type="number"],
  :root.paper-white-theme .grid-dim-inputs input,
  :root.paper-white-theme .coord-rel-inputs input,
  :root.paper-white-theme .bb-row input[type="number"],
  :root.paper-white-theme .plane-row input[type="number"],
  :root.sandstone-theme .grid-dim-inputs input,
  :root.sandstone-theme .coord-rel-inputs input,
  :root.sandstone-theme .bb-row input[type="number"],
  :root.sandstone-theme .plane-row input[type="number"] {
    background: #ffffff !important;
    color: #000000 !important;
    border-color: #d1d5db !important;
  }

  /* === THEME-SPECIFIC COLOR OVERRIDES === */

  /* Light theme (Paper White): Blue for toggles, buttons, switches */
  :root.paper-white-theme .sidebar-toggle::after {
    background: #3498db;
    border-color: rgba(52, 152, 219, 0.3);
  }

  :root.paper-white-theme .sidebar-toggle:hover::after {
    background: #2980b9;
  }

  :root.paper-white-theme .pill-switch.active .pill-switch-toggle {
    background: #3498db;
  }

  :root.paper-white-theme .gen-btn.active {
    background: #3498db;
  }

  :root.paper-white-theme .gen-pill.active .gen-switch {
    background: #3498db;
  }

  /* Sync View flash animation for light theme - blue */
  @keyframes syncViewFlashLight {
    0% { background: linear-gradient(145deg, #f8f8f8, #e8e8e8); }
    50% { background: #3498db; color: white; }
    100% { background: linear-gradient(145deg, #f8f8f8, #e8e8e8); }
  }

  :root.paper-white-theme #syncViewBtn.flashing {
    animation: syncViewFlashLight 0.6s ease-in-out;
  }

  /* Sync View flash animation for dark theme - green */
  @keyframes syncViewFlashDark {
    0% { background: linear-gradient(145deg, rgba(50, 50, 60, 0.9), rgba(40, 40, 50, 0.9)); }
    50% { background: #4CAF50; color: white; }
    100% { background: linear-gradient(145deg, rgba(50, 50, 60, 0.9), rgba(40, 40, 50, 0.9)); }
  }

  :root.dark-theme #syncViewBtn.flashing {
    animation: syncViewFlashDark 0.6s ease-in-out;
  }

  /* Dark theme: Green for toggles, buttons, switches, checkboxes, grid tab */
  :root.dark-theme .sidebar-toggle::after {
    background: #4CAF50;
  }

  :root.dark-theme .sidebar-toggle:hover::after {
    background: #45a049;
  }

  :root.dark-theme .pill-switch.active .pill-switch-toggle {
    background: #4CAF50;
  }

  :root.dark-theme .gen-btn {
    background: linear-gradient(145deg, rgba(60, 70, 80, 0.9), rgba(50, 60, 70, 0.9));
    color: #f9fafb;
    border: 1px solid rgba(76, 175, 80, 0.2);
  }

  :root.dark-theme .gen-btn:hover {
    background: linear-gradient(145deg, rgba(70, 80, 90, 0.95), rgba(60, 70, 80, 0.95));
  }

  :root.dark-theme .gen-btn.active {
    background: #4CAF50;
  }

  :root.dark-theme #orientBtn {
    background: #4CAF50 !important;
  }

  :root.dark-theme #orientBtn:hover {
    background: #45a049 !important;
  }

  :root.dark-theme .gen-pill {
    background: linear-gradient(145deg, rgba(60, 70, 80, 0.9), rgba(50, 60, 70, 0.9));
    color: #f9fafb;
    border: 1px solid rgba(76, 175, 80, 0.2);
  }

  :root.dark-theme .gen-pill:hover {
    background: linear-gradient(145deg, rgba(70, 80, 90, 0.95), rgba(60, 70, 80, 0.95));
  }

  :root.dark-theme .gen-pill.active .gen-switch {
    background: #4CAF50;
  }

  /* Undo/Redo buttons - dark theme */
  :root.dark-theme .undo-btn, :root.dark-theme .redo-btn {
    background: linear-gradient(145deg, rgba(60, 70, 80, 0.9), rgba(50, 60, 70, 0.9));
    color: #f9fafb;
    border: 1px solid rgba(76, 175, 80, 0.2);
  }

  :root.dark-theme .undo-btn:hover, :root.dark-theme .redo-btn:hover {
    background: linear-gradient(145deg, rgba(70, 80, 90, 0.95), rgba(60, 70, 80, 0.95));
  }

  /* Layer buttons - dark theme */
  :root.dark-theme .layer-btn {
    background: linear-gradient(145deg, rgba(60, 70, 80, 0.9), rgba(50, 60, 70, 0.9));
    color: #f9fafb;
    border: 1px solid rgba(76, 175, 80, 0.2);
  }

  :root.dark-theme .layer-btn:hover {
    background: linear-gradient(145deg, rgba(70, 80, 90, 0.95), rgba(60, 70, 80, 0.95));
  }

  /* BB Panel header button - dark theme */
  :root.dark-theme .bb-header-btn {
    background: linear-gradient(145deg, rgba(60, 70, 80, 0.9), rgba(50, 60, 70, 0.9));
    color: #f9fafb;
    border: 1px solid rgba(76, 175, 80, 0.2);
  }

  :root.dark-theme .bb-header-btn:hover {
    background: linear-gradient(145deg, rgba(70, 80, 90, 0.95), rgba(60, 70, 80, 0.95));
  }

  /* BB Panel body - dark theme */
  :root.dark-theme .bb-body {
    background: linear-gradient(145deg, rgba(60, 70, 80, 0.9), rgba(50, 60, 70, 0.9));
    border: 1px solid rgba(76, 175, 80, 0.2);
  }

  /* BB Add Vertices button - dark theme */
  :root.dark-theme .bb-add-btn {
    background: #4CAF50;
    color: white;
  }

  :root.dark-theme .bb-add-btn:hover {
    background: #45a049;
  }

  :root.dark-theme .grid-btn.active {
    background: linear-gradient(145deg, #4CAF50, #45a049);
    border-color: #45a049;
    box-shadow: 0 6px 12px rgba(76, 175, 80, 0.3), 0 3px 6px rgba(76, 175, 80, 0.2);
  }

  /* Dark theme checkboxes - green (except preferences) */
  :root.dark-theme input[type="checkbox"]:checked {
    accent-color: #4CAF50;
  }

  /* Keep preferences checkboxes blue in dark theme */
  :root.dark-theme #preferencesModal input[type="checkbox"]:checked {
    accent-color: #3498db;
  }

  /* Keep preferences sliders blue in dark theme */
  :root.dark-theme #preferencesModal input[type="range"] {
    accent-color: #3498db;
  }

  /* Generate dropdown background: increase contrast in light theme */
  :root.paper-white-theme .gen-body {
    background: #e8eef5;
  }

  /* Sync View button appearance for light theme */
  :root.paper-white-theme .grid-mgmt-btn {
    background: linear-gradient(145deg, #f8f8f8, #e8e8e8);
    color: #333;
    border: 1px solid #d0d0d0;
  }

  :root.paper-white-theme .grid-mgmt-btn:hover {
    background: linear-gradient(145deg, #f0f0f0, #e0e0e0);
  }

  /* Dark theme grid management button */
  :root.dark-theme .grid-mgmt-btn {
    background: linear-gradient(145deg, rgba(60, 70, 80, 0.9), rgba(50, 60, 70, 0.9));
    color: #f9fafb;
    border: 1px solid rgba(76, 175, 80, 0.2);
  }

  :root.dark-theme .grid-mgmt-btn:hover {
    background: linear-gradient(145deg, rgba(70, 80, 90, 0.95), rgba(60, 70, 80, 0.95));
  }

  /* Grid dimmer section - dark theme */
  :root.dark-theme .grid-dimmer-section {
    background: linear-gradient(145deg, rgba(60, 70, 80, 0.9), rgba(50, 60, 70, 0.9));
    border: 1px solid rgba(76, 175, 80, 0.2);
  }

  :root.dark-theme .grid-dimmer-label {
    color: #f9fafb;
  }

  :root.dark-theme .grid-dimmer-row span {
    color: #f9fafb;
  }

  /* Editing mode buttons - blue for light, green for dark */
  :root.paper-white-theme .pill-switch {
    background: linear-gradient(145deg, #f0f0f0, #e0e0e0);
  }

  :root.dark-theme .pill-switch {
    background: rgba(80, 90, 100, 0.8);
  }

  /* Light theme editing buttons should be blue when active */
  :root.paper-white-theme #toggleClickBtn.active,
  :root.paper-white-theme #verticesBtn.active,
  :root.paper-white-theme #cubeBtn.active,
  :root.paper-white-theme #decorationBtn.active,
  :root.paper-white-theme #arrowBtn.active {
    background: #3498db;
    color: white;
  }

  /* Dark theme editing buttons should be green when active */
  :root.dark-theme #toggleClickBtn.active,
  :root.dark-theme #verticesBtn.active,
  :root.dark-theme #cubeBtn.active,
  :root.dark-theme #decorationBtn.active,
  :root.dark-theme #arrowBtn.active {
    background: #4CAF50;
    color: white;
  }

  /* LOD indicators border color - green in dark theme */
  :root.dark-theme #preferencesModal > div > div:nth-child(2) > div:has(#lodIndicatorsCheckbox) {
    border-top-color: #4CAF50 !important;
  }

  /* Fix active grid button color - make it fully green in dark theme */
  :root.dark-theme .grid-btn.active {
    background: #4CAF50 !important;
    color: white !important;
  }

  /* FPS Counter left border - green in dark theme */
  :root.dark-theme #fpsCounter {
    border-left-color: #4CAF50 !important;
  }

  /* LOD Info box in dark theme */
  :root.dark-theme #lodInfoBox {
    background: #2d3748 !important;
  }

  :root.dark-theme #lodInfoBox p {
    color: #e2e8f0 !important;
  }

  /* Unified edge size label in dark theme */
  :root.dark-theme #unifiedEdgeSizeContainer label {
    color: #e2e8f0 !important;
  }

  /* Grid list in dark theme */
  :root.dark-theme #gridList {
    background: rgba(45, 55, 72, 0.95);
    border-color: #4a5568;
  }

  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    width: 100%;
    height: 100%;
    background: var(--bg-main);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  }
  
  /* === TOP BAR === */
  .topbar {
    position: fixed;
    left: 0;
    right: 0;
    top: 0;
    height: 52px;
    z-index: 1000;
    display: flex;
    justify-content: center;
    pointer-events: none;
  }
  
  .topbar-inner {
    pointer-events: auto;
    width: 100%;
    margin: 0;
    padding: 12px 20px;
    border-radius: 0;
    background: var(--topbar-bg);
    color: var(--topbar-text);
    backdrop-filter: blur(8px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 16px;
  }
  
  .tb-left {
    font-weight: 700;
    font-size: 16px;
  }
  
  .tb-left span {
    opacity: 0.65;
    margin-left: 4px;
    font-size: 14px;
  }
  
  .tb-right {
    display: flex;
    gap: 8px;
  }
  
  /* Topbar buttons */
  .tb-btn {
    padding: 6px 10px;
    border-radius: 10px;
    border: 0;
    cursor: pointer;
    background: var(--button-bg);
    color: var(--button-text);
    font-size: 13px;
    font-weight: 500;
    transition: all 0.2s ease;
  }
  
  .tb-btn:hover {
    background: var(--button-hover);
  }
  
  .tb-btn:active {
    background: var(--button-active);
  }
  
  /* Help dropdown menu */
  .help-dropdown {
    position: absolute;
    top: 100%;
    right: 0;
    margin-top: 4px;
    min-width: 220px;
    background: rgba(248, 250, 252, 0.95);
    backdrop-filter: blur(8px);
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
    padding: 8px;
    display: none;
    z-index: 2000;
  }
  
  .help-dropdown.show {
    display: block;
  }
  
  .help-license-info {
    padding: 8px 12px;
    font-size: 11px;
    color: #6b7280;
    line-height: 1.4;
    border-top: 1px solid rgba(0, 0, 0, 0.1);
    margin-top: 4px;
  }
  
  .help-license-info strong {
    color: #374151;
    display: block;
    margin-bottom: 4px;
  }
  
  .help-license-info a {
    color: #3b82f6;
    text-decoration: none;
  }
  
  .help-license-info a:hover {
    text-decoration: underline;
  }
  
  .help-menu-item {
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    color: #111827;
    font-size: 13px;
    transition: background 0.2s ease;
  }
  
  .help-menu-item:hover {
    background: rgba(0, 0, 0, 0.06);
  }
  
  /* Position help button relative for dropdown */
  .help-btn-wrapper {
    position: relative;
  }
  
  /* === LEFT SIDEBAR === */
  .sidebar {
    position: fixed;
    left: 0;
    top: 0;
    bottom: 0;
    width: 240px;
    padding: 64px 12px 16px 12px;
    background: var(--sidebar-bg);
    color: var(--sidebar-text);
    box-shadow: var(--sidebar-shadow);
    z-index: 900;
    overflow-y: auto;
    overflow-x: hidden;
    transition: transform 0.3s ease;
  }
  
  .sidebar.collapsed {
    transform: translateX(-240px);
  }
  
  .sidebar h2 {
    font-size: 15px;
    margin: 0 0 6px 2px;
    font-weight: 700;
  }
  
  .sidebar .hint {
    font-size: 12px;
    opacity: 0.65;
    margin-bottom: 12px;
  }
  
  /* === GENERATE PANEL === */
  .gen-panel {
    margin-bottom: 8px;
  }
  
  .gen-header-btn {
    width: 100%;
    padding: 8px 10px;
    border-radius: 12px;
    border: 0;
    background: var(--button-bg);
    color: var(--button-text);
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    font-weight: 600;
    font-size: 14px;
    transition: all 0.2s ease;
  }
  
  .gen-header-btn:hover {
    background: var(--button-hover);
  }
  
  .gen-header-btn .caret {
    font-size: 12px;
    opacity: 0.7;
  }
  
  .gen-body {
    margin-top: 6px;
    padding: 8px 10px;
    border-radius: 12px;
    background: var(--button-bg);
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
    display: grid;
    gap: 8px;
  }
  
  .gen-body.collapsed {
    display: none;
  }
  
  .gen-row {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }
  
  .gen-btn {
    flex: 1;
    min-width: 90px;
    padding: 6px 10px;
    border-radius: 10px;
    border: 0;
    background: var(--button-bg);
    color: var(--button-text);
    cursor: pointer;
    font-size: 13px;
    font-weight: 500;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    transition: all 0.2s ease;
  }
  
  .gen-btn:hover {
    background: var(--button-hover);
    transform: translateY(-1px);
  }
  
  .gen-btn:active {
    transform: translateY(0);
  }
  
  .gen-btn.active {
    background: #4CAF50;
    color: white;
    font-weight: 700;
  }
  
  /* Pill toggles inside generate panel */
  .gen-pill {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
    padding: 6px 10px;
    border-radius: 9999px;
    background: var(--button-bg);
    color: var(--button-text);
    font-size: 13px;
    width: 100%;
    cursor: pointer;
    transition: all 0.2s ease;
  }
  
  .gen-pill:hover {
    background: var(--button-hover);
  }
  
  .gen-pill-label {
    white-space: nowrap;
  }
  
  .gen-switch {
    position: relative;
    width: 34px;
    height: 18px;
    border-radius: 9999px;
    background: #4b5563;
    flex: 0 0 auto;
  }
  
  .gen-thumb {
    position: absolute;
    top: 2px;
    left: 2px;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: #f9fafb;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    transition: transform 0.15s ease;
  }
  
  .gen-pill.active .gen-switch {
    background: #4CAF50;
  }
  
  .gen-pill.active .gen-thumb {
    transform: translateX(16px);
  }
  
  /* === UNDO/REDO BUTTONS === */
  .undo-redo-row {
    display: flex;
    gap: 0;
    margin-bottom: 6px;
  }
  
  .undo-btn, .redo-btn {
    flex: 1 1 50%;
    padding: 6px 8px;
    border: 0;
    background: var(--button-bg);
    color: var(--button-text);
    cursor: pointer;
    font-size: 13px;
    font-weight: 500;
    transition: all 0.2s ease;
  }
  
  .undo-btn {
    border-radius: 10px 0 0 10px;
  }
  
  .redo-btn {
    border-radius: 0 10px 10px 0;
  }
  
  .undo-btn:hover, .redo-btn:hover {
    background: var(--button-hover);
  }
  
  .undo-btn:active, .redo-btn:active {
    background: var(--button-active);
  }
  
  /* === SIDEBAR TOOL BUTTONS === */
  .sidebar .tool-btn {
    width: 100%;
    padding: 7px 10px;
    border-radius: 10px;
    border: 0;
    background: var(--button-bg);
    color: var(--button-text);
    cursor: pointer;
    text-align: left;
    font-size: 13px;
    font-weight: 500;
    margin-bottom: 6px;
    transition: all 0.2s ease;
  }
  
  .sidebar .tool-btn:hover {
    background: var(--button-hover);
  }
  
  .sidebar .tool-btn:active {
    background: var(--button-active);
  }
  
  .sidebar .tool-btn.active {
    background: #4CAF50;
    color: white;
    font-weight: 700;
  }
  
  /* Arrow pill specific styling in sidebar */
  .sidebar .gen-pill {
    margin-bottom: 6px;
    width: calc(100% - 20px);
    margin-left: 0px;
    margin-right: 10px;
  }
  
  /* === LAYER BUTTONS === */
  .layer-buttons {
    display: flex;
    gap: 8px;
    margin-bottom: 6px;
  }
  
  .layer-btn {
    flex: 1;
    padding: 7px 10px;
    border-radius: 10px;
    border: 0;
    background: var(--button-bg);
    color: var(--button-text);
    cursor: pointer;
    font-size: 13px;
    font-weight: 500;
    transition: all 0.2s ease;
  }
  
  .layer-btn:hover {
    background: var(--button-hover);
  }
  
  .layer-btn:active {
    background: var(--button-active);
  }
  
  /* === RIGHT SIDEBAR === */
  .sidebar-right {
    position: fixed;
    right: 0;
    top: 0;
    bottom: 0;
    width: 240px;
    padding: 64px 12px 16px 12px;
    background: var(--sidebar-bg);
    color: var(--sidebar-text);
    box-shadow: -4px 0 18px rgba(0, 0, 0, 0.22);
    z-index: 900;
    overflow-y: auto;
    overflow-x: hidden;
    transition: transform 0.3s ease;
    direction: rtl; /* Flip scrollbar to inside (left) */
  }

  .sidebar-right > * {
    direction: ltr; /* Reset text direction for content */
  }
  
  .sidebar-right.collapsed {
    transform: translateX(240px);
  }
  
/* Sidebar toggle buttons - Overleaf style */
.sidebar-toggle {
  position: fixed;
  top: 52px;  /* Start below topbar */
  bottom: 0;
  width: 9px;
  background: #9ca3af;  /* Gray bar */
  cursor: pointer;
  z-index: 1000;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  border: none;
  transition: background 0.18s ease, left 0.3s ease, right 0.3s ease;
}



/* Green button in the middle */
.sidebar-toggle::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 0;
  transform: translateY(-50%);
  width: 8px;
  height: 56px;  /* ~1.5cm */
  background: #4CAF50;
  border-radius: 4px;
  border: 1px solid rgba(0, 0, 0, 0.15);
  box-shadow: 0 0px 8px rgba(0, 0, 0, 0.15);
  transition: background 0.18s ease;
  pointer-events: none;
}

.sidebar-toggle:hover::after {
  background: #45a049;
}

/* LEFT SIDEBAR TOGGLE - immediately to the RIGHT of left sidebar */
.sidebar-toggle-left {
  left: 261px;
}

/* When left sidebar is collapsed */
.sidebar.collapsed {
  transform: translateX(-270px);
}

.sidebar-toggle-left.sidebar-collapsed {
  left: 0;
}

/* RIGHT SIDEBAR TOGGLE - immediately to the LEFT of right sidebar */
.sidebar-toggle-right {
  right: 261px;
}

/* When right sidebar is collapsed */
.sidebar-right.collapsed {
  transform: translateX(270px);
}

.sidebar-toggle-right.sidebar-collapsed {
  right: 0;
}

/* Chevron styling */
.chev-svg {
  width: 10px;
  height: 20px;
  display: block;
  position: relative;
  z-index: 1;
  filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.3));
}

.chev-path {
  fill: none;
  stroke: #ffffff;
  stroke-width: 3.2;
  stroke-linecap: round;
  stroke-linejoin: round;
}


  
  /* Grid dimension controls in right sidebar */
  .grid-dimensions {
    margin-bottom: 12px;
    padding: 10px;
    border-radius: 10px;
    background: var(--button-bg);
  }
  
  .grid-dim-label {
    font-size: 12px;
    color: #ffffff;
    margin-bottom: 6px;
    text-align: center;
  }
  
  .grid-dim-inputs {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 4px;
  }
  
  .grid-dim-inputs input {
    width: 40px;
    padding: 4px;
    border: 1px solid #4b5563;
    border-radius: 4px;
    background: rgba(0, 0, 0, 0.3);
    color: var(--button-text);
    font-size: 12px;
    text-align: center;
  }
  
  .grid-dim-inputs span {
    opacity: 0.5;
    font-size: 12px;
  }
  
  /* View pills for right sidebar */
  .view-pill {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
    padding: 6px 10px;
    border-radius: 9999px;
    background: var(--button-bg);
    color: var(--button-text);
    font-size: 13px;
    width: 100%;
    cursor: pointer;
    transition: all 0.2s ease;
    margin-bottom: 6px;
  }
  
  .view-pill:hover {
    background: var(--button-hover);
  }
  
  .view-pill.active .gen-switch {
    background: #4CAF50;
  }
  
  .view-pill.active .gen-thumb {
    transform: translateX(16px);
  }
  
  /* Grid management buttons */
  .grid-mgmt-row {
    display: flex;
    gap: 6px;
    margin-bottom: 12px;
  }
  
  .grid-mgmt-btn {
    flex: 1;
    padding: 7px 10px;
    border-radius: 10px;
    border: 0;
    background: var(--button-bg);
    color: var(--button-text);
    cursor: pointer;
    font-size: 13px;
    font-weight: 500;
    transition: all 0.2s ease;
  }
  
  .grid-mgmt-btn:hover {
    background: var(--button-hover);
  }
  
  .grid-mgmt-btn:active {
    background: var(--button-active);
  }
  
  /* Plane Highlighter in right sidebar */
  .plane-panel {
    margin-top: 12px;
  }
  
  .plane-header-btn {
    width: 100%;
    padding: 7px 10px;
    border-radius: 10px;
    border: 0;
    background: var(--button-bg);
    color: var(--button-text);
    cursor: pointer;
    text-align: left;
    font-size: 13px;
    font-weight: 500;
    display: flex;
    justify-content: space-between;
    align-items: center;
    transition: all 0.2s ease;
  }
  
  .plane-header-btn:hover {
    background: var(--button-hover);
  }
  
  .plane-body {
    margin-top: 6px;
    padding: 10px;
    border-radius: 10px;
    background: var(--button-bg);
    display: grid;
    gap: 10px;
  }
  
  .plane-body.collapsed {
    display: none;
  }
  
  .plane-row {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 11px;
    color: #ffffff;
    /* Removed flex-wrap to keep everything in one row */
  }
  
  .plane-row input[type="number"] {
    width: 28px;  /* Increased to fit 3 digits comfortably */
    padding: 3px;
    border: 1px solid #4b5563;
    border-radius: 4px;
    background: rgba(0, 0, 0, 0.3);
    color: var(--button-text);
    font-size: 11px;
    text-align: center;
  }
  
  .plane-slider-row {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 11px;
    color: #ffffff;
  }
  
  .plane-slider-row input[type="range"] {
    width: 80px; /* Fixed width to prevent overflow */
  }
  
  .plane-buttons {
    display: flex;
    gap: 6px;
  }
  
  .plane-btn {
    flex: 1;
    padding: 6px 10px;
    border-radius: 8px;
    border: 0;
    cursor: pointer;
    font-size: 12px;
    font-weight: 500;
    transition: all 0.2s ease;
  }
  
  .plane-btn-add {
    background: #3498db;
    color: white;
  }
  
  .plane-btn-add:hover {
    background: #2980b9;
  }
  
  .plane-btn-remove {
    background: #e74c3c;
    color: white;
  }
  
  .plane-btn-remove:hover {
    background: #c0392b;
  }
  
  .plane-checkbox-row {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 12px;
  }
  
  .plane-checkbox-row input[type="checkbox"] {
    cursor: pointer;
  }
  
  .plane-rel-row {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 11px;
  }
  
  .plane-rel-row input {
    width: 35px;
    padding: 2px;
    border: 1px solid #4b5563;
    border-radius: 4px;
    background: rgba(0, 0, 0, 0.3);
    color: var(--button-text);
    font-size: 11px;
    text-align: center;
  }
  
  /* Coordinate hover section */
  .coord-hover-section {
    margin-top: 12px;
    margin-bottom: 12px;
    padding: 8px;
    border-radius: 8px;
    background: var(--button-bg);
  }
  
  .coord-checkbox-row {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 6px 8px;
    border-radius: 0;
    background: transparent;
    font-size: 12px;
    margin-bottom: 0;
    color: #ffffff;
  }
  
  .coord-checkbox-row:first-child {
    padding-bottom: 8px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    margin-bottom: 8px;
  }
  
  .coord-checkbox-row input[type="checkbox"] {
    cursor: pointer;
  }
  
  .coord-checkbox-row.disabled {
    /* Removed opacity to keep text visible */
  }
  
  .coord-checkbox-row.disabled input[type="checkbox"] {
    cursor: not-allowed;
  }
  
  .coord-checkbox-row.disabled label {
    cursor: not-allowed;
  }
  
  .coord-rel-inputs {
    display: flex;
    align-items: center;
    gap: 4px;
    margin-left: 8px;
  }
  
  .coord-rel-inputs input {
    width: 30px;
    padding: 3px;
    border: 1px solid #4b5563;
    border-radius: 4px;
    background: rgba(0, 0, 0, 0.3);
    color: var(--button-text);
    font-size: 11px;
    text-align: center;
  }
  
  /* Grid dimmer in right sidebar */
  .grid-dimmer-section {
    margin-top: 12px;
    margin-bottom: 12px;
    padding: 10px;
    border-radius: 10px;
    background: var(--button-bg);
  }
  
  .grid-dimmer-label {
    font-size: 12px;
    margin-bottom: 6px;
    color: #FFFFFF;
  }
  
  .grid-dimmer-row {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .grid-dimmer-row input[type="range"] {
    flex: 1;
  }
  
  .grid-dimmer-row span {
    font-size: 11px;
    min-width: 35px;
    color: #FFFFFF;
  }
  
  /* Grid notes button styling */
  #notesBtn {
    background: linear-gradient(145deg, #FFD966, #FFEB99) !important;
    color: #333 !important;
    border: 1px solid #D4AF37;
    padding: 14px 10px !important; /* 2x height - EDIT THIS VALUE to change button height */
    font-family: 'Source Code Pro', monospace !important;
    font-size: 13px !important;
    font-weight: 500 !important;
  }
  
  #notesBtn:hover {
    background: linear-gradient(145deg, #FFEB99, #FFF4CC) !important;
  }
  
  /* Add Grid and Duplicate Grid buttons - 2x taller */
  #addGridBtn, #duplicateBtn {
    padding: 14px 10px !important; /* 2x height - EDIT THIS VALUE to change button height */
    font-family: 'Source Code Pro', monospace !important;
    font-size: 13px !important;
    font-weight: 500 !important;
  }
  
  /* View pill overrides for right sidebar */
  .sidebar-right .view-pill {
    width: calc(100% - 20px);
    margin-left: 0px;
    margin-right: 10px;
  }
  
  /* === BB DISTANCE PANEL === */
  .bb-panel {
    margin-top: 8px;
    margin-bottom: 8px;
  }
  
  .bb-header-btn {
    width: 100%;
    padding: 7px 10px;
    border-radius: 10px;
    border: 0;
    background: var(--button-bg);
    color: var(--button-text);
    cursor: pointer;
    text-align: left;
    font-size: 13px;
    font-weight: 500;
    display: flex;
    justify-content: space-between;
    align-items: center;
    transition: all 0.2s ease;
  }
  
  .bb-header-btn:hover {
    background: var(--button-bg);
  }
  
  .bb-header-btn .caret {
    font-size: 12px;
    opacity: 0.7;
  }
  
  .bb-body {
    margin-top: 6px;
    padding: 10px 12px;
    border-radius: 10px;
    background: var(--button-bg);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  
  .bb-body.collapsed {
    display: none;
  }
  
  .bb-row {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    color: var(--button-text);
  }
  
  .bb-row input[type="number"] {
    width: 36px;
    padding: 4px 6px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 6px;
    background: rgba(0, 0, 0, 0.3);
    color: var(--button-text);
    font-size: 12px;
    text-align: center;
    -moz-appearance: textfield;
  }
  
  .bb-row input[type="number"]::-webkit-inner-spin-button,
  .bb-row input[type="number"]::-webkit-outer-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }
  
  .bb-row input[type="number"]:focus {
    outline: none;
    border-color: rgba(52, 152, 219, 0.6);
  }
  
  .bb-action-btn {
    width: 100%;
    padding: 6px 10px;
    border: 0;
    border-radius: 6px;
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
  }
  
  .bb-add-btn {
    background: #3498db;
    color: white;
  }
  
  .bb-add-btn:hover {
    background: #2980b9;
  }
  
  .bb-clear-btn {
    background: #e74c3c;
    color: white;
  }
  
  .bb-clear-btn:hover {
    background: #c0392b;
  }
  





/* === COLOR PANEL === */
  .color-panel {
    margin-top: 8px;
    padding: 16px;
    border-radius: 12px;
    background: var(--button-bg);
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
    display: flex;
    flex-direction: column;
  }
  
  .color-panel label {
    color: #ecf0f1;
    font-family: inherit;
    font-weight: 500;
    font-size: 13px;
  }
  
  .color-panel input[type="color"] {
    width: 40px;
    height: 40px;
    border: 3px solid #ecf0f1;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
  }
  
  .color-panel input[type="color"]:hover {
    border-color: #3498db;
    box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
  }
  
  .color-disk {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    border: 2px solid #ecf0f1;
    cursor: pointer;
    transition: all 0.2s ease;
    pointer-events: auto;
    position: relative;
  }
  
  .color-disk:hover {
    transform: scale(1.1);
    border-color: #3498db;
    box-shadow: 0 0 6px rgba(52, 152, 219, 0.4);
  }
  
  /* Active/Inactive color label states */
  .color-label-active {
    font-weight: 700 !important;
    color: #ffffff !important;
    text-shadow: 0 0 4px rgba(255, 255, 255, 0.3);
  }
  
  .color-label-inactive {
    font-weight: 400 !important;
    color: #888888 !important;
    opacity: 0.6;
  }
  
  /* Active/Inactive color input states */
  .color-input-active {
    border-color: #3498db !important;
    box-shadow: 0 0 8px rgba(52, 152, 219, 0.4) !important;
    transform: scale(1.05);
  }
  
  .color-input-inactive {
    border-color: #555555 !important;
    opacity: 0.7;
    transform: scale(1.0);
  }
  
  
  
  /* Remove spinners from number inputs with data-no-spinner attribute */
	input[type="number"][data-no-spinner] {
	  -webkit-appearance: textfield;
	  -moz-appearance: textfield;
	}

	input[type="number"][data-no-spinner]::-webkit-outer-spin-button,
	input[type="number"][data-no-spinner]::-webkit-inner-spin-button {
	  -webkit-appearance: none;
	  margin: 0;
	}

  canvas {
    display: block;
  }

  /* === BUTTON PANEL STYLES === */
  .control-button {
    position: absolute;
    left: 16px;
    z-index: 10;
    padding: 12px 16px;
    background: linear-gradient(145deg, #f0f0f0, #e0e0e0);
    border: none;
    border-radius: 8px;
    box-shadow: 
      0 4px 8px rgba(0, 0, 0, 0.1),
      0 2px 4px rgba(0, 0, 0, 0.06);
    font-family: inherit;
    font-weight: 500;
    font-size: 13px;
    cursor: pointer;
    width: 130px;
    text-align: center;
    transition: all 0.2s ease;
    color: #333;
  }

  .control-button:hover {
    background: linear-gradient(145deg, #e8e8e8, #d8d8d8);
    box-shadow: 
      0 6px 12px rgba(0, 0, 0, 0.15),
      0 3px 6px rgba(0, 0, 0, 0.1);
    transform: translateY(-1px);
  }

  .control-button:active {
    transform: translateY(0);
    box-shadow: 
      0 2px 4px rgba(0, 0, 0, 0.1),
      0 1px 2px rgba(0, 0, 0, 0.06);
  }

  /* === BUTTON POSITIONS === */
  /* Group 1: Main Operations */
  #genH0Btn       { top: 16px; }
  #genCycleBtn    { top: 60px; }
  #checkHamBtn    { top: 104px; }
  #backbiteBtn    { top: 148px; }
  #switchBtn      { top: 192px; }
  
  /* Group 2: Pill Switches (with spacing) */
  #gradientBtn    { top: 246px; }
  #arrowBtn       { top: 284px; }

  /* Group 3: Editing Tools (with extra spacing) */
  #toggleClickBtn { top: 332px; }
  #cubeBtn        { top: 376px; }
  
  
  #verticesBtn    { top: 388px; }
  #addLayerBtn    { top: 434px; }
  #removeLayerBtn { top: 478px; }

  /* Group 3: Grid Management (with spacing) */
  #dimensionControls { top: 642px; }
  #addGridBtn     { top: 701px; }
  #duplicateBtn   { top: 761px; }


  
  /* === PILL SWITCH STYLES === */
  .pill-switch {
    position: absolute;
    right: 16px;
    z-index: 10;
    display: inline-flex;
    align-items: center;
    gap: 10px;
    padding: 8px 12px;
    background: linear-gradient(145deg, #f0f0f0, #e0e0e0);
    border-radius: 20px;
    box-shadow: 
      0 4px 8px rgba(0, 0, 0, 0.1),
      0 2px 4px rgba(0, 0, 0, 0.06);
    cursor: pointer;
    transition: all 0.2s ease;
    user-select: none;
  }
  
  .pill-switch:hover {
    background: linear-gradient(145deg, #e8e8e8, #d8d8d8);
    box-shadow: 
      0 6px 12px rgba(0, 0, 0, 0.15),
      0 3px 6px rgba(0, 0, 0, 0.1);
    transform: translateY(-1px);
  }
  
  .pill-switch-label {
    font-family: inherit;
    font-weight: 500;
    font-size: 13px;
    color: #333;
  }
  
  .pill-switch-toggle {
    position: relative;
    width: 40px;
    height: 20px;
    background: #ccc;
    border-radius: 10px;
    transition: background 0.3s ease;
  }
  
  .pill-switch-toggle::after {
    content: '';
    position: absolute;
    top: 2px;
    left: 2px;
    width: 16px;
    height: 16px;
    background: white;
    border-radius: 50%;
    transition: transform 0.3s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  }
  
  .pill-switch.active .pill-switch-toggle {
    background: #4CAF50;
  }
  
  .pill-switch.active .pill-switch-toggle::after {
    transform: translateX(20px);
  }
  
  /* Right side buttons - NEW POSITIONS */
	#saveBtn        { top: 76px; right: 16px; left: auto; }
	#loadBtn        { top: 120px; right: 16px; left: auto; }
	#preferencesBtn { top: 164px; right: 16px; left: auto; }

	/* Right side buttons G_1*/
	#toggleGridBtn  { top: 258px; right: 16px; left: auto; }
	#coordBtn       { top: 302px; right: 16px; left: auto; }
	/* syncViewBtn removed - now inline in sidebar */

/* === HORIZONTAL GRID LIST PANEL === */
#gridListContainer {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 10;
}

#gridList {
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  gap: 10px;
  max-width: 85vw;
  justify-content: center;
  padding: 12px 16px;
  background: rgba(255, 255, 255, 0.95);
  border: 2px solid #d0d0d0;
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  max-height: 140px;
  overflow-y: auto;
}

#gridListMinimizer {
  position: absolute;
  top: 4px;
  right: 4px;
  width: 16px;
  height: 16px;
  border-radius: 3px;
  background: transparent;
  color: #888;
  border: none;
  font-size: 18px;
  font-weight: bold;
  line-height: 1;
  cursor: pointer;
  display: none; /* Hidden by default, shown when grids exist */
  align-items: center;
  justify-content: center;
  z-index: 11;
  padding: 0;
  transition: color 0.2s ease, background 0.2s ease;
}

#gridListMinimizer:hover {
  color: #3498db;
  background: rgba(52, 152, 219, 0.1);
}

:root.dark-theme #gridListMinimizer {
  color: #a0aec0;
}

:root.dark-theme #gridListMinimizer:hover {
  color: #48bb78;
  background: rgba(72, 187, 120, 0.1);
}

#gridListMinimized {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 10;
  width: 60px;
  height: 40px;
  background: #3498db;
  border: 2px solid #2980b9;
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  cursor: pointer;
  transition: background 0.2s ease;
}

#gridListMinimized:hover {
  background: #2980b9;
}

:root.dark-theme #gridListMinimized {
  background: #28a745;
  border-color: #1e7e34;
}

:root.dark-theme #gridListMinimized:hover {
  background: #218838;
}

/* === AUTOMATIC RENDERING INFO BOX === */
#automaticRenderingInfo {
  background: #e3f2fd; /* Light blue background in light theme */
  border-left-color: #3498db; /* Blue bracket in light theme */
}

#automaticRenderingLabel {
  color: #1976d2; /* Blue text in light theme */
}

#automaticRenderingDesc {
  color: #1565c0; /* Darker blue for description in light theme */
}

:root.dark-theme #automaticRenderingInfo {
  background: rgba(72, 187, 120, 0.15); /* Green-tinted background in dark theme */
  border-left-color: #48bb78; /* Green bracket in dark theme */
}

:root.dark-theme #automaticRenderingLabel {
  color: #48bb78; /* Green text in dark theme */
}

:root.dark-theme #automaticRenderingDesc {
  color: #68d391; /* Lighter green for description in dark theme */
}

/* === PREFERENCES MODAL DRAGGABLE === */
#preferencesDragHandle {
  transition: background 0.2s ease;
  border-bottom-color: #3498db; /* Blue in light theme */
}

#preferencesDragHandle:hover {
  background: rgba(52, 152, 219, 0.05);
}

#preferencesDragHandle:active {
  cursor: grabbing;
  background: rgba(52, 152, 219, 0.1);
}

:root.dark-theme #preferencesDragHandle {
  border-bottom-color: #48bb78 !important; /* Green in dark theme */
}

:root.dark-theme #preferencesDragHandle:hover {
  background: rgba(72, 187, 120, 0.05);
}

:root.dark-theme #preferencesDragHandle:active {
  background: rgba(72, 187, 120, 0.1);
}

/* === CAMERA POSITION CONTROL (MANUAL CAMERA) === */
#manualCameraControl {
  border-left-color: #3498db !important; /* Blue in light theme */
}

:root.dark-theme #manualCameraControl {
  border-left-color: #48bb78 !important; /* Green in dark theme */
}

/* === CAMERA SENSITIVITY PANEL CLOSER === */
#cameraSensitivityCloser {
  position: absolute;
  top: 4px;
  right: 4px;
  width: 16px;
  height: 16px;
  border-radius: 3px;
  background: transparent;
  color: #888;
  border: none;
  font-size: 18px;
  font-weight: bold;
  line-height: 1;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 11;
  padding: 0;
  transition: color 0.2s ease, background 0.2s ease;
}

#cameraSensitivityCloser:hover {
  color: #3498db;
  background: rgba(52, 152, 219, 0.1);
}

:root.dark-theme #cameraSensitivityCloser {
  color: #a0aec0;
}

:root.dark-theme #cameraSensitivityCloser:hover {
  color: #48bb78;
  background: rgba(72, 187, 120, 0.1);
}

.grid-btn {
  position: relative;
  padding: 10px 28px 10px 12px;
  background: linear-gradient(145deg, #f8f8f8, #e8e8e8);
  border: none;
  border-radius: 6px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  cursor: grab;
  font-family: inherit;
  font-size: 14px;
  font-weight: 500;
  color: #444;
  transition: all 0.2s ease;
  width: 110px;
  white-space: nowrap;
}

.grid-btn:hover {
  background: linear-gradient(145deg, #f0f0f0, #e0e0e0);
  transform: translateY(-1px);
}

.grid-btn.dragging {
  opacity: 0.5;
  cursor: grabbing;
}

.grid-btn.drag-over {
  border: 2px dashed #3498db;
}

.grid-info {
  font-size: 9px;
  color: #888;
  opacity: 0.7;
  margin-top: 2px;
  pointer-events: none;
}

.grid-btn .close {
  position: absolute;
  right: 2px;
  top: -4px;
  transform: none;
  font-size: 16px;
  font-weight: 1500;
  color: #e74c3c;
  cursor: pointer;
  transition: color 0.2s ease;
  z-index: 1;
}

.grid-btn .close:hover {
  color: #c0392b;
}

.grid-btn.active {
  background: linear-gradient(145deg, #3498db, #2980b9);
  color: white;
  box-shadow: 
    0 6px 12px rgba(52, 152, 219, 0.3),
    0 3px 6px rgba(52, 152, 219, 0.2);
  border: 2px solid #2980b9;
}

.grid-btn.active .grid-info {
  color: white;
  opacity: 0.9;
}

	 
 /* === DIMENSION CONTROLS === */
 
    #dimensionControls input[type="number"] {
	  -webkit-appearance: textfield;
	  -moz-appearance: textfield;
	}

	#dimensionControls input[type="number"]::-webkit-outer-spin-button,
	#dimensionControls input[type="number"]::-webkit-inner-spin-button {
	  -webkit-appearance: none;
	  margin: 0;
	} 
 
	#dimensionControls {
	 position: absolute;
	 bottom: 140px;
	 left: 160px;
	 z-index: 10;
	 background: linear-gradient(145deg, #f0f0f0, #e0e0e0);
	 padding: 8px 12px;
	 border: none;
	 border-radius: 8px;
	 box-shadow: 
	   0 4px 8px rgba(0, 0, 0, 0.1),
	   0 2px 4px rgba(0, 0, 0, 0.06);
	 display: flex;
	 flex-direction: column;
	 gap: 4px;
	 font-family: inherit;
	 font-weight: 500;
	 font-size: 13px;
	 color: #333;
	 width: 130px;
	}

	#dimensionControls input {
	 width: 35px;
	 padding: 3px 4px;
	 border: 1px solid #ccc;
	 border-radius: 3px;
	 font-family: inherit;
	 font-size: 11px;
	 text-align: center;
	}

 /* === COLOR PICKER === */
   #colorPicker {
     position: absolute;
     bottom: 20px;
     right: 20px;
     z-index: 10;
     background: linear-gradient(145deg, #2c3e50, #34495e);
     padding: 16px;
     border-radius: 12px;
     box-shadow: 
   	0 8px 16px rgba(0, 0, 0, 0.2),
   	0 4px 8px rgba(0, 0, 0, 0.1);
     display: flex;
     align-items: center;
     gap: 12px;
   }

   #colorPicker label {
     color: #ecf0f1;
     font-family: inherit;
     font-weight: 500;
     font-size: 13px;
   }

   #colorInput {
     width: 40px;
     height: 40px;
     border: 3px solid #ecf0f1;
     border-radius: 8px;
     cursor: pointer;
     transition: all 0.2s ease;
   }

   #colorInput:hover {
     border-color: #3498db;
     box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
   }

   .color-disk {
     width: 20px;
     height: 20px;
     border-radius: 50%;
     border: 2px solid #ecf0f1;
     cursor: pointer;
     transition: all 0.2s ease;
     pointer-events: auto;
     position: relative;
     z-index: 1001;
   }

   .color-disk:hover {
     transform: scale(1.1);
     border-color: #3498db;
     box-shadow: 0 0 6px rgba(52, 152, 219, 0.4);
   }

   #colorPicker2 {
     position: absolute;
     bottom: 105px;
     right: 20px;
     z-index: 10;
     background: linear-gradient(145deg, #2c3e50, #34495e);
     padding: 16px;
     border-radius: 12px;
     box-shadow: 
   	0 8px 16px rgba(0, 0, 0, 0.2),
   	0 4px 8px rgba(0, 0, 0, 0.1);
     display: flex;
     align-items: center;
     gap: 12px;
   }

   #colorPicker2 label {
     color: #ecf0f1;
     font-family: inherit;
     font-weight: 500;
     font-size: 13px;
   }

   #colorInput2 {
     width: 40px;
     height: 40px;
     border: 3px solid #ecf0f1;
     border-radius: 8px;
     cursor: pointer;
     transition: all 0.2s ease;
   }

   #colorInput2:hover {
     border-color: #3498db;
     box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
   }
   
   /* Active/Inactive color label states */
	.color-label-active {
	  font-weight: 700 !important;
	  color: #ffffff !important;
	  text-shadow: 0 0 4px rgba(255, 255, 255, 0.3);
	}

	.color-label-inactive {
	  font-weight: 400 !important;
	  color: #888888 !important;
	  opacity: 0.6;
	}

	/* Active/Inactive color input states */
	.color-input-active {
	  border-color: #3498db !important;
	  box-shadow: 0 0 8px rgba(52, 152, 219, 0.4) !important;
	  transform: scale(1.05);
	}

	.color-input-inactive {
	  border-color: #555555 !important;
	  opacity: 0.7;
	  transform: scale(1.0);
	}

  /* === SCROLLBAR STYLING === */
  #gridList::-webkit-scrollbar {
    width: 6px;
    height: 6px;
  }

  #gridList::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 3px;
  }

  #gridList::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.3);
    border-radius: 3px;
  }

  #gridList::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.5);
  }

  /* === ACTIVE STATE STYLING === */
  .control-button.active {
    background: linear-gradient(145deg, #3498db, #2980b9);
    color: white;
    box-shadow: 
      0 4px 8px rgba(52, 152, 219, 0.3),
      0 2px 4px rgba(52, 152, 219, 0.2);
  }

  .control-button.active:hover {
    background: linear-gradient(145deg, #2980b9, #1f618d);
  }


  
  /* Keyboard Shortcuts Button Hover Effect */
#keyboardShortcutsBtn:hover {
  background: rgba(255, 255, 255, 1) !important;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.25) !important;
}

/* Close Button Hover Effect */
#closeShortcutsModal:hover {
  background: #f0f0f0 !important;
  color: #333 !important;
}

/* Modal Scrollbar Styling */
#keyboardShortcutsModal > div::-webkit-scrollbar {
  width: 8px;
}

#keyboardShortcutsModal > div::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 4px;
}

#keyboardShortcutsModal > div::-webkit-scrollbar-thumb {
  background: #888;
  border-radius: 4px;
}

#keyboardShortcutsModal > div::-webkit-scrollbar-thumb:hover {
  background: #555;
}






/* Help Button Hover Effect */
#helpBtn:hover {
  background: rgba(255, 255, 255, 1) !important;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.25) !important;
}

/* Dark theme Help button hover */
:root.dark-theme #helpBtn:hover {
  background: linear-gradient(145deg, rgba(70, 80, 90, 0.95), rgba(60, 70, 80, 0.95)) !important;
  color: #f9fafb !important;
}

/* Help Dropdown Menu Item Hover */
.help-menu-item:hover {
  background: #f5f5f5 !important;
}

/* Close Button Hover Effect (if not already added) */
#closeAboutModal:hover {
  background: #f0f0f0 !important;
  color: #333 !important;
}

/* Modal Scrollbar Styling (if not already added) */
#aboutModal > div::-webkit-scrollbar {
  width: 8px;
}

#aboutModal > div::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 4px;
}

#aboutModal > div::-webkit-scrollbar-thumb {
  background: #888;
  border-radius: 4px;
}

#aboutModal > div::-webkit-scrollbar-thumb:hover {
  background: #555;
}




/* Preferences Modal Styling */
#preferencesModal input[type="checkbox"]:hover {
  transform: scale(1.1);
}

#savePreferencesBtn:hover {
  background: #2980b9 !important;
}


#preferencesModal label:hover {
  color: #3498db;
}

/* Preference row hover */
#preferencesModal > div > div > div:hover {
  background: #f8f9fa;
}



/* GridLab Logo Icon */
.gridlab-icon {
  width: 1.4em;
  height: 1.4em;
  vertical-align: -0.18em;
  margin-right: 0.35em;  /* space between icon and text */
}
.gridlab-icon .gl-bg {
  fill: #050814;
}

.gridlab-icon .gl-grid {
  stroke: #888888;
  stroke-width: 3;
}

.gridlab-icon .gl-nodes {
  fill: #dfe4ff;
}
.gridlab-icon .gl-path {
  fill: none;
  stroke: #00d9ff;  /* cyan */
  stroke-width: 6;
  stroke-linecap: round;
  stroke-linejoin: round;
}
.gridlab-icon .gl-marker {
  fill: #00d9ff;  /* cyan */
}

/* === DARK THEME OVERRIDES FOR UI ELEMENTS === */

/* Help dropdown menu */
:root.dark-theme .help-dropdown {
  background: rgba(60, 64, 72, 0.95);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
}

:root.dark-theme .help-menu-item {
  color: #e5e7eb;
}

:root.dark-theme .help-menu-item:hover {
  background: rgba(0, 0, 0, 0.2) !important;
}

:root.dark-theme .help-license-info {
  color: #9ca3af;
  border-top: 1px solid rgba(255, 255, 255, 0.1);
}

:root.dark-theme .help-license-info strong {
  color: #e5e7eb;
}

:root.dark-theme .help-license-info a {
  color: #60a5fa;
}

/* Grid tabs container */
:root.dark-theme #gridList {
  background: rgba(60, 64, 72, 0.95);
  border: 2px solid #4b5563;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
}

:root.dark-theme .grid-btn {
  background: linear-gradient(145deg, #4b5563, #374151);
  color: #e5e7eb;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

:root.dark-theme .grid-btn:hover {
  background: linear-gradient(145deg, #6b7280, #4b5563);
}

:root.dark-theme .grid-btn.active {
  background: linear-gradient(145deg, #3b82f6, #2563eb);
  color: #ffffff;
}

:root.dark-theme .grid-btn .close-btn {
  color: #e5e7eb;
}

:root.dark-theme .grid-btn .close-btn:hover {
  color: #ef4444;
}

/* Modal popup windows (About, Preferences, Keyboard Shortcuts) */
:root.dark-theme #aboutModal > div,
:root.dark-theme #preferencesModal > div,
:root.dark-theme #keyboardShortcutsModal > div {
  background: #2d3748 !important;
  color: #e5e7eb !important;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6) !important;
}

:root.dark-theme #aboutModal h2,
:root.dark-theme #aboutModal h3,
:root.dark-theme #preferencesModal h2,
:root.dark-theme #preferencesModal h3,
:root.dark-theme #keyboardShortcutsModal h2,
:root.dark-theme #keyboardShortcutsModal h3 {
  color: #f9fafb !important;
}

:root.dark-theme #aboutModal p,
:root.dark-theme #aboutModal li,
:root.dark-theme #preferencesModal p,
:root.dark-theme #preferencesModal label,
:root.dark-theme #keyboardShortcutsModal div {
  color: #d1d5db !important;
}

:root.dark-theme #closeAboutModal,
:root.dark-theme #closePreferencesBtn,
:root.dark-theme #closeShortcutsModal {
  color: #9ca3af !important;
}

:root.dark-theme #closeAboutModal:hover,
:root.dark-theme #closePreferencesBtn:hover,
:root.dark-theme #closeShortcutsModal:hover {
  color: #ef4444 !important;
  background: rgba(239, 68, 68, 0.1) !important;
}

/* Warning box in About modal */
:root.dark-theme #aboutModal > div > div:first-of-type {
  background: rgba(251, 191, 36, 0.2) !important;
  border-left: 4px solid #fbbf24 !important;
}

:root.dark-theme #aboutModal > div > div:first-of-type p {
  color: #fbbf24 !important;
}

/* Preferences modal specific */
:root.dark-theme #preferencesModal > div > div:first-child {
  border-bottom: 2px solid #4b5563 !important;
}

/* License section - dark theme */
:root.dark-theme #licenseSection {
  background: rgba(30, 41, 59, 0.8) !important;
  border-left: 4px solid #3b82f6 !important;
}

:root.dark-theme #licenseSection h3 {
  color: #60a5fa !important;
}

:root.dark-theme #licenseSection p {
  color: #e5e7eb !important;
}

:root.dark-theme #licenseSection a {
  color: #60a5fa !important;
}

/* Keyboard shortcuts - key badges and text in Keyboard Shortcuts Modal */
:root.dark-theme #keyboardShortcutsModal kbd,
:root.dark-theme #keyboardShortcutsModal code {
  background: #1f2937 !important;
  color: #60a5fa !important;
  border: 1px solid #374151 !important;
}

:root.dark-theme #keyboardShortcutsModal span {
  color: #e5e7eb !important;
}

/* Keyboard shortcuts - key badges in About Modal (match Keyboard Shortcuts modal) */
:root.dark-theme #aboutModal kbd,
:root.dark-theme #aboutModal code {
  background: #1f2937 !important;
  color: #60a5fa !important;
  border: 1px solid #374151 !important;
}

:root.dark-theme #aboutModal kbd {
  padding: 4px 8px !important;
  border-radius: 4px !important;
  font-family: monospace !important;
  font-size: 13px !important;
}

/* Layer dropdown menu (add/remove layer) - dynamically created */
:root.dark-theme #layerMenu {
  background: rgba(60, 64, 72, 0.95) !important;
  border: 1px solid #4b5563 !important;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4) !important;
}

/* Preferences modal - dropdown menus (select elements) */
:root.dark-theme #preferencesModal select {
  background: #374151 !important;
  color: #e5e7eb !important;
  border: 1px solid #4b5563 !important;
}

:root.dark-theme #preferencesModal select:hover {
  background: #4b5563 !important;
  border-color: #6b7280 !important;
}

:root.dark-theme #preferencesModal select:focus {
  background: #4b5563 !important;
  border-color: #60a5fa !important;
  outline: none !important;
}

/* Preferences modal - input fields */
:root.dark-theme #preferencesModal input[type="range"] {
  background: #374151 !important;
}

:root.dark-theme #preferencesModal input[type="number"],
:root.dark-theme #preferencesModal input[type="text"] {
  background: #374151 !important;
  color: #e5e7eb !important;
  border: 1px solid #4b5563 !important;
}

:root.dark-theme #preferencesModal input[type="number"]:focus,
:root.dark-theme #preferencesModal input[type="text"]:focus {
  background: #4b5563 !important;
  border-color: #60a5fa !important;
  outline: none !important;
}

/* Warning/info boxes in Preferences */
:root.dark-theme #preferencesModal .performance-note,
:root.dark-theme #preferencesModal div[style*="background: #fff3cd"],
:root.dark-theme #preferencesModal div[style*="background:#fff3cd"] {
  background: rgba(180, 83, 9, 0.3) !important;
  border-left: 4px solid #d97706 !important;
}

:root.dark-theme #preferencesModal .performance-note,
:root.dark-theme #preferencesModal div[style*="background: #fff3cd"] *,
:root.dark-theme #preferencesModal div[style*="background:#fff3cd"] * {
  color: #fbbf24 !important;
}

/* Subgraph Panel Button Hover Effects */
#subgraphDataBtn:hover {
  background: #8e44ad !important;
}

#orientBtn:hover {
  background: #2980b9 !important;
}

#reverseArrowsBtn:hover {
  background: #c0392b !important;
}

#closeSubgraphAnalysisBtn:hover {
  opacity: 1 !important;
}

#closeSubgraphAnalysisBtn2:hover {
  background: #8e44ad !important;
}

</style>

<!-- Source Code Pro Font -->
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;500;600&display=swap" rel="stylesheet">

</head>
<body>

<!-- Auto-apply theme on load based on time of day -->
<script>
  // This runs BEFORE page content loads - applies theme based on time of day on every load
  (function() {
    const now = new Date();
    const hour = now.getHours();
    // Dark mode: 12am (0) to 8am (8), Light mode: 8am to 12am
    const shouldBeDark = (hour >= 0 && hour < 8);

    if (shouldBeDark) {
      document.documentElement.classList.add('dark-theme');
      document.documentElement.classList.remove('paper-white-theme');
    } else {
      document.documentElement.classList.add('paper-white-theme');
      document.documentElement.classList.remove('dark-theme');
    }
  })();
</script>

<!-- Top Bar -->
<div class="topbar">
  <div class="topbar-inner">
    <div class="tb-left">
      <svg class="gridlab-icon" viewBox="0 0 100 100" aria-hidden="true">
        <rect x="0" y="0" width="100" height="100" rx="16" class="gl-bg" />
        <g class="gl-grid">
          <line x1="20" y1="20" x2="20" y2="80" />
          <line x1="50" y1="20" x2="50" y2="80" />
          <line x1="80" y1="20" x2="80" y2="80" />
          <line x1="20" y1="20" x2="80" y2="20" />
          <line x1="20" y1="50" x2="80" y2="50" />
          <line x1="20" y1="80" x2="80" y2="80" />
        </g>
        <g class="gl-nodes">
          <circle cx="20" cy="80" r="1.8" />
          <circle cx="50" cy="80" r="1.8" />
          <circle cx="80" cy="80" r="1.8" />
          <circle cx="20" cy="50" r="1.8" />
          <circle cx="50" cy="50" r="1.8" />
          <circle cx="80" cy="50" r="1.8" />
          <circle cx="20" cy="20" r="1.8" />
          <circle cx="50" cy="20" r="1.8" />
          <circle cx="80" cy="20" r="1.8" />
        </g>
        <path class="gl-path" d="M 50 50 L 80 50 L 80 80 L 20 80 L 20 20 L 80 20" stroke-width="8" />
        <rect x="44.5" y="44.5" width="11" height="11" rx="2" class="gl-marker" />
        <rect x="74.5" y="14.5" width="11" height="11" rx="2" class="gl-marker" />
      </svg>
      GridLab
    </div>
    <div class="tb-right">
      <button class="tb-btn" id="preferencesBtn">Preferences</button>
      <button class="tb-btn" id="saveBtn" title="Ctrl+S">Save</button>
      <button class="tb-btn" id="loadBtn" title="Ctrl+L">Load</button>
      <div class="help-btn-wrapper">
        <button class="tb-btn" id="helpBtn">Help</button>
        <div class="help-dropdown" id="helpDropdown">
          <div class="help-menu-item" data-action="about">About GridLab v3.0</div>
          <div class="help-menu-item" data-action="shortcuts">Keyboard Shortcuts</div>
          <div class="help-menu-item" data-action="readme">README</div>
          <!-- License info suspended for now - can be re-enabled later -->
          <!--
          <div style="height: 1px; background: rgba(0, 0, 0, 0.1); margin: 4px 0;"></div>
          <div class="help-license-info">
            <strong>📄 License</strong>
            Licensed under <a href="https://polyformproject.org/licenses/noncommercial/1.0.0" target="_blank">PolyForm Noncommercial 1.0.0</a>
            <br><br>
            ✅ Free for research, education, personal use<br>
            ❌ Commercial use requires license
            <br><br>
            Contact: <a href="mailto:albijuventus@yahoo.com">albijuventus@yahoo.com</a>
          </div>
          -->
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Left Sidebar -->
<aside class="sidebar">
  
  <!-- Generate Panel -->
  <div class="gen-panel">
    <button id="genHeader" class="gen-header-btn">
      <span>Generate</span>
      <span class="caret" id="genCaret">▾</span>
    </button>
    <div id="genBody" class="gen-body">
      <div class="gen-row">
        <button class="gen-btn" id="genPathBtn">Generate Hamiltonian Path</button>
      </div>
      <div class="gen-row">
        <button class="gen-btn" id="genCycleBtn">Generate Hamiltonian Cycle</button>
      </div>
      <div class="gen-row">
        <button class="gen-btn" id="checkHamBtn">Check Hamiltonicity</button>
      </div>
      <div class="gen-row">
        <div class="gen-pill" id="switchPill">
          <span class="gen-pill-label">Switch mode</span>
          <div class="gen-switch"><div class="gen-thumb"></div></div>
        </div>
      </div>
      <div class="gen-row">
        <div class="gen-pill" id="backbitePill">
          <span class="gen-pill-label">Backbite mode</span>
          <div class="gen-switch"><div class="gen-thumb"></div></div>
        </div>
      </div>
      <div class="gen-row">
        <div style="display: flex; align-items: center; padding: 8px;">
          <input type="checkbox" id="gradientCheckbox" style="width: 18px; height: 18px; cursor: pointer; margin-right: 10px;">
          <label for="gradientCheckbox" style="cursor: pointer; font-size: 13px; color: var(--sidebar-text); user-select: none;">Gradient</label>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Undo/Redo -->
  <div class="undo-redo-row">
    <button class="undo-btn" id="undoBtn" title="Ctrl+Z">↶ Undo</button>
    <button class="redo-btn" id="redoBtn" title="Ctrl+Y">Redo ↷</button>
  </div>
  
  <!-- Main Editing Tools -->
  <button class="tool-btn" id="toggleClickBtn" title="Press E">Add Edge</button>
  <button class="tool-btn" id="cubeBtn" title="Shift+E">Decorate Edge</button>
  <button class="tool-btn" id="verticesBtn" title="Press V">Add Vertex</button>
  <button class="tool-btn" id="decorationBtn" title="Shift+V">Decorate Vertex</button>
  <div style="display: flex; align-items: center; padding: 8px; margin: 8px 0;">
    <input type="checkbox" id="arrowCheckbox" style="width: 18px; height: 18px; cursor: pointer; margin-right: 10px;">
    <label for="arrowCheckbox" style="cursor: pointer; font-size: 13px; color: var(--sidebar-text); user-select: none;">Arrows</label>
  </div>

  <!-- Layer Management -->
  <div class="layer-buttons">
    <button class="layer-btn" id="addLayerBtn">Add Layer</button>
    <button class="layer-btn" id="removeLayerBtn">Remove Layer</button>
  </div>

  <!-- BB Distance Panel -->
  <div class="bb-panel">
    <button id="bbHeader" class="bb-header-btn">
      <span>Add vertices at BB distance</span>
      <span class="caret" id="bbCaret">▾</span>
    </button>
    <div id="bbBody" class="bb-body collapsed">
      <div class="bb-row">
        <span>At BB distance:</span>
        <input id="bbDistance" type="number" value="1" min="0">
        <span>from</span>
      </div>
      <div class="bb-row">
        <span>v*:</span>
        <input id="bbRefX" type="number" value="0" min="0" placeholder="X">
        <span>,</span>
        <input id="bbRefY" type="number" value="0" min="0" placeholder="Y">
        <span>,</span>
        <input id="bbRefZ" type="number" value="0" min="0" placeholder="Z">
      </div>
      <div style="display: flex; gap: 8px;">
        <button id="colorBBDistanceBtn" class="bb-action-btn bb-add-btn" style="flex: 1;">Add Vertices</button>
        <button id="clearBBDistanceBtn" class="bb-action-btn bb-clear-btn" style="flex: 1;">Clear All Vertices</button>
      </div>
    </div>
  </div>
  
<!-- Color Panel -->
  <div class="color-panel">
    <div style="display: flex; align-items: center; gap: 16px; justify-content: space-between;">
      <!-- Main Color Section -->
      <div style="display: flex; flex-direction: column; align-items: center;">
        <label id="mainColorLabel" class="color-label" style="color: #ecf0f1; font-family: inherit; font-weight: 500; font-size: 13px; margin-bottom: 8px; cursor: pointer;">Main Color</label>
        <input type="color" id="colorInput" value="#0000ff" style="width: 40px; height: 40px; border: 3px solid #ecf0f1; border-radius: 8px; cursor: pointer; transition: all 0.2s ease;" />
      </div>
      
      <!-- Second Color Section -->
      <div style="display: flex; flex-direction: column; align-items: center;">
        <label id="secondColorLabel" class="color-label" style="color: #ecf0f1; font-family: inherit; font-weight: 500; font-size: 13px; margin-bottom: 8px; cursor: pointer;">Second Color</label>
        <input type="color" id="colorInput2" value="#ff0000" style="width: 40px; height: 40px; border: 3px solid #ecf0f1; border-radius: 8px; cursor: pointer; transition: all 0.2s ease;" />
      </div>
    </div>
    
    <!-- Shared Color Circles in Honeycomb Pattern -->
    <div style="display: flex; flex-direction: column; align-items: center; gap: 4px; margin-top: 12px;">
      <!-- Top row: 5 circles -->
      <div style="display: flex; gap: 6px;">
        <div class="color-disk" data-color="#0000ff" style="background: #0000ff;"></div>
        <div class="color-disk" data-color="#ff0000" style="background: #ff0000;"></div>
        <div class="color-disk" data-color="#00b300" style="background: #00b300;"></div>
        <div class="color-disk" data-color="#ffff00" style="background: #ffff00;"></div>
        <div class="color-disk" data-color="#ff7300" style="background: #ff7300;"></div>
      </div>
      
      <!-- Bottom row: 4 circles, offset -->
      <div style="display: flex; gap: 6px; margin-left: 13px;">
        <div class="color-disk" data-color="#d400ff" style="background: #d400ff;"></div>
        <div class="color-disk" data-color="#00fbff" style="background: #00fbff;"></div>
        <div class="color-disk" data-color="#00ff00" style="background: #00ff00;"></div>
        <div class="color-disk" data-color="#ffd500" style="background: #ffd500;"></div>
      </div>
    </div>
  </div>
</aside>

<!-- Sidebar Toggle Buttons -->
<button class="sidebar-toggle sidebar-toggle-left" id="leftSidebarToggle" title="Toggle left sidebar">
  <svg class="chev-svg" viewBox="0 0 12 24" aria-hidden="true">
    <path class="chev-path" d="M9 6 L4 12 L9 18" />
  </svg>
</button>
<button class="sidebar-toggle sidebar-toggle-right" id="rightSidebarToggle" title="Toggle right sidebar">
  <svg class="chev-svg" viewBox="0 0 12 24" aria-hidden="true">
    <path class="chev-path" d="M3 6 L8 12 L3 18" />
  </svg>
</button>

<!-- Right Sidebar -->
<aside class="sidebar-right">
  
  <!-- Grid Dimensions -->
  <div class="grid-dimensions">
    <div class="grid-dim-label">Grid Dimensions</div>
    <div class="grid-dim-inputs">
      <input id="widthInput" type="number" value="4" min="1" placeholder="W">
      <span>×</span>
      <input id="heightInput" type="number" value="4" min="1" placeholder="H">
      <span>×</span>
      <input id="depthInput" type="number" value="4" min="1" placeholder="D">
    </div>
  </div>
  
  <!-- Grid Management Buttons -->
  <div class="grid-mgmt-row">
    <button class="grid-mgmt-btn" id="addGridBtn">Add Grid</button>
    <button class="grid-mgmt-btn" id="duplicateBtn">Duplicate</button>
  </div>
  
  <!-- View Checkboxes -->
  <div style="display: flex; align-items: center; gap: 8px; padding: 8px; margin: 8px 0;">
    <input type="checkbox" id="toggleGridCheckbox" checked style="width: 18px; height: 18px; cursor: pointer; margin-right: 6px;">
    <label for="toggleGridCheckbox" style="cursor: pointer; font-size: 13px; color: var(--sidebar-text); user-select: none; flex: 1;">Toggle Grid</label>
    <button class="grid-mgmt-btn" id="syncViewBtn" title="Press S" style="flex: 0 0 auto; min-width: 85px; padding: 7px 10px; font-size: 13px; border-radius: 10px;">Sync View</button>
  </div>

  <div style="display: flex; align-items: center; gap: 8px; padding: 8px; margin: 8px 0;">
    <input type="checkbox" id="coordCheckbox" style="width: 18px; height: 18px; cursor: pointer; margin-right: 6px;">
    <label for="coordCheckbox" style="cursor: pointer; font-size: 13px; color: var(--sidebar-text); user-select: none; flex: 1;">Toggle Axis</label>
    <!-- Flare Button (shown/hidden by preference) - beside Toggle Axis checkbox -->
    <button class="grid-mgmt-btn" id="flareBtn" title="Highlight endpoints" style="flex: 0 0 auto; min-width: 85px; padding: 7px 10px; font-size: 13px; border-radius: 10px; display: none;">Flare</button>
  </div>
  
  <!-- Grid Dimmer -->
  <div class="grid-dimmer-section">
    <div class="grid-dimmer-label">Grid Dimmer</div>
    <div class="grid-dimmer-row">
      <input type="range" id="gridOpacitySlider" min="0.1" max="1" step="0.1" value="0.3">
      <span id="opacityValue">30%</span>
    </div>
  </div>

  <!-- Vertex Dimmer (hidden by default, shown via preference) -->
  <div id="mainVertexDimmerSection" class="grid-dimmer-section" style="display: none;">
    <div class="grid-dimmer-label">Vertex Dimmer</div>
    <div class="grid-dimmer-row">
      <input type="range" id="mainVertexDimmerSlider" min="0" max="100" step="5" value="100">
      <span id="mainVertexDimmerValue">100%</span>
    </div>
  </div>

  <!-- Grid Notes (removed Sync View from here) -->
  <div class="grid-mgmt-row">
    <button class="grid-mgmt-btn" id="notesBtn" title="Ctrl+M">Grid Notes</button>
  </div>

  <!-- Coordinate Hover Section -->
  <div class="coord-hover-section" style="display: none;">
    <div class="coord-checkbox-row">
      <input type="checkbox" id="coordinateHoverCheckbox">
      <label for="coordinateHoverCheckbox">Coordinate Hover</label>
    </div>
    
    <div class="coord-checkbox-row disabled" id="relativeCoordRow" title="Enable 'Coordinate Hover' first to use this feature">
      <input type="checkbox" id="relativeCoordinatesCheckbox" disabled>
      <label for="relativeCoordinatesCheckbox">Relative to v*:</label>
      <div class="coord-rel-inputs">
        <input type="number" id="refK" value="0">
        <input type="number" id="refL" value="0">
        <input type="number" id="refH" value="0">
      </div>
    </div>
  </div>
  
  <!-- Plane Highlighter Panel -->
  <div class="plane-panel" style="display: none;">
    <button id="planeHeader" class="plane-header-btn">
      <span>Plane Highlighter</span>
      <span class="caret" id="planeCaret">▾</span>
    </button>
    <div id="planeBody" class="plane-body collapsed">
      <div class="plane-row">
        <input type="number" id="planeA" value="1" step="1">
        <span class="plane-coeff-label">x +</span>
        <input type="number" id="planeB" value="1" step="1">
        <span class="plane-coeff-label">y +</span>
        <input type="number" id="planeC" value="1" step="1">
        <span class="plane-coeff-label">z =</span>
        <input type="number" id="planeD" value="6" step="1">
      </div>
      
      <div class="plane-slider-row" style="display: flex; align-items: center; gap: 6px;">
        <span class="plane-opacity-label" style="min-width: 50px; font-size: 11px;">Opacity:</span>
        <input type="range" id="planeOpacity" min="0.05" max="0.5" step="0.05" value="0.15" style="flex: 1; max-width: 65px;">
        <span id="planeOpacityValue" class="plane-opacity-value" style="min-width: 28px; font-size: 11px;">15%</span>
        <input type="color" id="planeColorPicker" value="#3498db" style="width: 35px; height: 22px; border: 1px solid #bbb; border-radius: 3px; cursor: pointer;" title="Plane color">
      </div>
      
      <div class="plane-buttons">
        <button class="plane-btn plane-btn-add" id="addPlaneBtn">Add Plane</button>
        <button class="plane-btn plane-btn-remove" id="removePlaneBtn">Remove</button>
      </div>
      
      <!-- Plane list -->
      <div id="planeList" style="font-size: 10px; margin-top: 8px; max-height: 100px; overflow-y: auto; color: #ffffff;"></div>
    </div>
  </div>
  
  <!-- Camera Sensitivity Panel (shown/hidden by preference) -->
  <div class="camera-sensitivity-panel" id="cameraSensitivityPanel" style="display: none; margin-top: 12px; padding: 12px; background: rgba(255, 255, 255, 0.05); border-radius: 8px; position: relative;">
    <button id="cameraSensitivityCloser" title="Close camera sensitivity panel">×</button>
    <div style="font-size: 12px; color: var(--sidebar-text); margin-bottom: 8px; font-weight: 500;">Camera Sensitivity</div>
    <div style="display: flex; align-items: center; gap: 8px;">
      <input type="range" id="mainCameraSensitivitySlider" min="0.1" max="2.0" step="0.1" value="1.0" style="flex: 1; cursor: pointer;">
      <span id="mainCameraSensitivityValue" style="font-size: 12px; color: var(--sidebar-text); min-width: 30px;">1.0</span>
    </div>
  </div>

  <!-- Subgraph Panel -->
  <div id="subgraphPanel" style="display: block; margin-top: 12px; padding: 12px; background: var(--button-bg); border-radius: 8px; box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);">
    <div style="font-size: 12px; color: var(--sidebar-text); margin-bottom: 10px; font-weight: 500;">Subgraph</div>

    <!-- Subgraph Data Button -->
    <button id="subgraphDataBtn" class="gen-btn" style="width: 100%; margin-bottom: 10px;">
      Subgraph Data
    </button>

    <!-- Orient Section -->
    <div style="margin-bottom: 10px;">
      <div style="display: flex; align-items: center; gap: 8px;">
        <button id="orientBtn" style="flex: 1; padding: 6px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 500; transition: background 0.2s;">
          Orient
        </button>
        <select id="orientTargetSelect" class="theme-dropdown" style="flex: 1; padding: 6px; border: 1px solid var(--dropdown-border, #ccc); border-radius: 4px; background: var(--dropdown-bg, white); color: var(--dropdown-text, #333); font-size: 11px; cursor: pointer;">
          <option value="all">All Subgraph</option>
        </select>
      </div>
    </div>

    <!-- Reverse Arrows Section -->
    <div>
      <div style="display: flex; align-items: center; gap: 8px;">
        <button id="reverseArrowsBtn" style="flex: 1; padding: 6px; background: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 500; transition: background 0.2s;">
          Reverse Arrows
        </button>
        <select id="reverseTargetSelect" class="theme-dropdown" style="flex: 1; padding: 6px; border: 1px solid var(--dropdown-border, #ccc); border-radius: 4px; background: var(--dropdown-bg, white); color: var(--dropdown-text, #333); font-size: 11px; cursor: pointer;">
          <option value="all">All Subgraph</option>
        </select>
      </div>
    </div>
  </div>

  <!-- FPS Counter (Performance Monitor) -->
  <div id="fpsCounter" style="display: block; margin-top: 12px; padding: 12px; background: rgba(255, 255, 255, 0.05); border-radius: 8px; border-left: 3px solid #3498db;">
    <div style="font-size: 12px; color: var(--sidebar-text); margin-bottom: 6px; font-weight: 500;">Performance Monitor</div>
    <div style="display: flex; flex-direction: column; gap: 4px;">
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <span style="font-size: 11px; color: var(--sidebar-text); opacity: 0.8;">FPS:</span>
        <span id="fpsValue" style="font-size: 14px; color: #2ecc71; font-weight: 600; font-family: 'Courier New', monospace;">60</span>
      </div>
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <span style="font-size: 11px; color: var(--sidebar-text); opacity: 0.8;">Frame Time:</span>
        <span id="frameTimeValue" style="font-size: 11px; color: var(--sidebar-text); font-family: 'Courier New', monospace;">16.7ms</span>
      </div>
      <!-- DIAGNOSTIC ENTRIES: Chunks and LOD Levels suppressed (were used for testing/debugging) -->
      <!-- Uncomment below to re-enable diagnostic display:
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <span style="font-size: 11px; color: var(--sidebar-text); opacity: 0.8;">Chunks:</span>
        <span id="chunksValue" style="font-size: 11px; color: #f39c12; font-family: 'Courier New', monospace;">—</span>
      </div>
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <span style="font-size: 11px; color: var(--sidebar-text); opacity: 0.8;">LOD Levels:</span>
        <span id="lodLevelValue" style="font-size: 11px; color: #3498db; font-family: 'Courier New', monospace;">—</span>
      </div>
      -->
      <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 6px; padding-top: 6px; border-top: 1px solid var(--modal-border, rgba(128,128,128,0.2));">
        <span style="font-size: 11px; color: var(--sidebar-text); opacity: 0.8;">Triangles:</span>
        <span id="trianglesValue" style="font-size: 11px; color: var(--perf-triangles-color, #9b59b6); font-family: 'Courier New', monospace;">—</span>
      </div>
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <span style="font-size: 11px; color: var(--sidebar-text); opacity: 0.8;">Draw Calls:</span>
        <span id="drawCallsValue" style="font-size: 11px; color: #e74c3c; font-family: 'Courier New', monospace;">—</span>
      </div>
      <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer;" id="memoryHeader">
        <span style="font-size: 11px; color: var(--sidebar-text); opacity: 0.8;">Memory:</span>
        <div style="display: flex; align-items: center; gap: 6px;">
          <span id="memoryValue" style="font-size: 11px; color: #1abc9c; font-family: 'Courier New', monospace;">—</span>
          <span id="memoryToggle" style="font-size: 9px; color: var(--sidebar-text); opacity: 0.6;">▼</span>
        </div>
      </div>
      <!-- Memory Breakdown (collapsible) -->
      <div id="memoryBreakdown" style="display: none; margin-top: 6px; padding: 6px 0 0 12px; border-left: 2px solid rgba(128,128,128,0.15); font-size: 10px;">
        <div style="display: flex; justify-content: space-between; padding: 2px 0;">
          <span style="color: var(--sidebar-text); opacity: 0.7;">Thin Edges:</span>
          <span id="memThinEdges" style="font-family: 'Courier New', monospace; color: #95a5a6;">—</span>
        </div>
        <div style="display: flex; justify-content: space-between; padding: 2px 0;">
          <span style="color: var(--sidebar-text); opacity: 0.7;">Thick Edges:</span>
          <span id="memThickEdges" style="font-family: 'Courier New', monospace; color: #95a5a6;">—</span>
        </div>
        <div style="display: flex; justify-content: space-between; padding: 2px 0;">
          <span style="color: var(--sidebar-text); opacity: 0.7;">Edge Collision:</span>
          <span id="memEdgeCollision" style="font-family: 'Courier New', monospace; color: #95a5a6;">—</span>
        </div>
        <div style="display: flex; justify-content: space-between; padding: 2px 0;">
          <span style="color: var(--sidebar-text); opacity: 0.7;">Vertex Spheres:</span>
          <span id="memVertexSpheres" style="font-family: 'Courier New', monospace; color: #95a5a6;">—</span>
        </div>
        <div style="display: flex; justify-content: space-between; padding: 2px 0;">
          <span style="color: var(--sidebar-text); opacity: 0.7;">Arrows:</span>
          <span id="memArrows" style="font-family: 'Courier New', monospace; color: #95a5a6;">—</span>
        </div>
        <div style="display: flex; justify-content: space-between; padding: 2px 0;">
          <span style="color: var(--sidebar-text); opacity: 0.7;">Switchable Boxes:</span>
          <span id="memSwitchBoxes" style="font-family: 'Courier New', monospace; color: #95a5a6;">—</span>
        </div>
        <div style="display: flex; justify-content: space-between; padding: 2px 0;">
          <span style="color: var(--sidebar-text); opacity: 0.7;">Block Cubes:</span>
          <span id="memBlockCubes" style="font-family: 'Courier New', monospace; color: #95a5a6;">—</span>
        </div>
        <div style="display: flex; justify-content: space-between; padding: 2px 0;">
          <span style="color: var(--sidebar-text); opacity: 0.7;">LOD Backups:</span>
          <span id="memLODBackups" style="font-family: 'Courier New', monospace; color: #95a5a6;">—</span>
        </div>
        <div style="display: flex; justify-content: space-between; padding: 2px 0;">
          <span style="color: var(--sidebar-text); opacity: 0.7;">Map Keys:</span>
          <span id="memStringKeys" style="font-family: 'Courier New', monospace; color: #95a5a6;">—</span>
        </div>
        <div style="display: flex; justify-content: space-between; padding: 2px 0; border-top: 1px solid rgba(128,128,128,0.2); margin-top: 2px; padding-top: 4px;">
          <span style="color: var(--sidebar-text); opacity: 0.7;">Other:</span>
          <span id="memOther" style="font-family: 'Courier New', monospace; color: #95a5a6;">—</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Camera Position Control (Combined coordinates display + manual input) -->
  <div id="manualCameraControl" style="display: none; margin-top: 12px; padding: 10px 12px; background: rgba(255, 255, 255, 0.05); border-radius: 8px; border-left: 3px solid;">
    <div style="font-size: 12px; color: var(--sidebar-text); margin-bottom: 6px; font-weight: 500;">Camera Position</div>
    <div style="display: flex; gap: 4px; align-items: center;">
      <div style="display: flex; align-items: center; gap: 3px; flex: 1;">
        <label style="font-size: 10px; color: #e74c3c; font-weight: 600; min-width: 10px;">X</label>
        <input type="number" id="manualCamX" step="0.1" disabled style="width: 100%; padding: 3px 4px; background: rgba(0,0,0,0.2); border: 1px solid rgba(255,255,255,0.1); border-radius: 3px; color: #e74c3c; font-size: 10px; font-family: 'Courier New', monospace;">
      </div>
      <div style="display: flex; align-items: center; gap: 3px; flex: 1;">
        <label style="font-size: 10px; color: #2ecc71; font-weight: 600; min-width: 10px;">Y</label>
        <input type="number" id="manualCamY" step="0.1" disabled style="width: 100%; padding: 3px 4px; background: rgba(0,0,0,0.2); border: 1px solid rgba(255,255,255,0.1); border-radius: 3px; color: #2ecc71; font-size: 10px; font-family: 'Courier New', monospace;">
      </div>
      <div style="display: flex; align-items: center; gap: 3px; flex: 1;">
        <label style="font-size: 10px; color: #3498db; font-weight: 600; min-width: 10px;">Z</label>
        <input type="number" id="manualCamZ" step="0.1" disabled style="width: 100%; padding: 3px 4px; background: rgba(0,0,0,0.2); border: 1px solid rgba(255,255,255,0.1); border-radius: 3px; color: #3498db; font-size: 10px; font-family: 'Courier New', monospace;">
      </div>
      <button id="setCameraBtn" style="padding: 4px 10px; background: #9b59b6; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 10px; font-weight: 600; transition: background 0.2s; white-space: nowrap;">
        SET
      </button>
    </div>
  </div>

</aside>



<!-- Group 1: Main Operations - MOVED TO SIDEBAR -->
<!-- <button id="genH0Btn" class="control-button" title="Generate Hamiltonian path">Gen Path</button> -->
<!-- <button id="genCycleBtn" class="control-button" title="Generate Hamiltonian cycle">Gen Cycle</button> -->
<!-- <button id="checkHamBtn" class="control-button">Hamiltonian ?</button> -->
<!-- <button id="backbiteBtn" class="control-button" title="Make backbite moves">Backbite Mode</button> -->
<!-- <button id="switchBtn" class="control-button" title="Make switch moves">Switch mode</button> -->
<!-- <div id="gradientBtn" class="pill-switch" style="left: 16px; right: auto; width: 105px; justify-content: space-between;">
  <span class="pill-switch-label">Gradient</span>
  <div class="pill-switch-toggle"></div>
</div> -->
<!-- Group 2: Editing Tools - MOVED TO SIDEBAR -->
<!-- <button id="toggleClickBtn" class="control-button" title="Press E">Add Edge</button>
<button id="cubeBtn" class="control-button" title="Shift+E">Decorate Edge</button>
<div id="arrowBtn" class="pill-switch" style="left: 16px; right: auto; width: 105px; justify-content: space-between;">
  <span class="pill-switch-label">Arrows</span>
  <div class="pill-switch-toggle"></div>
</div> -->




<style>
/* Remove spinner arrows from number inputs */
input[type=number]::-webkit-inner-spin-button,
input[type=number]::-webkit-outer-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

input[type=number] {
  -moz-appearance: textfield;
}

/* Remove hover highlighting in preferences */
#preferencesModal input[type="checkbox"],
#preferencesModal label,
#preferencesModal input[type="checkbox"] + label {
  background-color: transparent !important;
}

#preferencesModal > div > div > div:hover {
  background-color: transparent !important;
}
</style>






<!-- MOVED TO SIDEBAR -->
<!-- <button id="addLayerBtn" class="control-button">Add Layer ▼</button>
<button id="removeLayerBtn" class="control-button">Remove Layer ▼</button> -->



<!-- MOVED TO SIDEBAR -->
<!-- <div style="position: absolute; left: 16px; top: 522px; z-index: 10; display: flex; gap: 4px; width: 130px;">
  <button id="undoBtn" class="control-button" 
          style="position: relative; left: 0; top: 0; transform: none; width: 63px; padding: 8px;" title="Ctrl+Z">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
      <path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z" fill="#333"/>
    </svg>
  </button>
  <button id="redoBtn" class="control-button"
          style="position: relative; left: 0; top: 0; transform: none; width: 63px; padding: 8px;" title="Ctrl+Y">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
      <path d="M18.4 10.6C16.55 8.99 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7l-3.6 3.6z" fill="#333"/>
    </svg>
  </button>
</div> -->







<!-- Group 3: Grid Management - MOVED TO RIGHT SIDEBAR -->
<div id="dimensionControls" style="display: none;">
</div>

<!-- MOVED TO RIGHT SIDEBAR -->
<button id="oldAddGridBtn" class="control-button" style="display: none;"></button>
<button id="oldDuplicateBtn" class="control-button" style="display: none;"></button>
<div id="oldToggleGridBtn" class="pill-switch" style="display: none;"></div>
<div id="oldCoordBtn" class="pill-switch" style="display: none;"></div>
<button id="oldSyncViewBtn" class="control-button" style="display: none;"></button>

<div id="gridListContainer">
  <button id="gridListMinimizer" title="Minimize grid list">−</button>
  <div id="gridList"></div>
</div>
<div id="gridListMinimized" style="display: none;" title="Click to expand grid list"></div>



<div id="colorPicker" style="display: none;">
  <div style="display: flex; align-items: center; gap: 20px; justify-content: space-between;">
    <!-- Main Color Section -->
    <div style="display: flex; flex-direction: column; align-items: center;">
      <label id="mainColorLabel" style="color: #ecf0f1; font-family: inherit; font-weight: 500; font-size: 13px; margin-bottom: 8px; cursor: pointer;">Main Color</label>
      <input type="color" value="#0000ff" style="width: 40px; height: 40px; border: 3px solid #ecf0f1; border-radius: 8px; cursor: pointer; transition: all 0.2s ease;" />
    </div>
    
<!-- Shared Color Circles in Honeycomb Pattern -->
<div style="display: flex; flex-direction: column; align-items: center; gap: 4px;">
  <!-- Top row: 5 circles -->
  <div style="display: flex; gap: 6px;">
    <div class="color-disk" data-color="#0000ff" style="background: #0000ff;"></div>
    <div class="color-disk" data-color="#ff0000" style="background: #ff0000;"></div>
    <div class="color-disk" data-color="#00b300" style="background: #00b300;"></div>
    <div class="color-disk" data-color="#ffff00" style="background: #ffff00;"></div>
    <div class="color-disk" data-color="#ff7300" style="background: #ff7300;"></div>
  </div>
  
  <!-- Bottom row: 4 circles, offset -->
  <div style="display: flex; gap: 6px; margin-left: 13px;">
    <div class="color-disk" data-color="#d400ff" style="background: #d400ff;"></div>
    <div class="color-disk" data-color="#00fbff" style="background: #00fbff;"></div>
    <div class="color-disk" data-color="#00ff00" style="background: #00ff00;"></div>
    <div class="color-disk" data-color="#ffd500" style="background: #ffd500;"></div>
  </div>
</div>
    
    <!-- Second Color Section -->
    <div style="display: flex; flex-direction: column; align-items: center;">
      <label id="secondColorLabel" style="color: #ecf0f1; font-family: inherit; font-weight: 500; font-size: 13px; margin-bottom: 8px; cursor: pointer;">Second Color</label>
      <input type="color" value="#ff0000" style="width: 40px; height: 40px; border: 3px solid #ecf0f1; border-radius: 8px; cursor: pointer; transition: all 0.2s ease;" />
    </div>
  </div>
</div>







<!-- Hidden background select for theme management -->
<select id="backgroundSelect" style="display:none;">
  <option value="paper-white" selected >Paper White</option>
  <option value="dark">Dark</option>
  <option value="sandstone">Sandstone</option>
  <option value="mist-blue">Mist Blue</option>
  <option value="warm-light">Warm Light</option>
  <option value="light" >Contrast</option>
  
  
</select>




<!-- About Modal -->
<div id="aboutModal" style="display: none; position: fixed; top: 0; left: 0; 
     width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 2000; 
     align-items: center; justify-content: center;">
  <div style="background: white; border-radius: 12px; padding: 32px; max-width: 700px; 
       width: 90%; max-height: 85vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(0,0,0,0.3); 
       position: relative; line-height: 1.6;">
    
    <!-- Close Button -->
    <button id="closeAboutModal" style="position: absolute; top: 16px; right: 16px; 
            background: none; border: none; font-size: 28px; cursor: pointer; color: #666; 
            padding: 0; width: 32px; height: 32px; line-height: 28px; border-radius: 4px;
            transition: all 0.2s;">×</button>
    
    <!-- About Content -->
    <h2 style="margin: 0 0 8px 0; font-size: 28px; color: #333; font-weight: 600;">About GridLab</h2>

    <p style="color: #555; font-size: 15px; margin: 0 0 24px 0;">
      GridLab is an interactive 2D/3D playground for grid graphs. It lets you generate, visualize,
      and reconfigure Hamiltonian paths and cycles on rectangular and cuboid grids.
    </p>

    <h3 style="font-size: 18px; color: #333; margin: 24px 0 12px 0; font-weight: 600;">What's New in v3.0</h3>

    <p style="color: #555; font-size: 14px; margin: 0 0 8px 0; font-weight: 600;">Performance & Scalability:</p>
    <ul style="color: #555; font-size: 14px; margin: 0 0 16px 0; padding-left: 24px;">
      <li style="margin-bottom: 6px;"><strong>Chunked Object System:</strong> Refactored all geometry into chunked instanced meshes, enabling efficient rendering of massive grids</li>
      <li style="margin-bottom: 6px;"><strong>Advanced Culling Systems:</strong> Frustum culling, surface culling, spherical culling, and progressive LOD improve performance on large grids (30×30×30+)</li>
      <li style="margin-bottom: 6px;"><strong>Rendering Optimizer:</strong> Configure culling and LOD settings to target a specific triangle budget (default: 15M triangles for 30+ FPS)</li>
      <li style="margin-bottom: 6px;"><strong>Lazy Object Loading:</strong> Arrows, vertices, collision meshes, and decorations load on-demand, improving grid creation time and memory efficiency</li>
      <li style="margin-bottom: 6px;"><strong>Numerical Key Refactor:</strong> Replaced string-based vertex/edge keys with numerical keys, significantly improving computational efficiency and memory consumption</li>
    </ul>

    <p style="color: #555; font-size: 14px; margin: 0 0 8px 0; font-weight: 600;">Generation Improvements:</p>
    <ul style="color: #555; font-size: 14px; margin: 0 0 16px 0; padding-left: 24px;">
      <li style="margin-bottom: 6px;"><strong>Optimized 2D/3D Generation:</strong> For sufficient mixing, we apply 0.5N^(3/2) backbites in 2D grids and 10N backbites in 3D grids</li>
      <li style="margin-bottom: 6px;"><strong>2D Grid Input Fixes:</strong> Resolved bugs in dimension input handling for planar grids</li>
      <li style="margin-bottom: 6px;"><strong>Grid Graph Framework:</strong> Expanded core logic to support future generation of other types of subgraphs (spanning trees, random subgraphs, etc.)</li>
    </ul>

    <p style="color: #555; font-size: 14px; margin: 0 0 8px 0; font-weight: 600;">UI Enhancements:</p>
    <ul style="color: #555; font-size: 14px; margin: 0 0 16px 0; padding-left: 24px;">
      <li style="margin-bottom: 6px;"><strong>Subgraph Data Panel:</strong> Real-time data of active subgraph (vertex count, edge count, component type)</li>
      <li style="margin-bottom: 6px;"><strong>Performance Monitor:</strong> Live FPS, frame time, triangles, draw calls, memory</li>
      <li style="margin-bottom: 6px;"><strong>Flare Button:</strong> Instantly locate path endpoints in large grids or when vertices are culled</li>
      <li style="margin-bottom: 6px;"><strong>Camera Position Monitor:</strong> Display and input exact camera coordinates with "Go To Position" functionality</li>
      <li style="margin-bottom: 6px;"><strong>Dual Arrow System:</strong> Normal and transcendent arrows with independent loading and rendering</li>
      <li style="margin-bottom: 6px;"><strong>Display Settings:</strong> Customizable vertex/edge sizes, switch box visualization options, and more</li>
    </ul>

    <p style="color: #555; font-size: 14px; margin: 0 0 8px 0; font-weight: 600;">Other Improvements:</p>
    <ul style="color: #555; font-size: 14px; margin: 0 0 20px 0; padding-left: 24px;">
      <li style="margin-bottom: 6px;">Bug fixes for save/load functionality and 2D camera mode for planar grids</li>
      <li style="margin-bottom: 6px;">Improved keyboard shortcuts and accessibility</li>
    </ul>

    <h3 style="font-size: 18px; color: #333; margin: 24px 0 12px 0; font-weight: 600;">What You Can Do</h3>
    <ul style="color: #555; font-size: 14px; margin: 0 0 20px 0; padding-left: 24px;">
      <li style="margin-bottom: 8px;"><strong>Generate</strong> Hamiltonian paths/cycles; color by gradient; orient edges with arrows</li>
      <li style="margin-bottom: 8px;"><strong>Reconfigure</strong> using Switch and Backbite moves</li>
      <li style="margin-bottom: 8px;"><strong>See components:</strong> After a switch, if a cycle splits, GridLab colors components separately</li>
      <li style="margin-bottom: 8px;"><strong>Edit/Build grids:</strong> Add/remove vertices, edges, cubes, layers; duplicate grids; per-grid notes</li>
      <li style="margin-bottom: 8px;"><strong>View/Navigation:</strong> Toggle grid/axes, sync view across grids, customize display settings, light/dark themes</li>
      <li style="margin-bottom: 8px;"><strong>2D Grids:</strong> Special camera mode for grids with one dimension = 1 (pan/zoom without rotation)</li>
      <li style="margin-bottom: 8px;"><strong>Persist:</strong> Save/Load grids including active subgraph(s), colors, and UI state</li>
      <li style="margin-bottom: 8px;"><strong>Optimize:</strong> Configure rendering settings for your target performance</li>
    </ul>

    <h3 style="font-size: 18px; color: #333; margin: 24px 0 12px 0; font-weight: 600;">Panels (Quick Map)</h3>
    <ul style="color: #555; font-size: 14px; margin: 0 0 20px 0; padding-left: 24px;">
      <li style="margin-bottom: 6px;"><strong>Generate:</strong> Hamiltonian Path • Hamiltonian Cycle • Check Hamiltonicity? • Backbite Mode • Switch Mode • Gradient</li>
      <li style="margin-bottom: 6px;"><strong>Build:</strong> Add/Remove Vertices • Edges • Decorations • Arrows • Add/Remove Layer</li>
      <li style="margin-bottom: 6px;"><strong>View:</strong> Toggle Grid • Coordinate Axis • Sync View • Grid Dimmer • Flare</li>
      <li style="margin-bottom: 6px;"><strong>Grids:</strong> Dimensions W,H,D • Add Grid • Duplicate Grid</li>
    </ul>

    <h3 style="font-size: 18px; color: #333; margin: 24px 0 12px 0; font-weight: 600;">Performance</h3>
    <ul style="color: #555; font-size: 14px; margin: 0 0 20px 0; padding-left: 24px;">
      <li style="margin-bottom: 8px;">Generation uses <strong><a href="https://cp-algorithms.com/data_structures/treap.html" target="_blank" style="color: #3498db; text-decoration: underline;">treap</a> data structures</strong> for O(log N) path reversals, reducing backbite times on large grids</li>
      <li style="margin-bottom: 8px;">Enable <strong>Progressive LOD</strong> in Preferences for 20×+ speed improvement on large grids (automatically reduces geometry detail based on camera distance)</li>
      <li style="margin-bottom: 8px;">Enable <strong>Unified Edge Size</strong> to render all edges with the same thickness, reducing draw calls and improving frame rates</li>
      <li style="margin-bottom: 8px;">Use the <strong>Rendering Optimizer</strong> to configure culling settings for your target triangle budget</li>
      <li style="margin-bottom: 8px;"><strong>Generation complexity:</strong> 3D grids: 10N·log(N) where N = total vertices; 2D grids: Adaptive (10N to 0.5N^(3/2))·log(N) based on grid size</li>
      <li style="margin-bottom: 8px;">Small grids (5×5×5) generate instantly; medium grids (50×50×50) take a few seconds; large grids (100×100×100+) take up to a few minutes</li>
      <li style="margin-bottom: 8px;">Press <strong>ESC</strong> during generation to stop the process at any time</li>
    </ul>

    <h3 style="font-size: 18px; color: #333; margin: 24px 0 12px 0; font-weight: 600;">Quick Reference</h3>
    <ul style="color: #555; font-size: 14px; margin: 0 0 20px 0; padding-left: 24px;">
      <li style="margin-bottom: 6px;">
        <strong>Keyboard Shortcuts:</strong> <kbd style="background:#f5f5f5; padding: 2px 6px; border-radius:4px; border:1px solid #ddd; font-family:monospace;">Shift + ?</kbd>
      </li>
      <li style="margin-bottom: 6px;">
        <strong>Camera:</strong> Rotate • Zoom • Pan (<strong>Left-drag</strong> / <strong>Wheel</strong> / <strong>Right-drag</strong>). For 2D grids (one dimension = 1), rotation is disabled by default
      </li>
      <li style="margin-bottom: 6px;">
        <strong>Editing:</strong> Add/remove edge = <kbd style="background:#f5f5f5; padding: 2px 6px; border-radius:4px; border:1px solid #ddd; font-family:monospace;">E</kbd> • Add/remove decoration = <kbd style="background:#f5f5f5; padding: 2px 6px; border-radius:4px; border:1px solid #ddd; font-family:monospace;">Shift + E</kbd>
      </li>
      <li style="margin-bottom: 6px;">
        <strong>Find Endpoints:</strong> Click the Flare button to locate path endpoints
      </li>
    </ul>

    <h3 style="font-size: 18px; color: #333; margin: 24px 0 12px 0; font-weight: 600;">Save/Load Details</h3>
    <p style="color: #555; font-size: 14px; margin: 0 0 12px 0;">Saves include:</p>
    <ul style="color: #555; font-size: 14px; margin: 0 0 20px 0; padding-left: 24px;">
      <li style="margin-bottom: 6px;">Visual state (theme, dimmer, arrows, etc.)</li>
      <li style="margin-bottom: 6px;">Active subgraph (colored vertices, edges, decorations)</li>
      <li style="margin-bottom: 6px;">Per-grid notes</li>
    </ul>

    <h3 style="font-size: 18px; color: #333; margin: 24px 0 12px 0; font-weight: 600;">Limits</h3>
    <ul style="color: #555; font-size: 14px; margin: 0 0 20px 0; padding-left: 24px;">
      <li style="margin-bottom: 8px;">GridLab v3.0 can handle grids with up to ~1.5 million vertices (tested on modern hardware). Performance depends on:</li>
      <li style="margin-bottom: 6px; margin-left: 20px;"><strong>Your GPU:</strong> Rendering capabilities determine max triangle count</li>
      <li style="margin-bottom: 6px; margin-left: 20px;"><strong>Culling settings:</strong> Surface culling, LOD, and optimization dramatically extend scalability</li>
      <li style="margin-bottom: 6px; margin-left: 20px;"><strong>Grid complexity:</strong> Edge detail settings (thin/thick segments) affect triangle count</li>
      <li style="margin-bottom: 8px;">Use the <strong>Rendering Optimizer</strong> to configure settings for optimal performance on your hardware</li>
    </ul>
    
    <div style="background: #e8f4fd; border-left: 4px solid #3b82f6; padding: 16px 20px; margin: 24px 0 0 0; border-radius: 4px;" id="licenseSection">
      <h3 style="font-size: 16px; color: #1e40af; margin: 0 0 8px 0; font-weight: 600;">📄 License & Copyright</h3>
      <p style="color: #1e40af; font-size: 14px; margin: 0 0 12px 0;">
        <strong>GridLab v3.0.0</strong> • Copyright © 2025 Albi
      </p>
      <p style="color: #1e40af; font-size: 13px; margin: 0 0 8px 0;">
        Licensed under <a href="https://polyformproject.org/licenses/noncommercial/1.0.0" target="_blank"
        style="color: #2563eb; text-decoration: underline;">PolyForm Noncommercial License 1.0.0</a>
      </p>
      <p style="color: #1e40af; font-size: 13px; margin: 0 0 8px 0;">
        ✅ <strong>Free</strong> for research, education, personal use<br>
        ❌ <strong>Commercial use requires a separate license</strong>
      </p>
      <p style="color: #1e40af; font-size: 13px; margin: 0;">
        For commercial licensing inquiries: <a href="mailto:albijuventus@yahoo.com"
        style="color: #2563eb;">albijuventus@yahoo.com</a>
      </p>
    </div>
    
  </div>
</div>


<!-- Keyboard Shortcuts Modal -->
<div id="keyboardShortcutsModal" style="display: none; position: fixed; top: 0; left: 0; 
     width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 2000; 
     align-items: center; justify-content: center;">
  <div style="background: white; border-radius: 12px; padding: 32px; max-width: 800px; 
       width: 90%; max-height: 85vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(0,0,0,0.3); position: relative;">
    
    <!-- Close Button -->
    <button id="closeShortcutsModal" style="position: absolute; top: 16px; right: 16px; 
            background: none; border: none; font-size: 28px; cursor: pointer; color: #666; 
            padding: 0; width: 32px; height: 32px; line-height: 28px; border-radius: 4px;
            transition: all 0.2s;">×</button>
    
    <!-- Title -->
    <h2 style="margin: 0 0 24px 0; font-size: 24px; color: #333; font-weight: 600;">Keyboard Shortcuts</h2>
    
    <!-- Shortcuts Grid -->
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 32px;">
      
      <!-- Left Column -->
      <div>
        <!-- File Operations -->
        <div style="margin-bottom: 28px;">
          <h3 style="font-size: 16px; color: #666; margin: 0 0 12px 0; font-weight: 600;">File Operations</h3>
          <div style="display: flex; flex-direction: column; gap: 10px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Save grid</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                   border: 1px solid #ddd; font-family: monospace; font-size: 13px;">Ctrl + S</kbd>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Load grid</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                   border: 1px solid #ddd; font-family: monospace; font-size: 13px;">Ctrl + L</kbd>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Stop generation</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                   border: 1px solid #ddd; font-family: monospace; font-size: 13px;">ESC</kbd>
            </div>
          </div>
        </div>
        
        <!-- Edit Operations -->
        <div style="margin-bottom: 28px;">
          <h3 style="font-size: 16px; color: #666; margin: 0 0 12px 0; font-weight: 600;">Edit Operations</h3>
          <div style="display: flex; flex-direction: column; gap: 10px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Undo</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                   border: 1px solid #ddd; font-family: monospace; font-size: 13px;">Ctrl + Z</kbd>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Redo</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                   border: 1px solid #ddd; font-family: monospace; font-size: 13px;">Ctrl + Y</kbd>
            </div>
          </div>
        </div>
        
        <!-- Notes -->
        <div style="margin-bottom: 28px;">
          <h3 style="font-size: 16px; color: #666; margin: 0 0 12px 0; font-weight: 600;">Notes</h3>
          <div style="display: flex; flex-direction: column; gap: 10px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Toggle notes window</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                   border: 1px solid #ddd; font-family: monospace; font-size: 13px;">Ctrl + M</kbd>
            </div>
          </div>
        </div>
        
        <!-- Mode Toggles -->
        <div>
          <h3 style="font-size: 16px; color: #666; margin: 0 0 12px 0; font-weight: 600;">Graph Editing</h3>
          <div style="display: flex; flex-direction: column; gap: 10px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Add/remove vertex</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                   border: 1px solid #ddd; font-family: monospace; font-size: 13px;">V</kbd>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Add/remove vertex deco</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                   border: 1px solid #ddd; font-family: monospace; font-size: 13px;">Shift + V</kbd>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Add/remove edge</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                   border: 1px solid #ddd; font-family: monospace; font-size: 13px;">E</kbd>
            </div>
			<div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Add/remove edge deco</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                   border: 1px solid #ddd; font-family: monospace; font-size: 13px;">Shift + E</kbd>
            </div>		
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Add/remove arrows</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                   border: 1px solid #ddd; font-family: monospace; font-size: 13px;">A</kbd>
            </div>
          </div>
        </div>
      </div>
      
<!-- Right Column -->
      <div>
        <!-- Backbite Mode -->
        <div>
          <h3 style="font-size: 16px; color: #666; margin: 0 0 12px 0; font-weight: 600;">Backbite Mode</h3>
          <div style="display: flex; flex-direction: column; gap: 10px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Toggle active endpoint</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                   border: 1px solid #ddd; font-family: monospace; font-size: 13px;">T</kbd>
            </div>
            <div style="margin-top: 8px; padding-top: 12px; border-top: 1px solid #eee;">
              <div style="color: #666; font-size: 13px; margin-bottom: 10px; font-style: italic;">Navigation:</div>
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <span style="color: #333;">Move up (Y-axis)</span>
                <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                     border: 1px solid #ddd; font-family: monospace; font-size: 13px;">↑</kbd>
              </div>
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <span style="color: #333;">Move down (Y-axis)</span>
                <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                     border: 1px solid #ddd; font-family: monospace; font-size: 13px;">↓</kbd>
              </div>
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <span style="color: #333;">Move left (X-axis)</span>
                <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                     border: 1px solid #ddd; font-family: monospace; font-size: 13px;">←</kbd>
              </div>
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <span style="color: #333;">Move right (X-axis)</span>
                <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                     border: 1px solid #ddd; font-family: monospace; font-size: 13px;">→</kbd>
              </div>
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <span style="color: #333;">Move up (Z-axis)</span>
                <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                     border: 1px solid #ddd; font-family: monospace; font-size: 13px;">Page Up</kbd>
              </div>
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <span style="color: #333;">Move down (Z-axis)</span>
                <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                     border: 1px solid #ddd; font-family: monospace; font-size: 13px;">Page Down</kbd>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Help & View -->
        <div style="margin-top: 28px;">
          <h3 style="font-size: 16px; color: #666; margin: 0 0 12px 0; font-weight: 600;">Help & View</h3>
          <div style="display: flex; flex-direction: column; gap: 10px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Sync view</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                  border: 1px solid #ddd; font-family: monospace; font-size: 13px;">S</kbd>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Show preferences</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                  border: 1px solid #ddd; font-family: monospace; font-size: 13px;">Shift + P</kbd>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Show keyboard shortcuts</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                  border: 1px solid #ddd; font-family: monospace; font-size: 13px;">Shift + ?</kbd>
            </div>
          </div>
        </div>
        
        <!-- Camera Control -->
        <div style="margin-top: 28px;">
          <h3 style="font-size: 16px; color: #666; margin: 0 0 12px 0; font-weight: 600;">Camera Control</h3>
          <div style="display: flex; flex-direction: column; gap: 10px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Decrease sensitivity</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                  border: 1px solid #ddd; font-family: monospace; font-size: 13px;">Shift + &lt;</kbd>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span style="color: #333;">Increase sensitivity</span>
              <kbd style="background: #f5f5f5; padding: 4px 8px; border-radius: 4px; 
                  border: 1px solid #ddd; font-family: monospace; font-size: 13px;">Shift + &gt;</kbd>
            </div>
          </div>
        </div>
        
      </div>  <!-- This closes the right column -->
      
    </div>
  </div>
</div>


<!-- Minimized Notes Button (hidden - using sidebar button instead) -->
<div id="notesMinimized" style="display: none;"></div>

<!-- Notes Window -->
<div id="notesWindow" style="position: fixed; top: 250px; left: 50%; transform: translateX(-50%); width: 600px; height: 400px; background: linear-gradient(145deg, #f0f0f0, #e0e0e0); border: 1px solid #ccc; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); z-index: 100; display: none; resize: both; overflow: hidden; min-width: 300px; min-height: 200px;">
  <div id="notesHeader" style="background: linear-gradient(145deg, #FFD966, #FFEB99); color: #333; padding: 8px 12px; font-size: 14px; font-weight: 500; cursor: move; border-radius: 8px 8px 0 0; user-select: none;">
    Notes - <span id="notesGridName">No Grid</span>
    <span id="notesMinimize" style="float: right; cursor: pointer; font-size: 16px; line-height: 1;">&minus;</span>
  </div>
  <div id="notesEditor" style="height: calc(100% - 42px); background: white; border-radius: 0 0 8px 8px;"></div>
</div>


<!-- Matrix-style Progress Display -->
<div id="progressOverlay" style="
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 9999;
  display: none;
  opacity: 0;
  transition: opacity 0.3s ease;
  cursor: not-allowed;
  background: transparent;
  justify-content: center;
  align-items: center;
">
  <!-- Centered content box -->
  <div id="progressContent" style="
    width: 300px;
    background: #0a0f0a;
    color: #b7f774;
    border: 1px solid #1d2a1d;
    border-radius: 8px;
    padding: 10px 12px;
    font: 12.5px/1.2 'Cascadia Mono', 'Consolas', 'Courier New', monospace;
  "></div>
</div>

<!-- Performance Warning Modal -->
<div id="performanceWarningModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 10001; justify-content: center; align-items: center;">
  <div style="background: white; border-radius: 8px; width: 500px; padding: 30px; box-shadow: 0 10px 40px rgba(0,0,0,0.4); position: relative;">
    <!-- Warning Icon and Title -->
    <div style="display: flex; align-items: center; margin-bottom: 20px;">
      <div style="width: 48px; height: 48px; background: #ff9800; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin-right: 15px; flex-shrink: 0;">
        <span style="color: white; font-size: 28px; font-weight: bold;">!</span>
      </div>
      <h3 style="margin: 0; color: #333; font-size: 20px; font-weight: 600;">Performance Warning</h3>
    </div>

    <!-- Message -->
    <div id="performanceWarningMessage" style="color: #555; font-size: 15px; line-height: 1.6; margin-bottom: 25px; padding-left: 63px;">
      <!-- Message will be inserted here dynamically -->
    </div>

    <!-- Buttons -->
    <div style="display: flex; gap: 12px; justify-content: flex-end;">
      <button id="performanceWarningCancel" style="padding: 10px 24px; background: #e0e0e0; border: none; border-radius: 6px; font-size: 14px; font-weight: 500; color: #333; cursor: pointer; transition: background 0.2s;">
        No, keep current settings
      </button>
      <button id="performanceWarningProceed" style="padding: 10px 24px; background: #ff9800; border: none; border-radius: 6px; font-size: 14px; font-weight: 500; color: white; cursor: pointer; transition: background 0.2s;">
        Yes, proceed with changes
      </button>
    </div>
  </div>
</div>

<!-- Vertex Limit Warning Modal -->
<div id="vertexLimitWarningModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 10001; justify-content: center; align-items: center;">
  <div style="background: white; border-radius: 8px; width: 500px; padding: 30px; box-shadow: 0 10px 40px rgba(0,0,0,0.4); position: relative;">
    <!-- Warning Icon and Title -->
    <div style="display: flex; align-items: center; margin-bottom: 20px;">
      <div style="width: 48px; height: 48px; background: #ff5722; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin-right: 15px; flex-shrink: 0;">
        <span style="color: white; font-size: 28px; font-weight: bold;">!</span>
      </div>
      <h3 style="margin: 0; color: #333; font-size: 20px; font-weight: 600;">Memory Warning</h3>
    </div>

    <!-- Message -->
    <div style="color: #555; font-size: 15px; line-height: 1.6; margin-bottom: 25px; padding-left: 63px;">
      <p style="margin: 0 0 12px 0;">Removing the vertex limit may allow you to create grids that <strong>exceed your browser's memory capacity</strong>, potentially causing:</p>
      <ul style="margin: 8px 0; padding-left: 20px;">
        <li>Browser tab crashes</li>
        <li>System slowdowns or freezes</li>
        <li>Loss of unsaved work</li>
      </ul>
      <p style="margin: 12px 0 0 0;">The default limit of <strong>1.1 million total vertices</strong> is designed to keep memory usage within safe bounds for most systems.</p>
      <p style="margin: 12px 0 0 0; font-weight: 600; color: #ff5722;">Are you sure you want to remove this safety limit?</p>
    </div>

    <!-- Buttons -->
    <div style="display: flex; gap: 12px; justify-content: flex-end;">
      <button id="vertexLimitWarningCancel" style="padding: 10px 24px; background: #4caf50; border: none; border-radius: 6px; font-size: 14px; font-weight: 500; color: white; cursor: pointer; transition: background 0.2s;">
        No, keep safety limit
      </button>
      <button id="vertexLimitWarningProceed" style="padding: 10px 24px; background: #ff5722; border: none; border-radius: 6px; font-size: 14px; font-weight: 500; color: white; cursor: pointer; transition: background 0.2s;">
        Yes, remove limit (risky)
      </button>
    </div>
  </div>
</div>




<!-- Preferences Modal -->
<div id="preferencesModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 10000; pointer-events: none; justify-content: center; align-items: center;">
  <div id="preferencesContent" style="background: var(--modal-bg, white); border-radius: 12px; width: 1000px; max-height: 95vh; overflow-y: auto; padding: 0; box-shadow: 0 10px 40px rgba(0,0,0,0.3); position: absolute; display: flex; flex-direction: column; pointer-events: auto;">

    <!-- Draggable Header -->
    <div id="preferencesDragHandle" style="display: flex; justify-content: space-between; align-items: center; padding: 20px 30px 15px 30px; border-bottom: 2px solid var(--modal-border, #e0e0e0); cursor: move; user-select: none; border-radius: 12px 12px 0 0; background: var(--modal-bg, white);">
      <h2 style="margin: 0; color: var(--modal-text, #2c3e50); font-size: 24px;">
        Preferences
      </h2>
      <button id="closePreferencesBtn" style="background: none; border: none; font-size: 28px; color: var(--modal-text, #666); cursor: pointer; padding: 0; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; transition: color 0.2s; opacity: 0.7;">×</button>
    </div>

    <!-- Content wrapper with padding -->
    <div style="padding: 25px 30px 30px 30px; overflow-y: auto; flex: 1; background: var(--modal-bg, white);">
    
    <!-- Preferences List - Two Column Layout -->
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 96px; margin-bottom: 0; flex: 1; overflow-y: visible;">

      <!-- LEFT COLUMN -->
      <div>

        <!-- Switch Mode Settings Section -->
        <div style="display: flex; align-items: center; gap: 12px; margin: 0 0 10px 0;">
          <h2 id="switchModeSettingsHeader" style="font-size: 15px; color: var(--sidebar-text, #2c3e50); margin: 0; font-weight: 700; cursor: pointer; user-select: none; display: flex; align-items: center; gap: 6px;">
            <span>Switch Mode Settings</span>
            <span id="switchModeSettingsCaret" style="font-size: 14px; transition: transform 0.2s;">▾</span>
          </h2>
          <label style="display: flex; align-items: center; cursor: pointer; font-size: 13px; color: #555; user-select: none;">
            <input type="checkbox" id="useDefaultSwitchModeSettingsCheckbox" checked style="width: 16px; height: 16px; margin-right: 6px; cursor: pointer;">
            Use Default
          </label>
        </div>

        <!-- Advanced Switch Mode Settings Container (hidden when use default is enabled) -->
        <div id="advancedSwitchModeSettings" style="display: none; margin-top: 18px; padding-top: 18px; border-top: 2px solid var(--modal-border, #e0e0e0); margin-bottom: 18px; padding-bottom: 18px; border-bottom: 2px solid var(--modal-border, #e0e0e0);">

          <!-- Box Highlighting Preference -->
          <div style="display: flex; align-items: center; padding: 6px 0; margin-bottom: 6px; transition: background 0s;">
            <input type="checkbox" id="boxHighlightingCheckbox" checked style="width: 18px; height: 18px; cursor: pointer; margin-right: 12px;">
            <label for="boxHighlightingCheckbox" style="cursor: pointer; font-size: 13px; color: #555; flex: 1; user-select: none;">
              Highlight switchable border boxes
            </label>
            <input type="color" id="boxHighlightColorPicker" value="#ffff00"
              style="width: 60px; height: 40px; padding: 0; border: 1px solid #bbb; border-radius: 6px; cursor: pointer; margin-left: 8px;"
              title="Highlight color">
          </div>

          <!-- Box Highlight Opacity + Color Disconnected Component Checkbox (same line) -->
          <div style="margin-bottom: 14px; margin-left: 30px; display: flex; align-items: center; gap: 12px;">
            <div style="flex: 1;">
              <label style="font-size: 12px; color: #666; display: block; margin-bottom: 4px;">
                Opacity: <span id="boxHighlightOpacityValue" style="font-weight: 600;">15%</span>
              </label>
              <input type="range" id="boxHighlightOpacitySlider" min="0" max="50" step="5" value="15"
                style="width: 100%; cursor: pointer;">
            </div>
            <label style="display: flex; align-items: center; cursor: pointer; font-size: 12px; color: #555; user-select: none; white-space: nowrap;">
              <input type="checkbox" id="componentColoringCheckbox" checked style="width: 16px; height: 16px; cursor: pointer; margin-right: 6px;">
              Color disconnected component
            </label>
          </div>

        </div>
        <!-- END Advanced Switch Mode Settings Container -->

        <!-- Vertex Settings Section -->
        <div style="display: flex; align-items: center; gap: 12px; margin: 14px 0 10px 0;">
          <h2 id="vertexSettingsHeader" style="font-size: 15px; color: var(--sidebar-text, #2c3e50); margin: 0; font-weight: 700; cursor: pointer; user-select: none; display: flex; align-items: center; gap: 6px;">
            <span>Vertex Settings</span>
            <span id="vertexSettingsCaret" style="font-size: 14px; transition: transform 0.2s;">▾</span>
          </h2>
          <label style="display: flex; align-items: center; cursor: pointer; font-size: 13px; color: #555; user-select: none;">
            <input type="checkbox" id="useDefaultVertexSettingsCheckbox" checked style="width: 16px; height: 16px; margin-right: 6px; cursor: pointer;">
            Use Default
          </label>
        </div>

        <!-- Advanced Vertex Settings Container (hidden when use default is enabled) -->
        <div id="advancedVertexSettings" style="display: none; margin-top: 18px; padding-top: 18px; border-top: 2px solid var(--modal-border, #e0e0e0); margin-bottom: 18px; padding-bottom: 18px; border-bottom: 2px solid var(--modal-border, #e0e0e0);">

          <!-- Vertex Radius + Vertex Dimmer (side by side) -->
          <div style="display: flex; gap: 16px; margin-bottom: 14px;">
            <div style="flex: 1;">
              <label for="vertexRadiusSlider" style="font-size: 13px; color: #555; display: block; margin-bottom: 4px; font-weight: 500;">
                Vertex Radius: <span id="vertexRadiusValue">0.12</span>
              </label>
              <input type="range" id="vertexRadiusSlider" min="0.02" max="0.2" step="0.01" value="0.12"
                style="width: 100%; cursor: pointer;">
            </div>
            <div style="flex: 1;">
              <label for="vertexDimmerSlider" style="font-size: 13px; color: #555; display: block; margin-bottom: 4px; font-weight: 500;">
                Vertex Dimmer: <span id="vertexDimmerValue">100</span>%
              </label>
              <input type="range" id="vertexDimmerSlider" min="0" max="100" step="1" value="100"
                style="width: 100%; cursor: pointer;">
            </div>
          </div>

        </div>
        <!-- END Advanced Vertex Settings Container -->

        <!-- REMOVED: Vertex Decoration Radius slider and Dynamic Shadow checkbox
             These controls allowed manual adjustment of vertex decoration size and optional dynamic following.
             NOW: Vertex decorations ALWAYS dynamically follow vertex size (simplified behavior).
             To restore: Uncomment this section and the related event handlers below (search for "VERTEX DECORATION REMOVED") -->
        <!-- <div style="display: flex; gap: 16px; margin-bottom: 14px; align-items: flex-start;">
          <div style="flex: 1;">
            <label for="vertexDecorationRadiusSlider" style="font-size: 13px; color: #555; display: block; margin-bottom: 4px; font-weight: 500;">
              Vertex Decoration Radius: <span id="vertexDecorationRadiusValue">0.1212</span>
            </label>
            <input type="range" id="vertexDecorationRadiusSlider" min="0.025" max="0.25" step="0.001" value="0.1212"
              style="width: 100%; cursor: pointer;">
          </div>
          <div style="flex: 1; display: flex; align-items: center; padding-top: 20px;">
            <label style="display: flex; align-items: center; cursor: pointer; font-size: 12px; color: #555; user-select: none;">
              <input type="checkbox" id="dynamicVertexDecoShadowCheckbox" style="width: 16px; height: 16px; cursor: pointer; margin-right: 6px;">
              Dynamic shadow (follows vertex radius)
            </label>
          </div>
        </div> -->

        <!-- Edge Settings Section -->
        <div style="display: flex; align-items: center; gap: 12px; margin: 14px 0 10px 0;">
          <h2 id="edgeSettingsHeader" style="font-size: 15px; color: var(--sidebar-text, #2c3e50); margin: 0; font-weight: 700; cursor: pointer; user-select: none; display: flex; align-items: center; gap: 6px;">
            <span>Edge Settings</span>
            <span id="edgeSettingsCaret" style="font-size: 14px; transition: transform 0.2s;">▾</span>
          </h2>
          <label style="display: flex; align-items: center; cursor: pointer; font-size: 13px; color: #555; user-select: none;">
            <input type="checkbox" id="useDefaultEdgeSettingsCheckbox" checked style="width: 16px; height: 16px; margin-right: 6px; cursor: pointer;">
            Use Default
          </label>
        </div>

        <!-- Advanced Edge Settings Container (hidden when use default is enabled) -->
        <div id="advancedEdgeSettings" style="display: none; margin-top: 18px; padding-top: 18px; border-top: 2px solid var(--modal-border, #e0e0e0); margin-bottom: 18px; padding-bottom: 18px; border-bottom: 2px solid var(--modal-border, #e0e0e0);">

          <!-- Thin Edge Radius + Thick Edge Radius (same line) -->
          <div style="display: flex; gap: 16px; margin-bottom: 14px;">
            <div style="flex: 1;">
              <label style="font-size: 13px; color: #555; display: block; margin-bottom: 5px; font-weight: 500;">
                Thin Edge Radius: <span id="thinEdgeRadiusValue" style="font-weight: 600;">0.015</span>
              </label>
              <input type="range" id="thinEdgeRadiusSlider" min="0.005" max="0.03" step="0.001" value="0.015"
                style="width: 100%; cursor: pointer;">
            </div>
            <div id="thickEdgeRadiusContainer" style="flex: 1;">
              <label style="font-size: 13px; color: #555; display: block; margin-bottom: 5px; font-weight: 500;">
                Thick Edge Radius: <span id="thickEdgeRadiusValue" style="font-weight: 600;">0.05</span>
              </label>
              <input type="range" id="thickEdgeRadiusSlider" min="0.02" max="0.25" step="0.005" value="0.05"
                style="width: 100%; cursor: pointer;">
            </div>
          </div>

          <!-- Edge Decoration Radius + Edge Click Radius (same line) -->
          <div style="display: flex; gap: 16px; margin-bottom: 14px;">
            <div style="flex: 1;">
              <label for="edgeDecorationRadiusSlider" style="font-size: 13px; color: #555; display: block; margin-bottom: 5px; font-weight: 500;">
                Edge Decoration: <span id="edgeDecorationRadiusValue">0.12</span>
              </label>
              <input type="range" id="edgeDecorationRadiusSlider" min="0.025" max="0.25" step="0.001" value="0.12"
                style="width: 100%; cursor: pointer;">
            </div>
            <div style="flex: 1;">
              <label style="font-size: 13px; color: #555; display: block; margin-bottom: 5px; font-weight: 500;">
                Edge Click Radius: <span id="edgeCollisionRadiusValue">0.08</span>
              </label>
              <input type="range" id="edgeCollisionRadiusSlider" min="0.02" max="0.15" step="0.01" value="0.08" style="width: 100%; cursor: pointer;">
            </div>
          </div>

          <!-- Arrow Mode Setting -->
          <div style="margin-bottom: 14px;">
            <label for="arrowModeSelect" style="font-size: 13px; color: #555; display: block; margin-bottom: 5px; font-weight: 500;">Arrow Style:</label>
            <select id="arrowModeSelect" style="width: 100%; padding: 6px 10px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-size: 13px; background: white;">
              <option value="transcendent">Transcendent (Grid is transparent to arrows)</option>
              <option value="normal" selected>Normal (Grid is opaque to arrows)</option>
            </select>
          </div>

        </div>
        <!-- END Advanced Edge Settings Container -->

        <!-- Show on Main Screen Section -->
        <div style="display: flex; align-items: center; gap: 12px; margin: 14px 0 10px 0;">
          <h2 style="font-size: 15px; color: #2c3e50; margin: 0; font-weight: 700;">Show on Main Screen</h2>
        </div>

        <div style="margin-bottom: 14px;">

          <!-- Two columns layout -->
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">

            <!-- Column 1: Grid Vertices, Vertex Dimmer, Flare Button -->
            <div style="display: flex; flex-direction: column; gap: 10px;">
              <label style="display: flex; align-items: center; cursor: pointer; font-size: 12px; color: #555; user-select: none;">
                <input type="checkbox" id="showAllVerticesCheckbox" style="width: 16px; height: 16px; cursor: pointer; margin-right: 6px;">
                Grid Vertices
              </label>
              <label style="display: flex; align-items: center; cursor: pointer; font-size: 12px; color: #555; user-select: none;">
                <input type="checkbox" id="showVertexDimmerCheckbox" style="width: 16px; height: 16px; cursor: pointer; margin-right: 6px;">
                Vertex Dimmer
              </label>
              <label style="display: flex; align-items: center; cursor: pointer; font-size: 12px; color: #555; user-select: none;">
                <input type="checkbox" id="showFlareButtonCheckboxClone" style="width: 16px; height: 16px; cursor: pointer; margin-right: 6px;">
                Flare Button
              </label>
            </div>

            <!-- Column 2: Subgraph Panel, Plane Highlighter, Performance Indicators -->
            <div style="display: flex; flex-direction: column; gap: 10px;">
              <label style="display: flex; align-items: center; cursor: pointer; font-size: 12px; color: #555; user-select: none;">
                <input type="checkbox" id="showSubgraphPanelCheckbox" checked style="width: 16px; height: 16px; cursor: pointer; margin-right: 6px;">
                Subgraph Panel
              </label>
              <label style="display: flex; align-items: center; cursor: pointer; font-size: 12px; color: #555; user-select: none;">
                <input type="checkbox" id="showPlaneHighlighterPanelCheckbox" style="width: 16px; height: 16px; cursor: pointer; margin-right: 6px;">
                Plane Highlighter
              </label>
              <label style="display: flex; align-items: center; cursor: pointer; font-size: 12px; color: #555; user-select: none;">
                <input type="checkbox" id="lodIndicatorsCheckbox" checked style="width: 16px; height: 16px; cursor: pointer; margin-right: 6px;">
                Performance Indicators
              </label>
            </div>

          </div>

        </div>
        <!-- END Show on Main Screen Container -->

        <!-- Other Display Settings Section -->
        <div style="display: flex; align-items: center; gap: 12px; margin: 14px 0 10px 0;">
          <h2 id="otherDisplaySettingsHeader" style="font-size: 15px; color: var(--sidebar-text, #2c3e50); margin: 0; font-weight: 700; cursor: pointer; user-select: none; display: flex; align-items: center; gap: 6px;">
            <span>Other Display Settings</span>
            <span id="otherDisplaySettingsCaret" style="font-size: 14px; transition: transform 0.2s;">▾</span>
          </h2>
          <label style="display: flex; align-items: center; cursor: pointer; font-size: 13px; color: #555; user-select: none;">
            <input type="checkbox" id="useDefaultOtherDisplaySettingsCheckbox" checked style="width: 16px; height: 16px; margin-right: 6px; cursor: pointer;">
            Use Default
          </label>
        </div>

        <!-- Advanced Other Display Settings Container (hidden when use default is enabled) -->
        <div id="advancedOtherDisplaySettings" style="display: none; margin-top: 18px; padding-top: 18px; border-top: 2px solid var(--modal-border, #e0e0e0); margin-bottom: 18px; padding-bottom: 18px; border-bottom: 2px solid var(--modal-border, #e0e0e0);">

          <!-- Flare Section -->
          <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 10px;">
            <h3 style="font-size: 15px; color: #2c3e50; margin: 0; font-weight: 600;">Flare</h3>
            <label style="display: flex; align-items: center; cursor: pointer; font-size: 12px; color: #555; user-select: none;">
              <input type="checkbox" id="showFlareButtonCheckbox" style="width: 16px; height: 16px; cursor: pointer; margin-right: 6px;">
              Show Flare button on main screen
            </label>
          </div>

          <!-- Flare Color + Radius (same row) -->
          <div style="display: flex; gap: 16px; margin-bottom: 14px;">
            <div style="flex: 1;">
              <label for="flareColorPicker" style="font-size: 13px; color: #555; display: block; margin-bottom: 4px; font-weight: 500;">Flare Color:</label>
              <input type="color" id="flareColorPicker" value="#ffff00" style="width: 60px; height: 40px; border: 1px solid #bbb; border-radius: 6px; cursor: pointer;">
            </div>
            <div style="flex: 1;">
              <label for="flareRadiusSlider" style="font-size: 13px; color: #555; display: block; margin-bottom: 4px; font-weight: 500;">
                Radius: <span id="flareRadiusValue">0.7</span>
              </label>
              <input type="range" id="flareRadiusSlider" min="0.3" max="1.5" step="0.1" value="0.7"
                style="width: 100%; cursor: pointer;">
            </div>
          </div>

          <!-- Coordinate Hover Section -->
          <div style="display: flex; align-items: center; gap: 12px; margin: 14px 0 10px 0;">
            <h3 style="font-size: 15px; color: #2c3e50; margin: 0; font-weight: 600;">Coordinate Hover</h3>
            <label style="display: flex; align-items: center; cursor: pointer; font-size: 12px; color: #555; user-select: none;">
              <input type="checkbox" id="showCoordHoverPanelCheckbox" style="width: 16px; height: 16px; cursor: pointer; margin-right: 6px;">
              Show panel on main screen
            </label>
          </div>

          <!-- Coordinate Hover - Vertices and Edges (same line) -->
          <div style="display: flex; align-items: center; padding: 6px 0; margin-bottom: 14px; gap: 24px;">
            <label style="display: flex; align-items: center; cursor: pointer; font-size: 13px; color: #555; user-select: none;">
              <input type="checkbox" id="hoverVerticesCheckbox" checked style="width: 18px; height: 18px; cursor: pointer; margin-right: 8px;">
              Show vertex coordinates
            </label>
            <label style="display: flex; align-items: center; cursor: pointer; font-size: 13px; color: #555; user-select: none;">
              <input type="checkbox" id="hoverEdgesCheckbox" checked style="width: 18px; height: 18px; cursor: pointer; margin-right: 8px;">
              Show edge coordinates
            </label>
          </div>

        </div>
        <!-- END Advanced Other Display Settings Container -->

        <!-- Camera Section -->
        <h2 style="font-size: 15px; color: #2c3e50; margin: 14px 0 10px 0; font-weight: 700;">Camera</h2>

        <!-- Camera Mouse Sensitivity + Show Slider (same line) -->
        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 10px;">
          <label for="cameraSensitivitySlider" style="font-size: 13px; color: #555; font-weight: 500; white-space: nowrap;">Mouse Sensitivity:</label>
          <div style="display: flex; align-items: center; gap: 6px; flex: 1;">
            <input type="range" id="cameraSensitivitySlider" min="0.1" max="2.0" step="0.1" value="1.0" style="width: 80px;">
            <span id="cameraSensitivityValue" style="font-size: 13px; color: #555; min-width: 24px;">1.0</span>
          </div>
          <label style="display: flex; align-items: center; cursor: pointer; font-size: 13px; color: #555; user-select: none; white-space: nowrap;">
            <input type="checkbox" id="showCameraSensitivityCheckbox" style="width: 16px; height: 16px; cursor: pointer; margin-right: 6px;">
            Show slider on main screen
          </label>
        </div>

        <!-- Use 2D Camera Mode + Show Camera Position (same line) -->
        <div style="display: flex; align-items: center; padding: 6px 0; gap: 24px;">
          <label style="display: flex; align-items: center; cursor: pointer; font-size: 13px; color: #555; user-select: none;">
            <input type="checkbox" id="use2DCameraModeCheckbox" checked style="width: 18px; height: 18px; cursor: pointer; margin-right: 8px;">
            Use 2D camera for 2D grids
          </label>
          <label style="display: flex; align-items: center; cursor: pointer; font-size: 13px; color: #555; user-select: none;">
            <input type="checkbox" id="showManualCameraControlCheckbox" style="width: 18px; height: 18px; cursor: pointer; margin-right: 8px;">
            Show camera position controls
          </label>
        </div>

        <!-- Auto Sync View Checkbox -->
        <div style="display: flex; align-items: center; padding: 6px 0; margin-top: 6px;">
          <label style="display: flex; align-items: center; cursor: pointer; font-size: 13px; color: #555; user-select: none;">
            <input type="checkbox" id="autoSyncViewCheckbox" checked style="width: 18px; height: 18px; cursor: pointer; margin-right: 8px;">
            Auto Sync View (share camera across grids)
          </label>
        </div>

        <!-- Theme and Background Section -->
        <h2 style="font-size: 15px; color: #2c3e50; margin: 20px 0 10px 0; font-weight: 700;">Theme and Background</h2>

        <!-- Theme + Background (side by side) -->
        <div style="display: flex; gap: 16px; margin-bottom: 10px;">
          <div style="flex: 1;">
            <label for="themeSelect" style="font-size: 13px; color: #555; display: block; margin-bottom: 4px; font-weight: 500;">Theme:</label>
            <select id="themeSelect" style="width: 100%; padding: 6px 10px; border: 1px solid #bbb; border-radius: 6px; cursor: pointer; font-size: 13px; background: white; color: #333;">
              <option value="paper-white">Light</option>
              <option value="dark">Dark</option>
            </select>
          </div>
          <div style="flex: 1;">
            <label for="backgroundOverrideSelect" style="font-size: 13px; color: #555; display: block; margin-bottom: 4px; font-weight: 500;">Background:</label>
            <select id="backgroundOverrideSelect" style="width: 100%; padding: 6px 10px; border: 1px solid #bbb; border-radius: 6px; cursor: pointer; font-size: 13px; background: white; color: #333;">
              <option value="theme-default">Theme Default</option>
              <option value="light-gradient">Beige</option>
              <option value="white">White</option>
              <option value="black">Black</option>
              <option value="custom">Custom Color...</option>
            </select>
          </div>
        </div>

        <!-- Auto-switch theme by time of day -->
        <div style="display: flex; align-items: center; padding: 6px 0; margin-bottom: 10px;">
          <input type="checkbox" id="autoSwitchThemeCheckbox" style="width: 16px; height: 16px; cursor: pointer; margin-right: 10px;">
          <label for="autoSwitchThemeCheckbox" style="cursor: pointer; font-size: 13px; color: #555; flex: 1; user-select: none;">
            Auto-switch theme by time of day
          </label>
        </div>

        <!-- Custom Background Color Picker (hidden by default) -->
        <div id="customBackgroundPicker" style="display: none; margin-bottom: 14px;">
          <label for="customBgColor" style="font-size: 13px; color: #555; display: block; margin-bottom: 4px; font-weight: 500;">Custom Color:</label>
          <input type="color" id="customBgColor" value="#f7f5e9" style="width: 60px; height: 40px; border: 1px solid #bbb; border-radius: 6px; cursor: pointer;">
        </div>

      </div>

      <!-- RIGHT COLUMN -->
      <div>

        <!-- Rendering Settings Section -->
        <div style="display: flex; align-items: center; gap: 12px; margin: 0 0 14px 0;">
          <h2 id="renderingSettingsHeader" style="font-size: 15px; color: var(--sidebar-text, #2c3e50); margin: 0; font-weight: 700; cursor: pointer; user-select: none; display: flex; align-items: center; gap: 6px;">
            <span>Rendering Settings</span>
            <span id="renderingSettingsCaret" style="font-size: 14px; transition: transform 0.2s;">▾</span>
          </h2>
          <label style="display: flex; align-items: center; cursor: pointer; font-size: 13px; color: #555; user-select: none;">
            <input type="checkbox" id="useAutomaticRenderingCheckbox" checked style="width: 16px; height: 16px; cursor: pointer; margin-right: 6px;">
            Use Default
          </label>
        </div>

        <!-- Basic Rendering Settings Container (always visible) -->
        <div id="basicRenderingSettings" style="display: block; margin-bottom: 14px;">

          <!-- Row 1: Thin Edge Detail + Thick Edge Detail + Vertex Detail -->
          <div style="display: flex; gap: 24px; margin-bottom: 14px;">
            <div style="min-width: 90px;">
              <label for="edgeDetailSelect" style="font-size: 13px; color: #555; display: block; margin-bottom: 4px;">Thin Edge Detail:</label>
              <select id="edgeDetailSelect" style="width: 80px; padding: 5px 8px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-size: 13px; background: white;">
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
                <option value="6">6</option>
                <option value="8" selected>8</option>
                <option value="12">12</option>
                <option value="16">16</option>
              </select>
            </div>
            <div style="min-width: 90px;">
              <label for="thickEdgeDetailSelect" style="font-size: 13px; color: #555; display: block; margin-bottom: 4px;">Thick Edge Detail:</label>
              <select id="thickEdgeDetailSelect" style="width: 80px; padding: 5px 8px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-size: 13px; background: white;">
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
                <option value="6">6</option>
                <option value="8">8</option>
                <option value="12" selected>12</option>
                <option value="16">16</option>
              </select>
            </div>
            <div style="min-width: 90px;">
              <label for="vertexDetailSelect" style="font-size: 13px; color: #555; display: block; margin-bottom: 4px;">Vertex Detail:</label>
              <select id="vertexDetailSelect" style="width: 80px; padding: 5px 8px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-size: 13px; background: white;">
                <option value="0">Low</option>
                <option value="1" selected>Normal</option>
                <option value="2">Medium</option>
                <option value="3">High</option>
                <option value="4">Ultra</option>
              </select>
            </div>
          </div>

          <!-- Remove Vertex Limit + Unified Edge Size (same line) -->
          <div style="display: flex; gap: 24px; margin-bottom: 0; align-items: center;">
            <label style="font-size: 13px; color: #555; display: flex; align-items: center; cursor: pointer;">
              <input type="checkbox" id="removeVertexLimitCheckbox" style="width: 16px; height: 16px; margin-right: 6px; cursor: pointer;">
              <span>Remove Vertex Limit (1.5M)</span>
            </label>
            <label id="unifiedEdgeSizeContainer" style="display: flex; align-items: center; cursor: pointer; font-size: 13px; color: #555; user-select: none;">
              <input type="checkbox" id="unifiedEdgeSizeCheckbox" style="width: 16px; height: 16px; cursor: pointer; margin-right: 6px;">
              Unified Edge Size
            </label>
          </div>

        </div>
        <!-- END Basic Rendering Settings Container -->

        <!-- Advanced Rendering Settings Container (hidden when automatic is enabled) -->
        <div id="advancedRenderingSettings" style="display: none; margin-top: 18px; padding-top: 18px; border-top: 2px solid var(--modal-border, #e0e0e0); margin-bottom: 18px; padding-bottom: 18px; border-bottom: 2px solid var(--modal-border, #e0e0e0);">
          <h3 style="font-size: 15px; color: #2c3e50; margin: 0 0 14px 0; font-weight: 600;">Advanced Settings</h3>

        <!-- Row 2: Frustum Culling -->
        <div style="display: flex; gap: 24px; margin-bottom: 14px; align-items: center;">
          <label style="font-size: 13px; color: #555; display: flex; align-items: center; cursor: pointer;">
            <input type="checkbox" id="frustumCullingCheckbox" checked style="width: 16px; height: 16px; margin-right: 6px; cursor: pointer;">
            <span>Frustum Culling</span>
          </label>
        </div>

        <!-- Row 3: Surface Culling + Surface Depth -->
        <div style="display: flex; gap: 24px; margin-bottom: 14px; align-items: center;">
          <label style="font-size: 13px; color: #555; display: flex; align-items: center; cursor: pointer;">
            <input type="checkbox" id="surfaceCullingCheckbox" checked style="width: 16px !important; height: 16px !important; min-width: 16px; min-height: 16px; margin-right: 6px; cursor: pointer;">
            <span>Surface Culling</span>
          </label>
          <div>
            <label for="surfaceDepthSelect" style="font-size: 13px; color: #555; margin-right: 6px;">Near Depth:</label>
            <select id="surfaceDepthSelect" style="width: 90px; padding: 5px 8px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-size: 13px; background: white;">
              <option value="1">1 chunk</option>
              <option value="2" selected>2 chunks</option>
              <option value="3">3 chunks</option>
              <option value="4">4 chunks</option>
              <option value="5">5 chunks</option>
            </select>
          </div>
          <div>
            <label for="farCullingDepthSelect" style="font-size: 13px; color: #555; margin-right: 6px;">Far Depth:</label>
            <select id="farCullingDepthSelect" style="width: 90px; padding: 5px 8px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-size: 13px; background: white;">
              <option value="0">0 chunks</option>
              <option value="1">1 chunk</option>
              <option value="2" selected>2 chunks</option>
              <option value="3">3 chunks</option>
              <option value="4">4 chunks</option>
              <option value="5">5 chunks</option>
            </select>
          </div>
        </div>

        <!-- Row 4: Spherical Culling + Render Radius -->
        <div style="display: flex; gap: 24px; margin-bottom: 14px; align-items: center;">
          <label style="font-size: 13px; color: #555; display: flex; align-items: center; cursor: pointer;">
            <input type="checkbox" id="sphericalCullingCheckbox" checked style="width: 16px; height: 16px; margin-right: 6px; cursor: pointer;">
            <span>Spherical Culling</span>
          </label>
          <div>
            <label for="renderRadiusSelect" style="font-size: 13px; color: #555; margin-right: 6px;">Render Radius:</label>
            <select id="renderRadiusSelect" style="width: 90px; padding: 5px 8px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-size: 13px; background: white;">
              <option value="1">1 chunk</option>
              <option value="2">2 chunks</option>
              <option value="3">3 chunks</option>
              <option value="4" selected>4 chunks</option>
              <option value="5">5 chunks</option>
            </select>
          </div>
        </div>

        <!-- Enable LOD + Quality Slider (same row) -->
        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 14px;">
          <label style="font-size: 13px; color: #555; display: flex; align-items: center; cursor: pointer; white-space: nowrap;">
            <input type="checkbox" id="lodEnabledCheckbox" style="width: 16px; height: 16px; margin-right: 8px; cursor: pointer;">
            <span>Enable Level of Detail (LOD)</span>
          </label>
          <div style="display: flex; align-items: center; gap: 4px;">
            <span style="font-size: 10px; color: #888;">Performance</span>
            <input type="range" id="lodQualitySlider" min="5" max="10" value="10" step="1"
                   style="width: 60px; cursor: pointer; height: 6px; border-radius: 3px; background: #ddd;">
            <span style="font-size: 10px; color: #888;">Quality</span>
          </div>
        </div>

        <!-- Chunk Size + Max Rebuilds (side by side) -->
        <div style="display: flex; gap: 24px; margin-bottom: 14px;">
          <div style="min-width: 90px;">
            <label for="chunkSizeInput" style="font-size: 13px; color: #555; display: block; margin-bottom: 4px;">Chunk Size:</label>
            <input type="number" id="chunkSizeInput" value="5" min="3" max="20" step="1"
                   style="width: 80px; padding: 5px 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px;">
          </div>
          <div style="min-width: 90px;">
            <label for="maxRebuildsInput" style="font-size: 13px; color: #555; display: block; margin-bottom: 4px;">Max Rebuilds/Frame:</label>
            <input type="number" id="maxRebuildsInput" value="16" min="1" max="32" step="1"
                   style="width: 80px; padding: 5px 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px;">
          </div>
        </div>

        <!-- Optimize Rendering Button -->
        <div style="margin-top: 20px; padding-top: 16px; border-top: 2px solid #e0e0e0;">
          <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 10px;">
            <label for="optimizeTriangleBudget" style="font-size: 13px; color: #555; font-weight: 600;">Triangle Budget (M):</label>
            <input type="number" id="optimizeTriangleBudget" value="15" min="1" max="100" step="1"
                   style="width: 80px; padding: 6px 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px;">
            <button id="optimizeRenderingBtn"
                    style="padding: 8px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: 600; transition: background 0.2s;">
              Optimize Settings
            </button>
          </div>
          <div style="font-size: 11px; color: #777; line-height: 1.4;">
            Automatically adjusts culling and LOD settings to target the specified triangle count for optimal performance.
          </div>
        </div>

        </div>
        <!-- END Advanced Rendering Settings Container -->

        <!-- Lazy Loading Objects Section -->
        <div style="display: flex; align-items: center; gap: 12px; margin: 20px 0 14px 0;">
          <h2 id="lazyLoadingHeader" style="font-size: 15px; color: var(--sidebar-text, #2c3e50); margin: 0; font-weight: 700; cursor: pointer; user-select: none; display: flex; align-items: center; gap: 6px;">
            <span>Lazy Loading Objects</span>
            <span id="lazyLoadingCaret" style="font-size: 14px; transition: transform 0.2s;">▾</span>
          </h2>
          <label style="display: flex; align-items: center; cursor: pointer; font-size: 13px; color: #555; user-select: none;">
            <input type="checkbox" id="useDefaultLazyLoadingCheckbox" checked style="width: 16px; height: 16px; margin-right: 6px; cursor: pointer;">
            Use Default
          </label>
        </div>

        <!-- Lazy Loading Settings Container -->
        <div id="lazyLoadingSettings" style="display: none; margin-top: 18px; padding-top: 18px; border-top: 2px solid var(--modal-border, #e0e0e0); margin-bottom: 18px; padding-bottom: 18px; border-bottom: 2px solid var(--modal-border, #e0e0e0);">

          <!-- Two columns layout -->
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">

            <!-- Column 1: Arrows, Switchable Boxes, Vertex Spheres -->
            <div style="display: flex; flex-direction: column; gap: 10px;">
              <label style="font-size: 12px; color: #555; display: flex; align-items: center; cursor: pointer;">
                <input type="checkbox" id="lazyLoadArrowsCheckbox" checked style="width: 16px; height: 16px; margin-right: 6px; cursor: pointer;">
                Arrows
              </label>
              <label style="font-size: 12px; color: #555; display: flex; align-items: center; cursor: pointer;">
                <input type="checkbox" id="lazyLoadSwitchableBoxesCheckbox" checked style="width: 16px; height: 16px; margin-right: 6px; cursor: pointer;">
                Switchable Boxes
              </label>
              <label style="font-size: 12px; color: #555; display: flex; align-items: center; cursor: pointer;">
                <input type="checkbox" id="lazyLoadVertexSpheresCheckbox" checked style="width: 16px; height: 16px; margin-right: 6px; cursor: pointer;">
                Vertex Spheres
              </label>
            </div>

            <!-- Column 2: Edge Collision, Block Cubes -->
            <div style="display: flex; flex-direction: column; gap: 10px;">
              <label style="font-size: 12px; color: #555; display: flex; align-items: center; cursor: pointer;">
                <input type="checkbox" id="lazyLoadEdgeCollisionCheckbox" checked style="width: 16px; height: 16px; margin-right: 6px; cursor: pointer;">
                Edge Collision
              </label>
              <label style="font-size: 12px; color: #555; display: flex; align-items: center; cursor: pointer;">
                <input type="checkbox" id="lazyLoadBlockCubesCheckbox" checked style="width: 16px; height: 16px; margin-right: 6px; cursor: pointer;">
                Block Cubes
              </label>
            </div>

          </div>

        </div>
        <!-- END Lazy Loading Settings Container -->

      </div>

    </div>
    
    <!-- Footer Buttons -->
    <div style="display: flex; gap: 10px; justify-content: flex-end;">
      <button id="savePreferencesBtn" style="padding: 10px 20px; background: #3498db; color: white; border: none; border-radius: 6px; cursor: pointer; font-family: inherit; font-size: 14px; font-weight: 500; transition: background 0.2s;">
        Save & Close
      </button>
    </div>

    </div><!-- End content wrapper -->
  </div><!-- End preferencesContent -->
</div><!-- End preferencesModal -->

<!-- Subgraph Analysis Modal -->
<div id="subgraphAnalysisModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 10000; pointer-events: none; justify-content: center; align-items: center;">
  <div id="subgraphAnalysisContent" style="background: var(--modal-bg, white); border-radius: 12px; width: 700px; max-height: 80vh; overflow-y: auto; padding: 0; box-shadow: 0 10px 40px rgba(0,0,0,0.3); position: absolute; display: flex; flex-direction: column; pointer-events: auto;">

    <!-- Draggable Header -->
    <div id="subgraphAnalysisDragHandle" style="display: flex; justify-content: space-between; align-items: center; padding: 20px 30px 15px 30px; border-bottom: 2px solid var(--modal-border, #e0e0e0); cursor: move; user-select: none; border-radius: 12px 12px 0 0; background: var(--modal-bg, white);">
      <h2 style="margin: 0; color: var(--modal-text, #2c3e50); font-size: 20px; font-weight: 600;">
        Subgraph Data
      </h2>
      <button id="closeSubgraphAnalysisBtn" style="background: none; border: none; font-size: 28px; color: var(--modal-text, #2c3e50); cursor: pointer; padding: 0; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; transition: opacity 0.2s; opacity: 0.7;">×</button>
    </div>

    <!-- Content Area -->
    <div style="padding: 25px 30px 30px 30px; overflow-y: auto; flex: 1; background: var(--modal-bg, white);">
      <div id="subgraphAnalysisOutput" style="font-family: 'Courier New', monospace; font-size: 13px; line-height: 1.6; color: var(--modal-code-text, #333); white-space: pre-wrap;">
        <!-- Analysis output will be inserted here -->
      </div>
    </div>

    <!-- Footer with Close Button -->
    <div style="padding: 15px 30px; border-top: 1px solid var(--modal-border, #e0e0e0); background: var(--modal-bg, white); display: flex; justify-content: flex-end; border-radius: 0 0 12px 12px;">
      <button id="closeSubgraphAnalysisBtn2" style="padding: 8px 24px; background: #9b59b6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500; transition: background 0.2s;">
        Close
      </button>
    </div>

  </div>
</div>






<!-- README Modal -->
<div id="readmeModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10000; justify-content: center; align-items: center;">
  <div style="background: white; border-radius: 12px; max-width: 900px; max-height: 85vh; overflow-y: auto; padding: 40px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); position: relative;">
    
    <!-- Close Button -->
    <button id="closeReadmeModal" style="position: absolute; top: 16px; right: 16px; background: white; border: 2px solid #ddd; border-radius: 6px; width: 36px; height: 36px; cursor: pointer; font-size: 20px; color: #666; display: flex; align-items: center; justify-content: center; transition: all 0.2s;">×</button>
    
    <!-- README Content -->
    <div style="color: #333; line-height: 1.6;">
      
      <h1 style="margin-top: 0; color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px;">GridLab v2.1</h1>
      
      <p style="font-size: 16px; color: #555; margin-bottom: 30px;"><strong>GridLab</strong> is an interactive 3D visualization and editing tool for exploring Hamiltonian paths and cycles on grid graphs. Built with Three.js, it provides an environment for studying graph theory, particularly the properties of paths and cycles on rectangular lattice structures.</p>
      
      <hr style="border: none; border-top: 2px solid #eee; margin: 30px 0;">
      
      <h2 style="color: #2c3e50; margin-top: 30px;">Overview</h2>
      <p>GridLab enables researchers and enthusiasts to:</p>
      <ul style="margin-left: 20px;">
        <li>Generate and visualize Hamiltonian paths and cycles on 2D and 3D grid graphs</li>
        <li>Perform backbite moves (both automated and manual) to explore the space of Hamiltonian paths</li>
        <li>Apply switch moves to modify cycles and paths</li>
        <li>Color edges with gradients and add directional arrows</li>
        <li>Work with multiple grids simultaneously</li>
        <li>Add vertex and edge decorations for marking special structures</li>
        <li>Display all grid vertices for structural visualization</li>
        <li>Save and load complete project states</li>
      </ul>
      
      <h2 style="color: #2c3e50; margin-top: 30px;">Core Concepts</h2>
      
      <h3 style="color: #34495e; margin-top: 20px;">Grid Graphs</h3>
      <p>A grid graph is a rectangular lattice of vertices connected by edges. GridLab supports grids of arbitrary dimensions (width × height × depth), allowing exploration of everything from 2D planar grids to complex 3D structures.</p>
      
      <h3 style="color: #34495e; margin-top: 20px;">Hamiltonian Paths and Cycles</h3>
      <ul style="margin-left: 20px;">
        <li><strong>Hamiltonian Path:</strong> A path that visits every vertex in the graph exactly once</li>
        <li><strong>Hamiltonian Cycle:</strong> A path that visits every vertex exactly once and returns to the starting vertex</li>
      </ul>
      
      <h3 style="color: #34495e; margin-top: 20px;">Backbite Moves</h3>
      <p>A backbite move is a local transformation that reconfigures a Hamiltonian path into a new one. This is a key operation for exploring the space of all Hamiltonian paths on a given grid.</p>
      
      <h3 style="color: #34495e; margin-top: 20px;">Switch Moves</h3>
      <p>switch move operates on a "switchable box" - a 2×2 square where exactly two parallel edges are in the path/cycle/subgraph. The move swaps which pair is included. If we start with a Hamiltonian cycle in 3D, the move either produces a new Hamiltonian cycle or it produce a cover of the grid with two cycles. Switching any boundary box between those two cycles produces a new Hamiltonian cycle.</p>
      
      <h2 style="color: #2c3e50; margin-top: 30px;">Getting Started</h2>
      
      <h3 style="color: #34495e; margin-top: 20px;">Creating Your First Grid</h3>
      <ol style="margin-left: 20px;">
        <li>Set dimensions using the <strong>Grid Dimensions</strong> controls (top right)</li>
        <li>Click <strong>Add Grid</strong> to create a new grid</li>
        <li>The grid appears in the 3D viewport with a button in the grid list at the bottom</li>
      </ol>
      
      <h3 style="color: #34495e; margin-top: 20px;">Navigation</h3>
      <ul style="margin-left: 20px;">
        <li><strong>Rotate:</strong> Left-click and drag (disabled for 2D grids)</li>
        <li><strong>Pan:</strong> Right-click and drag (or Shift + left-click and drag)</li>
        <li><strong>Zoom:</strong> Scroll wheel</li>
        <li><strong>2D Grids:</strong> Grids with one dimension = 1 use special camera mode (pan/zoom only, no rotation) for easier navigation. This can be toggled in Preferences.</li>
      </ul>
      
      <h2 style="color: #2c3e50; margin-top: 30px;">Performance & Complexity</h2>
      
      <p>Path generation uses a backbite algorithm optimized with <a href="https://cp-algorithms.com/data_structures/treap.html" target="_blank" style="color: #3498db; text-decoration: underline;">treap</a> data structures. Computational complexity:</p>

      <div style="background: #f0f7ff; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #3498db;">
        <p style="margin: 0; font-family: monospace; font-size: 16px; color: #2c3e50;"><strong>Running time ≈ c·N·log(N)</strong></p>
        <p style="margin: 10px 0 0 0; color: #555;">Where <strong>N = x × y × z</strong> (total vertices), <strong>c ≥ 10</strong> is the backbite iteration multiplier, and <strong>log(N)</strong> is the cost per backbite move using <a href="https://cp-algorithms.com/data_structures/treap.html" target="_blank" style="color: #3498db; text-decoration: underline;">treap</a>-optimized path reversals. Enable Progressive LOD in Preferences for 1.5-2× additional speedup on large grids.</p>
      </div>
      

      
      <p style="color: #555;"><strong>Note:</strong> Press <kbd style="background: #f5f5f5; padding: 2px 6px; border-radius: 4px; border: 1px solid #ddd; font-family: monospace;">ESC</kbd> during generation to stop the process at any time.</p>

      <p style="color: #666; margin-top: 20px; padding: 15px; background: #fff9e6; border-left: 4px solid #f39c12; border-radius: 4px;">
        <strong>Performance Note:</strong> For very large grids (30×30×30 and above), GPU rendering capabilities become the bottleneck, not the cost of backbite moves themselves. The <a href="https://cp-algorithms.com/data_structures/treap.html" target="_blank" style="color: #3498db; text-decoration: underline;">treap</a> optimization reduces backbite computational cost to near-instant O(log N) operations. To maximize performance on large grids, <strong>enable Progressive LOD</strong> in Preferences, <strong>enable Unified Edge Size</strong> to reduce draw calls by rendering all edges with the same thickness, and use <strong>Toggle Grid</strong> to hide uncolored edges, which dramatically improves rendering performance and interactivity.
      </p>

      <h2 style="color: #2c3e50; margin-top: 30px;">Key Features</h2>
      
      <h3 style="color: #34495e; margin-top: 20px;">Path Generation</h3>
      <ul style="margin-left: 20px;">
        <li><strong>Generate Path:</strong> Creates a random Hamiltonian path with colored endpoints (green = start, red = end)</li>
        <li><strong>Generate Cycle:</strong> Creates a random Hamiltonian cycle</li>
        <li><strong>Check Hamiltonian:</strong> Verifies if the current structure is Hamiltonian</li>
      </ul>
      
      <h3 style="color: #34495e; margin-top: 20px;">Interactive Modes</h3>
      <ul style="margin-left: 20px;">
        <li><strong>Backbite Mode:</strong> Manual or automated backbite transformations. Use arrow keys, PgUp, and PgDn for manual control, T key to reverse path direction</li>
        <li><strong>Switch Mode:</strong> Click on 2×2 switchable boxes to perform switch moves</li>
        <li><strong>Add Edge:</strong> Click edges to toggle their colors</li>
        <li><strong>Arrows:</strong> Show directional arrows along an edge or generated Hamiltonian path or cycle</li>
        <li><strong>Gradient Mode:</strong> Apply smooth color gradients along generated Hamiltonian paths or cycles</li>
      </ul>
      
      <h3 style="color: #34495e; margin-top: 20px;">Decorations</h3>
      <ul style="margin-left: 20px;">
        <li><strong>Decorate Edge:</strong> Add small cubes to mark specific edges</li>
        <li><strong>Add Vertex:</strong> Place colored spheres at vertices</li>
        <li><strong>Decorate Vertex:</strong> Add three orthogonal great circles as a secondary vertex marker</li>
        <li><strong>BB Distance Coloring:</strong> Color all vertices at a specific backbite distance from a reference vertex</li>
      </ul>
      
      <h3 style="color: #34495e; margin-top: 20px;">Grid Management</h3>
      <ul style="margin-left: 20px;">
        <li><strong>Multiple Grids:</strong> Work with multiple grids simultaneously using the grid list at the bottom of the screen</li>
        <li><strong>Drag to Reorder:</strong> Click and drag grid tabs to rearrange their order</li>
        <li><strong>Duplicate:</strong> Create copies of grids to preserve configurations before modifications</li>
        <li><strong>Per-Grid Notes:</strong> Attach rich-text notes to individual grids (draggable window)</li>
        <li><strong>Sync View:</strong> Align camera position across all grids for easy comparison</li>
      </ul>
      
      <h3 style="color: #34495e; margin-top: 20px;">Preferences</h3>
      <p>Access via <strong>Preferences</strong> button (or <kbd style="background: #f5f5f5; padding: 2px 6px; border-radius: 4px; border: 1px solid #ddd; font-family: monospace;">Shift+P</kbd>) to customize:</p>
      <ul style="margin-left: 20px;">
        <li><strong>Switch Mode:</strong> Enable/disable box highlighting and component coloring</li>
        <li><strong>Coordinate Hover:</strong> Toggle vertex/edge coordinate display on hover</li>
        <li><strong>Vertex Settings:</strong> Show all grid vertices as gray spheres for structure visualization</li>
        <li><strong>Edge Settings:</strong> Adjust edge click radius for easier selection</li>
        <li><strong>Display:</strong> Choose from 6 themes (Paper White, Dark, Sandstone, Mist Blue, Warm Light, Contrast) and custom backgrounds</li>
        <li><strong>Camera:</strong> Adjust mouse sensitivity, toggle 2D camera mode for grids with one dimension = 1, show/hide sensitivity slider</li>
      </ul>
      
      <h2 style="color: #2c3e50; margin-top: 30px;">Keyboard Shortcuts</h2>
      
      <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
        <h4 style="color: #2c3e50;">File Operations</h4>
        <ul style="margin-left: 20px; margin-bottom: 15px;">
          <li><strong>Ctrl+S:</strong> Save all grids</li>
          <li><strong>Ctrl+L:</strong> Load grids from file</li>
          <li><strong>Ctrl+M:</strong> Toggle notes window</li>
          <li><strong>Esc:</strong> Stop path/cycle generation in progress</li>
        </ul>
        
        <h4 style="color: #2c3e50;">Undo/Redo</h4>
        <ul style="margin-left: 20px; margin-bottom: 15px;">
          <li><strong>Ctrl+Z:</strong> Undo</li>
          <li><strong>Ctrl+Y:</strong> Redo</li>
        </ul>
        
        <h4 style="color: #2c3e50;">Mode Toggles</h4>
        <ul style="margin-left: 20px; margin-bottom: 15px;">
          <li><strong>E:</strong> Toggle edge coloring mode</li>
          <li><strong>Shift+E:</strong> Toggle edge decoration mode</li>
          <li><strong>Shift+A:</strong> Toggle arrows</li>
          <li><strong>V:</strong> Toggle vertex mode</li>
          <li><strong>Shift+V:</strong> Toggle vertex decoration mode</li>
        </ul>
        
        <h4 style="color: #2c3e50;">Backbite Mode</h4>
        <ul style="margin-left: 20px;">
          <li><strong>Arrow Keys:</strong> Move in X-Y plane</li>
          <li><strong>Page Up/Down:</strong> Move in Z direction</li>
          <li><strong>T:</strong> Reverse path direction</li>
        </ul>
      </div>
      
      <h2 style="color: #2c3e50; margin-top: 30px;">Use Cases</h2>
      
      <ul style="margin-left: 20px;">
        <li><strong>Research:</strong> Hamiltonian path/cycle reconfiguration, grid graph structure analysis.</li>
        <li><strong>Education:</strong> Graph theory teaching, algorithm visualization, 3D spatial reasoning</li>
        <li><strong>Art:</strong> Generative patterns, color studies, aesthetic exploration</li>
      </ul>
      
      <h2 style="color: #2c3e50; margin-top: 30px;">Tips</h2>
      
      <ul style="margin-left: 20px;">
        <li>Use <strong>Toggle Grid</strong> to hide uncolored edges on large grids</li>
        <li>Enable <strong>Plane Controls</strong> to highlight cross-sections of 3D grids</li>
        <li>Use <strong>gradient mode</strong> to visualize position along long paths</li>
        <li>Add <strong>vertex markers</strong> at key positions for reference</li>
        <li>In Preferences, enable <strong>"Show all grid vertices"</strong> to visualize the complete grid structure with gray spheres</li>
        <li>For 2D grids, the camera defaults to 2D mode (pan/zoom only). This can be changed in Preferences → Camera</li>
        <li><strong>Duplicate</strong> grids before major changes to preserve configurations</li>
      </ul>
      
      <hr style="border: none; border-top: 2px solid #eee; margin: 30px 0;">
      
      <p style="text-align: center; color: #7f8c8d; font-style: italic; margin-top: 40px;">GridLab - Explore the space of Hamiltonian paths</p>
      
    </div>
  </div>
</div>





<!-- Three.js core (v0.134.0) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.134.0/build/three.min.js"></script>

<!-- OrbitControls for Three.js v0.134.0 -->
<script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.min.js"></script>

<!-- Quill.js CSS and JS -->
<link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
<script src="https://cdn.quilljs.com/1.3.6/quill.min.js"></script>

</body>
</html>
  <script>
    // ============================================================================
    // GridLab - Core Application Code
    // Build: GL-2025-11A7B91F3E-YORK
    // Dev: ALBI.YORK.RGH.2024
    // ============================================================================

/*
================================================================================
                            TABLE OF CONTENTS
================================================================================

SECTION 1: CONSTANTS & GLOBAL VARIABLES (~4620-4780)
  - Distinctive constants (fingerprint markers)
  - Global variables (grids, modes, settings)
  - Rendering constants (radii, colors, thresholds)

SECTION 2: RENDERING OPTIMIZATION & PERFORMANCE (~4786-5257)
  - Triangle counting & estimation
  - Rendering optimizer
  - Performance warnings & vertex limits
  - Auto-theme switching

SECTION 3: CHUNKING SYSTEM (~5258-5434)
  - Optimal chunk size calculation
  - Chunk key generation
  - Chunk boundary calculations
  - Chunk data structures

SECTION 4: GRID CREATION & MANAGEMENT (~5436-6413)
  - Grid data structures
  - Vertex/Edge creation
  - Vertex/Edge key functions (encoding/decoding)
  - Grid disposal

SECTION 5: GRID CONTENT BUILDING (~6414-7441)
  - Box creation (XY, XZ, YZ planes)
  - Grid geometry initialization

SECTION 6: SUBGRAPH CLASS (~6482-7441)
  - Subgraph data structure
  - Component analysis
  - Path/cycle detection
  - Arrow direction management

SECTION 7: INSTANCED RENDERING SYSTEM (~7442-9217)
  - Instanced edge rendering (IER)
  - Instanced box rendering
  - Instanced arrow rendering
  - Instanced vertex sphere rendering
  - Lazy loading functions (edges, vertices, arrows, boxes, cubes)

SECTION 8: UNDO/REDO SYSTEM (~8988-11447)
  - Core undo/redo (recordAction, performUndo, performRedo)
  - Helper validation functions
  - Action handlers (vertex, edge, backbite, switch, layer operations)
  - State capture functions
  - State restoration functions

SECTION 9: GEOMETRY REBUILDING (~9218-10433)
  - Edge segment rebuilding
  - Vertex detail/radius rebuilding
  - Frustum culling
  - LOD (Level of Detail) system

SECTION 10: GRID EXPANSION & CONTRACTION (~11448-12227)
  - Layer expansion
  - Layer removal
  - Coordinate translation
  - Subgraph preservation

SECTION 11: PATH GENERATION & ALGORITHMS (~12228-13182)
  - Hamiltonian path generation
  - Snake path generation
  - Backbite algorithm (optimized & array-based)
  - Cycle generation
  - Path extraction from subgraph

SECTION 12: ENDPOINT & ARROW MANAGEMENT (~13183-13833)
  - Endpoint markers
  - Arrow textures & materials
  - Arrow addition/removal (normal & instanced)
  - Directional arrow application

SECTION 13: BACKBITE OPERATIONS (~13900-14109)
  - Valid backbite edge detection
  - Endpoint toggling
  - Manual backbite execution

SECTION 14: COLOR & GRADIENT FUNCTIONS (~14115-14480)
  - Color utilities (hex/RGB conversion, interpolation)
  - Edge coloring (instanced & individual)
  - Gradient application
  - Hamiltonian checking

SECTION 15: SWITCH MODE & BOX OPERATIONS (~14483-17569)
  - Box validation (isSwitchable)
  - Grid duplication
  - Drag & drop handlers
  - Grid button management
  - State copying (edges, subgraphs)
  - Switch execution

SECTION 16: EDGE & VERTEX INTERACTIONS (~15357-16177)
  - Edge click handlers
  - Block cube operations
  - Vertex sphere toggle & creation
  - Vertex decorations
  - BB Distance operations

SECTION 17: COORDINATE DISPLAY & UI (~16186-17170)
  - Coordinate tooltips
  - Coordinate hover handling
  - Underlying grid & axes
  - Transparent planes

SECTION 18: SUBGRAPH HIGHLIGHTING (~17171-17900)
  - Component coloring
  - Border box detection
  - Box highlighting
  - Component labeling

SECTION 19: MODE MANAGEMENT (~17901-18122)
  - setMode() function
  - Mode button state updates
  - Collision helper visibility

SECTION 20: EVENT LISTENERS & UI HANDLERS (~18123-20636)
  - Button click handlers
  - Keyboard shortcuts
  - Checkbox change handlers
  - Theme management
  - Color interface
  - Layer menus

SECTION 21: MODAL DIALOGS & WARNINGS (~20636-21239)
  - Backbite warnings
  - Performance warnings
  - Quit dialogs

SECTION 22: SUBGRAPH ANALYSIS PANEL (~19985-20348)
  - Component dropdown updates
  - Analysis modal
  - Orient/Reverse operations

SECTION 23: NOTES EDITOR (~19558-19794)
  - Quill editor initialization
  - Notes save/load for grids

SECTION 24: FLARE EFFECTS (~19796-19984)
  - Flare texture creation
  - Flare animation

SECTION 25: MOUSE INTERACTION (~22811-24445)
  - Click handlers (onClick, onMouseDown, onMouseUp)
  - Mouse move & hover handlers
  - Edge/vertex/box hover logic
  - Arrow direction determination

SECTION 26: MEMORY MONITORING (~24546-24696)
  - Memory breakdown calculation
  - Memory display updates

SECTION 27: ANIMATION & RENDERING LOOP (~24697-24862)
  - Main animate() function
  - Flare updates
  - Camera controls

SECTION 28: SAVE/LOAD SYSTEM (~24863-25750)
  - State serialization
  - File operations (save/load)
  - Grid state restoration
  - Visibility updates

SECTION 29: THEME MANAGEMENT (~18541-18912)
  - Theme switching (light/dark)
  - Auto-theme by time of day
  - Theme-aware UI updates

SECTION 30: BUG HISTORY & DOCUMENTATION (~26244+)
  - Recurring bug documentation
  - Known issues & fixes

================================================================================
*/

    // === DISTINCTIVE CONSTANTS (Fingerprint markers) ===
    const VERTEX_SPHERE_RADIUS = 0.12; // Unique sphere radius for vertices
    const ENDPOINT_MARKER_RADIUS = 0.18; // Unique endpoint marker size
    const SWITCH_HIGHLIGHT_PULSE_SPEED = 0.002; // Distinctive pulse timing
    const ARROW_CONE_RADIUS = 0.06; // Unique arrow geometry
    const ARROW_CONE_HEIGHT = 0.15; // Unique arrow geometry
    const BACKBITE_ANIMATION_EPSILON = 0.000001; // Signature epsilon value
    
    // Dev note: GL.SIGNATURE.RECT_GRID_HAMILTON_PATH_CYCLE_RECONFIG
    const _buildMeta = "GL-2025-11A7B91F3E-YORK"; // Hidden build signature
    
    const raycaster = new THREE.Raycaster();
	//raycaster.params.Line.threshold = 0.2;  // Increase click tolerance for thin edges
    const mouse = new THREE.Vector2();
    let mode = "default";
	const UNCOLORED_COLOR = 0x888888;
	let selectedColor = 0x0000ff; // default blue
    let gridCounter = 0;
    let currentGrid = null;
	// === Set your grid dimensions here ===
		let GRID_WIDTH = 4;
		let GRID_HEIGHT = 4;
		let GRID_DEPTH = 4;
    const allGrids = new Map();
	let lastHighlighted = null;
	let gridVisible = true;
	let edgeClickEnabled = false;
	let currentPath = [];
	let highlightedBoxes = [];
	let switchMode = false; // Whether switch highlighting is active
	let boxHighlightingEnabled = true; // NEW: Toggle for highlighting switchable boxes (instanced only)
	
	let componentColoringEnabled = true; // NEW: Toggle for component coloring after switches
	let hoverVertices = true; // Coordinate hover shows vertices
	let hoverEdges = true; // Coordinate hover shows edges
	let cameraSensitivity = 1.0; // Camera mouse sensitivity
	let showCameraSensitivityInMain = false; // Whether to show camera sensitivity in main UI
	let showCameraSensitivityBeforeBackbite = false; // Store original state before backbite mode
	let showVertexDimmerInMain = false; // Whether to show vertex dimmer in main UI
	let use2DCameraMode = true; // Whether to use 2D camera mode for grids with one dimension = 1
	let showAllVertices = false; // Whether to show all grid vertices as gray spheres
	window.isGenerating = false; // Track if generation is in progress
	let currentGenerationType = null; // 'path' or 'cycle' or null
	let shouldStopGeneration = false; // Flag to stop generation
	window.isAddingGrid = false; // Track if grid is being added
	let shouldStopGridAddition = false; // Flag to stop grid addition
	let isQuitDialogOpen = false; // Flag to prevent multiple quit dialogs from stacking
	let boxHighlightHelpers = [];
	let selectedColor2 = 0xff0000; // default red
	let arrowMode = false;
	let gradientMode = false; // Controls gradient coloring
	let batchMode = false; // Add this global variable
	let arrowReverse = false;
	let dontShowBackbiteWarning = false; // User dismissal for non-Hamiltonian backbite warning

	// Track unsaved changes for beforeunload protection
	let hasUnsavedChanges = false;
	let lastSaveTime = null;
	
	// Notes functionality
	let isDraggingNotes = false;
	let notesOffset = { x: 0, y: 0 };
	
	let decorationEnabled = false; // Controls whether decoration cycle is active
	let selectedDecorationColor = 0xffff00; // Default yellow for decorations
	let boxHighlightColor = 0xffff00; // Default yellow for switchable box highlights
	let boxHighlightOpacity = 0.15; // Default opacity for switchable box highlights (0-0.5)
	
	let coordinateHoverMode = false;
	
	let quillEditor = null;
	let isQuillInitialized = false;
	
	let useInstancedRendering = true; // Toggle for new rendering system
	
	
let activeColorTarget = 'main'; // 'main' or 'second'
// Add these global variables at the top
let mouseDownTarget = null;
let mouseDownType = null; // 'edge', 'vertex', 'box'


let edgeCollisionRadius = 0.065; // Default: slightly larger than thick edges (0.05)
let unifiedEdgeSize = false; // SLEDGEHAMMER: Use only thin edges for everything (no thick, no collision mesh)

// Flare system variables
let flareActive = false;
let flareStartTime = 0;
let flareSprites = []; // Array of {sprite, initialPosition} for start and end markers
let flareColor = 0xffcc00; // Default warm yellow
let flareRadius = 0.7; // Default radius
let showFlareButton = false; // Whether to show flare button on main screen

// Arrow rendering mode: 'transcendent' (3D cones, float through edges) or 'normal' (textures on edges, respect occlusion)
let arrowRenderMode = 'normal';
let arrowTextureForward = null;  // Lazy initialized when normal mode first used
let arrowTextureBackward = null;

// Rendering preferences
let edgeSegments = 8; // Default edge cylinder segments (for thin/uncolored edges - affected by LOD)
let thickEdgeSegments = 12; // Fixed quality for thick/colored edges (NOT affected by LOD)
let thinEdgeRadius = 0.015; // Default thin edge cylinder radius
let thickEdgeRadius = 0.05; // Default thick edge cylinder radius
let vertexSubdivisions = 1; // Default vertex icosphere subdivisions (0=20 tris, 1=80 tris, 2=320 tris, 3=1280 tris, 4=5120 tris) - Medium by default
let coloredVertexSubdivisions = 2; // Fixed quality for colored vertices (NOT affected by LOD) - 2 = 320 triangles per sphere
let vertexRadius = 0.12; // Default vertex sphere radius (0.02-0.2 range)
let vertexDimmer = 1.0; // Vertex opacity multiplier (0.0-1.0, default 1.0 = 100%)
let vertexDecorationRadius = 0.1212; // Vertex decoration sphere absolute radius (0.025-0.25 range, default 1% larger than default vertex)
let edgeDecorationRadius = 0.0153; // Edge decoration (arrow) cylinder absolute radius (0.025-0.2 range, default 2% larger than default edge)
let blockCubeSize = 0.12; // Block cube size (controlled by edge decoration slider)
// REMOVED: dynamicVertexDecoShadow - Vertex decorations now ALWAYS dynamically follow vertex size (no manual control)
// let dynamicVertexDecoShadow = false; // FORMER FUNCTIONALITY: When true, vertex decoration radius adjusts automatically with vertex radius changes

// Progressive LOD (Level of Detail) system
let lodEnabled = false; // Toggle for LOD system (disabled by default)
let lodDistanceThresholds = {
  lod3: 7,    // Full detail distance (LOD 3 = highest quality)
  lod2: 11,   // Reduced detail (1.5x full)
  lod1: 14    // Lines mode (2x full, LOD 1 = lowest quality)
};
let lodHysteresis = 0.05; // 5% buffer to prevent flickering (reduced from 10%)
let lastLODUpdatePosition = null; // Last camera position when LOD was updated
let lodUpdateDistanceThreshold = 20; // Camera must move this far to trigger LOD update
let lodLastUpdateTime = 0; // Timestamp of last LOD update
let lodUpdateInterval = 100; // Minimum milliseconds between LOD updates (reduced from 250)
let currentLODLevel = 3; // DEPRECATED: Now using per-chunk LOD, this is unused

// Per-chunk progressive LOD settings
let lodMaxChunkRebuildsPerFrame = 16; // Max chunks to rebuild per frame (prevents stuttering)
let lodChunkRebuildQueue = []; // Queue of {chunk, chunkKey, targetLevel} awaiting rebuild
let lodRebuildInProgress = false; // Flag to block LOD updates during grid rebuild

// Frustum culling system
let frustumCullingEnabled = true; // Toggle for frustum culling
const frustum = new THREE.Frustum();
const frustumMatrix = new THREE.Matrix4();

// Spherical culling system (when camera is inside grid)
let sphericalCullingEnabled = true; // Toggle for spherical distance-based culling
let renderRadiusChunks = 4; // Render radius in chunks (for inside-grid radius culling)

// Surface culling system (when camera is outside grid)
let surfaceCullingEnabled = true; // Toggle for surface culling (only render visible faces)

// Vertex limit system
let vertexLimitEnabled = true; // Toggle for vertex limit (enabled by default)
const VERTEX_LIMIT = 1500000; // 1.5 million total vertices across all grids
let surfaceDepth = 2; // Number of chunk layers to render when outside grid (near faces - facing camera)
let farCullingDepth = 2; // Number of chunk layers to render on far faces (back faces - away from camera)

// Lazy loading preferences
let lazyLoadArrows = true; // When true, arrows only load when activated (default: true - lazy loading)
let lazyLoadSwitchableBoxes = true; // When true, switchable boxes only load in switch mode (default: true - lazy loading)
let lazyLoadVertexSpheres = true; // When true, vertex spheres only load when Show Grid Vertices is checked (default: true - lazy loading)
let lazyLoadEdgeCollision = true; // When true, edge collision helpers only load when Add Edge/Decoration/Backbite modes are active (default: true - lazy loading)
let lazyLoadBlockCubes = true; // When true, block cubes only load when Add Decoration mode is active or decorations exist (default: true - lazy loading)

// Automatic rendering settings
let useAutomaticRenderingSettings = true; // Use automatic rendering configuration

let preferredChunkSize = 5; // User-preferred chunk size

// ==================== RENDERING OPTIMIZATION SYSTEM ====================

// Get current actual triangle count from renderer
function getCurrentTriangleCount() {
  renderer.info.reset();
  renderer.render(scene, camera);
  return renderer.info.render.triangles;
}

// Calculate estimated triangle count by temporarily changing culling settings
function calculateEstimatedTriangles(gridWidth, gridHeight, gridDepth, chunkSize, surfaceDepth, farDepth, surfaceCullingOn) {
  // If we have a current grid, we can measure actual triangles
  if (currentGrid) {
    // Save current settings
    const oldSurfaceCulling = surfaceCullingEnabled;
    const oldSurfaceDepth = currentGrid.lodState ? currentGrid.lodState.surfaceDepth : surfaceDepth;
    const oldFarDepth = currentGrid.lodState ? currentGrid.lodState.farCullingDepth : farCullingDepth;

    // Apply temporary settings
    surfaceCullingEnabled = surfaceCullingOn;
    if (currentGrid.lodState) {
      currentGrid.lodState.surfaceDepth = surfaceDepth;
      currentGrid.lodState.farCullingDepth = farDepth;
    }

    // Update culling
    updateFrustumCulling();

    // Measure triangles
    const triangles = getCurrentTriangleCount();

    // Restore settings
    surfaceCullingEnabled = oldSurfaceCulling;
    if (currentGrid.lodState) {
      currentGrid.lodState.surfaceDepth = oldSurfaceDepth;
      currentGrid.lodState.farCullingDepth = oldFarDepth;
    }
    updateFrustumCulling();

    return triangles;
  }

  // Fallback: rough estimation based on grid size
  // This is very approximate and doesn't account for edges/vertices
  const totalCells = gridWidth * gridHeight * gridDepth;
  const trianglesPerCell = 200; // Rough estimate including edges
  return totalCells * trianglesPerCell;
}

// Optimize rendering settings to target a specific triangle budget
function optimizeRenderingSettings(gridWidth, gridHeight, gridDepth, targetTrianglesMillions = 15) {
  const chunkSize = preferredChunkSize;
  const targetTriangles = targetTrianglesMillions * 1000000;

  // Step 1: Calculate full view triangle count
  const fullViewTriangles = calculateEstimatedTriangles(
    gridWidth, gridHeight, gridDepth,
    chunkSize, 0, 0, false
  );

  console.log(`[Optimizer] Full view: ${(fullViewTriangles / 1000000).toFixed(2)}M triangles`);

  // If full view is under budget, no culling needed
  if (fullViewTriangles <= targetTriangles) {
    return {
      frustumCulling: true,
      surfaceCulling: false,
      surfaceDepth: 0,
      farCullingDepth: 0,
      sphericalCulling: false,
      lodEnabled: false,
      estimatedTriangles: fullViewTriangles,
      message: `Full view (${(fullViewTriangles / 1000000).toFixed(2)}M tri) fits budget. No culling needed.`
    };
  }

  // Step 2: Find optimal surface depth
  let optimalSurfaceDepth = 1;
  let optimalFarDepth = 1;
  let bestTriangles = Number.MAX_VALUE;

  // Try different surface depths
  const maxDepth = Math.ceil(Math.max(gridWidth, gridHeight, gridDepth) / chunkSize / 2);
  for (let depth = 1; depth <= maxDepth; depth++) {
    const triangles = calculateEstimatedTriangles(
      gridWidth, gridHeight, gridDepth,
      chunkSize, depth, depth, true
    );

    if (triangles <= targetTriangles && triangles > bestTriangles - targetTriangles * 0.1) {
      // Found a depth that fits, prefer higher depth if within 10% of target
      optimalSurfaceDepth = depth;
      optimalFarDepth = depth;
      bestTriangles = triangles;
      if (triangles >= targetTriangles * 0.9) break; // Close enough to target
    } else if (triangles < bestTriangles) {
      bestTriangles = triangles;
      optimalSurfaceDepth = depth;
      optimalFarDepth = depth;
    }
  }

  // Step 3: Check if spherical culling should be enabled
  const enableSphericalCulling = optimalSurfaceDepth < 3;

  // Step 4: Check if LOD is needed (even at minimum surface depth)
  const minSurfaceTriangles = calculateEstimatedTriangles(
    gridWidth, gridHeight, gridDepth,
    chunkSize, 1, 1, true
  );
  const enableLOD = minSurfaceTriangles > targetTriangles;

  if (enableLOD) {
    // If LOD is needed, use minimum surface depth
    optimalSurfaceDepth = 1;
    optimalFarDepth = 1;
  }

  return {
    frustumCulling: true,
    surfaceCulling: true,
    surfaceDepth: optimalSurfaceDepth,
    farCullingDepth: optimalFarDepth,
    sphericalCulling: enableSphericalCulling,
    lodEnabled: enableLOD,
    estimatedTriangles: bestTriangles,
    message: `Optimized: ${(bestTriangles / 1000000).toFixed(2)}M tri | Surface: ${optimalSurfaceDepth} | Spherical: ${enableSphericalCulling} | LOD: ${enableLOD}`
  };
}

// Apply optimized settings to the application
function applyOptimizedSettings(settings) {
  console.log(`[Optimizer] Applying settings:`, settings);

  // Update global variables
  frustumCullingEnabled = settings.frustumCulling;
  surfaceCullingEnabled = settings.surfaceCulling;
  surfaceDepth = settings.surfaceDepth;
  farCullingDepth = settings.farCullingDepth;
  sphericalCullingEnabled = settings.sphericalCulling;
  lodEnabled = settings.lodEnabled;

  // Update UI checkboxes
  const frustumCheckbox = document.getElementById('frustumCullingCheckbox');
  if (frustumCheckbox) frustumCheckbox.checked = settings.frustumCulling;

  const surfaceCheckbox = document.getElementById('surfaceCullingCheckbox');
  if (surfaceCheckbox) surfaceCheckbox.checked = settings.surfaceCulling;

  const sphericalCheckbox = document.getElementById('sphericalCullingCheckbox');
  if (sphericalCheckbox) sphericalCheckbox.checked = settings.sphericalCulling;

  const lodCheckbox = document.getElementById('lodCheckbox');
  if (lodCheckbox) lodCheckbox.checked = settings.lodEnabled;

  // Update UI sliders
  const surfaceDepthSlider = document.getElementById('surfaceDepthSlider');
  const surfaceDepthValue = document.getElementById('surfaceDepthValue');
  if (surfaceDepthSlider && surfaceDepthValue) {
    surfaceDepthSlider.value = settings.surfaceDepth;
    surfaceDepthValue.textContent = settings.surfaceDepth;
  }

  const farDepthSlider = document.getElementById('farCullingDepthSlider');
  const farDepthValue = document.getElementById('farCullingDepthValue');
  if (farDepthSlider && farDepthValue) {
    farDepthSlider.value = settings.farCullingDepth;
    farDepthValue.textContent = settings.farCullingDepth;
  }

  // Trigger updates
  if (currentGrid) {
    updateFrustumCulling();
    if (settings.lodEnabled && !lodEnabled) {
      // LOD was just enabled, trigger LOD update
      updateLOD();
    }
  }

  console.log(`[Optimizer] ${settings.message}`);
  alert(settings.message);
}

// ==================== PERFORMANCE WARNING MODAL ====================

// Show performance warning modal and return a promise that resolves to true (proceed) or false (cancel)
function showPerformanceWarning(message) {
  return new Promise((resolve) => {
    const modal = document.getElementById('performanceWarningModal');
    const messageDiv = document.getElementById('performanceWarningMessage');
    const proceedBtn = document.getElementById('performanceWarningProceed');
    const cancelBtn = document.getElementById('performanceWarningCancel');

    // Set message
    messageDiv.innerHTML = message;

    // Show modal
    modal.style.display = 'flex';

    // Handle proceed
    const handleProceed = () => {
      modal.style.display = 'none';
      proceedBtn.removeEventListener('click', handleProceed);
      cancelBtn.removeEventListener('click', handleCancel);
      resolve(true);
    };

    // Handle cancel
    const handleCancel = () => {
      modal.style.display = 'none';
      proceedBtn.removeEventListener('click', handleProceed);
      cancelBtn.removeEventListener('click', handleCancel);
      resolve(false);
    };

    // Attach event listeners
    proceedBtn.addEventListener('click', handleProceed);
    cancelBtn.addEventListener('click', handleCancel);
  });
}

// Check if grid is large enough to warrant performance warning
function shouldWarnForPerformance(grid) {
  if (!grid) return false;
  const totalVertices = grid.width * grid.height * grid.depth;
  return totalVertices > 100000;
}

// Show vertex limit removal warning modal
function showVertexLimitWarning() {
  return new Promise((resolve) => {
    const modal = document.getElementById('vertexLimitWarningModal');
    const proceedBtn = document.getElementById('vertexLimitWarningProceed');
    const cancelBtn = document.getElementById('vertexLimitWarningCancel');

    // Show modal
    modal.style.display = 'flex';

    // Handle proceed
    const handleProceed = () => {
      modal.style.display = 'none';
      proceedBtn.removeEventListener('click', handleProceed);
      cancelBtn.removeEventListener('click', handleCancel);
      resolve(true);
    };

    // Handle cancel
    const handleCancel = () => {
      modal.style.display = 'none';
      proceedBtn.removeEventListener('click', handleProceed);
      cancelBtn.removeEventListener('click', handleCancel);
      resolve(false);
    };

    // Attach event listeners
    proceedBtn.addEventListener('click', handleProceed);
    cancelBtn.addEventListener('click', handleCancel);
  });
}

// Calculate total vertices across all grids
function getTotalVerticesAcrossAllGrids() {
  let total = 0;
  for (const [id, grid] of allGrids.entries()) {
    if (grid) {
      total += grid.width * grid.height * grid.depth;
    }
  }
  return total;
}

// ==================== CHUNKING SYSTEM ====================

// Chunking system for spatial optimization
// Enables frustum culling and per-chunk LOD
function getOptimalChunkSize(w, h, d) {
  const maxDim = Math.max(w, h, d);

  // Use user preference if set, otherwise use automatic sizing
  if (preferredChunkSize > 0) {
    // Cap at grid dimension (can't have chunks larger than grid)
    return Math.min(preferredChunkSize, maxDim);
  }

  // Automatic sizing (fallback)
  if (maxDim <= 15) return maxDim; // Very small grids: single chunk
  if (maxDim <= 30) return 10;     // Small grids
  if (maxDim <= 60) return 10;     // Medium grids
  if (maxDim <= 100) return 12;    // Large grids
  return 15;                        // Very large grids
}

function getChunkKey(cx, cy, cz) {
  return `${cx},${cy},${cz}`;
}

// Calculate chunk boundaries that distribute remainders to outer chunks
// numChunks = floor(dim/chunkSize), remainder distributed to first and last chunks
// First chunk = chunkSize + floor(remainder/2)
// Last chunk = chunkSize + ceil(remainder/2)
// Middle chunks = chunkSize
// Example: dim=37, chunkSize=10, numChunks=3 → [0,13), [13,23), [23,37) = 13+10+14
function calculateChunkBoundaries(dim, chunkSize, numChunks) {
  const boundaries = [0];

  if (numChunks === 1) {
    boundaries.push(dim);
    return boundaries;
  }

  const remainder = dim % chunkSize;
  const extraFirst = Math.floor(remainder / 2);
  const extraLast = Math.ceil(remainder / 2);

  // First chunk: chunkSize + extraFirst
  const firstChunkSize = chunkSize + extraFirst;
  boundaries.push(firstChunkSize);

  // Middle chunks (uniform chunkSize)
  for (let i = 1; i < numChunks - 1; i++) {
    boundaries.push(boundaries[i] + chunkSize);
  }

  // Last boundary is always dim (last chunk = chunkSize + extraLast)
  boundaries.push(dim);

  return boundaries;
}

// Find which chunk index a position falls into given boundaries
function getChunkIndexFromBoundaries(pos, boundaries) {
  // Clamp to valid range
  if (pos < 0) return 0;
  if (pos >= boundaries[boundaries.length - 1]) return boundaries.length - 2;

  // Binary search for efficiency (though linear is fine for small chunk counts)
  for (let i = 0; i < boundaries.length - 1; i++) {
    if (pos < boundaries[i + 1]) {
      return i;
    }
  }
  return boundaries.length - 2;
}

// Get chunk indices for a position using grid's chunk boundaries
function getChunkForPositionWithBoundaries(x, y, z, grid) {
  const bx = grid.chunkBoundaries.x;
  const by = grid.chunkBoundaries.y;
  const bz = grid.chunkBoundaries.z;

  return {
    cx: getChunkIndexFromBoundaries(x, bx),
    cy: getChunkIndexFromBoundaries(y, by),
    cz: getChunkIndexFromBoundaries(z, bz)
  };
}

// Legacy function for backward compatibility (uniform chunks)
function getChunkForPosition(x, y, z, chunkSize) {
  return {
    cx: Math.floor(x / chunkSize),
    cy: Math.floor(y / chunkSize),
    cz: Math.floor(z / chunkSize)
  };
}

function getChunkForEdge(a, b, grid) {
  // Assign edge to chunk based on midpoint
  const midX = (a[0] + b[0]) / 2;
  const midY = (a[1] + b[1]) / 2;
  const midZ = (a[2] + b[2]) / 2;

  // Use boundaries if available, otherwise fall back to uniform
  if (grid && grid.chunkBoundaries) {
    return getChunkForPositionWithBoundaries(midX, midY, midZ, grid);
  }
  return getChunkForPosition(midX, midY, midZ, grid.chunkSize || 10);
}

function getChunkForVertex(vKey, grid) {
  const [x, y, z] = unpackVertex(vKey, grid);

  // Use boundaries if available, otherwise fall back to uniform
  if (grid && grid.chunkBoundaries) {
    return getChunkForPositionWithBoundaries(x, y, z, grid);
  }
  return getChunkForPosition(x, y, z, grid.chunkSize || grid);
}

// Create empty chunk data structure
function createChunkData() {
  return {
    // Edges
    instancedEdgesThin: null,
    instancedEdgesThick: null,
    instancedEdgesCollision: null,
    instancedBlockCubes: null,
    lineEdges: null,

    // Vertices
    instancedVertexSpheres: null,
    instancedVertexCollisionHelpers: null,
    pointVertices: null,

    // Mappings (within this chunk)
    edgeToInstanceMap: new Map(),  // eKey → { thin, thick, collision }
    vertexToInstanceMap: new Map(), // vKey → instanceIndex
    edgeToLineIndex: new Map(),    // eKey → lineIndex

    // Counts
    edgeCount: 0,
    vertexCount: 0,

    // Metadata for culling/LOD
    boundingBox: null,
    center: null,
    isVisible: true,  // Default to visible; frustum culling will update this

    // Per-chunk LOD state
    lodState: {
      level: 3,           // LOD 3 = full detail, LOD 2 = reduced, LOD 1 = lines
      edgeSegments: null, // Current edge segment count (null = use global)
      lastRebuildTime: 0
    }
  };
}

// Calculate chunk counts for a grid
// Uses floor(dim/chunkSize) to ensure no thin remainder chunks
// The remainder is distributed to the outer (first and last) chunks
function calculateChunkCounts(w, h, d, chunkSize) {
  return {
    x: Math.max(1, Math.floor(w / chunkSize)),
    y: Math.max(1, Math.floor(h / chunkSize)),
    z: Math.max(1, Math.floor(d / chunkSize))
  };
}

// FPS Counter variables
let fpsFrames = 0;
let fpsLastTime = performance.now();
let fpsUpdateInterval = 500; // Update FPS display every 500ms
let lastFrameTime = performance.now();

// Auto-switch theme by time of day (variables - functions relocated to THEME MANAGEMENT section)
let autoSwitchThemeEnabled = localStorage.getItem('autoSwitchThemeEnabled') === 'true'; // Toggle for auto-switching theme
let lastAutoSwitchCheck = 0; // Timestamp of last auto-switch check
const autoSwitchCheckInterval = 60000; // Check every 60 seconds
let autoSyncView = true; // Toggle for auto-syncing camera view across grids (enabled by default)


//     ====================================================================================================================
// 											   1. GRID CREATION FUNCTIONS
//     ====================================================================================================================

function addVertex(grid, x, y, z = 0) {
  const key = vertexKey(x, y, z, grid);
  if (!grid.vertices.has(key)) {
    grid.vertices.set(key, { coords: [x, y, z], neighbors: new Set() });

    // Only create individual collision helper if NOT using instanced rendering
    // When instanced rendering is enabled, collisions are handled by instancedVertexCollisionHelpers
    if (!useInstancedRendering) {
      // Create invisible collision helper for vertex clicking
      const collisionGeometry = new THREE.SphereGeometry(0.4, 8, 8);
      const collisionMaterial = new THREE.MeshBasicMaterial({
        transparent: true,
        opacity: 0,
        visible: false
      });
      const collisionHelper = new THREE.Mesh(collisionGeometry, collisionMaterial);
      collisionHelper.position.set(x, y, z);
      collisionHelper.userData.vertexKey = key;
      collisionHelper.userData.isVertexHelper = true;

      grid.group.add(collisionHelper);
      grid.vertices.get(key).collisionHelper = collisionHelper;
    }
  }
}



function addEdge(grid, a, b) {
  const vKey1 = vertexKey(a[0], a[1], a[2], grid);
  const vKey2 = vertexKey(b[0], b[1], b[2], grid);
  const eKey = edgeKey(a, b, grid);
  if (!grid.edges.has(eKey)) {
    const start = new THREE.Vector3(...a);
    const end = new THREE.Vector3(...b);
    const direction = new THREE.Vector3().subVectors(end, start);
    const length = direction.length();
    const midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
    const axis = new THREE.Vector3(0, 1, 0);
    
    // Only create individual meshes if NOT using instanced rendering
    let cylinder = null;
    let collisionHelper = null;
    
    if (!useInstancedRendering) {
      // Visual mesh
      const material = new THREE.MeshBasicMaterial({ color: 0x888888 });
      const geometry = new THREE.CylinderGeometry(thinEdgeRadius, thinEdgeRadius, length, 8);
      cylinder = new THREE.Mesh(geometry, material);
      cylinder.quaternion.setFromUnitVectors(axis, direction.clone().normalize());
      cylinder.position.copy(midpoint);
      grid.group.add(cylinder);
      
      // Invisible collision helper (larger radius for easier clicking)
      const collisionGeometry = new THREE.CylinderGeometry(thickEdgeRadius, thickEdgeRadius, length, 8);
      const collisionMaterial = new THREE.MeshBasicMaterial({ 
        transparent: true, 
        opacity: 0,
        visible: false
      });
      collisionHelper = new THREE.Mesh(collisionGeometry, collisionMaterial);
      collisionHelper.quaternion.setFromUnitVectors(axis, direction.clone().normalize());
      collisionHelper.position.copy(midpoint);
      collisionHelper.userData.parentEdge = eKey;
      grid.group.add(collisionHelper);
    }
    
    grid.edges.set(eKey, { 
      vertices: [vKey1, vKey2], 
      color: 0x888888, 
      mesh: cylinder,
      collisionHelper: collisionHelper,
      arrowDirection: 0,
      blockCube: null
    });
    
    grid.vertices.get(vKey1).neighbors.add(vKey2);
    grid.vertices.get(vKey2).neighbors.add(vKey1);
  }
}


// Numeric key generation (Hybrid approach: grid-relative encoding)
// Uses: id = x + W * (y + H * z)
// This is more efficient than absolute coordinate encoding and stays well within safe integer range

// Low-level functions that take explicit dimensions
function vertexKeyWithDims(x, y, z, W, H, D) {
  // Grid-relative encoding: id = x + W * (y + H * z)
  // For a 50×50×50 grid: max id = 49 + 50*(49 + 50*49) = 124,999
  return x + W * (y + H * z);
}

function edgeKeyWithDims(a, b, W, H, D) {
  const v1 = vertexKeyWithDims(a[0], a[1], a[2], W, H, D);
  const v2 = vertexKeyWithDims(b[0], b[1], b[2], W, H, D);

  // Canonical ordering (smaller vertex first)
  const minV = Math.min(v1, v2);
  const maxV = Math.max(v1, v2);

  // Encode edge: min * n + max, where n is total vertex count
  const n = W * H * D;
  return minV * n + maxV;
}

function unpackVertexWithDims(key, W, H, D) {
  // Decode: id = x + W * (y + H * z)
  const x = key % W;
  const y = Math.floor(key / W) % H;
  const z = Math.floor(key / (W * H));

  // Bounds checking to catch dimension mismatches
  if (z >= D || x >= W || y >= H || z < 0 || x < 0 || y < 0) {
    console.error("❌ BAD VERTEX DECODE - Key from wrong grid dimensions!", {
      key,
      decoded: {x, y, z},
      gridDims: {W, H, D},
      stackTrace: new Error().stack
    });
  }

  return [x, y, z];
}

function unpackEdgeWithDims(key, W, H, D) {
  const n = W * H * D;
  const v1 = Math.floor(key / n);
  const v2 = key % n;
  return [unpackVertexWithDims(v1, W, H, D), unpackVertexWithDims(v2, W, H, D)];
}

// High-level functions that use grid dimensions
// Accept optional grid parameter, fall back to currentGrid
function vertexKey(x, y, z = 0, grid = null) {
  const g = grid || currentGrid;
  if (!g) {
    console.error("vertexKey called without grid parameter and currentGrid not set");
    return 0;
  }
  return vertexKeyWithDims(x, y, z, g.width, g.height, g.depth);
}

function edgeKey(a, b, grid = null) {
  const g = grid || currentGrid;
  if (!g) {
    console.error("edgeKey called without grid parameter and currentGrid not set");
    return 0;
  }
  return edgeKeyWithDims(a, b, g.width, g.height, g.depth);
}

function unpackVertex(key, grid = null) {
  const g = grid || currentGrid;
  if (!g) {
    console.error("unpackVertex called without grid parameter and currentGrid not set");
    return [0, 0, 0];
  }
  return unpackVertexWithDims(key, g.width, g.height, g.depth);
}

function unpackEdge(key, grid = null) {
  const g = grid || currentGrid;
  if (!g) {
    console.error("unpackEdge called without grid parameter and currentGrid not set");
    return [[0, 0, 0], [0, 0, 0]];
  }
  return unpackEdgeWithDims(key, g.width, g.height, g.depth);
}
	
	

function createEmptyGridData() {
  const gridData = {
    vertices: new Map(),
    edges: new Map(),
    boxesXY: new Map(),
    boxesXZ: new Map(),
    boxesYZ: new Map(),
    group: new THREE.Group(),
    ringBoxes: [],
    ringBands: { XY: {}, XZ: {}, YZ: {} },
    highlightedBoxHelpers: [],
    cameraPosition: null,
    cameraTarget: null,
    highlightOverlay: null,
    vertexSpheres: new Map(),
    standaloneDecorations: new Map(),  // Store decorations without vertices
    vertexHighlight: null,
    notes: "",
    customPlanes: [],  // <-- Changed from customPlane to customPlanes array
    undoStack: [],
    redoStack: [],
    maxUndoSteps: 200,
    isInstanced: false,  // Track if this grid uses instanced rendering
    showAllVertices: false,  // Per-grid setting for showing all vertices

    // Chunking system
    chunks: new Map(),        // chunkKey → ChunkData
    chunkSize: 10,            // Size of each chunk (auto-computed)
    chunkCounts: { x: 1, y: 1, z: 1 },  // Number of chunks in each dimension
    edgeToChunk: new Map(),   // eKey → chunkKey (for fast lookup)
    vertexToChunk: new Map(), // vKey → chunkKey (for fast lookup)

    // Arrow continuity tracking
    lastArrowedEdgeAtVertex: new Map(), // vKey → { eKey, timestamp }

    // Subgraph tracking - initialized for all grids to track in background
    activeSubgraph: null,  // Will be initialized after grid dimensions are set
  };

  return gridData;
}

// Properly dispose of all grid resources to free memory
function disposeGrid(grid) {
  if (!grid) return;

  console.log('[disposeGrid] Starting disposal of grid resources...');

  // Dispose chunk resources
  if (grid.chunks) {
    for (const chunk of grid.chunks.values()) {
      // Remove from group before disposing
      if (grid.group) {
        if (chunk.instancedEdgesThin) grid.group.remove(chunk.instancedEdgesThin);
        if (chunk.instancedEdgesThick) grid.group.remove(chunk.instancedEdgesThick);
        if (chunk.instancedEdgesCollision) grid.group.remove(chunk.instancedEdgesCollision);
        if (chunk.instancedBlockCubes) grid.group.remove(chunk.instancedBlockCubes);
        if (chunk.lineEdges) grid.group.remove(chunk.lineEdges);
        if (chunk.instancedVertexSpheres) grid.group.remove(chunk.instancedVertexSpheres);
        if (chunk.instancedVertexCollisionHelpers) grid.group.remove(chunk.instancedVertexCollisionHelpers);
        if (chunk.pointVertices) grid.group.remove(chunk.pointVertices);
      }

      // Dispose edge meshes
      if (chunk.instancedEdgesThin) {
        chunk.instancedEdgesThin.geometry.dispose();
        chunk.instancedEdgesThin.material.dispose();
      }
      if (chunk.instancedEdgesThick) {
        chunk.instancedEdgesThick.geometry.dispose();
        chunk.instancedEdgesThick.material.dispose();
      }
      if (chunk.instancedEdgesCollision) {
        chunk.instancedEdgesCollision.geometry.dispose();
        chunk.instancedEdgesCollision.material.dispose();
      }
      if (chunk.instancedBlockCubes) {
        chunk.instancedBlockCubes.geometry.dispose();
        chunk.instancedBlockCubes.material.dispose();
      }
      if (chunk.lineEdges) {
        chunk.lineEdges.geometry.dispose();
        chunk.lineEdges.material.dispose();
      }

      // Dispose vertex meshes
      if (chunk.instancedVertexSpheres) {
        chunk.instancedVertexSpheres.geometry.dispose();
        chunk.instancedVertexSpheres.material.dispose();
      }
      if (chunk.instancedVertexCollisionHelpers) {
        chunk.instancedVertexCollisionHelpers.geometry.dispose();
        chunk.instancedVertexCollisionHelpers.material.dispose();
      }
      if (chunk.pointVertices) {
        chunk.pointVertices.geometry.dispose();
        chunk.pointVertices.material.dispose();
      }
    }
  }

  // Dispose global vertex mesh (if any - old system)
  if (grid.instancedVertexSpheres) {
    if (grid.group) grid.group.remove(grid.instancedVertexSpheres);
    grid.instancedVertexSpheres.geometry.dispose();
    grid.instancedVertexSpheres.material.dispose();
  }

  // Dispose collision helpers if present (old system)
  if (grid.instancedVertexCollisionHelpers) {
    if (grid.group) grid.group.remove(grid.instancedVertexCollisionHelpers);
    grid.instancedVertexCollisionHelpers.geometry.dispose();
    grid.instancedVertexCollisionHelpers.material.dispose();
  }

  // Dispose instanced arrows
  if (grid.instancedArrowsForward) {
    if (grid.group) grid.group.remove(grid.instancedArrowsForward);
    grid.instancedArrowsForward.geometry.dispose();
    grid.instancedArrowsForward.material.dispose();
  }
  if (grid.instancedArrowsBackward) {
    if (grid.group) grid.group.remove(grid.instancedArrowsBackward);
    grid.instancedArrowsBackward.geometry.dispose();
    grid.instancedArrowsBackward.material.dispose();
  }

  // Dispose old arrow system (if any)
  if (grid.arrows) {
    for (const arrow of grid.arrows) {
      if (grid.group) grid.group.remove(arrow);
      if (arrow.geometry) arrow.geometry.dispose();
      if (arrow.material) arrow.material.dispose();
    }
  }

  // Dispose markers
  if (grid.startMarker) {
    if (grid.group) grid.group.remove(grid.startMarker);
    if (grid.startMarker.geometry) grid.startMarker.geometry.dispose();
    if (grid.startMarker.material) grid.startMarker.material.dispose();
  }
  if (grid.endMarker) {
    if (grid.group) grid.group.remove(grid.endMarker);
    if (grid.endMarker.geometry) grid.endMarker.geometry.dispose();
    if (grid.endMarker.material) grid.endMarker.material.dispose();
  }

  // Dispose box helpers
  if (grid.highlightedBoxHelpers) {
    for (const helper of grid.highlightedBoxHelpers) {
      scene.remove(helper);
      if (helper.geometry) helper.geometry.dispose();
      if (helper.material) helper.material.dispose();
    }
  }

  // Clear all children from group
  if (grid.group) {
    while (grid.group.children.length > 0) {
      grid.group.remove(grid.group.children[0]);
    }
  }

  // Clear maps to release references
  if (grid.edges) grid.edges.clear();
  if (grid.vertices) grid.vertices.clear();
  if (grid.chunks) grid.chunks.clear();
  if (grid.edgeToChunk) grid.edgeToChunk.clear();
  if (grid.vertexToChunk) grid.vertexToChunk.clear();
  if (grid.vertexSpheres) grid.vertexSpheres.clear();
  if (grid.boxesXY) grid.boxesXY.clear();
  if (grid.boxesXZ) grid.boxesXZ.clear();
  if (grid.boxesYZ) grid.boxesYZ.clear();

  // Clear THREE.js renderer caches to help release GPU memory
  if (typeof renderer !== 'undefined' && renderer.renderLists) {
    renderer.renderLists.dispose();
  }
  if (typeof renderer !== 'undefined' && renderer.info) {
    renderer.info.reset();
  }

  console.log('[disposeGrid] Grid disposal complete');
}

async function addGrid() {
 // Note: Don't dispose currentGrid - we want to keep all grids!
 // The switchToGrid function will handle removing the old grid from scene
 // and adding the new one.

 // Read dimensions from inputs automatically
 let w = parseInt(document.getElementById("widthInput").value) || 6;
 let h = parseInt(document.getElementById("heightInput").value) || 6;
 let d = parseInt(document.getElementById("depthInput").value) || 6;

 if (w <= 0 || h <= 0 || d <= 0) {
   alert("All dimensions must be positive integers.");
   return;
 }

 // Check vertex limit
 if (vertexLimitEnabled) {
   const newGridVertices = w * h * d;
   const currentTotalVertices = getTotalVerticesAcrossAllGrids();
   const totalAfterAdd = currentTotalVertices + newGridVertices;

   if (totalAfterAdd > VERTEX_LIMIT) {
     const verticesOver = totalAfterAdd - VERTEX_LIMIT;
     alert(
       `Cannot create grid: This would exceed the total vertex limit.\n\n` +
       `Current total vertices: ${currentTotalVertices.toLocaleString()}\n` +
       `New grid vertices: ${newGridVertices.toLocaleString()}\n` +
       `Combined total: ${totalAfterAdd.toLocaleString()}\n` +
       `Limit: ${VERTEX_LIMIT.toLocaleString()}\n` +
       `Over by: ${verticesOver.toLocaleString()} vertices\n\n` +
       `To remove this safety limit, check "Remove Vertex Limit" in Preferences.`
     );
     return;
   }
 }

 // Normalize dimensions: always keep Z=1 for 2D grids, and Y=Z=1 for 1D grids
 // This ensures optimal viewing with the 2D camera mode
 const ones = (w === 1 ? 1 : 0) + (h === 1 ? 1 : 0) + (d === 1 ? 1 : 0);

 if (ones === 2) {
   // 1D grid: put the non-1 dimension in X, set Y=Z=1
   const nonOne = w !== 1 ? w : (h !== 1 ? h : d);
   w = nonOne;
   h = 1;
   d = 1;
 } else if (ones === 1) {
   // 2D grid: put the two non-1 dimensions in X and Y, set Z=1
   if (d === 1) {
     // Already correct: X×Y×1
   } else if (h === 1) {
     // X×1×Z → X×Z×1
     const temp = d;
     d = 1;
     h = temp;
   } else if (w === 1) {
     // 1×Y×Z → Y×Z×1
     w = h;
     h = d;
     d = 1;
   }
 }
 // If ones === 0 or ones === 3, no normalization needed

 // Update input fields to reflect normalized dimensions
 document.getElementById("widthInput").value = w;
 document.getElementById("heightInput").value = h;
 document.getElementById("depthInput").value = d;

 // Set global dimensions
 GRID_WIDTH = w;
 GRID_HEIGHT = h;
 GRID_DEPTH = d;
 
 const id = `Grid ${++gridCounter}`;
 const grid = createEmptyGridData();
 grid.width = GRID_WIDTH;
 grid.height = GRID_HEIGHT;
 grid.depth = GRID_DEPTH;

 // Initialize subgraph tracking for this grid (always active in background)
 grid.activeSubgraph = new Subgraph(grid);

 // New grids start with showAllVertices = false (default from createEmptyGridData)
 // This ensures vertex spheres are NOT expensive to create for large grids by default

 // Distinctive initialization with signature epsilon for 3x3x3 grids
 // (Research-standard coordinate adjustment)
 if (GRID_WIDTH === 3 && GRID_HEIGHT === 3 && GRID_DEPTH === 3) {
   const epsilon = BACKBITE_ANIMATION_EPSILON;
   // Apply infinitesimal offset for build fingerprinting
   grid.signatureOffset = epsilon;
 }

 grid.path = null;
 grid.startMarker = null;
 grid.endMarker = null;
 grid.activeBoxHelpers = [];

 // Determine performance settings based on grid size
 // Three tiers of optimization:
 // 1. Normal: ≤5000 vertices OR min dimension < 10
 // 2. Large: >5000 vertices AND min dimension ≥ 10
 // 3. Very Large: >500,000 vertices
 // 4. Massive: ≥1,000,000 vertices (enable LOD by default)
 const totalVertices = grid.width * grid.height * grid.depth;
 const minDimension = Math.min(grid.width, grid.height, grid.depth);

 const isMassiveGrid = totalVertices >= 1000000;
 const isVeryLargeGrid = totalVertices > 500000;
 const isLargeGrid = totalVertices > 5000 && minDimension >= 10;

 let initialEdgeSegments = edgeSegments;
 let initialThickEdgeSegments = thickEdgeSegments;
 let initialVertexDetail = vertexSubdivisions;
 let initialLodEnabled = lodEnabled;

 if (isMassiveGrid) {
   // Massive grids (≥1M vertices): enable LOD by default + maximum optimization
   initialLodEnabled = true;
   initialEdgeSegments = 3;
   initialThickEdgeSegments = 3;
   initialVertexDetail = 0; // Low vertex detail
 } else if (isVeryLargeGrid) {
   // Very large grids: maximum optimization (LOD stays at user default)
   initialEdgeSegments = 3;
   initialThickEdgeSegments = 3;
   initialVertexDetail = 0; // Low vertex detail
 } else if (isLargeGrid) {
   // Large grids: moderate optimization
   initialEdgeSegments = 3;
   initialThickEdgeSegments = 6;
   // Keep default vertex detail and LOD setting
 }
 // Normal grids: use global defaults

 // Set surface depth based on grid size
 const initialSurfaceDepth = totalVertices < 50000 ? 2 : 1;

 // Authoritative LOD state (ChatGPT fix)
 grid.lodState = {
   edgeSegments: initialEdgeSegments,      // Current edge detail (thin edges)
   thickEdgeSegments: initialThickEdgeSegments, // Current thick edge detail
   vertexDetail: initialVertexDetail, // Current vertex detail
   surfaceDepth: initialSurfaceDepth, // Surface culling depth (chunks)
   lodEnabled: initialLodEnabled,    // Whether LOD system is enabled for this grid
   level: 0,                         // Current LOD level (0=full, 1=medium, 2=low, 3=min)
   lastRebuildTime: 0                // Timestamp of last rebuild for cooldown
 };

 // Only initialize camera state if it's a fresh grid
 grid.cameraPosition = camera.position.clone();
 grid.cameraTarget = controls.target.clone();
 allGrids.set(id, grid);
 
 // Create button with rename functionality
 const button = document.createElement("div");
 button.className = "grid-btn";

 const textSpan = document.createElement("span");
 textSpan.textContent = id;
 textSpan.style.cursor = "text";
 textSpan.onclick = (e) => {
   e.stopPropagation();
   startGridRename(id, textSpan, button);
 };

 // Add grid info (dimensions only - all grids use instanced rendering now)
 const infoSpan = document.createElement("div");
 infoSpan.className = "grid-info";
 infoSpan.textContent = `${grid.width}×${grid.height}×${grid.depth}`;

const close = document.createElement("span");
close.className = "close";
close.innerHTML = "&times;";
close.onclick = e => {
  e.stopPropagation();
  
  // Confirm deletion before proceeding
  if (!confirm("Delete this grid? This cannot be undone.")) {
    return; // User cancelled, do nothing
  }

  if (currentGrid === grid) {
    clearEndpointMarkers(grid);
    currentGrid = null;
  }
  disposeGrid(grid);
  scene.remove(grid.group);
  allGrids.delete(id);
  button.remove();
};

 button.appendChild(textSpan);
 button.appendChild(infoSpan);
 button.appendChild(close);
 button.onclick = () => switchToGrid(id);
 document.getElementById("gridList").appendChild(button);

 // Set grid addition flags
 isAddingGrid = true;
 shouldStopGridAddition = false;

 // Start operation and show overlay
 const gridDimensions = `${grid.width}×${grid.height}×${grid.depth}`;
 const tStart = performance.now();

 // Choose overlay based on whether this is standalone or part of path/cycle
 if (isGenerating && currentGenerationType) {
   ProgressOverlay.startGridForPathCycle(gridDimensions, currentGenerationType);
 } else {
   ProgressOverlay.startGrid(gridDimensions);
 }

 // Give browser time to render the overlay
 await new Promise(resolve => setTimeout(resolve, 50));

 try {
   await buildGridContent(grid);

   // Check if user cancelled
   if (shouldStopGridAddition) {
     console.log("Grid addition cancelled by user");
     // Clean up incomplete grid
     disposeGrid(grid);
     scene.remove(grid.group);
     allGrids.delete(id);
     button.remove();
     ProgressOverlay.hide();
     isAddingGrid = false;
     return;
   }

   // Note: switchToGrid will be called later, after showing "Rendering..." message
 } catch (error) {
   // Check if this is a cancellation (not an actual error)
   if (error.message === "Grid addition cancelled") {
     console.log("Grid addition cancelled by user");
     // Clean up incomplete grid
     disposeGrid(grid);
     scene.remove(grid.group);
     allGrids.delete(id);
     button.remove();
     ProgressOverlay.hide();
     window.isAddingGrid = false;
     return;
   }

   // Actual error occurred
   console.error("Error during grid generation:", error);
   // Clean up on error
   disposeGrid(grid);
   scene.remove(grid.group);
   allGrids.delete(id);
   button.remove();
   ProgressOverlay.hide();
   window.isAddingGrid = false;
   alert("Grid generation failed. Please try again.");
   return;
 }

 // If Auto Sync View is enabled and we have a current camera position, copy it to the new grid
 if (autoSyncView && camera && controls) {
   grid.cameraPosition = camera.position.clone();
   grid.cameraTarget = controls.target.clone();
 }

 // Call switchToGrid which adds grid to scene (this is the slow part)
 switchToGrid(id);

 // If lazy loading is enabled and arrows checkbox is ON, load arrows for the new grid
 if (lazyLoadArrows && arrowMode && grid.isInstanced && !grid.instancedArrowsForward && !grid.instancedArrowsBackward) {
   console.log('[addGrid] Arrow mode is ON, loading arrows for new grid');
   loadArrows(grid);
 }

 // If lazy loading is enabled and switch mode is ON, load switchable boxes for the new grid
 if (lazyLoadSwitchableBoxes && mode === "switch" && grid.isInstanced && !grid.instancedBoxesXY && !grid.instancedBoxesXZ && !grid.instancedBoxesYZ) {
   console.log('[addGrid] Switch mode is ON, loading switchable boxes for new grid');
   loadSwitchableBoxes(grid);
 }

 // If lazy loading is enabled and showAllVertices is ON, load vertex spheres for the new grid
 if (lazyLoadVertexSpheres && showAllVertices && grid.isInstanced) {
   // Check if vertex spheres need loading by checking first chunk
   let needsLoading = false;
   if (grid.chunks && grid.chunks.size > 0) {
     const firstChunk = grid.chunks.values().next().value;
     if (!firstChunk.instancedVertexSpheres && !firstChunk.instancedVertexCollisionHelpers) {
       needsLoading = true;
     }
   }

   if (needsLoading) {
     console.log('[addGrid] Show All Vertices is ON, loading vertex spheres for new grid');
     loadVertexSpheres(grid);
   }
 }

 // If lazy loading is enabled and an edge editing mode is ON, load edge collision for the new grid
 if (lazyLoadEdgeCollision && grid.isInstanced) {
   const edgeEditingModeActive = (mode === 'addEdge' || mode === 'addCube' || mode === 'backbite');

   if (edgeEditingModeActive) {
     // Check if edge collision needs loading
     let needsLoading = false;
     if (grid.chunks && grid.chunks.size > 0) {
       const firstChunk = grid.chunks.values().next().value;
       if (!firstChunk.instancedEdgesCollision) {
         needsLoading = true;
       }
     }

     if (needsLoading) {
       console.log(`[addGrid] Edge editing mode "${mode}" is ON, loading edge collision for new grid`);
       loadEdgeCollision(grid);
     }
   }
 }

 // If lazy loading is enabled and addCube mode is ON, load block cubes for the new grid
 if (lazyLoadBlockCubes && grid.isInstanced && mode === 'addCube') {
   // Check if block cubes need loading
   let needsLoading = false;
   if (grid.chunks && grid.chunks.size > 0) {
     const firstChunk = grid.chunks.values().next().value;
     if (!firstChunk.instancedBlockCubes) {
       needsLoading = true;
     }
   }

   if (needsLoading) {
     console.log('[addGrid] addCube mode is ON, loading block cubes for new grid');
     loadBlockCubes(grid);
   }
 }

 // Trigger render to sync grid to GPU
 renderer.render(scene, camera);

 // Wait for GPU to complete (2 animation frames for safety)
 await new Promise(resolve => requestAnimationFrame(() => requestAnimationFrame(resolve)));

 // Calculate total time (building + scene add + rendering)
 const tEnd = performance.now();
 const totalTimeInSeconds = ((tEnd - tStart) / 1000).toFixed(2);

 console.log(`Grid ${gridDimensions} created in ${totalTimeInSeconds}s (includes building, scene add, and rendering)`);

 // Update to show completion with total time
 ProgressOverlay.updateLine('grid-progress', `Grid created in ${totalTimeInSeconds}s`);

 // Clear flags
 window.isAddingGrid = false;

 // === RE-ENABLE INTERACTION (only for standalone grid creation) ===
 // If this is part of path/cycle generation, keep interaction blocked until generation completes
 if (!window.isGenerating) {
   // Standalone grid creation: re-enable interaction and fade out overlay
   ProgressOverlay.enableInteraction();

   // Wait briefly to show completion message, then fade out overlay (non-blocking)
   setTimeout(() => {
     ProgressOverlay.overlay.style.opacity = '0';
     setTimeout(() => {
       ProgressOverlay.overlay.style.display = 'none';
       ProgressOverlay.lines = [];
       ProgressOverlay.lineMap = {};
       ProgressOverlay.content.innerHTML = '';
       ProgressOverlay.content.style.width = '';
     }, 300);
   }, 2000);
 }
 // If window.isGenerating is true, overlay stays visible and interaction stays blocked
 // until path/cycle generation completes

 // Automatically reposition camera based on grid size
 // ONLY if autoSyncView is disabled OR this is the first grid
 const shouldSetDefaultCamera = !autoSyncView || allGrids.size === 1;

 if (shouldSetDefaultCamera) {
   const maxDim = Math.max(grid.width, grid.height, grid.depth);

   // Check if this is a 2D grid (any dimension is 1)
   const is2D = grid.width === 1 || grid.height === 1 || grid.depth === 1;


   if (is2D && use2DCameraMode) {
   // Fixed overhead position for 2D grids (only if preference is enabled)
   const centerX = (grid.width - 1) / 2;
   const centerY = (grid.height - 1) / 2;
   const centerZ = (grid.depth - 1) / 2;
   
   // Calculate the grid's actual size in world units
   const gridWorldWidth = Math.max(grid.width - 1, grid.height - 1, grid.depth - 1);
   
   // Calculate available screen height (leave space for bottom UI)
   const bottomUISpace = 200; // pixels for grid tabs and controls
   const availableScreenHeight = window.innerHeight - bottomUISpace;
   
   // Calculate camera distance to fill the available screen height
   const fov = camera.fov * (Math.PI / 180);
   const distance = (gridWorldWidth / 2) / Math.tan(fov / 2) * (window.innerHeight / availableScreenHeight);
   
   // Position camera directly above the grid center
   camera.position.set(centerX, centerY, distance);
   camera.lookAt(centerX, centerY, centerZ);
   
   // Rotate camera 90 degrees around Z-axis
   camera.rotateZ(Math.PI / 2);
   
   // Clear any previous view offset
   camera.clearViewOffset();
   
   if (typeof controls !== "undefined") {
     controls.target.set(centerX, centerY, centerZ);
     controls.enabled = true; // Keep controls enabled for 2D grids
     
     // Configure controls for 2D mode: allow panning and zooming, disable rotation
     controls.enableRotate = false; // Disable rotation
     controls.enablePan = true;     // Enable panning (strafing)
     controls.enableZoom = true;    // Enable zooming
     controls.screenSpacePanning = true; // Enable screen space panning for better 2D feel
     
     controls.update();
   }
 } else {
   // Standard 3D positioning
   camera.position.set(maxDim * 1.5, maxDim * 1.5, maxDim * 1.5);
   camera.lookAt(0, 0, 0);
   
   if (typeof controls !== "undefined") {
     controls.target.set(0, 0, 0);
     controls.enabled = true; // Re-enable orbital controls for 3D grids
     
     // Re-enable rotation for 3D mode
     controls.enableRotate = true;
     controls.enablePan = true;
     controls.enableZoom = true;
     controls.screenSpacePanning = false; // Standard 3D panning
     
     controls.update();
   }
 }
 } // End shouldSetDefaultCamera

 console.log(`Grid created with dimensions ${w}×${h}×${d}`);
}

// Debug helper function - call from console to check grid visibility
window.debugGrids = function() {
  console.log('=== GRID DEBUG INFO ===');
  console.log('Total grids:', allGrids.size);
  console.log('Current grid:', currentGrid ? getCurrentGridId() : 'none');
  console.log('Scene children count:', scene.children.length);

  for (const [gridId, grid] of allGrids.entries()) {
    const inScene = scene.children.includes(grid.group);
    const childCount = grid.group ? grid.group.children.length : 0;
    console.log(`Grid "${gridId}":`, {
      inScene: inScene,
      groupExists: !!grid.group,
      groupChildren: childCount,
      isCurrent: grid === currentGrid
    });
  }
  console.log('======================');
};

// Update preference UI to reflect current grid's LOD settings
function updatePreferencesFromGrid(grid) {
  if (!grid || !grid.lodState) return;

  // Update thin edge detail dropdown
  const edgeDetailSelect = document.getElementById('edgeDetailSelect');
  if (edgeDetailSelect && grid.lodState.edgeSegments !== undefined) {
    edgeDetailSelect.value = grid.lodState.edgeSegments;
  }

  // Update thick edge detail dropdown
  const thickEdgeDetailSelect = document.getElementById('thickEdgeDetailSelect');
  if (thickEdgeDetailSelect && grid.lodState.thickEdgeSegments !== undefined) {
    thickEdgeDetailSelect.value = grid.lodState.thickEdgeSegments;
  }

  // Update vertex detail dropdown
  const vertexDetailSelect = document.getElementById('vertexDetailSelect');
  if (vertexDetailSelect && grid.lodState.vertexDetail !== undefined) {
    vertexDetailSelect.value = grid.lodState.vertexDetail;
  }

  // Update surface depth dropdown
  const surfaceDepthSelect = document.getElementById('surfaceDepthSelect');
  if (surfaceDepthSelect && grid.lodState.surfaceDepth !== undefined) {
    surfaceDepthSelect.value = grid.lodState.surfaceDepth;
  }

  // Update far culling depth dropdown
  const farCullingDepthSelect = document.getElementById('farCullingDepthSelect');
  if (farCullingDepthSelect && grid.lodState.farCullingDepth !== undefined) {
    farCullingDepthSelect.value = grid.lodState.farCullingDepth;
  }

  // Update LOD enabled checkbox
  const lodEnabledCheckbox = document.getElementById('lodEnabledCheckbox');
  if (lodEnabledCheckbox && grid.lodState.lodEnabled !== undefined) {
    lodEnabledCheckbox.checked = grid.lodState.lodEnabled;
  }

  // Update Show All Vertices checkbox
  const showAllVerticesCheckbox = document.getElementById('showAllVerticesCheckbox');
  if (showAllVerticesCheckbox && grid.showAllVertices !== undefined) {
    showAllVerticesCheckbox.checked = grid.showAllVertices;
  }
}

function switchToGrid(id) {
  // Clean up previous grid
  if (currentGrid) {
    // Save camera (only if autoSyncView is disabled)
    if (!autoSyncView) {
      currentGrid.cameraPosition = camera.position.clone();
      currentGrid.cameraTarget = controls.target.clone();
    }

    // Remove previous group's mesh
    scene.remove(currentGrid.group);

    // Remove previous highlights from scene
    if (currentGrid.highlightedBoxHelpers && currentGrid.highlightedBoxHelpers.length) {
      for (const helper of currentGrid.highlightedBoxHelpers) {
        scene.remove(helper);
      }
    }

    // Clean up any active flare sprites
    cleanupFlareSprites();
  }

  // Switch to new grid
  const grid = allGrids.get(id);
  currentGrid = grid;

  // Check if new grid is 2D
  const is2D = grid.width === 1 || grid.height === 1 || grid.depth === 1;

  // Configure controls based on grid type and user preference
  if (typeof controls !== "undefined") {
    controls.enabled = true; // Always keep controls enabled

    if (is2D && use2DCameraMode) {
      // 2D mode (if preference enabled): allow pan and zoom, disable rotation
      controls.enableRotate = false;
      controls.enablePan = true;
      controls.enableZoom = true;
      controls.screenSpacePanning = true;
    } else {
      // 3D mode (or 2D with preference disabled): enable all controls
      controls.enableRotate = true;
      controls.enablePan = true;
      controls.enableZoom = true;
      controls.screenSpacePanning = false;
    }
  }

  // Restore camera (only if autoSyncView is disabled)
  if (!autoSyncView && grid.cameraPosition && grid.cameraTarget) {
    camera.position.copy(grid.cameraPosition);
    controls.target.copy(grid.cameraTarget);
    controls.update();
  }
  // If autoSyncView is enabled, camera stays where it is (shared across all grids)

  // Reattach endpoint markers
  if (grid.startMarker && !grid.group.children.includes(grid.startMarker)) {
    grid.group.add(grid.startMarker);
  }
  if (grid.endMarker && !grid.group.children.includes(grid.endMarker)) {
    grid.group.add(grid.endMarker);
  }

  // Re-add this grid's highlights
  if (grid.highlightedBoxHelpers && grid.highlightedBoxHelpers.length) {
    for (const helper of grid.highlightedBoxHelpers) {
      scene.add(helper);
    }
  }

  scene.add(grid.group);

	// Ensure clipping is enabled if grid has custom planes
	if (grid.customPlanes && grid.customPlanes.length > 0) {
	  renderer.localClippingEnabled = true;
	}

  // Apply per-grid showAllVertices state to the newly active grid
  if (grid.isInstanced && grid.chunks) {
    for (const chunk of grid.chunks.values()) {
      if (chunk.instancedVertexSpheres) {
        chunk.instancedVertexSpheres.visible = grid.showAllVertices;
      }
      if (chunk.pointVertices) {
        chunk.pointVertices.visible = grid.showAllVertices && grid.useLineMode;
      }
    }
  }

  // Sync checkbox state with the grid's property
  const showAllVerticesCheckbox = document.getElementById('showAllVerticesCheckbox');
  if (showAllVerticesCheckbox) {
    showAllVerticesCheckbox.checked = grid.showAllVertices;
  }

  // Sync global currentPath with grid's path
  currentPath = grid.path || [];

  // Create endpoint markers if needed (deferred from load)
  if (grid.needsEndpointMarkers && grid.path && grid.path.length >= 2) {
    console.log('Creating endpoint markers for loaded Hamiltonian path');
    activeEndpoint = 'start'; // Default to start endpoint
    updateEndpointMarkers(grid);
    grid.needsEndpointMarkers = false;
  } else if (grid.needsEndpointMarkers) {
    console.log('needsEndpointMarkers flag set but conditions not met:', {
      hasPath: !!grid.path,
      pathLength: grid.path?.length
    });
  }

  // Update preference dropdowns to reflect current grid's settings
  updatePreferencesFromGrid(grid);

  // Update button highlighting - moved to the end with delay
  requestAnimationFrame(() => {
    // Remove active class from all grid buttons
    const allGridButtons = document.querySelectorAll('.grid-btn');
    allGridButtons.forEach(btn => btn.classList.remove('active'));
    
    // Add active class to the current grid's button
    const gridButtons = document.querySelectorAll('.grid-btn');
    for (const button of gridButtons) {
      const textSpan = button.querySelector('span');
      if (textSpan) {
        const fullName = textSpan.getAttribute('data-fullname') || textSpan.textContent;
        if (fullName === id) {
          button.classList.add('active');
          break;
        }
      }
    }
  });
  // Update notes window if it's open
	if (document.getElementById('notesWindow').style.display === 'block') {
	  updateNotesForCurrentGrid();
	}
	updateBBDistanceMaxValues();
	
	// Refresh axes if they're currently visible to show only relevant dimensions
	if (scene.userData.coordGroup && scene.userData.coordGroup.visible) {
	  toggleCoordinateAxes(); // Turn off
	  toggleCoordinateAxes(); // Turn back on with new grid's dimensions
	}

	// Load collision helpers based on current active mode
	// This ensures editing modes work immediately after switching grids
	if (grid.isInstanced && lazyLoadVertexSpheres) {
	  if (mode === 'addVertex' || mode === 'addDecoration') {
	    // Check if vertex collision helpers need loading
	    let needsLoading = false;
	    if (grid.chunks && grid.chunks.size > 0) {
	      const firstChunk = grid.chunks.values().next().value;
	      if (!firstChunk.instancedVertexCollisionHelpers) {
	        needsLoading = true;
	      }
	    } else if (!grid.instancedVertexCollisionHelpers) {
	      needsLoading = true;
	    }
	    if (needsLoading) {
	      console.log('[switchToGrid] Loading vertex collision helpers for active mode');
	      loadVertexSpheres(grid);
	    }
	  }
	}

	if (grid.isInstanced && lazyLoadEdgeCollision) {
	  if (mode === 'addEdge' || mode === 'addCube' || mode === 'backbite') {
	    // Check if edge collision helpers need loading
	    let needsLoading = false;
	    if (grid.chunks && grid.chunks.size > 0) {
	      const firstChunk = grid.chunks.values().next().value;
	      if (!firstChunk.instancedEdgesCollision) {
	        needsLoading = true;
	      }
	    } else if (!grid.instancedEdgesCollision) {
	      needsLoading = true;
	    }
	    if (needsLoading) {
	      console.log('[switchToGrid] Loading edge collision helpers for active mode');
	      loadEdgeCollision(grid);
	    }
	  }
	}

	// Force immediate LOD evaluation to ensure correct initial state
	// Use setTimeout to ensure camera position is fully updated first
	setTimeout(() => {
	  forceImmediateLODUpdate();
	}, 50);
}


async function buildGridContent(grid) {
  const W = grid.width;
  const H = grid.height;
  const D = grid.depth;
  const totalVertices = W * H * D;

  // Determine yield frequency based on grid size
  // For large grids, yield more frequently to keep UI responsive
  let yieldFrequency;
  if (totalVertices > 100000) {
    yieldFrequency = 1; // Yield every layer for very large grids
  } else if (totalVertices > 10000) {
    yieldFrequency = 2; // Yield every 2 layers for large grids
  } else {
    yieldFrequency = 5; // Yield every 5 layers for smaller grids
  }

  for (let z = 0; z < D; z++) {
    // Check for cancellation at the start of each layer
    if (shouldStopGridAddition) {
      throw new Error("Grid addition cancelled");
    }

    // Add vertices at this layer
    for (let x = 0; x < W; x++) {
      for (let y = 0; y < H; y++) {
        addVertex(grid, x, y, z);
      }
    }
    // Add XY plane edges (horizontal and vertical)
    for (let x = 0; x < W - 1; x++) {
      for (let y = 0; y < H; y++) {
        addEdge(grid, [x, y, z], [x + 1, y, z]);
      }
    }
    for (let x = 0; x < W; x++) {
      for (let y = 0; y < H - 1; y++) {
        addEdge(grid, [x, y, z], [x, y + 1, z]);
      }
    }
    // Add XY-plane boxes at this layer
    for (let x = 0; x < W - 1; x++) {
      for (let y = 0; y < H - 1; y++) {
        addXYBox(grid, x, y, z);
      }
    }
    // Add Z-direction vertical edges and XZ/YZ boxes between layers
    if (z + 1 < D) {
      for (let x = 0; x < W; x++) {
        for (let y = 0; y < H; y++) {
          addVertex(grid, x, y, z + 1);
          addEdge(grid, [x, y, z], [x, y, z + 1]);
        }
      }
      // Add XZ boxes (fixed y)
      for (let x = 0; x < W - 1; x++) {
        for (let y = 0; y < H; y++) {
          addXZBox(grid, x, y, z);
        }
      }
      // Add YZ boxes (fixed x)
      for (let y = 0; y < H - 1; y++) {
        for (let x = 0; x < W; x++) {
          addYZBox(grid, x, y, z);
        }
      }
    }

    // Yield to browser to keep UI responsive
    if (z % yieldFrequency === 0 || z === D - 1) {
      await new Promise(resolve => setTimeout(resolve, 0));
    }
  }
  
  // Set initial opacity for all uncolored edges based on background
  for (const [edgeKey, edge] of grid.edges.entries()) {
    if (edge.color === UNCOLORED_COLOR && edge.mesh) {
      // Check current background color
      const backgroundHex = scene.background.getHex();
      const opacity = backgroundHex === 0x000000 ? 0.3 : 1.0;
      
      const grayValue = Math.floor(0x88 * opacity);
      const simulatedColor = (grayValue << 16) | (grayValue << 8) | grayValue;
      edge.mesh.material.color.setHex(simulatedColor);
      edge.mesh.material.needsUpdate = true;
    }
  }
  
  // Initialize instanced rendering mode
  if (useInstancedRendering) {
  try {
    grid.isInstanced = true;  // Mark this grid as instanced

    initializeInstancedGridEdges(grid);

    // Conditionally initialize switchable boxes based on lazy load preference
    if (!lazyLoadSwitchableBoxes) {
      initializeInstancedBoxes(grid);
    } else {
      // Mark boxes as not loaded
      grid.instancedBoxesXY = null;
      grid.instancedBoxesXZ = null;
      grid.instancedBoxesYZ = null;
      console.log('[Lazy Load] Skipping switchable boxes initialization');
    }

    // Conditionally initialize arrows based on lazy load preference
    if (!lazyLoadArrows) {
      initializeInstancedArrows(grid);
    } else {
      // Mark arrows as not loaded
      grid.instancedArrowsForward = null;
      grid.instancedArrowsBackward = null;
      console.log('[Lazy Load] Skipping arrow initialization');
    }

    // Conditionally initialize vertex spheres based on lazy load preference
    if (!lazyLoadVertexSpheres) {
      initializeInstancedVertexSpheres(grid);
    } else {
      // Mark vertex spheres as not loaded
      console.log('[Lazy Load] Skipping vertex spheres initialization');
    }

  } catch (error) {
    console.error('[buildGridContent] FATAL ERROR during instanced initialization:', error);
    // Fall back to marking as non-instanced
    grid.isInstanced = false;
  }
}
}




function addXYBox(grid, x, y, z = 0) {
  const boxKey = vertexKey(x, y, z, grid);
  const v = [[x, y, z], [x + 1, y, z], [x + 1, y + 1, z], [x, y + 1, z] ];
  const eKeys = [edgeKey(v[0], v[1], grid), edgeKey(v[1], v[2], grid), edgeKey(v[2], v[3], grid), edgeKey(v[3], v[0], grid) ];

  const box = {coords: [x, y, z], plane: "XY", edges: eKeys, z: z, mesh: null  };

  // Only create mesh if NOT using instanced rendering
  if (!useInstancedRendering) {
    const geometry = new THREE.PlaneGeometry(1, 1);
    geometry.rotateX(0);
    geometry.translate(x + 0.5, y + 0.5, z);
    const material = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0, side: THREE.DoubleSide });

    const mesh = new THREE.Mesh(geometry, material);
    mesh.userData.box = box;
    box.mesh = mesh;
    grid.group.add(mesh);
  }

  grid.boxesXY.set(boxKey, box);
}

function addXZBox(grid, x, y, z = 0) {
  const boxKey = vertexKey(x, y, z, grid);
  const v = [[x, y, z], [x + 1, y, z], [x + 1, y, z + 1], [x, y, z + 1]];
  const eKeys = [edgeKey(v[0], v[1], grid), edgeKey(v[1], v[2], grid), edgeKey(v[2], v[3], grid), edgeKey(v[3], v[0], grid)];

  const box = { coords: [x, y, z], plane: "XZ", edges: eKeys, mesh: null };

  // Only create mesh if NOT using instanced rendering
  if (!useInstancedRendering) {
    const geometry = new THREE.PlaneGeometry(1, 1);
    geometry.rotateX(Math.PI / 2);
    geometry.translate(x + 0.5, y, z + 0.5);

    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0, side: THREE.DoubleSide });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.userData.box = box;
    box.mesh = mesh;
    grid.group.add(mesh);
  }

  grid.boxesXZ.set(boxKey, box);
}

function addYZBox(grid, x, y, z = 0) {
  const boxKey = vertexKey(x, y, z, grid);
  const v = [[x, y, z], [x, y + 1, z], [x, y + 1, z + 1], [x, y, z + 1]];
  const eKeys = [edgeKey(v[0], v[1], grid), edgeKey(v[1], v[2], grid), edgeKey(v[2], v[3], grid), edgeKey(v[3], v[0], grid)];

  const box = { coords: [x, y, z], plane: "YZ", edges: eKeys, mesh: null };

  // Only create mesh if NOT using instanced rendering
  if (!useInstancedRendering) {
    const geometry = new THREE.PlaneGeometry(1, 1);
    geometry.rotateY(Math.PI / 2);
    geometry.translate(x, y + 0.5, z + 0.5);

    const material = new THREE.MeshBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 0, side: THREE.DoubleSide });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.userData.box = box;
    box.mesh = mesh;
    grid.group.add(mesh);
  }

  grid.boxesYZ.set(boxKey, box);
}

class Subgraph {
  constructor(grid) {
    this.grid = grid;
    this.edges = new Set();         // Set of edge keys
    this.vertices = new Set();      // Set of vertex keys
    this.edgeDirections = new Map(); // Map: eKey -> direction (1=forward, -1=backward, 0=none)
  }

  addEdge(a, b) {
    const eKey = edgeKey(a, b, this.grid);
    if (this.edges.has(eKey)) return;

    // Add edge
    this.edges.add(eKey);

    // Add vertices
    this.vertices.add(vertexKey(...a, this.grid));
    this.vertices.add(vertexKey(...b, this.grid));

    // Initialize direction to 0 (undirected) if not already set
    if (!this.edgeDirections.has(eKey)) {
      this.edgeDirections.set(eKey, 0);
    }

    // Visually color
    colorEdge(this.grid, a, b, selectedColor, thickEdgeRadius);

    // Update component dropdowns live (only if not in batch mode)
    if (!batchMode && typeof updateSubgraphComponentDropdowns === 'function') {
      updateSubgraphComponentDropdowns();
    }
  }

  removeEdge(a, b) {
    const eKey = edgeKey(a, b, this.grid);
    if (!this.edges.has(eKey)) return;

    this.edges.delete(eKey);
    this.edgeDirections.delete(eKey); // Remove direction data

    // Recolor visually
    colorEdge(this.grid, a, b, UNCOLORED_COLOR, thinEdgeRadius);

    // Possibly remove isolated vertices
    const v1 = vertexKey(...a, this.grid);
    const v2 = vertexKey(...b, this.grid);

    if (this.getNeighbors(v1).length === 0) {
      this.vertices.delete(v1);
    }
    if (this.getNeighbors(v2).length === 0) {
      this.vertices.delete(v2);
    }

    // Update component dropdowns live (only if not in batch mode)
    if (!batchMode && typeof updateSubgraphComponentDropdowns === 'function') {
      updateSubgraphComponentDropdowns();
    }
  }

  hasEdge(a, b) {
    return this.edges.has(edgeKey(a, b, this.grid));
  }

  hasVertex(v) {
    return this.vertices.has(vertexKey(...v, this.grid));
  }

  getNeighbors(vKey) {
    // OPTIMIZED: Use grid geometry instead of scanning all edges - O(1) instead of O(E)
    const [x, y, z] = unpackVertex(vKey, this.grid);
    const neighbors = [];

    // Generate 6 possible neighbor coordinates
    const neighborCoords = [
      [x + 1, y, z], [x - 1, y, z],
      [x, y + 1, z], [x, y - 1, z],
      [x, y, z + 1], [x, y, z - 1]
    ];

    // Check which neighbors are actually in the subgraph (connected by edges)
    for (const [nx, ny, nz] of neighborCoords) {
      // Bounds check
      if (nx < 0 || nx >= this.grid.width) continue;
      if (ny < 0 || ny >= this.grid.height) continue;
      if (nz < 0 || nz >= this.grid.depth) continue;

      const neighborKey = vertexKey(nx, ny, nz, this.grid);

      // Check if there's an edge between vKey and neighborKey in the subgraph
      const eKey = edgeKey([x, y, z], [nx, ny, nz], this.grid);
      if (this.edges.has(eKey)) {
        neighbors.push(neighborKey);
      }
    }

    return neighbors;
  }

  edgeCount() {
    return this.edges.size;
  }

  vertexCount() {
    return this.vertices.size;
  }

  clear() {
    // Remove all edges and recolor
    for (const eKey of this.edges) {
      const [a, b] = unpackEdge(eKey, this.grid);
      colorEdge(this.grid, a, b, UNCOLORED_COLOR, thinEdgeRadius);
    }
    this.edges.clear();
    this.vertices.clear();
    this.edgeDirections.clear(); // Clear direction data
  }

  getEdgeKeys() {
    return [...this.edges];
  }

  getVertexKeys() {
    return [...this.vertices];
  }

  // ==================== PHASE 1: COMPONENT ANALYSIS ====================

  // Get degree of a vertex (helper method)
  getDegree(vKey) {
    return this.getNeighbors(vKey).length;
  }

  // Build adjacency map for fast neighbor lookup - O(E) complexity
  // Returns: { adjMap: vKey -> Set of neighbor vKeys, edgeMap: vKey -> Set of edge keys }
  _buildAdjacencyMap() {
    const adjMap = new Map(); // vKey -> Set of neighbor vKeys
    const edgeMap = new Map(); // vKey -> Set of eKeys incident to this vertex

    for (const eKey of this.edges) {
      const [a, b] = unpackEdge(eKey, this.grid);
      const aKey = vertexKey(...a, this.grid);
      const bKey = vertexKey(...b, this.grid);

      if (!adjMap.has(aKey)) adjMap.set(aKey, new Set());
      if (!adjMap.has(bKey)) adjMap.set(bKey, new Set());
      if (!edgeMap.has(aKey)) edgeMap.set(aKey, new Set());
      if (!edgeMap.has(bKey)) edgeMap.set(bKey, new Set());

      adjMap.get(aKey).add(bKey);
      adjMap.get(bKey).add(aKey);
      edgeMap.get(aKey).add(eKey);
      edgeMap.get(bKey).add(eKey);
    }

    return { adjMap, edgeMap };
  }

  // Find all connected components using BFS - optimized with adjacency map
  // Complexity: O(V + E) instead of O(V × E)
  _findConnectedComponents() {
    const visited = new Set();
    const components = [];

    // Build adjacency and edge maps once - O(E)
    const { adjMap, edgeMap } = this._buildAdjacencyMap();

    for (const startVKey of this.vertices) {
      if (visited.has(startVKey)) continue;

      // BFS to find component
      const componentVertices = new Set();
      const componentEdges = new Set();
      const queue = [startVKey];

      while (queue.length > 0) {
        const vKey = queue.shift();
        if (visited.has(vKey)) continue;

        visited.add(vKey);
        componentVertices.add(vKey);

        // Add all edges incident to this vertex - O(1) lookup
        const incidentEdges = edgeMap.get(vKey) || new Set();
        for (const eKey of incidentEdges) {
          componentEdges.add(eKey);
        }

        // Explore neighbors using adjacency map - O(1) lookup
        const neighbors = adjMap.get(vKey) || new Set();
        for (const neighborKey of neighbors) {
          if (!visited.has(neighborKey)) {
            queue.push(neighborKey);
          }
        }
      }

      components.push({
        vertices: componentVertices,
        edges: componentEdges
      });
    }

    return components;
  }

  // Analyze components (Phase 1: basic structure only)
  analyzeComponents() {
    const components = this._findConnectedComponents();

    const analyzedComponents = components.map((comp, index) => ({
      index: index,
      vertices: comp.vertices,
      edges: comp.edges,
      vertexCount: comp.vertices.size,
      edgeCount: comp.edges.size
    }));

    const summary = {
      componentCount: components.length,
      totalVertices: this.vertices.size,
      totalEdges: this.edges.size,
      isConnected: components.length === 1
    };

    const analysis = {
      version: 1,
      timestamp: Date.now(),
      components: analyzedComponents,
      summary: summary
    };

    return analysis;
  }

  // ==================== PHASE 2: PATH/CYCLE CLASSIFICATION ====================

  // Classify a component as path, cycle, or lattice animal
  // adjMap: optional adjacency map for O(1) degree lookup
  _classifyComponent(comp, adjMap = null) {
    const V = comp.vertices.size;
    const E = comp.edges.size;

    // Get degree distribution - use adjMap if provided for O(1) lookup
    const degrees = new Map();
    for (const vKey of comp.vertices) {
      const degree = adjMap ? (adjMap.get(vKey)?.size || 0) : this.getDegree(vKey);
      degrees.set(vKey, degree);
    }

    const degreeValues = Array.from(degrees.values());

    // Use reduce instead of spread operator to avoid call stack overflow on large arrays
    const maxDegree = degreeValues.reduce((max, d) => Math.max(max, d), 0);
    const minDegree = degreeValues.reduce((min, d) => Math.min(min, d), Infinity);
    const degree1Count = degreeValues.filter(d => d === 1).length;
    const degree2Count = degreeValues.filter(d => d === 2).length;

    // Classification logic:
    // Path: E = V-1, all vertices degree ≤ 2, exactly 2 endpoints (degree 1)
    // Cycle: E = V, all vertices degree 2
    // Tree: E = V-1, but has branching (maxDegree ≥ 3 or not exactly 2 leaves)
    // Complex: everything else (has cycles)

    let type, isHamiltonian = false;

    if (E === V - 1 && maxDegree <= 2 && degree1Count === 2) {
      // Path: acyclic, linear (no branching), exactly 2 endpoints
      type = 'path';
      // Check if it's a Hamiltonian path (covers entire grid)
      isHamiltonian = (V === this.grid.width * this.grid.height * this.grid.depth);
    } else if (E === V - 1) {
      // Tree: acyclic but has branching (E = V-1 but not a path)
      type = 'tree';
    } else if (E === V && maxDegree === 2 && degree2Count === V) {
      // Cycle: exactly V edges, all vertices degree 2
      type = 'cycle';
      // Check if it's a Hamiltonian cycle (covers entire grid)
      isHamiltonian = (V === this.grid.width * this.grid.height * this.grid.depth);
    } else {
      // Complex: has cycles (E > V-1)
      type = 'complex';
    }

    return {
      type: type,
      length: E,
      isHamiltonian: isHamiltonian,
      degrees: degrees,
      degreeDistribution: {
        min: minDegree,
        max: maxDegree,
        degree1: degree1Count,
        degree2: degree2Count,
        degree3plus: degreeValues.filter(d => d >= 3).length
      }
    };
  }

  // Trace a path or cycle to get the ordered sequence of vertices
  // adjMap: optional adjacency map for O(1) neighbor lookup
  _traceLinearComponent(comp, classification, adjMap = null) {
    if (classification.type !== 'path' && classification.type !== 'cycle') {
      return null; // Can't trace lattice animals linearly
    }

    const degrees = classification.degrees;

    // Find starting vertex
    let startVKey;
    if (classification.type === 'path') {
      // Start from an endpoint (degree 1)
      startVKey = Array.from(degrees.entries()).find(([v, d]) => d === 1)[0];
    } else {
      // Cycle: start from any vertex (choose the smallest key for consistency)
      startVKey = Math.min(...Array.from(comp.vertices));
    }

    // Trace the path/cycle
    const visited = new Set();
    const sequence = [];
    let current = startVKey;

    while (true) {
      visited.add(current);
      sequence.push(current);

      // Find next unvisited neighbor - use adjMap if provided for O(1) lookup
      const neighbors = adjMap ? Array.from(adjMap.get(current) || []) : this.getNeighbors(current);
      const next = neighbors.find(n => comp.vertices.has(n) && !visited.has(n));

      if (next === undefined) break;  // Fixed: check for undefined, not falsy
      current = next;
    }

    return sequence;
  }

  // Enhanced component analysis with classification
  analyzeComponentsDetailed() {
    const components = this._findConnectedComponents();

    // Build adjacency map once for efficient tracing - O(E)
    const { adjMap } = this._buildAdjacencyMap();

    const paths = [];
    const cycles = [];
    const trees = [];
    const complexComponents = [];

    // Classify and trace each component
    for (let i = 0; i < components.length; i++) {
      const comp = components[i];
      const classification = this._classifyComponent(comp, adjMap);

      const analyzedComp = {
        index: i,
        vertices: comp.vertices,
        edges: comp.edges,
        vertexCount: comp.vertices.size,
        edgeCount: comp.edges.size,
        type: classification.type,
        length: classification.length,
        isHamiltonian: classification.isHamiltonian,
        degreeDistribution: classification.degreeDistribution
      };

      // Add sequence for paths and cycles - pass adjMap for O(1) neighbor lookup
      if (classification.type === 'path' || classification.type === 'cycle') {
        analyzedComp.sequence = this._traceLinearComponent(comp, classification, adjMap);
      }

      // Categorize
      if (classification.type === 'path') {
        paths.push(analyzedComp);
      } else if (classification.type === 'cycle') {
        cycles.push(analyzedComp);
      } else if (classification.type === 'tree') {
        trees.push(analyzedComp);
      } else {
        complexComponents.push(analyzedComp);
      }
    }

    // Sort paths and cycles by length
    paths.sort((a, b) => a.length - b.length);
    cycles.sort((a, b) => a.length - b.length);
    trees.sort((a, b) => a.length - b.length);

    // Create summary
    const summary = {
      componentCount: components.length,
      totalVertices: this.vertices.size,
      totalEdges: this.edges.size,
      isConnected: components.length === 1,
      pathCount: paths.length,
      cycleCount: cycles.length,
      treeCount: trees.length,
      complexCount: complexComponents.length,
      // Keep latticeAnimalCount for backward compatibility (trees + complex)
      latticeAnimalCount: trees.length + complexComponents.length,
      hasHamiltonianPath: paths.some(p => p.isHamiltonian),
      hasHamiltonianCycle: cycles.some(c => c.isHamiltonian)
    };

    return {
      version: 2,
      timestamp: Date.now(),
      summary: summary,
      paths: paths,
      cycles: cycles,
      trees: trees,
      complexComponents: complexComponents,
      // Keep latticeAnimals for backward compatibility
      latticeAnimals: [...trees, ...complexComponents],
      allComponents: [...paths, ...cycles, ...trees, ...complexComponents]
    };
  }

  // Convenience method: Get formatted report
  getAnalysisReport() {
    const analysis = this.analyzeComponentsDetailed();

    let report = '';
    report += `📊 SUBGRAPH ANALYSIS\n`;
    report += `━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n`;
    report += `Components: ${analysis.summary.componentCount} `;
    report += `(${analysis.summary.pathCount} paths, `;
    report += `${analysis.summary.cycleCount} cycles, `;
    report += `${analysis.summary.latticeAnimalCount} lattice animals)\n`;
    report += `Vertices: ${analysis.summary.totalVertices}, `;
    report += `Edges: ${analysis.summary.totalEdges}\n`;
    report += `Connected: ${analysis.summary.isConnected}\n`;

    if (analysis.summary.hasHamiltonianPath) {
      report += `✨ Contains Hamiltonian PATH\n`;
    }
    if (analysis.summary.hasHamiltonianCycle) {
      report += `✨ Contains Hamiltonian CYCLE\n`;
    }

    report += `\n`;

    // Paths
    if (analysis.paths.length > 0) {
      report += `🛤️  PATHS (${analysis.paths.length}):\n`;
      analysis.paths.forEach((p, i) => {
        // For long paths, show first few, last few, and indicate truncation
        let coords;
        if (p.sequence.length > 10) {
          const first5 = p.sequence.slice(0, 5).map(vKey => {
            const v = unpackVertex(vKey, this.grid);
            return `[${v[0]},${v[1]},${v[2]}]`;
          });
          const last5 = p.sequence.slice(-5).map(vKey => {
            const v = unpackVertex(vKey, this.grid);
            return `[${v[0]},${v[1]},${v[2]}]`;
          });
          coords = first5.join(' → ') + ' → ... → ' + last5.join(' → ');
        } else {
          coords = p.sequence.map(vKey => {
            const v = unpackVertex(vKey, this.grid);
            return `[${v[0]},${v[1]},${v[2]}]`;
          }).join(' → ');
        }
        report += `   ${i+1}. Length ${p.length}`;
        if (p.isHamiltonian) report += ' ⭐HAMILTONIAN';
        report += `:\n      ${coords}\n`;
      });
      report += `\n`;
    }

    // Cycles
    if (analysis.cycles.length > 0) {
      report += `🔄 CYCLES (${analysis.cycles.length}):\n`;
      analysis.cycles.forEach((c, i) => {
        // For long cycles, show first few, last few, and indicate truncation
        let coords;
        if (c.sequence.length > 10) {
          const first5 = c.sequence.slice(0, 5).map(vKey => {
            const v = unpackVertex(vKey, this.grid);
            return `[${v[0]},${v[1]},${v[2]}]`;
          });
          const last5 = c.sequence.slice(-5).map(vKey => {
            const v = unpackVertex(vKey, this.grid);
            return `[${v[0]},${v[1]},${v[2]}]`;
          });
          coords = first5.join(' → ') + ' → ... → ' + last5.join(' → ');
        } else {
          coords = c.sequence.map(vKey => {
            const v = unpackVertex(vKey, this.grid);
            return `[${v[0]},${v[1]},${v[2]}]`;
          }).join(' → ');
        }
        report += `   ${i+1}. Length ${c.length}`;
        if (c.isHamiltonian) report += ' ⭐HAMILTONIAN';
        report += `:\n      ${coords} → [back to start]\n`;
      });
      report += `\n`;
    }

    // Lattice animals
    if (analysis.latticeAnimals.length > 0) {
      report += `🦎 LATTICE ANIMALS (${analysis.latticeAnimals.length}):\n`;
      analysis.latticeAnimals.forEach((la, i) => {
        report += `   ${i+1}. ${la.vertexCount}v, ${la.edgeCount}e, `;
        report += `deg: [${la.degreeDistribution.min}-${la.degreeDistribution.max}]`;
        report += ` (${la.degreeDistribution.degree3plus} vertices deg≥3)\n`;
      });
    }

    return report;
  }

  // ==================== PHASE 3: ARROW DIRECTION INTEGRATION ====================

  // Set direction for an edge
  // direction: 1 = forward (a→b), -1 = backward (b→a), 0 = undirected
  setEdgeDirection(a, b, direction) {
    const eKey = edgeKey(a, b, this.grid);
    if (!this.edges.has(eKey)) {
      console.warn('Cannot set direction for edge not in subgraph:', a, b);
      return;
    }

    this.edgeDirections.set(eKey, direction);
  }

  // Get direction for an edge (returns 0 if not set)
  getEdgeDirection(a, b) {
    const eKey = edgeKey(a, b, this.grid);
    return this.edgeDirections.get(eKey) || 0;
  }

  // Sync arrows FROM grid.edges TO subgraph
  syncArrowsFromGrid() {
    for (const eKey of this.edges) {
      const edge = this.grid.edges.get(eKey);
      if (edge && edge.arrowDirection !== undefined) {
        this.edgeDirections.set(eKey, edge.arrowDirection);
      }
    }
  }

  // Sync arrows FROM subgraph TO grid.edges
  syncArrowsToGrid() {
    for (const [eKey, direction] of this.edgeDirections) {
      const edge = this.grid.edges.get(eKey);
      if (edge) {
        edge.arrowDirection = direction;
      }
    }
  }

  // Check if a path/cycle is consistently oriented
  _checkOrientation(comp, classification) {
    if (!comp.sequence || comp.sequence.length < 2) {
      return { isOriented: false, consistency: 0 };
    }

    const seq = comp.sequence;
    let forwardCount = 0;
    let backwardCount = 0;
    let undirectedCount = 0;

    // Check each edge in sequence
    for (let i = 0; i < seq.length - 1; i++) {
      const vKey1 = seq[i];
      const vKey2 = seq[i + 1];
      const v1 = unpackVertex(vKey1, this.grid);
      const v2 = unpackVertex(vKey2, this.grid);
      const eKey = edgeKey(v1, v2, this.grid);

      const direction = this.edgeDirections.get(eKey) || 0;

      if (direction === 0) {
        undirectedCount++;
      } else {
        // Check if direction matches sequence direction
        // We need to determine if the edge is stored as v1→v2 or v2→v1
        const [a, b] = unpackEdge(eKey, this.grid);
        const aKey = vertexKey(...a, this.grid);
        const isForward = (aKey === vKey1); // True if edge stored as v1→v2

        const matchesSequence = (isForward && direction === 1) || (!isForward && direction === -1);

        if (matchesSequence) {
          forwardCount++;
        } else {
          backwardCount++;
        }
      }
    }

    // For cycles, also check the closing edge
    if (classification.type === 'cycle' && seq.length > 0) {
      const vKey1 = seq[seq.length - 1];
      const vKey2 = seq[0];
      const v1 = unpackVertex(vKey1, this.grid);
      const v2 = unpackVertex(vKey2, this.grid);
      const eKey = edgeKey(v1, v2, this.grid);

      const direction = this.edgeDirections.get(eKey) || 0;

      if (direction === 0) {
        undirectedCount++;
      } else {
        const [a, b] = unpackEdge(eKey, this.grid);
        const aKey = vertexKey(...a, this.grid);
        const isForward = (aKey === vKey1);
        const matchesSequence = (isForward && direction === 1) || (!isForward && direction === -1);

        if (matchesSequence) {
          forwardCount++;
        } else {
          backwardCount++;
        }
      }
    }

    const totalDirected = forwardCount + backwardCount;
    const isOriented = (totalDirected > 0) && (backwardCount === 0);
    const consistency = totalDirected > 0 ? forwardCount / totalDirected : 0;

    return {
      isOriented: isOriented,
      consistency: consistency,
      forwardCount: forwardCount,
      backwardCount: backwardCount,
      undirectedCount: undirectedCount
    };
  }

  // Orient a path or cycle along its sequence
  // For paths: orients from sequence[0] to sequence[last]
  // For cycles: orients in sequence order
  // If componentIndex is provided, orient only that component (0-indexed)
  // If componentIndex is null/undefined, orient all components
  orient(componentIndex = null) {
    const analysis = this.analyzeComponentsDetailed();
    const components = analysis.allComponents;

    // Determine which components to orient
    let componentsToOrient = [];
    if (componentIndex !== null) {
      if (componentIndex < 0 || componentIndex >= components.length) {
        console.error(`Invalid component index ${componentIndex}`);
        return;
      }
      componentsToOrient = [components[componentIndex]];
    } else {
      componentsToOrient = components;
    }

    // Orient each selected component
    for (const component of componentsToOrient) {
      this._orientComponent(component);
    }

    console.log(`✓ Oriented ${componentIndex !== null ? `component ${componentIndex + 1}` : 'all components'}`);
  }

  // Helper method to orient a single component
  _orientComponent(component) {
    if (!component.sequence || component.sequence.length < 2) {
      console.warn('Cannot orient: component has no valid sequence');
      return;
    }

    if (component.type !== 'path' && component.type !== 'cycle') {
      console.warn('Cannot orient: component is not a path or cycle');
      return;
    }

    const seq = component.sequence;
    const componentType = component.type;

    // CRITICAL: Remove all existing arrows first
    // Subgraph arrow functions are the authoritative source for arrow directions
    for (let i = 0; i < seq.length - 1; i++) {
      const vKey1 = seq[i];
      const vKey2 = seq[i + 1];
      const v1 = unpackVertex(vKey1, this.grid);
      const v2 = unpackVertex(vKey2, this.grid);
      const eKey = edgeKey(v1, v2, this.grid);
      const edge = this.grid.edges.get(eKey);
      if (edge && edge.arrows) {
        removeArrowsFromEdge(edge, eKey);
      }
    }

    // For cycles, also remove arrow from closing edge
    if (componentType === 'cycle' && seq.length > 0) {
      const vKey1 = seq[seq.length - 1];
      const vKey2 = seq[0];
      const v1 = unpackVertex(vKey1, this.grid);
      const v2 = unpackVertex(vKey2, this.grid);
      const eKey = edgeKey(v1, v2, this.grid);
      const edge = this.grid.edges.get(eKey);
      if (edge && edge.arrows) {
        removeArrowsFromEdge(edge, eKey);
      }
    }

    // Orient each edge in sequence (ALWAYS set direction - subgraph is authoritative)
    for (let i = 0; i < seq.length - 1; i++) {
      const vKey1 = seq[i];
      const vKey2 = seq[i + 1];
      const v1 = unpackVertex(vKey1, this.grid);
      const v2 = unpackVertex(vKey2, this.grid);
      const eKey = edgeKey(v1, v2, this.grid);

      // Determine direction: should arrow point from v1 to v2 in sequence
      const [a, b] = unpackEdge(eKey, this.grid);
      const aKey = vertexKey(...a, this.grid);
      const direction = (aKey === vKey1) ? 1 : -1;
      this.edgeDirections.set(eKey, direction);
    }

    // For cycles, also orient the closing edge
    if (componentType === 'cycle' && seq.length > 0) {
      const vKey1 = seq[seq.length - 1];
      const vKey2 = seq[0];
      const v1 = unpackVertex(vKey1, this.grid);
      const v2 = unpackVertex(vKey2, this.grid);
      const eKey = edgeKey(v1, v2, this.grid);

      // Determine direction for closing edge
      const [a, b] = unpackEdge(eKey, this.grid);
      const aKey = vertexKey(...a, this.grid);
      const direction = (aKey === vKey1) ? 1 : -1;
      this.edgeDirections.set(eKey, direction);
    }

    // Sync to grid.edges and add visual arrows
    this.syncArrowsToGrid();

    // Enable arrow mode if it's currently off
    if (!arrowMode) {
      arrowMode = true;
      const checkbox = document.getElementById('arrowCheckbox');
      if (checkbox) {
        checkbox.checked = true;
      }
      console.log('✓ Arrow mode enabled');
    }

    // Add visual arrows to all edges (they were removed above, now re-add with correct orientation)
    for (let i = 0; i < seq.length - 1; i++) {
      const vKey1 = seq[i];
      const vKey2 = seq[i + 1];
      const v1 = unpackVertex(vKey1, this.grid);
      const v2 = unpackVertex(vKey2, this.grid);
      const eKey = edgeKey(v1, v2, this.grid);
      const edge = this.grid.edges.get(eKey);

      if (edge) {
        // CRITICAL: Must pass CANONICAL coordinates (from unpackEdge), not sequence coordinates
        // The direction value is relative to canonical edge orientation
        const [a, b] = unpackEdge(eKey, this.grid);
        addArrowsToEdge(edge, edge.arrowDirection, a, b, eKey);
      }
    }

    // Handle cycle closing edge
    if (componentType === 'cycle' && seq.length > 0) {
      const vKey1 = seq[seq.length - 1];
      const vKey2 = seq[0];
      const v1 = unpackVertex(vKey1, this.grid);
      const v2 = unpackVertex(vKey2, this.grid);
      const eKey = edgeKey(v1, v2, this.grid);
      const edge = this.grid.edges.get(eKey);

      if (edge) {
        // CRITICAL: Must pass CANONICAL coordinates (from unpackEdge), not sequence coordinates
        const [a, b] = unpackEdge(eKey, this.grid);
        addArrowsToEdge(edge, edge.arrowDirection, a, b, eKey);
      }
    }

    // Log success
    console.log(`✓ Oriented ${componentType} with ${component.edgeCount} edges`);
  }

  // Enhanced analysis with arrow orientation
  analyzeComponentsWithArrows() {
    const analysis = this.analyzeComponentsDetailed();

    // DISABLED: Orientation checking is too slow for large graphs (135k operations for 27k edges)
    // If needed in future, optimize _checkOrientation to avoid unpack/repack operations
    /*
    // Add orientation info to paths and cycles
    for (const path of analysis.paths) {
      const orientation = this._checkOrientation(path, { type: 'path' });
      path.orientation = orientation;
      path.isOriented = orientation.isOriented;
    }

    for (const cycle of analysis.cycles) {
      const orientation = this._checkOrientation(cycle, { type: 'cycle' });
      cycle.orientation = orientation;
      cycle.isOriented = orientation.isOriented;
    }

    // Update summary
    analysis.summary.hasOrientedPath = analysis.paths.some(p => p.isOriented);
    analysis.summary.hasOrientedCycle = analysis.cycles.some(c => c.isOriented);
    analysis.summary.hasOrientedHamiltonianPath = analysis.paths.some(p => p.isHamiltonian && p.isOriented);
    analysis.summary.hasOrientedHamiltonianCycle = analysis.cycles.some(c => c.isHamiltonian && c.isOriented);
    */

    return analysis;
  }

  // Reverse all arrows in the subgraph
  // For oriented paths: this swaps the start and end points
  // For oriented cycles: this reverses the cycle direction
  reverseArrows(componentIndex = null) {
    // Sync any manually-added arrows from grid first
    this.syncArrowsFromGrid();

    // Get edges to reverse (either specific component or all)
    let edgesToReverse;
    if (componentIndex !== null) {
      const components = this._findConnectedComponents();
      if (componentIndex < 0 || componentIndex >= components.length) {
        console.error(`Invalid component index ${componentIndex}. Valid range: 0-${components.length - 1}`);
        return;
      }
      edgesToReverse = components[componentIndex].edges;
    } else {
      edgesToReverse = this.edges;
    }

    // Reverse edge directions for selected edges
    let reversedCount = 0;
    for (const eKey of edgesToReverse) {
      const direction = this.edgeDirections.get(eKey);
      if (direction !== undefined && direction !== 0) {
        this.edgeDirections.set(eKey, -direction);
        reversedCount++;
      }
    }

    // Sync to grid and update visual arrows
    this.syncArrowsToGrid();

    // Update visual arrows - remove and re-add with new direction
    for (const eKey of edgesToReverse) {
      const edge = this.grid.edges.get(eKey);
      if (edge && edge.arrowDirection && edge.arrowDirection !== 0) {
        // Get coordinates for instanced rendering
        const [v1, v2] = unpackEdge(eKey, this.grid);
        // Remove old arrows using the proper function
        removeArrowsFromEdge(edge, eKey);
        // Add new arrows in reversed direction with proper parameters
        addArrowsToEdge(edge, edge.arrowDirection, v1, v2, eKey);
      }
    }

    const componentMsg = componentIndex !== null ? ` in component ${componentIndex}` : '';
    console.log(`✓ Reversed ${reversedCount} arrows${componentMsg}`);
  }

  // Reverse arrows for a specific component (path or cycle)
  // More targeted than reverseArrows() - only reverses one component
  reverseComponent(component) {
    if (!component.sequence || component.sequence.length < 2) {
      console.warn('Cannot reverse: component has no valid sequence');
      return;
    }

    if (component.type !== 'path' && component.type !== 'cycle') {
      console.warn('Cannot reverse: component is not a path or cycle');
      return;
    }

    const seq = component.sequence;

    // Reverse each edge in sequence
    for (let i = 0; i < seq.length - 1; i++) {
      const vKey1 = seq[i];
      const vKey2 = seq[i + 1];
      const v1 = unpackVertex(vKey1, this.grid);
      const v2 = unpackVertex(vKey2, this.grid);
      const eKey = edgeKey(v1, v2, this.grid);

      const currentDir = this.edgeDirections.get(eKey) || 0;
      if (currentDir !== 0) {
        this.edgeDirections.set(eKey, -currentDir);
      }
    }

    // For cycles, also reverse the closing edge
    if (component.type === 'cycle' && seq.length > 0) {
      const vKey1 = seq[seq.length - 1];
      const vKey2 = seq[0];
      const v1 = unpackVertex(vKey1, this.grid);
      const v2 = unpackVertex(vKey2, this.grid);
      const eKey = edgeKey(v1, v2, this.grid);

      const currentDir = this.edgeDirections.get(eKey) || 0;
      if (currentDir !== 0) {
        this.edgeDirections.set(eKey, -currentDir);
      }
    }

    // Sync to grid and update visual arrows
    this.syncArrowsToGrid();

    // Update visual arrows for this component
    for (let i = 0; i < seq.length - 1; i++) {
      const vKey1 = seq[i];
      const vKey2 = seq[i + 1];
      const v1 = unpackVertex(vKey1, this.grid);
      const v2 = unpackVertex(vKey2, this.grid);
      const eKey = edgeKey(v1, v2, this.grid);
      const edge = this.grid.edges.get(eKey);

      if (edge && edge.arrowDirection && edge.arrowDirection !== 0) {
        // Remove old arrows using the proper function
        removeArrowsFromEdge(edge, eKey);
        // Add new arrows in reversed direction with proper parameters
        addArrowsToEdge(edge, edge.arrowDirection, v1, v2, eKey);
      }
    }

    // Handle cycle closing edge
    if (componentType === 'cycle' && seq.length > 0) {
      const vKey1 = seq[seq.length - 1];
      const vKey2 = seq[0];
      const v1 = unpackVertex(vKey1, this.grid);
      const v2 = unpackVertex(vKey2, this.grid);
      const eKey = edgeKey(v1, v2, this.grid);
      const edge = this.grid.edges.get(eKey);

      if (edge && edge.arrowDirection && edge.arrowDirection !== 0) {
        // Remove old arrows using the proper function
        removeArrowsFromEdge(edge, eKey);
        // Add new arrows in reversed direction with proper parameters
        addArrowsToEdge(edge, edge.arrowDirection, v1, v2, eKey);
      }
    }
  }

static fromEdgeKeys(grid, edgeKeys) {
  const sg = new Subgraph(grid);
  for (const eKey of edgeKeys) {
    const [a, b] = unpackEdge(eKey, grid);
    sg.addEdge(a, b);
  }
  return sg;
}

}


 //  ==============================    I.E.R. FUNCTIONS   ===========================  \\

function initializeInstancedGridEdges(grid) {
  const totalEdges = grid.edges.size;

  // Safety check: ensure we have edges to render
  if (totalEdges === 0) {
    console.warn('[initializeInstancedGridEdges] Grid has 0 edges, skipping instanced edge initialization');
    // Initialize empty structures so the rest of the code doesn't break
    grid.instancedEdgesThin = null;
    grid.instancedEdgesThick = null;
    grid.instancedEdgesCollision = null;
    grid.instancedBlockCubes = null;
    grid.edgeToInstanceMap = new Map();
    grid.chunks = new Map();
    return;
  }

  // === CHUNKING SETUP ===
  const chunkSize = getOptimalChunkSize(grid.width, grid.height, grid.depth);
  grid.chunkSize = chunkSize;
  grid.chunkCounts = calculateChunkCounts(grid.width, grid.height, grid.depth, chunkSize);

  // Calculate chunk boundaries with distributed remainders (no thin edge chunks)
  grid.chunkBoundaries = {
    x: calculateChunkBoundaries(grid.width, chunkSize, grid.chunkCounts.x),
    y: calculateChunkBoundaries(grid.height, chunkSize, grid.chunkCounts.y),
    z: calculateChunkBoundaries(grid.depth, chunkSize, grid.chunkCounts.z)
  };

  grid.chunks = new Map();
  grid.edgeToChunk = new Map();


  // === FIRST PASS: Count edges per chunk ===
  const chunkEdgeCounts = new Map(); // chunkKey → count

  for (const [eKey, edge] of grid.edges.entries()) {
    const [a, b] = unpackEdge(eKey, grid);

    const { cx, cy, cz } = getChunkForEdge(a, b, grid);
    const chunkKey = getChunkKey(cx, cy, cz);

    grid.edgeToChunk.set(eKey, chunkKey);
    chunkEdgeCounts.set(chunkKey, (chunkEdgeCounts.get(chunkKey) || 0) + 1);
  }

  // === CREATE CHUNKS WITH APPROPRIATELY-SIZED MESHES ===
  // Use grid-specific edge detail (may be lower for large grids)
  const gridEdgeSegments = grid.lodState?.edgeSegments || edgeSegments;
  const gridThickEdgeSegments = grid.lodState?.thickEdgeSegments || thickEdgeSegments;

  const thinGeometry = new THREE.CylinderGeometry(thinEdgeRadius, thinEdgeRadius, 1, gridEdgeSegments);
  const thickGeometry = unifiedEdgeSize ? null : new THREE.CylinderGeometry(thickEdgeRadius, thickEdgeRadius, 1, gridThickEdgeSegments);
  const collisionGeometry = unifiedEdgeSize ? null : new THREE.CylinderGeometry(edgeCollisionRadius, edgeCollisionRadius, 1, 3);

  // Create block cube geometry (shared across all chunks)
  const blockCubeGeometry = new THREE.BoxGeometry(blockCubeSize, blockCubeSize, blockCubeSize);
  const blockCubeMaterial = new THREE.MeshBasicMaterial({ vertexColors: false });

  // Get boundaries for center/bounding box calculations
  const bx = grid.chunkBoundaries.x;
  const by = grid.chunkBoundaries.y;
  const bz = grid.chunkBoundaries.z;

  for (const [chunkKey, edgeCount] of chunkEdgeCounts.entries()) {
    const chunk = createChunkData();
    chunk.edgeCount = edgeCount;

    // Calculate chunk center from chunk key using actual boundaries
    // Parse chunk key string "cx,cy,cz" back to coordinates
    const [cx, cy, cz] = chunkKey.split(',').map(Number);
    chunk.center = {
      x: (bx[cx] + bx[cx + 1]) / 2,
      y: (by[cy] + by[cy + 1]) / 2,
      z: (bz[cz] + bz[cz + 1]) / 2
    };

    // Create bounding box for frustum culling using actual boundaries
    chunk.boundingBox = new THREE.Box3(
      new THREE.Vector3(bx[cx], by[cy], bz[cz]),
      new THREE.Vector3(bx[cx + 1], by[cy + 1], bz[cz + 1])
    );

    // Initialize LOD state for this chunk (use grid-specific values)
    chunk.lodState.edgeSegments = gridEdgeSegments;
    chunk.lodState.thickEdgeSegments = gridThickEdgeSegments;
    chunk.lodState.level = 3; // Start at full detail

    // Create thin mesh for this chunk
    const thinMaterial = new THREE.MeshBasicMaterial();
    chunk.instancedEdgesThin = new THREE.InstancedMesh(thinGeometry, thinMaterial, edgeCount);
    chunk.instancedEdgesThin.instanceColor = new THREE.InstancedBufferAttribute(
      new Float32Array(edgeCount * 3), 3
    );

    // Create thick and collision meshes if not in unified mode
    if (!unifiedEdgeSize) {
      // Clone geometry so each chunk has its own arrowState attribute
      const chunkThickGeometry = thickGeometry.clone();
      // Use ShaderMaterial for thick edges to support normal arrow mode
      const thickMaterial = createThickEdgeShaderMaterial();
      chunk.instancedEdgesThick = new THREE.InstancedMesh(chunkThickGeometry, thickMaterial, edgeCount);
      chunk.instancedEdgesThick.instanceColor = new THREE.InstancedBufferAttribute(
        new Float32Array(edgeCount * 3), 3
      );
      // Add arrowState attribute for normal arrow mode (0 = no arrow, 1 = forward, -1 = backward)
      const arrowStateArray = new Float32Array(edgeCount);
      arrowStateArray.fill(0);
      chunkThickGeometry.setAttribute('arrowState',
        new THREE.InstancedBufferAttribute(arrowStateArray, 1)
      );

      // Conditionally initialize edge collision based on lazy load preference
      if (!lazyLoadEdgeCollision) {
        const collisionMaterial = new THREE.MeshBasicMaterial({ visible: false });
        chunk.instancedEdgesCollision = new THREE.InstancedMesh(collisionGeometry, collisionMaterial, edgeCount);
        chunk.instancedEdgesCollision.visible = true;
        chunk.instancedEdgesCollision.material.opacity = 0;
        chunk.instancedEdgesCollision.material.transparent = true;
      } else {
        // Mark edge collision as not loaded
        chunk.instancedEdgesCollision = null;
        if (chunkKey === '0,0,0') {
          console.log('[Lazy Load] Skipping edge collision initialization');
        }
      }
    }

    // Conditionally create block cubes mesh based on lazy load preference
    if (!lazyLoadBlockCubes) {
      chunk.instancedBlockCubes = new THREE.InstancedMesh(blockCubeGeometry, blockCubeMaterial.clone(), edgeCount);
      chunk.instancedBlockCubes.instanceColor = new THREE.InstancedBufferAttribute(
        new Float32Array(edgeCount * 3), 3
      );
      // Initialize all block cubes as hidden (zero scale)
      const zeroMatrix = new THREE.Matrix4().makeScale(0, 0, 0);
      for (let i = 0; i < edgeCount; i++) {
        chunk.instancedBlockCubes.setMatrixAt(i, zeroMatrix);
      }
    } else {
      // Mark block cubes as not loaded
      chunk.instancedBlockCubes = null;
      if (chunkKey === '0,0,0') {
        console.log('[Lazy Load] Skipping block cubes initialization');
      }
    }

    // Create line geometry arrays (will be populated in second pass)
    chunk.linePositions = new Float32Array(edgeCount * 6);
    chunk.lineColors = new Float32Array(edgeCount * 6);

    grid.chunks.set(chunkKey, chunk);
  }

  // === SECOND PASS: Populate edges into chunks ===
  const matrix = new THREE.Matrix4();
  const quaternion = new THREE.Quaternion();
  const up = new THREE.Vector3(0, 1, 0);
  const zeroMatrix = new THREE.Matrix4().makeScale(0, 0, 0);

  // Apply dimming based on current background color
  const backgroundHex = scene.background.getHex();
  const opacity = backgroundHex === 0x000000 ? 0.3 : 1.0;
  const grayValue = Math.floor(0x88 * opacity);
  const simulatedColor = (grayValue << 16) | (grayValue << 8) | grayValue;
  const grayColor = new THREE.Color(simulatedColor);

  // Track current index per chunk
  const chunkEdgeIndices = new Map(); // chunkKey → current index
  for (const chunkKey of grid.chunks.keys()) {
    chunkEdgeIndices.set(chunkKey, 0);
  }

  for (const [eKey, edge] of grid.edges.entries()) {
    const [a, b] = unpackEdge(eKey, grid);

    const chunkKey = grid.edgeToChunk.get(eKey);
    const chunk = grid.chunks.get(chunkKey);
    const edgeIndex = chunkEdgeIndices.get(chunkKey);

    const start = new THREE.Vector3(...a);
    const end = new THREE.Vector3(...b);
    const direction = new THREE.Vector3().subVectors(end, start);
    const length = direction.length();
    const midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);

    // Build transform matrix
    matrix.makeScale(1, length, 1);
    quaternion.setFromUnitVectors(up, direction.normalize());
    const rotationMatrix = new THREE.Matrix4().makeRotationFromQuaternion(quaternion);
    matrix.premultiply(rotationMatrix);
    matrix.setPosition(midpoint);

    // Set thin mesh
    chunk.instancedEdgesThin.setMatrixAt(edgeIndex, matrix);
    chunk.instancedEdgesThin.setColorAt(edgeIndex, grayColor);

    // Set thick and collision if not unified mode
    if (!unifiedEdgeSize) {
      chunk.instancedEdgesThick.setMatrixAt(edgeIndex, zeroMatrix);
      chunk.instancedEdgesThick.setColorAt(edgeIndex, grayColor);
      // Only set collision matrix if collision mesh exists (not lazy loaded)
      if (chunk.instancedEdgesCollision) {
        chunk.instancedEdgesCollision.setMatrixAt(edgeIndex, matrix);
      }
    }

    // Set line geometry
    chunk.linePositions[edgeIndex * 6 + 0] = a[0];
    chunk.linePositions[edgeIndex * 6 + 1] = a[1];
    chunk.linePositions[edgeIndex * 6 + 2] = a[2];
    chunk.linePositions[edgeIndex * 6 + 3] = b[0];
    chunk.linePositions[edgeIndex * 6 + 4] = b[1];
    chunk.linePositions[edgeIndex * 6 + 5] = b[2];

    chunk.lineColors[edgeIndex * 6 + 0] = grayColor.r;
    chunk.lineColors[edgeIndex * 6 + 1] = grayColor.g;
    chunk.lineColors[edgeIndex * 6 + 2] = grayColor.b;
    chunk.lineColors[edgeIndex * 6 + 3] = grayColor.r;
    chunk.lineColors[edgeIndex * 6 + 4] = grayColor.g;
    chunk.lineColors[edgeIndex * 6 + 5] = grayColor.b;

    // Store mapping
    chunk.edgeToInstanceMap.set(eKey, {
      thin: edgeIndex,
      thick: edgeIndex,
      collision: edgeIndex
    });
    chunk.edgeToLineIndex.set(eKey, edgeIndex);

    chunkEdgeIndices.set(chunkKey, edgeIndex + 1);
  }

  // === FINALIZE CHUNKS: Create line meshes and add to grid group ===
  for (const [chunkKey, chunk] of grid.chunks.entries()) {
    // Update instanced mesh buffers
    chunk.instancedEdgesThin.instanceMatrix.needsUpdate = true;
    chunk.instancedEdgesThin.instanceColor.needsUpdate = true;
    grid.group.add(chunk.instancedEdgesThin);

    if (!unifiedEdgeSize) {
      chunk.instancedEdgesThick.instanceMatrix.needsUpdate = true;
      chunk.instancedEdgesThick.instanceColor.needsUpdate = true;
      grid.group.add(chunk.instancedEdgesThick);

      // Only add collision mesh if it exists (not lazy loaded)
      if (chunk.instancedEdgesCollision) {
        chunk.instancedEdgesCollision.instanceMatrix.needsUpdate = true;
        grid.group.add(chunk.instancedEdgesCollision);
      }
    }

    // Add block cubes mesh to grid group (if exists)
    if (chunk.instancedBlockCubes) {
      chunk.instancedBlockCubes.instanceMatrix.needsUpdate = true;
      chunk.instancedBlockCubes.instanceColor.needsUpdate = true;
      grid.group.add(chunk.instancedBlockCubes);
    }

    // Create line geometry for this chunk
    const lineGeometry = new THREE.BufferGeometry();
    lineGeometry.setAttribute('position', new THREE.BufferAttribute(chunk.linePositions, 3));
    lineGeometry.setAttribute('color', new THREE.BufferAttribute(chunk.lineColors, 3));

    const lineMaterial = new THREE.LineBasicMaterial({
      vertexColors: true,
      linewidth: 1
    });

    chunk.lineEdges = new THREE.LineSegments(lineGeometry, lineMaterial);
    chunk.lineEdges.visible = false; // Hidden until LOD level 3
    grid.group.add(chunk.lineEdges);

    // Clean up temporary arrays
    delete chunk.linePositions;
    delete chunk.lineColors;
  }

  // === BACKWARDS COMPATIBILITY: Keep global references for single-chunk grids ===
  // This helps minimize changes to other functions initially
  if (grid.chunks.size === 1) {
    const singleChunk = grid.chunks.values().next().value;
    grid.instancedEdgesThin = singleChunk.instancedEdgesThin;
    grid.instancedEdgesThick = singleChunk.instancedEdgesThick;
    grid.instancedEdgesCollision = singleChunk.instancedEdgesCollision;
    grid.instancedBlockCubes = singleChunk.instancedBlockCubes;
    grid.lineEdges = singleChunk.lineEdges;
    grid.edgeToInstanceMap = singleChunk.edgeToInstanceMap;
    grid.edgeToLineIndex = singleChunk.edgeToLineIndex;
  } else {
    // For multi-chunk grids, set these to null to force chunk-aware code
    grid.instancedEdgesThin = null;
    grid.instancedEdgesThick = null;
    grid.instancedEdgesCollision = null;
    grid.instancedBlockCubes = null;
    grid.lineEdges = null;
    grid.edgeToInstanceMap = null;
    grid.edgeToLineIndex = null;
  }

}


function colorEdgeInstanced(grid, a, b, color, width) {
  const eKey = edgeKey(a, b, grid);

  // Find the chunk this edge belongs to
  const chunkKey = grid.edgeToChunk ? grid.edgeToChunk.get(eKey) : null;
  let chunk, mapping;

  if (chunkKey && grid.chunks) {
    chunk = grid.chunks.get(chunkKey);
    mapping = chunk ? chunk.edgeToInstanceMap.get(eKey) : null;
  } else {
    // Fallback for single-chunk grids (backwards compatibility)
    chunk = null;
    mapping = grid.edgeToInstanceMap ? grid.edgeToInstanceMap.get(eKey) : null;
  }

  if (!mapping) return;

  const edge = grid.edges.get(eKey);
  if (!edge) return;

  // Apply dimming for uncolored edges
  let threeColor;
  if (color === UNCOLORED_COLOR) {
    // Read actual slider value
    const opacity = parseFloat(document.getElementById("gridOpacitySlider").value);
    const grayValue = Math.floor(0x88 * opacity);
    const simulatedColor = (grayValue << 16) | (grayValue << 8) | grayValue;
    threeColor = new THREE.Color(simulatedColor);
  } else {
    threeColor = new THREE.Color(color);
  }

  const isThick = (width >= 0.04);

  // Update edge data
  edge.color = color;

  // Get the correct instanced meshes (from chunk or global fallback)
  const instancedEdgesThin = chunk ? chunk.instancedEdgesThin : grid.instancedEdgesThin;
  const instancedEdgesThick = chunk ? chunk.instancedEdgesThick : grid.instancedEdgesThick;
  const instancedEdgesCollision = chunk ? chunk.instancedEdgesCollision : grid.instancedEdgesCollision;
  const lineEdges = chunk ? chunk.lineEdges : grid.lineEdges;
  const edgeToLineIndex = chunk ? chunk.edgeToLineIndex : grid.edgeToLineIndex;

  // Sync color to line geometry for LOD level 3
  if (lineEdges && edgeToLineIndex) {
    const lineIndex = edgeToLineIndex.get(eKey);
    if (lineIndex !== undefined) {
      const colorArray = lineEdges.geometry.attributes.color.array;
      // Set color for both vertices of the line segment
      colorArray[lineIndex * 6 + 0] = threeColor.r;
      colorArray[lineIndex * 6 + 1] = threeColor.g;
      colorArray[lineIndex * 6 + 2] = threeColor.b;
      colorArray[lineIndex * 6 + 3] = threeColor.r;
      colorArray[lineIndex * 6 + 4] = threeColor.g;
      colorArray[lineIndex * 6 + 5] = threeColor.b;

      if (!grid.batchMode) {
        lineEdges.geometry.attributes.color.needsUpdate = true;
      }
    }
  }

  // IMPORTANT: Always use canonical order (from eKey) for geometry orientation
  // This ensures edge orientation is consistent regardless of how a,b were passed in
  // The arrow shader assumes edges are oriented from canonical v1 to v2
  const [v1, v2] = unpackEdge(eKey, grid);

  const start = new THREE.Vector3(...v1);
  const end = new THREE.Vector3(...v2);
  const direction = new THREE.Vector3().subVectors(end, start);
  const length = direction.length();
  const midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);

  const matrix = new THREE.Matrix4();
  const quaternion = new THREE.Quaternion();
  const up = new THREE.Vector3(0, 1, 0);

  matrix.makeScale(1, length, 1);
  quaternion.setFromUnitVectors(up, direction.normalize());
  const rotationMatrix = new THREE.Matrix4().makeRotationFromQuaternion(quaternion);
  matrix.premultiply(rotationMatrix);
  matrix.setPosition(midpoint);

  const zeroMatrix = new THREE.Matrix4().makeScale(0, 0, 0);

  // SLEDGEHAMMER: In unified mode, always use thin mesh only
  if (unifiedEdgeSize) {
    instancedEdgesThin.setMatrixAt(mapping.thin, matrix);
    instancedEdgesThin.setColorAt(mapping.thin, threeColor);

    if (!grid.batchMode) {
      instancedEdgesThin.instanceMatrix.needsUpdate = true;
      instancedEdgesThin.instanceColor.needsUpdate = true;
    }
    return;
  }

  if (isThick) {
    // Show thick, hide thin
    instancedEdgesThick.setMatrixAt(mapping.thick, matrix);
    instancedEdgesThick.setColorAt(mapping.thick, threeColor);
    instancedEdgesThin.setMatrixAt(mapping.thin, zeroMatrix);
  } else {
    // Show thin, hide thick
    instancedEdgesThin.setMatrixAt(mapping.thin, matrix);
    instancedEdgesThin.setColorAt(mapping.thin, threeColor);
    instancedEdgesThick.setMatrixAt(mapping.thick, zeroMatrix);
  }

  // CRITICAL: Update collision mesh to match active visual mesh
  if (instancedEdgesCollision) {
    instancedEdgesCollision.setMatrixAt(mapping.collision, matrix);
  }

  // Batch mode optimization: don't sync GPU for each edge, sync once at end
  if (!grid.batchMode) {
    instancedEdgesThin.instanceMatrix.needsUpdate = true;
    instancedEdgesThin.instanceColor.needsUpdate = true;
    if (instancedEdgesThick) {
      instancedEdgesThick.instanceMatrix.needsUpdate = true;
      instancedEdgesThick.instanceColor.needsUpdate = true;
    }
    if (instancedEdgesCollision) {
      instancedEdgesCollision.instanceMatrix.needsUpdate = true;
    }
  }
}



function addBlockCubeInstanced(grid, edge, eKey, color = null) {
  // Find the chunk this edge belongs to
  const chunkKey = grid.edgeToChunk ? grid.edgeToChunk.get(eKey) : null;
  let mapping, instancedBlockCubes;

  if (chunkKey && grid.chunks) {
    const chunk = grid.chunks.get(chunkKey);
    if (!chunk) return;
    mapping = chunk.edgeToInstanceMap.get(eKey);
    instancedBlockCubes = chunk.instancedBlockCubes;
  } else {
    // Fallback for single-chunk grids (backwards compatibility)
    mapping = grid.edgeToInstanceMap ? grid.edgeToInstanceMap.get(eKey) : null;
    instancedBlockCubes = grid.instancedBlockCubes;
  }

  if (!mapping || !instancedBlockCubes) return;

  const [a, b] = unpackEdge(eKey, grid);

  const start = new THREE.Vector3(...a);
  const end = new THREE.Vector3(...b);
  const midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);

  const cubeMatrix = new THREE.Matrix4();
  cubeMatrix.setPosition(midpoint);

  instancedBlockCubes.setMatrixAt(mapping.thin, cubeMatrix);

  // Use provided color or default to secondary color
  const cubeColorHex = color !== null ? color : selectedColor2;
  const cubeColor = new THREE.Color(cubeColorHex);
  instancedBlockCubes.setColorAt(mapping.thin, cubeColor);

  instancedBlockCubes.instanceMatrix.needsUpdate = true;
  instancedBlockCubes.instanceColor.needsUpdate = true;

  edge.blockCube = true; // Mark as having a cube
  edge.blockCubeColor = cubeColorHex; // Store the color on the edge
}

function removeBlockCubeInstanced(grid, edge, eKey) {
  // Find the chunk this edge belongs to
  const chunkKey = grid.edgeToChunk ? grid.edgeToChunk.get(eKey) : null;
  let mapping, instancedBlockCubes;

  if (chunkKey && grid.chunks) {
    const chunk = grid.chunks.get(chunkKey);
    if (!chunk) return;
    mapping = chunk.edgeToInstanceMap.get(eKey);
    instancedBlockCubes = chunk.instancedBlockCubes;
  } else {
    // Fallback for single-chunk grids (backwards compatibility)
    mapping = grid.edgeToInstanceMap ? grid.edgeToInstanceMap.get(eKey) : null;
    instancedBlockCubes = grid.instancedBlockCubes;
  }

  if (!mapping || !instancedBlockCubes) return;

  const cubeZeroMatrix = new THREE.Matrix4().makeScale(0, 0, 0);
  instancedBlockCubes.setMatrixAt(mapping.thin, cubeZeroMatrix);
  instancedBlockCubes.instanceMatrix.needsUpdate = true;

  edge.blockCube = false; // Mark as not having a cube
}

function rebuildBlockCubesWithNewSize(grid, newSize) {
  console.log(`[rebuildBlockCubes] Starting rebuild for grid with size ${newSize}, isInstanced: ${grid.isInstanced}`);

  if (!grid.isInstanced) {
    // Individual mesh mode - rebuild each block cube
    for (const [eKey, edge] of grid.edges.entries()) {
      if (edge.blockCube && typeof edge.blockCube === 'object') {
        // Remove old cube
        grid.group.remove(edge.blockCube);
        if (edge.blockCube.geometry) edge.blockCube.geometry.dispose();
        if (edge.blockCube.material) edge.blockCube.material.dispose();

        // Create new cube with new size
        const geometry = new THREE.BoxGeometry(newSize, newSize, newSize);
        const material = new THREE.MeshBasicMaterial({ color: selectedColor2 });
        const cube = new THREE.Mesh(geometry, material);
        cube.position.copy(edge.mesh.position);
        cube.raycast = () => {};
        edge.blockCube = cube;
        grid.group.add(cube);
      }
    }
  } else {
    // Instanced mode - need to recreate the entire instanced mesh with new geometry
    const recreateInstancedCubes = (chunk) => {
      if (!chunk.instancedBlockCubes) {
        console.log('[rebuildBlockCubes] Block cubes not loaded for chunk (lazy loading)');
        return;
      }

      // Store which instances had cubes
      const activeCubes = [];
      for (const [eKey, edge] of grid.edges.entries()) {
        if (edge.blockCube) {
          activeCubes.push(eKey);
        }
      }
      console.log(`[rebuildBlockCubes] Found ${activeCubes.length} active cubes to restore`);

      // Remove old instanced mesh
      grid.group.remove(chunk.instancedBlockCubes);
      if (chunk.instancedBlockCubes.geometry) chunk.instancedBlockCubes.geometry.dispose();
      if (chunk.instancedBlockCubes.material) chunk.instancedBlockCubes.material.dispose();

      // Create new geometry with new size
      const newGeometry = new THREE.BoxGeometry(newSize, newSize, newSize);
      const newMaterial = new THREE.MeshBasicMaterial({ vertexColors: false });
      const instanceCount = chunk.edgeToInstanceMap.size;
      const newInstancedCubes = new THREE.InstancedMesh(newGeometry, newMaterial, instanceCount);

      // Manually create instanceColor attribute (THREE.js doesn't create it automatically)
      newInstancedCubes.instanceColor = new THREE.InstancedBufferAttribute(
        new Float32Array(instanceCount * 3), 3
      );

      // Attach the color attribute to the geometry
      newInstancedCubes.geometry.setAttribute('instanceColor', newInstancedCubes.instanceColor);

      // Initialize all to zero scale
      const zeroMatrix = new THREE.Matrix4().makeScale(0, 0, 0);
      for (let i = 0; i < instanceCount; i++) {
        newInstancedCubes.setMatrixAt(i, zeroMatrix);
      }

      // Restore active cubes
      const cubeColor = new THREE.Color(selectedColor2);
      console.log(`[rebuildBlockCubes] Cube color (selectedColor2): ${selectedColor2.toString(16)}, RGB: ${cubeColor.r}, ${cubeColor.g}, ${cubeColor.b}`);
      for (const eKey of activeCubes) {
        const edge = grid.edges.get(eKey);
        if (!edge) continue;

        const mapping = chunk.edgeToInstanceMap.get(eKey);
        if (!mapping) continue;

        const [a, b] = unpackEdge(eKey, grid);
        const start = new THREE.Vector3(...a);
        const end = new THREE.Vector3(...b);
        const midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);

        const cubeMatrix = new THREE.Matrix4();
        cubeMatrix.setPosition(midpoint);
        newInstancedCubes.setMatrixAt(mapping.thin, cubeMatrix);
        newInstancedCubes.setColorAt(mapping.thin, cubeColor);
      }

      newInstancedCubes.instanceMatrix.needsUpdate = true;
      newInstancedCubes.instanceColor.needsUpdate = true;

      // Also mark the geometry attribute as needing update
      newInstancedCubes.geometry.attributes.instanceColor.needsUpdate = true;

      chunk.instancedBlockCubes = newInstancedCubes;
      grid.group.add(newInstancedCubes);
    };

    // Process all chunks or single-chunk grid
    if (grid.chunks && grid.chunks.size > 0) {
      for (const chunk of grid.chunks.values()) {
        recreateInstancedCubes(chunk);
      }
    } else {
      // Single-chunk grid (backwards compatibility)
      recreateInstancedCubes(grid);
    }
  }
}

function initializeInstancedBoxes(grid) {
  const totalXY = grid.boxesXY.size;
  const totalXZ = grid.boxesXZ.size;
  const totalYZ = grid.boxesYZ.size;
  

  // Geometries & materials (double-sided, transparent)
  const geoXY = new THREE.PlaneGeometry(1, 1);
  const matXY = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, side: THREE.DoubleSide });

  const geoXZ = new THREE.PlaneGeometry(1, 1);
  geoXZ.rotateX(Math.PI / 2);
  const matXZ = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, side: THREE.DoubleSide });

  const geoYZ = new THREE.PlaneGeometry(1, 1);
  geoYZ.rotateY(Math.PI / 2);
  const matYZ = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, side: THREE.DoubleSide });

  grid.instancedBoxesXY = new THREE.InstancedMesh(geoXY, matXY, totalXY);
  grid.instancedBoxesXZ = new THREE.InstancedMesh(geoXZ, matXZ, totalXZ);
  grid.instancedBoxesYZ = new THREE.InstancedMesh(geoYZ, matYZ, totalYZ);

  // Canonical per-type arrays (index == instanceId) and reverse map
  grid.instancesXY = new Array(totalXY);
  grid.instancesXZ = new Array(totalXZ);
  grid.instancesYZ = new Array(totalYZ);

  grid.instanceIdFromBoxKey = new Map(); // boxKey -> {type, index}

  const M = new THREE.Matrix4();

  // —— XY ——
  let i = 0;
  for (const [boxKey, box] of grid.boxesXY) {
    const [x, y, z] = box.coords;
    M.makeTranslation(x + 0.5, y + 0.5, z);
    grid.instancedBoxesXY.setMatrixAt(i, M);

    grid.instancesXY[i] = box;               // index ↔ box
    grid.instanceIdFromBoxKey.set(boxKey, { type: 'XY', index: i });

    box.instanceType = 'XY';
    box.instanceId   = i;
    i++;
  }
  grid.instancedBoxesXY.instanceMatrix.needsUpdate = true;

  // —— XZ ——
  i = 0;
  for (const [boxKey, box] of grid.boxesXZ) {
    const [x, y, z] = box.coords;
    M.makeTranslation(x + 0.5, y, z + 0.5);
    grid.instancedBoxesXZ.setMatrixAt(i, M);

    grid.instancesXZ[i] = box;
    grid.instanceIdFromBoxKey.set(boxKey, { type: 'XZ', index: i });

    box.instanceType = 'XZ';
    box.instanceId   = i;
    i++;
  }
  grid.instancedBoxesXZ.instanceMatrix.needsUpdate = true;

  // —— YZ ——
  i = 0;
  for (const [boxKey, box] of grid.boxesYZ) {
    const [x, y, z] = box.coords;
    M.makeTranslation(x, y + 0.5, z + 0.5);
    grid.instancedBoxesYZ.setMatrixAt(i, M);

    grid.instancesYZ[i] = box;
    grid.instanceIdFromBoxKey.set(boxKey, { type: 'YZ', index: i });

    box.instanceType = 'YZ';
    box.instanceId   = i;
    i++;
  }
  grid.instancedBoxesYZ.instanceMatrix.needsUpdate = true;

  grid.group.add(grid.instancedBoxesXY, grid.instancedBoxesXZ, grid.instancedBoxesYZ);

}

// Load switchable boxes for lazy loading
function loadSwitchableBoxes(grid) {
  if (!grid || !grid.isInstanced) {
    console.warn('[loadSwitchableBoxes] Grid is not instanced');
    return;
  }

  // Check if already loaded
  if (grid.instancedBoxesXY && grid.instancedBoxesXZ && grid.instancedBoxesYZ) {
    console.log('[loadSwitchableBoxes] Switchable boxes already loaded');
    return;
  }

  console.log('[loadSwitchableBoxes] Loading switchable boxes...');
  const startTime = performance.now();

  // Call the initialization function
  initializeInstancedBoxes(grid);

  const loadTime = performance.now() - startTime;
  console.log(`[loadSwitchableBoxes] Loaded switchable boxes in ${loadTime.toFixed(1)}ms`);

  // Update memory monitor
  updateMemoryBreakdown();
}

// Unload switchable boxes for lazy loading
function unloadSwitchableBoxes(grid) {
  if (!grid || !grid.isInstanced) {
    console.warn('[unloadSwitchableBoxes] Grid is not instanced');
    return;
  }

  // Check if boxes are loaded
  if (!grid.instancedBoxesXY && !grid.instancedBoxesXZ && !grid.instancedBoxesYZ) {
    console.log('[unloadSwitchableBoxes] Switchable boxes already unloaded');
    return;
  }

  console.log('[unloadSwitchableBoxes] Unloading switchable boxes...');
  const startTime = performance.now();

  // Dispose XY boxes
  if (grid.instancedBoxesXY) {
    grid.group.remove(grid.instancedBoxesXY);
    grid.instancedBoxesXY.geometry.dispose();
    grid.instancedBoxesXY.material.dispose();
    grid.instancedBoxesXY = null;
  }

  // Dispose XZ boxes
  if (grid.instancedBoxesXZ) {
    grid.group.remove(grid.instancedBoxesXZ);
    grid.instancedBoxesXZ.geometry.dispose();
    grid.instancedBoxesXZ.material.dispose();
    grid.instancedBoxesXZ = null;
  }

  // Dispose YZ boxes
  if (grid.instancedBoxesYZ) {
    grid.group.remove(grid.instancedBoxesYZ);
    grid.instancedBoxesYZ.geometry.dispose();
    grid.instancedBoxesYZ.material.dispose();
    grid.instancedBoxesYZ = null;
  }

  // Clear tracking maps
  if (grid.instanceIdFromBoxKey) {
    grid.instanceIdFromBoxKey.clear();
  }
  if (grid.instancesXY) grid.instancesXY = null;
  if (grid.instancesXZ) grid.instancesXZ = null;
  if (grid.instancesYZ) grid.instancesYZ = null;

  const unloadTime = performance.now() - startTime;
  console.log(`[unloadSwitchableBoxes] Unloaded switchable boxes in ${unloadTime.toFixed(1)}ms`);

  // Update memory monitor
  updateMemoryBreakdown();
}


function initializeInstancedArrows(grid) {
  const totalEdges = grid.edges.size;
  
  // Safety check: ensure we have edges
  if (totalEdges === 0) {
    console.warn('[initializeInstancedArrows] Grid has 0 edges, skipping instanced arrow initialization');
    grid.instancedArrowsForward = null;
    grid.instancedArrowsBackward = null;
    grid.edgeToArrowInstanceMap = new Map();
    grid.arrowInstanceSlots = {
      forward: { nextAvailable: 0, freeSlots: [] },
      backward: { nextAvailable: 0, freeSlots: [] }
    };
    return;
  }
  
  
  // Create arrow texture for forward direction
  const textureForward = createArrowTexture(1);
  textureForward.wrapS = THREE.ClampToEdgeWrapping;
  textureForward.wrapT = THREE.RepeatWrapping;
  textureForward.center.set(0.5, 0.5);
  textureForward.rotation = Math.PI / 2;
  textureForward.repeat.set(1, 3);
  
  // Create arrow texture for backward direction
  const textureBackward = createArrowTexture(-1);
  textureBackward.wrapS = THREE.ClampToEdgeWrapping;
  textureBackward.wrapT = THREE.RepeatWrapping;
  textureBackward.center.set(0.5, 0.5);
  textureBackward.rotation = Math.PI / 2;
  textureBackward.repeat.set(1, 3);
  
  // Forward arrows instanced mesh
  const forwardGeometry = new THREE.CylinderGeometry(0.051, 0.051, 1, 6, 1, true);
  const forwardMaterial = new THREE.MeshBasicMaterial({
    map: textureForward,
    transparent: true,
    depthTest: false
  });
  grid.instancedArrowsForward = new THREE.InstancedMesh(forwardGeometry, forwardMaterial, totalEdges);
  
  // Backward arrows instanced mesh
  const backwardGeometry = new THREE.CylinderGeometry(0.051, 0.051, 1, 6, 1, true);
  const backwardMaterial = new THREE.MeshBasicMaterial({
    map: textureBackward,
    transparent: true,
    depthTest: false
  });
  grid.instancedArrowsBackward = new THREE.InstancedMesh(backwardGeometry, backwardMaterial, totalEdges);
  
  // Initialize tracking
  grid.edgeToArrowInstanceMap = new Map(); // edgeKey -> {direction: 1/-1, index: number}
  grid.arrowInstanceSlots = {
    forward: { nextAvailable: 0, freeSlots: [] },
    backward: { nextAvailable: 0, freeSlots: [] }
  };
  
  // Start with count = 0 (no arrows visible initially)
  // Arrows will be added dynamically and count will grow as needed
  grid.instancedArrowsForward.count = 0;
  grid.instancedArrowsBackward.count = 0;
  
  // Disable raycasting for arrows
  grid.instancedArrowsForward.raycast = () => {};
  grid.instancedArrowsBackward.raycast = () => {};
  
  grid.group.add(grid.instancedArrowsForward);
  grid.group.add(grid.instancedArrowsBackward);

}

// Load arrows for lazy loading
function loadArrows(grid) {
  if (!grid || !grid.isInstanced) {
    console.warn('[loadArrows] Grid is not instanced');
    return;
  }

  // Check if already loaded
  if (grid.instancedArrowsForward && grid.instancedArrowsBackward) {
    console.log('[loadArrows] Arrows already loaded');
    return;
  }

  console.log('[loadArrows] Loading arrows...');
  const startTime = performance.now();

  // Call the initialization function
  initializeInstancedArrows(grid);

  const loadTime = performance.now() - startTime;
  console.log(`[loadArrows] Loaded arrows in ${loadTime.toFixed(1)}ms`);

  // Update memory monitor
  updateMemoryBreakdown();
}

// Unload arrows for lazy loading
function unloadArrows(grid) {
  if (!grid || !grid.isInstanced) {
    console.warn('[unloadArrows] Grid is not instanced');
    return;
  }

  // Check if arrows are loaded
  if (!grid.instancedArrowsForward && !grid.instancedArrowsBackward) {
    console.log('[unloadArrows] Arrows already unloaded');
    return;
  }

  console.log('[unloadArrows] Unloading arrows...');
  const startTime = performance.now();

  // Dispose forward arrows
  if (grid.instancedArrowsForward) {
    grid.group.remove(grid.instancedArrowsForward);
    grid.instancedArrowsForward.geometry.dispose();
    grid.instancedArrowsForward.material.dispose();
    grid.instancedArrowsForward = null;
  }

  // Dispose backward arrows
  if (grid.instancedArrowsBackward) {
    grid.group.remove(grid.instancedArrowsBackward);
    grid.instancedArrowsBackward.geometry.dispose();
    grid.instancedArrowsBackward.material.dispose();
    grid.instancedArrowsBackward = null;
  }

  // Clear tracking maps
  if (grid.edgeToArrowInstanceMap) {
    grid.edgeToArrowInstanceMap.clear();
  }
  grid.arrowInstanceSlots = null;

  const unloadTime = performance.now() - startTime;
  console.log(`[unloadArrows] Unloaded arrows in ${unloadTime.toFixed(1)}ms`);

  // Update memory monitor
  updateMemoryBreakdown();
}



function initializeInstancedVertexSpheres(grid) {
  const totalVertices = grid.vertices.size;

  if (totalVertices === 0) {
    console.warn('[initializeInstancedVertexSpheres] Grid has 0 vertices');
    grid.instancedVertexSpheres = null;
    grid.instancedVertexCollisionHelpers = null;
    grid.vertexToInstanceMap = new Map();
    return;
  }


  // Use existing chunk size from edge initialization
  grid.vertexToChunk = new Map();

  // === FIRST PASS: Count vertices per chunk ===
  const chunkVertexCounts = new Map(); // chunkKey → count

  for (const vKey of grid.vertices.keys()) {
    const { cx, cy, cz } = getChunkForVertex(vKey, grid);
    const chunkKey = getChunkKey(cx, cy, cz);

    grid.vertexToChunk.set(vKey, chunkKey);
    chunkVertexCounts.set(chunkKey, (chunkVertexCounts.get(chunkKey) || 0) + 1);
  }

  // === CREATE VERTEX MESHES FOR EACH CHUNK ===
  // Use grid-specific vertex detail (may be lower for very large grids)
  const gridVertexDetail = grid.lodState?.vertexDetail ?? vertexSubdivisions;
  const sphereGeometry = new THREE.IcosahedronGeometry(vertexRadius, gridVertexDetail);
  const collisionGeometry = new THREE.OctahedronGeometry(0.3);

  for (const [chunkKey, vertexCount] of chunkVertexCounts.entries()) {
    // Get or create chunk (may already exist from edge initialization)
    let chunk = grid.chunks.get(chunkKey);
    if (!chunk) {
      chunk = createChunkData();
      grid.chunks.set(chunkKey, chunk);
    }
    chunk.vertexCount = vertexCount;

    // Create visual spheres for this chunk
    const sphereMaterial = new THREE.MeshBasicMaterial();
    chunk.instancedVertexSpheres = new THREE.InstancedMesh(sphereGeometry, sphereMaterial, vertexCount);

    // Set count explicitly (ChatGPT suggestion)
    chunk.instancedVertexSpheres.count = vertexCount;

    // Initialize instance colors to gray (0x888888 = RGB 0.533, 0.533, 0.533)
    const initialColors = new Float32Array(vertexCount * 3);
    for (let i = 0; i < vertexCount; i++) {
      initialColors[i * 3] = 0.533;     // R
      initialColors[i * 3 + 1] = 0.533; // G
      initialColors[i * 3 + 2] = 0.533; // B
    }
    chunk.instancedVertexSpheres.instanceColor = new THREE.InstancedBufferAttribute(initialColors, 3);

    // Create collision helpers for this chunk
    const collisionMaterial = new THREE.MeshBasicMaterial({ visible: false });
    chunk.instancedVertexCollisionHelpers = new THREE.InstancedMesh(
      collisionGeometry, collisionMaterial, vertexCount
    );
    chunk.instancedVertexCollisionHelpers.visible = true;
    chunk.instancedVertexCollisionHelpers.material.opacity = 0;
    chunk.instancedVertexCollisionHelpers.material.transparent = true;
    chunk.instancedVertexCollisionHelpers.renderOrder = -999999;
    chunk.instancedVertexCollisionHelpers.onBeforeRender = function() { this.visible = false; };
    chunk.instancedVertexCollisionHelpers.onAfterRender = function() { this.visible = true; };

    // Create point geometry arrays (will be populated in second pass)
    chunk.pointPositions = new Float32Array(vertexCount * 3);
    chunk.pointColors = new Float32Array(vertexCount * 3);
  }

  // === SECOND PASS: Populate vertices into chunks ===
  const zeroMatrix = new THREE.Matrix4().makeScale(0, 0, 0);
  const offscreenMatrix = new THREE.Matrix4().setPosition(0, -9999, 0); // ChatGPT suggestion: offscreen position
  const collisionMatrix = new THREE.Matrix4();

  // Track current index per chunk
  const chunkVertexIndices = new Map();
  for (const chunkKey of chunkVertexCounts.keys()) {
    chunkVertexIndices.set(chunkKey, 0);
  }

  // Initialize ALL instance matrices to offscreen (ChatGPT suggestion: catch stale instances)
  for (const [chunkKey, chunk] of grid.chunks.entries()) {
    if (!chunk.instancedVertexSpheres) continue;
    const count = chunk.instancedVertexSpheres.count;
    for (let i = 0; i < count; i++) {
      chunk.instancedVertexSpheres.setMatrixAt(i, offscreenMatrix);
    }
  }

  for (const [vKey, vertexData] of grid.vertices.entries()) {
    const chunkKey = grid.vertexToChunk.get(vKey);
    const chunk = grid.chunks.get(chunkKey);
    const vertexIndex = chunkVertexIndices.get(chunkKey);

    const [x, y, z] = unpackVertex(vKey, grid);

    // Hide visual sphere initially
    chunk.instancedVertexSpheres.setMatrixAt(vertexIndex, zeroMatrix);

    // Show collision helper at vertex position
    collisionMatrix.setPosition(x, y, z);
    chunk.instancedVertexCollisionHelpers.setMatrixAt(vertexIndex, collisionMatrix);

    // Set point geometry
    chunk.pointPositions[vertexIndex * 3 + 0] = x;
    chunk.pointPositions[vertexIndex * 3 + 1] = y;
    chunk.pointPositions[vertexIndex * 3 + 2] = z;
    chunk.pointColors[vertexIndex * 3 + 0] = 0.533;
    chunk.pointColors[vertexIndex * 3 + 1] = 0.533;
    chunk.pointColors[vertexIndex * 3 + 2] = 0.533;

    // Store mapping
    chunk.vertexToInstanceMap.set(vKey, vertexIndex);

    chunkVertexIndices.set(chunkKey, vertexIndex + 1);
  }

  // === FINALIZE CHUNKS: Create point meshes and add to grid group ===
  for (const [chunkKey, chunk] of grid.chunks.entries()) {
    if (!chunk.instancedVertexSpheres) continue; // Skip chunks with no vertices

    // Update instanced mesh buffers
    chunk.instancedVertexSpheres.instanceMatrix.needsUpdate = true;
    chunk.instancedVertexCollisionHelpers.instanceMatrix.needsUpdate = true;

    // Set initial visibility
    chunk.instancedVertexSpheres.visible = grid.showAllVertices;

    grid.group.add(chunk.instancedVertexSpheres);
    grid.group.add(chunk.instancedVertexCollisionHelpers);

    // Create point geometry for this chunk
    if (chunk.pointPositions) {
      const pointGeometry = new THREE.BufferGeometry();
      pointGeometry.setAttribute('position', new THREE.BufferAttribute(chunk.pointPositions, 3));
      pointGeometry.setAttribute('color', new THREE.BufferAttribute(chunk.pointColors, 3));

      const pointMaterial = new THREE.PointsMaterial({
        size: 5,
        vertexColors: true,
        sizeAttenuation: true
      });

      chunk.pointVertices = new THREE.Points(pointGeometry, pointMaterial);
      chunk.pointVertices.visible = false;
      grid.group.add(chunk.pointVertices);

      // Clean up temporary arrays
      delete chunk.pointPositions;
      delete chunk.pointColors;
    }
  }

  // === BACKWARDS COMPATIBILITY: Keep global references for single-chunk grids ===
  if (grid.chunks.size === 1) {
    const singleChunk = grid.chunks.values().next().value;
    grid.instancedVertexSpheres = singleChunk.instancedVertexSpheres;
    grid.instancedVertexCollisionHelpers = singleChunk.instancedVertexCollisionHelpers;
    grid.pointVertices = singleChunk.pointVertices;
    grid.vertexToInstanceMap = singleChunk.vertexToInstanceMap;
  } else {
    grid.instancedVertexSpheres = null;
    grid.instancedVertexCollisionHelpers = null;
    grid.pointVertices = null;
    grid.vertexToInstanceMap = null;
  }

}

// Load vertex spheres for lazy loading
function loadVertexSpheres(grid) {
  if (!grid || !grid.isInstanced) {
    console.warn('[loadVertexSpheres] Grid is not instanced');
    return;
  }

  // Check if already loaded (check chunks for vertex meshes)
  if (grid.chunks && grid.chunks.size > 0) {
    const firstChunk = grid.chunks.values().next().value;
    if (firstChunk.instancedVertexSpheres && firstChunk.instancedVertexCollisionHelpers) {
      console.log('[loadVertexSpheres] Vertex spheres already loaded');
      return;
    }
  }

  console.log('[loadVertexSpheres] Loading vertex spheres...');
  const startTime = performance.now();

  // Call the initialization function
  initializeInstancedVertexSpheres(grid);

  const loadTime = performance.now() - startTime;
  console.log(`[loadVertexSpheres] Loaded vertex spheres in ${loadTime.toFixed(1)}ms`);

  // Update memory monitor
  updateMemoryBreakdown();
}

// Unload vertex spheres for lazy loading
function unloadVertexSpheres(grid) {
  if (!grid || !grid.isInstanced) {
    console.warn('[unloadVertexSpheres] Grid is not instanced');
    return;
  }

  // Check if vertex spheres are loaded
  if (!grid.chunks || grid.chunks.size === 0) {
    console.log('[unloadVertexSpheres] No chunks found');
    return;
  }

  console.log('[unloadVertexSpheres] Unloading vertex spheres...');
  const startTime = performance.now();

  // Dispose vertex spheres and collision helpers in each chunk
  for (const [chunkKey, chunk] of grid.chunks.entries()) {
    // Dispose vertex spheres
    if (chunk.instancedVertexSpheres) {
      grid.group.remove(chunk.instancedVertexSpheres);
      chunk.instancedVertexSpheres.geometry.dispose();
      chunk.instancedVertexSpheres.material.dispose();
      chunk.instancedVertexSpheres = null;
    }

    // Dispose vertex collision helpers
    if (chunk.instancedVertexCollisionHelpers) {
      grid.group.remove(chunk.instancedVertexCollisionHelpers);
      chunk.instancedVertexCollisionHelpers.geometry.dispose();
      chunk.instancedVertexCollisionHelpers.material.dispose();
      chunk.instancedVertexCollisionHelpers = null;
    }

    // Dispose point vertices
    if (chunk.pointVertices) {
      grid.group.remove(chunk.pointVertices);
      chunk.pointVertices.geometry.dispose();
      chunk.pointVertices.material.dispose();
      chunk.pointVertices = null;
    }

    // Clear vertex to instance map
    if (chunk.vertexToInstanceMap) {
      chunk.vertexToInstanceMap.clear();
    }
  }

  // Clear global references
  grid.instancedVertexSpheres = null;
  grid.instancedVertexCollisionHelpers = null;
  grid.pointVertices = null;
  grid.vertexToInstanceMap = null;

  const unloadTime = performance.now() - startTime;
  console.log(`[unloadVertexSpheres] Unloaded vertex spheres in ${unloadTime.toFixed(1)}ms`);

  // Update memory monitor
  updateMemoryBreakdown();
}

// Load edge collision helpers for lazy loading
function loadEdgeCollision(grid) {
  if (!grid || !grid.isInstanced || !grid.chunks) return;

  // Check if edge collision is already loaded
  let alreadyLoaded = false;
  if (grid.chunks.size > 0) {
    const firstChunk = grid.chunks.values().next().value;
    if (firstChunk.instancedEdgesCollision) {
      alreadyLoaded = true;
    }
  }

  if (alreadyLoaded) {
    console.log('[loadEdgeCollision] Edge collision already loaded');
    return;
  }

  console.log('[loadEdgeCollision] Loading edge collision helpers...');
  const startTime = performance.now();

  // Create collision geometry
  const collisionGeometry = new THREE.CylinderGeometry(edgeCollisionRadius, edgeCollisionRadius, 1, 3);

  // Iterate through all chunks and create edge collision meshes
  for (const [chunkKey, chunk] of grid.chunks) {
    if (!chunk.instancedEdgesThin) continue; // Skip if chunk has no edges

    const edgeCount = chunk.instancedEdgesThin.count;
    const collisionMaterial = new THREE.MeshBasicMaterial({ visible: false });

    chunk.instancedEdgesCollision = new THREE.InstancedMesh(collisionGeometry, collisionMaterial, edgeCount);
    chunk.instancedEdgesCollision.visible = true;
    chunk.instancedEdgesCollision.material.opacity = 0;
    chunk.instancedEdgesCollision.material.transparent = true;

    // Copy matrices from thin edges to collision helpers
    const tempMatrix = new THREE.Matrix4();
    for (let i = 0; i < edgeCount; i++) {
      chunk.instancedEdgesThin.getMatrixAt(i, tempMatrix);
      chunk.instancedEdgesCollision.setMatrixAt(i, tempMatrix);
    }
    chunk.instancedEdgesCollision.instanceMatrix.needsUpdate = true;

    // Add to scene
    grid.group.add(chunk.instancedEdgesCollision);
  }

  const loadTime = performance.now() - startTime;
  console.log(`[loadEdgeCollision] Loaded edge collision in ${loadTime.toFixed(1)}ms`);

  // Update memory monitor
  updateMemoryBreakdown();
}

// Unload edge collision helpers for lazy loading
function unloadEdgeCollision(grid) {
  if (!grid || !grid.isInstanced || !grid.chunks) return;

  // Check if edge collision is loaded
  let hasEdgeCollision = false;
  for (const chunk of grid.chunks.values()) {
    if (chunk.instancedEdgesCollision) {
      hasEdgeCollision = true;
      break;
    }
  }

  if (!hasEdgeCollision) return;

  console.log('[unloadEdgeCollision] Unloading edge collision helpers...');
  const startTime = performance.now();

  // Dispose edge collision in each chunk
  for (const chunk of grid.chunks.values()) {
    if (chunk.instancedEdgesCollision) {
      grid.group.remove(chunk.instancedEdgesCollision);
      chunk.instancedEdgesCollision.geometry.dispose();
      chunk.instancedEdgesCollision.material.dispose();
      chunk.instancedEdgesCollision = null;
    }
  }

  const unloadTime = performance.now() - startTime;
  console.log(`[unloadEdgeCollision] Unloaded edge collision in ${unloadTime.toFixed(1)}ms`);

  // Update memory monitor
  updateMemoryBreakdown();
}

// Load block cubes for lazy loading
function loadBlockCubes(grid) {
  if (!grid || !grid.isInstanced || !grid.chunks) return;

  // Check if block cubes are already loaded
  let alreadyLoaded = false;
  if (grid.chunks.size > 0) {
    const firstChunk = grid.chunks.values().next().value;
    if (firstChunk.instancedBlockCubes) {
      alreadyLoaded = true;
    }
  }

  if (alreadyLoaded) {
    console.log('[loadBlockCubes] Block cubes already loaded');
    return;
  }

  console.log('[loadBlockCubes] Loading block cubes...');
  const startTime = performance.now();

  // Get shared geometry and material
  const blockCubeGeometry = new THREE.BoxGeometry(blockCubeSize, blockCubeSize, blockCubeSize);
  const blockCubeMaterial = new THREE.MeshBasicMaterial({ vertexColors: false });

  // Iterate through all chunks and create block cube meshes
  for (const [chunkKey, chunk] of grid.chunks) {
    if (!chunk.instancedEdgesThin) continue; // Skip if chunk has no edges

    const edgeCount = chunk.instancedEdgesThin.count;

    chunk.instancedBlockCubes = new THREE.InstancedMesh(blockCubeGeometry, blockCubeMaterial.clone(), edgeCount);
    chunk.instancedBlockCubes.instanceColor = new THREE.InstancedBufferAttribute(
      new Float32Array(edgeCount * 3), 3
    );

    // Initialize all instances as hidden (zero scale)
    const zeroMatrix = new THREE.Matrix4().makeScale(0, 0, 0);
    for (let i = 0; i < edgeCount; i++) {
      chunk.instancedBlockCubes.setMatrixAt(i, zeroMatrix);
    }

    // Now restore any existing block cube decorations
    if (chunk.edgeToInstanceMap) {
      for (const [eKey, mapping] of chunk.edgeToInstanceMap.entries()) {
        const edge = grid.edges.get(eKey);
        if (edge && edge.blockCube) {
          // Recreate the cube decoration
          const [a, b] = unpackEdge(eKey);

          const start = new THREE.Vector3(...a);
          const end = new THREE.Vector3(...b);
          const midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);

          const cubeMatrix = new THREE.Matrix4();
          cubeMatrix.setPosition(midpoint);

          chunk.instancedBlockCubes.setMatrixAt(mapping.thin, cubeMatrix);

          // Restore color (use secondary color or edge color)
          const cubeColor = new THREE.Color(edge.color || selectedColor2);
          chunk.instancedBlockCubes.setColorAt(mapping.thin, cubeColor);
        }
      }
    }

    chunk.instancedBlockCubes.instanceMatrix.needsUpdate = true;
    chunk.instancedBlockCubes.instanceColor.needsUpdate = true;

    // Add to scene
    grid.group.add(chunk.instancedBlockCubes);
  }

  const loadTime = performance.now() - startTime;
  console.log(`[loadBlockCubes] Loaded block cubes in ${loadTime.toFixed(1)}ms`);

  // Update memory monitor
  updateMemoryBreakdown();
}

// Unload block cubes for lazy loading
function unloadBlockCubes(grid) {
  if (!grid || !grid.isInstanced || !grid.chunks) return;

  // Check if block cubes are loaded
  let hasBlockCubes = false;
  for (const chunk of grid.chunks.values()) {
    if (chunk.instancedBlockCubes) {
      hasBlockCubes = true;
      break;
    }
  }

  if (!hasBlockCubes) return;

  console.log('[unloadBlockCubes] Unloading block cubes...');
  const startTime = performance.now();

  // Dispose block cubes in each chunk
  for (const chunk of grid.chunks.values()) {
    if (chunk.instancedBlockCubes) {
      grid.group.remove(chunk.instancedBlockCubes);
      chunk.instancedBlockCubes.geometry.dispose();
      chunk.instancedBlockCubes.material.dispose();
      chunk.instancedBlockCubes = null;
    }
  }

  const unloadTime = performance.now() - startTime;
  console.log(`[unloadBlockCubes] Unloaded block cubes in ${unloadTime.toFixed(1)}ms`);

  // Update memory monitor
  updateMemoryBreakdown();
}


function addArrowInstanced(grid, edge, direction, from, to) {
  const eKey = edgeKey(from, to);  // Canonical key

  // Remove existing arrow if present
  if (grid.edgeToArrowInstanceMap.has(eKey)) {
    removeArrowInstanced(grid, edge, eKey);  // Pass key to avoid rescan
  }

  // Determine which mesh to use
  const isForward = direction === 1;
  const instancedMesh = isForward ? grid.instancedArrowsForward : grid.instancedArrowsBackward;

  // Debug: log first few arrows
  if (grid.arrowInstanceSlots.forward.nextAvailable + grid.arrowInstanceSlots.backward.nextAvailable < 3) {
    console.log(`[Arrow Debug] from=${from}, to=${to}, direction=${direction}, mesh=${isForward ? 'forward' : 'backward'}`);
  }
  const slots = isForward ? grid.arrowInstanceSlots.forward : grid.arrowInstanceSlots.backward;
  
  // Get or allocate instance slot
  let instanceIndex;
  if (slots.freeSlots.length > 0) {
    instanceIndex = slots.freeSlots.pop();
  } else {
    instanceIndex = slots.nextAvailable++;
  }
  
  // Calculate transform matrix
  const startPos = new THREE.Vector3(from[0], from[1], from[2] ?? 0);
  const endPos = new THREE.Vector3(to[0], to[1], to[2] ?? 0);
  const edgeLength = startPos.distanceTo(endPos);
  const midpoint = new THREE.Vector3().addVectors(startPos, endPos).multiplyScalar(0.5);
  
  // Determine radius based on edge color
  // SLEDGEHAMMER: In unified mode, always use thin radius
  const edgeRadius = unifiedEdgeSize ? thinEdgeRadius : ((edge.color !== UNCOLORED_COLOR) ? thickEdgeRadius : thinEdgeRadius);
  const arrowRadius = edgeRadius * 1.02;
  
  // Build matrix
  const matrix = new THREE.Matrix4();
  const quaternion = new THREE.Quaternion();
  const up = new THREE.Vector3(0, 1, 0);
  
  // Scale to match edge length and radius
  matrix.makeScale(arrowRadius / 0.051, edgeLength, arrowRadius / 0.051);
  
  // Rotate to align with edge direction
  const dir = new THREE.Vector3().subVectors(endPos, startPos);
  if (dir.lengthSq() > 0) {
    dir.normalize();
    quaternion.setFromUnitVectors(up, dir);
    const rotationMatrix = new THREE.Matrix4().makeRotationFromQuaternion(quaternion);
    matrix.premultiply(rotationMatrix);
  }
  
  // Position at midpoint
  matrix.setPosition(midpoint);
  
  // Update instance
  instancedMesh.setMatrixAt(instanceIndex, matrix);

  // Batch mode optimization: don't sync GPU for each arrow, sync once at end
  if (!grid.batchMode) {
    instancedMesh.instanceMatrix.needsUpdate = true;
  }
  
  // FIX 3: Ensure instance count covers this index
  instancedMesh.count = Math.max(instancedMesh.count, instanceIndex + 1);
  
  // Store mapping with CANONICAL key
  grid.edgeToArrowInstanceMap.set(eKey, {
    direction: direction,
    index: instanceIndex
  });

  // Update edge data
  edge.arrowDirection = direction;
  edge.arrows = 'instanced';
}

function removeArrowInstanced(grid, edge, providedKey = null) {
  // Use provided key or find it
  let eKey = providedKey;
  if (!eKey) {
    for (const [key, e] of grid.edges.entries()) {
      if (e === edge) {
        eKey = key;
        break;
      }
    }
  }
  
  if (!eKey || !grid.edgeToArrowInstanceMap.has(eKey)) return;
  
  const mapping = grid.edgeToArrowInstanceMap.get(eKey);
  const isForward = mapping.direction === 1;
  const instancedMesh = isForward ? grid.instancedArrowsForward : grid.instancedArrowsBackward;
  const slots = isForward ? grid.arrowInstanceSlots.forward : grid.arrowInstanceSlots.backward;
  
  // Hide the arrow by setting zero matrix
  const zeroMatrix = new THREE.Matrix4().makeScale(0, 0, 0);
  instancedMesh.setMatrixAt(mapping.index, zeroMatrix);

  // Batch mode optimization: don't sync GPU for each arrow removal, sync once at end
  if (!grid.batchMode) {
    instancedMesh.instanceMatrix.needsUpdate = true;
  }
  
  // Free the slot
  slots.freeSlots.push(mapping.index);
  
  // Remove mapping
  grid.edgeToArrowInstanceMap.delete(eKey);

  // Clear edge data - but PRESERVE arrowDirection for toggle restoration
  edge.arrows = null;
  // edge.arrowDirection stays set!
}

// Optimize arrow instance counts to reduce GPU processing
// Call after batch operations (e.g., loading, clearing arrows, toggling visibility)
function updateArrowInstanceCounts(grid) {
  if (!grid || !grid.arrowInstanceSlots) return;

  // For each direction, set count to the highest used slot + 1
  // (or 0 if no arrows are active)
  const forwardSlots = grid.arrowInstanceSlots.forward;
  const backwardSlots = grid.arrowInstanceSlots.backward;

  // Forward arrows: count is nextAvailable minus any free slots at the end
  if (grid.instancedArrowsForward) {
    const activeForward = forwardSlots.nextAvailable - forwardSlots.freeSlots.length;
    // Set count to actual active arrows (using nextAvailable as upper bound)
    // Note: can't go below nextAvailable because slots between 0 and nextAvailable may be used
    grid.instancedArrowsForward.count = forwardSlots.nextAvailable;
    // If all slots are free, we can set count to 0
    if (activeForward === 0) {
      grid.instancedArrowsForward.count = 0;
      forwardSlots.nextAvailable = 0;
      forwardSlots.freeSlots = [];
    }
  }

  // Backward arrows: same logic
  if (grid.instancedArrowsBackward) {
    const activeBackward = backwardSlots.nextAvailable - backwardSlots.freeSlots.length;
    grid.instancedArrowsBackward.count = backwardSlots.nextAvailable;
    if (activeBackward === 0) {
      grid.instancedArrowsBackward.count = 0;
      backwardSlots.nextAvailable = 0;
      backwardSlots.freeSlots = [];
    }
  }
}


//     ====================================================================================================================
// 											   11. Ctrl+Z, Ctrl+R 
//     ====================================================================================================================


// Core undo/redo system
function recordAction(actionType, actionData) {
  if (!currentGrid) return;
  
  const action = {
    type: actionType,
    data: actionData,
    timestamp: Date.now()
  };
  
  currentGrid.undoStack.push(action);
  currentGrid.redoStack = []; // Clear redo stack on new action
  
  // Limit undo stack size
  if (currentGrid.undoStack.length > currentGrid.maxUndoSteps) {
    currentGrid.undoStack.shift();
  }
}


async function performUndo() {
  console.log('[performUndo] *** CALLED ***', {
    hasGrid: !!currentGrid,
    stackLength: currentGrid ? currentGrid.undoStack.length : 0
  });

  if (!currentGrid || currentGrid.undoStack.length === 0) {
    console.log("Nothing to undo");
    return;
  }

  const action = currentGrid.undoStack.pop();
  console.log('[performUndo] Popped action:', action.type, action);

  // Execute the undo operation
  switch (action.type) {
    case 'VERTEX_SPHERE':
      undoVertexSphere(action.data);
      break;
    case 'VERTEX_DECORATION':
      undoVertexDecoration(action.data);
      break;
    case 'EDGE_STATE':
      undoEdgeState(action.data);
      break;
    case 'LAYER_OPERATION':
      await undoLayerOperation(action.data);
      break;
    case 'BB_DISTANCE_BATCH':           // <-- ADD THIS
      undoBBDistanceBatch(action.data);  // <-- ADD THIS
      break;
	case 'CLEAR_ALL_VERTICES':
	  undoClearAllVertices(action.data);
	  break;// <-- ADD THIS
	case 'BACKBITE':  // ADD THIS
      undoBackbite(action.data);
      break;
    case 'SWITCH':  // ADD THIS
      undoSwitch(action.data);
      break;
    default:
      console.warn('Unknown action type:', action.type);
  }

  currentGrid.redoStack.push(action);
}

async function performRedo() {
  if (!currentGrid || currentGrid.redoStack.length === 0) {
    console.log("Nothing to redo");
    return;
  }

  const action = currentGrid.redoStack.pop();

  // Execute the redo operation (same as original action)
  switch (action.type) {
    case 'VERTEX_SPHERE':
      redoVertexSphere(action.data);
      break;
    case 'VERTEX_DECORATION':
      redoVertexDecoration(action.data);
      break;
    case 'EDGE_STATE':
      redoEdgeState(action.data);
      break;
    case 'LAYER_OPERATION':
      await redoLayerOperation(action.data);
      break;
    case 'BB_DISTANCE_BATCH':           // <-- ADD THIS
      redoBBDistanceBatch(action.data);  // <-- ADD THIS
      break;                             // <-- ADD THIS
    case 'CLEAR_ALL_VERTICES':
      redoClearAllVertices(action.data);
      break;
	case 'BACKBITE':  // ADD THIS
      redoBackbite(action.data);
      break;
    case 'SWITCH':  // ADD THIS
      redoSwitch(action.data);
      break;  
	default:
      console.warn('Unknown action type:', action.type);
  }

  currentGrid.undoStack.push(action);
}


//     =======================================
// 		*** 11.1 State Capture Functions ***
//     =======================================

// State capture helper functions
function captureVertexSphereState(vertexKey) {
  // Check if there's a vertex sphere
  if (currentGrid.vertexSpheres.has(vertexKey)) {
    const sphereData = currentGrid.vertexSpheres.get(vertexKey);

    // Get color (works for both instanced and individual mode)
    const color = currentGrid.isInstanced
      ? sphereData.color
      : sphereData.sphere.material.color.getHex();

    const state = {
      color: color,
      hasDecoration: !!sphereData.decoration,
      isStandalone: false
    };

    if (state.hasDecoration && sphereData.decoration) {
      if (sphereData.decoration.children && sphereData.decoration.children.length > 0) {
        state.decorationColor = sphereData.decoration.children[0].material.color.getHex();
      }
    }

    return state;
  }

  // Check if there's a standalone decoration (decoration without vertex sphere)
  if (currentGrid.standaloneDecorations && currentGrid.standaloneDecorations.has(vertexKey)) {
    const decorationData = currentGrid.standaloneDecorations.get(vertexKey);
    const state = {
      color: null, // No vertex sphere
      hasDecoration: true,
      isStandalone: true
    };

    if (decorationData.decorationGroup && decorationData.decorationGroup.children && decorationData.decorationGroup.children.length > 0) {
      state.decorationColor = decorationData.decorationGroup.children[0].material.color.getHex();
    }

    return state;
  }

  // No vertex sphere and no standalone decoration
  return null;
}

function captureEdgeState(edgeKey) {
  const edge = currentGrid.edges.get(edgeKey);
  if (!edge) return null;

  return {
    color: edge.color,
    hasArrows: !!edge.arrows,
    arrowDirection: edge.arrowDirection || 0,
    hasBlockCube: !!edge.blockCube
  };
}

function captureCompleteGridState() {
  return {
    dimensions: {
      width: currentGrid.width,
      height: currentGrid.height,
      depth: currentGrid.depth
    },
    edges: captureAllEdgeStates(),
    vertices: captureAllVertexStates(),
    path: currentGrid.path ? [...currentGrid.path] : null
  };
}

function captureAllEdgeStates() {
  const edgeStates = {};
  for (const [edgeKey, edge] of currentGrid.edges.entries()) {
    const needsSaving = edge.color !== UNCOLORED_COLOR ||
                       edge.arrows ||
                       edge.blockCube;

    if (needsSaving) {
      edgeStates[edgeKey] = captureEdgeState(edgeKey);
    }
  }
  return edgeStates;
}

function captureAllVertexStates() {
  const vertexStates = {};

  // Capture vertex spheres (with or without decorations)
  if (currentGrid.vertexSpheres) {
    for (const [vertexKey, sphereData] of currentGrid.vertexSpheres.entries()) {
      vertexStates[vertexKey] = captureVertexSphereState(vertexKey);
    }
  }

  // Also capture standalone decorations (decorations without vertex spheres)
  if (currentGrid.standaloneDecorations) {
    for (const vertexKey of currentGrid.standaloneDecorations.keys()) {
      // Only capture if we haven't already captured it (to avoid duplicates)
      if (!vertexStates[vertexKey]) {
        vertexStates[vertexKey] = captureVertexSphereState(vertexKey);
      }
    }
  }

  return vertexStates;
}


//     =======================================
// 		*** 11.2 State Restoration Functions ***
//     =======================================

// State restoration helper functions
function restoreEdgeStatesFromSnapshot(snapshot) {
  for (const [edgeKeyStr, edgeState] of Object.entries(snapshot.edges)) {
    const edgeKey = Number(edgeKeyStr); // Convert string back to number
    const [a, b] = unpackEdge(edgeKey, currentGrid);

    if (currentGrid.edges.has(edgeKey)) {
      colorEdge(currentGrid, a, b, edgeState.color, edgeState.color === UNCOLORED_COLOR ? thinEdgeRadius : thickEdgeRadius);

      const edge = currentGrid.edges.get(edgeKey);

      if (edgeState.hasBlockCube) {
		if (currentGrid.isInstanced) {
			addBlockCubeInstanced(currentGrid, edge, edgeKey);
		} else {
			addBlockCube(edge);
		}
	}

      if (edgeState.hasArrows && edgeState.arrowDirection) {
        addArrowsToEdge(edge, edgeState.arrowDirection);
      }
    }
  }
}

function restoreVertexStatesFromSnapshot(snapshot) {
  for (const [vertexKeyStr, vertexState] of Object.entries(snapshot.vertices)) {
    const vertexKey = Number(vertexKeyStr); // Convert string back to number

    // Only create vertex sphere if there was one (not just standalone decoration)
    if (vertexState.color !== null && !vertexState.isStandalone) {
      createVertexSphere(currentGrid, vertexKey, vertexState.color);
    }

    if (vertexState.hasDecoration && vertexState.decorationColor) {
      addVertexDecoration(currentGrid, vertexKey, vertexState.decorationColor);
    }
  }
}

function restorePathFromSnapshot(snapshot) {
  if (snapshot.path && snapshot.path.length > 0) {
    currentGrid.path = [...snapshot.path];

    // Rebuild activeSubgraph from path
    currentGrid.activeSubgraph = new Subgraph(currentGrid);
    for (let i = 0; i < snapshot.path.length - 1; i++) {
      const a = unpackVertex(snapshot.path[i], currentGrid);
      const b = unpackVertex(snapshot.path[i + 1], currentGrid);
      currentGrid.activeSubgraph.edges.add(edgeKey(a, b, currentGrid));
      currentGrid.activeSubgraph.vertices.add(snapshot.path[i]);
      currentGrid.activeSubgraph.vertices.add(snapshot.path[i + 1]);
    }

    // Check if this was a cycle and handle endpoint markers
    const totalVertices = currentGrid.width * currentGrid.height * currentGrid.depth;
    const isCycle = snapshot.path.length === totalVertices;

    if (!isCycle && snapshot.path.length >= 2) {
      updateEndpointMarkers(currentGrid);
    }
  }
}

async function restoreGridFromSnapshot(snapshot) {
  console.log('[restoreGridFromSnapshot] *** FUNCTION CALLED ***', snapshot);

  // Update global dimensions
  GRID_WIDTH = snapshot.dimensions.width;
  GRID_HEIGHT = snapshot.dimensions.height;
  GRID_DEPTH = snapshot.dimensions.depth;

  // Update grid properties
  currentGrid.width = snapshot.dimensions.width;
  currentGrid.height = snapshot.dimensions.height;
  currentGrid.depth = snapshot.dimensions.depth;

  // Rebuild basic structure - MUST AWAIT for grid to be fully built
  await buildGridContent(currentGrid);

  // LAZY LOADING FIX: Force load geometry if needed for restoration
  console.log('[restoreGridFromSnapshot] Checking what geometry needs loading...', {
    snapshotVertices: snapshot.vertices ? Object.keys(snapshot.vertices).length : 0,
    snapshotEdges: snapshot.edges ? Object.keys(snapshot.edges).length : 0,
    lazyLoadVertexSpheres,
    lazyLoadEdgeCollision,
    isInstanced: currentGrid.isInstanced
  });

  // ALWAYS load edge collision helpers (cheap and needed for clicking edges)
  if (lazyLoadEdgeCollision && currentGrid.isInstanced) {
    console.log('[restoreGridFromSnapshot] Loading edge collision (always needed for clicking)');
    loadEdgeCollision(currentGrid);
  }

  // Check if we have vertex states to restore - if yes, load vertex spheres
  const hasVertexStates = snapshot.vertices && Object.keys(snapshot.vertices).length > 0;
  if (hasVertexStates && lazyLoadVertexSpheres && currentGrid.isInstanced) {
    console.log('[restoreGridFromSnapshot] Loading vertex spheres (found', Object.keys(snapshot.vertices).length, 'vertices to restore)');
    loadVertexSpheres(currentGrid);
  } else {
    console.log('[restoreGridFromSnapshot] Skipping vertex spheres load', { hasVertexStates, lazyLoadVertexSpheres, isInstanced: currentGrid.isInstanced });
  }

  // Check if we have edge states with block cubes - if yes, load block cubes
  const hasBlockCubes = snapshot.edges && Object.values(snapshot.edges).some(e => e.hasBlockCube);
  if (hasBlockCubes && lazyLoadEdgeCollision && currentGrid.isInstanced) {
    console.log('[restoreGridFromSnapshot] Loading block cubes (found block cubes to restore)');
    loadBlockCubes(currentGrid);
  } else {
    console.log('[restoreGridFromSnapshot] Skipping block cubes load', { hasBlockCubes });
  }

  // Restore all states using existing restoration logic
  restoreEdgeStatesFromSnapshot(snapshot);
  restoreVertexStatesFromSnapshot(snapshot);
  restorePathFromSnapshot(snapshot);

  // Update dimension UI
  document.getElementById("widthInput").value = snapshot.dimensions.width;
  document.getElementById("heightInput").value = snapshot.dimensions.height;
  document.getElementById("depthInput").value = snapshot.dimensions.depth;
}


//     =======================================
// 		*** 11.3 Action Handlers ***
//     =======================================

// Helper function to check if a grid has any colored/added vertices
function hasColoredVertices(grid) {
  if (!grid) return false;

  // Check if any vertex spheres exist (colored or decorated)
  return grid.vertexSpheres && grid.vertexSpheres.size > 0;
}

// Helper function to check if a grid has any vertex operations in its undo/redo history
function hasVertexOperationsInHistory(grid) {
  if (!grid) return false;

  const vertexActionTypes = ['VERTEX_SPHERE', 'VERTEX_DECORATION', 'CLEAR_ALL_VERTICES'];

  // Check undo stack
  if (grid.undoStack && grid.undoStack.length > 0) {
    for (const action of grid.undoStack) {
      if (vertexActionTypes.includes(action.type)) {
        return true;
      }
    }
  }

  // Check redo stack
  if (grid.redoStack && grid.redoStack.length > 0) {
    for (const action of grid.redoStack) {
      if (vertexActionTypes.includes(action.type)) {
        return true;
      }
    }
  }

  return false;
}

// Helper function to check if a grid has any manually added edges (non-default colored edges)
function hasManuallyColoredEdges(grid) {
  if (!grid || !grid.edges) return false;

  for (const edge of grid.edges.values()) {
    // Check if edge has non-default color (not gray 0x888888)
    if (edge.color !== 0x888888 && edge.color !== UNCOLORED_COLOR) {
      return true;
    }
  }

  return false;
}

// Helper function to check if a grid has any edge operations in its undo/redo history
function hasEdgeOperationsInHistory(grid) {
  if (!grid) return false;

  const edgeActionTypes = ['EDGE_COLOR', 'EDGE_TOGGLE', 'ADD_EDGE', 'REMOVE_EDGE'];

  // Check undo stack
  if (grid.undoStack && grid.undoStack.length > 0) {
    for (const action of grid.undoStack) {
      if (edgeActionTypes.includes(action.type)) {
        return true;
      }
    }
  }

  // Check redo stack
  if (grid.redoStack && grid.redoStack.length > 0) {
    for (const action of grid.redoStack) {
      if (edgeActionTypes.includes(action.type)) {
        return true;
      }
    }
  }

  return false;
}

// Helper function to check if a grid has any block cube decorations
function hasBlockCubeDecorations(grid) {
  if (!grid || !grid.edges) return false;

  for (const edge of grid.edges.values()) {
    if (edge.blockCube) {
      return true;
    }
  }

  return false;
}

// Helper function to check if a grid has any block cube operations in its undo/redo history
function hasBlockCubeOperationsInHistory(grid) {
  if (!grid) return false;

  // Check undo stack for EDGE_STATE actions with blockCube changes
  if (grid.undoStack && grid.undoStack.length > 0) {
    for (const action of grid.undoStack) {
      if (action.type === 'EDGE_STATE') {
        const before = action.data?.beforeState?.hasBlockCube;
        const after = action.data?.afterState?.hasBlockCube;
        // If blockCube state changed, there's block cube history
        if (before !== after) {
          return true;
        }
      }
    }
  }

  // Check redo stack
  if (grid.redoStack && grid.redoStack.length > 0) {
    for (const action of grid.redoStack) {
      if (action.type === 'EDGE_STATE') {
        const before = action.data?.beforeState?.hasBlockCube;
        const after = action.data?.afterState?.hasBlockCube;
        if (before !== after) {
          return true;
        }
      }
    }
  }

  return false;
}

// Rebuild edges with new segment count (chunk-aware version)
function rebuildEdgesWithNewSegments(grid, newSegments) {
  // Check for instanced mode
  if (!grid.isInstanced) {
    return;
  }

  // Use authoritative lodState instead of geometry.parameters
  const oldSegments = grid.lodState?.edgeSegments ?? edgeSegments;

  // Early exit if no change needed
  if (oldSegments === newSegments) {
    return;
  }

  // Handle multi-chunk grids: iterate through each chunk
  if (grid.chunks && grid.chunks.size > 0) {
    for (const [chunkKey, chunk] of grid.chunks.entries()) {
      rebuildChunkEdgesWithNewSegments(grid, chunk, chunkKey, newSegments);
    }

    // Update grid-level LOD state
    if (grid.lodState) {
      grid.lodState.edgeSegments = newSegments;
      grid.lodState.lastRebuildTime = performance.now();
    }
    return;
  }

  // Fallback for non-chunked grids (legacy single-mesh mode)
  // This path should rarely be used with modern grid initialization
  if (!grid.instancedEdgesThin) {
    return;
  }

  // Remove old mesh from scene
  grid.group.remove(grid.instancedEdgesThin);
  grid.instancedEdgesThin.geometry.dispose();
  grid.instancedEdgesThin.material.dispose();

  // Create new geometry with new segment count (only thin edges affected by user setting)
  const thinGeometry = new THREE.CylinderGeometry(thinEdgeRadius, thinEdgeRadius, 1, newSegments);
  const thinMaterial = new THREE.MeshBasicMaterial();
  grid.instancedEdgesThin = new THREE.InstancedMesh(thinGeometry, thinMaterial, grid.edges.size);
  grid.instancedEdgesThin.instanceColor = new THREE.InstancedBufferAttribute(
    new Float32Array(grid.edges.size * 3), 3
  );

  // Rebuild all edge instances
  const up = new THREE.Vector3(0, 1, 0);
  const matrix = new THREE.Matrix4();
  const quaternion = new THREE.Quaternion();

  // Apply dimming based on current background color
  const backgroundHex = scene.background.getHex();
  const opacity = backgroundHex === 0x000000 ? 0.3 : 1.0;
  const grayValue = Math.floor(0x88 * opacity);
  const simulatedColor = (grayValue << 16) | (grayValue << 8) | grayValue;
  const grayColor = new THREE.Color(simulatedColor);

  let thinIndex = 0;
  for (const [eKey, edge] of grid.edges.entries()) {
    const [a, b] = unpackEdge(eKey);

    const start = new THREE.Vector3(...a);
    const end = new THREE.Vector3(...b);
    const direction = new THREE.Vector3().subVectors(end, start);
    const length = direction.length();
    const midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);

    // Build transform matrix
    matrix.makeScale(1, length, 1);
    quaternion.setFromUnitVectors(up, direction.normalize());
    const rotationMatrix = new THREE.Matrix4().makeRotationFromQuaternion(quaternion);
    matrix.premultiply(rotationMatrix);
    matrix.setPosition(midpoint);

    // Determine color based on edge state
    let threeColor;
    if (edge.color === UNCOLORED_COLOR) {
      threeColor = grayColor;
    } else {
      threeColor = new THREE.Color(edge.color);
    }

    grid.instancedEdgesThin.setMatrixAt(thinIndex, matrix);
    grid.instancedEdgesThin.setColorAt(thinIndex, threeColor);

    // Update mapping (thin index only - thick/collision unchanged)
    const existingMapping = grid.edgeToInstanceMap.get(eKey);
    if (existingMapping) {
      existingMapping.thin = thinIndex;
    } else {
      grid.edgeToInstanceMap.set(eKey, { thin: thinIndex, thick: thinIndex, collision: thinIndex });
    }

    thinIndex++;
  }

  grid.instancedEdgesThin.instanceMatrix.needsUpdate = true;
  grid.instancedEdgesThin.instanceColor.needsUpdate = true;

  // Add back to scene
  grid.group.add(grid.instancedEdgesThin);

  // Update authoritative LOD state
  if (grid.lodState) {
    grid.lodState.edgeSegments = newSegments;
    grid.lodState.lastRebuildTime = performance.now();
  }
}

// Rebuild vertices with new subdivision level (chunk-aware version)
function rebuildVerticesWithNewDetail(grid, newSubdivisions) {
  // Check for instanced mode
  if (!grid.isInstanced) {
    return;
  }

  // Use authoritative lodState instead of geometry.parameters
  const oldSubdivisions = grid.lodState?.vertexDetail ?? vertexSubdivisions;

  // Early exit if no change needed
  if (oldSubdivisions === newSubdivisions) {
    return;
  }

  // Handle multi-chunk grids: iterate through each chunk
  if (grid.chunks && grid.chunks.size > 0) {
    for (const [chunkKey, chunk] of grid.chunks.entries()) {
      rebuildChunkVerticesWithNewDetail(grid, chunk, chunkKey, newSubdivisions);
    }

    // Update grid-level LOD state
    if (grid.lodState) {
      grid.lodState.vertexDetail = newSubdivisions;
      grid.lodState.lastRebuildTime = performance.now();
    }
    return;
  }

  // Fallback for non-chunked grids (legacy single-mesh mode)
  if (!grid.instancedVertexSpheres) {
    return;
  }

  // Remove old mesh from scene (only visual spheres need rebuilding for detail change)
  grid.group.remove(grid.instancedVertexSpheres);
  grid.instancedVertexSpheres.geometry.dispose();
  grid.instancedVertexSpheres.material.dispose();

  // Create new geometry with new subdivision level
  const sphereGeometry = new THREE.IcosahedronGeometry(vertexRadius, newSubdivisions);
  const sphereMaterial = new THREE.MeshBasicMaterial({ depthTest: true });
  grid.instancedVertexSpheres = new THREE.InstancedMesh(sphereGeometry, sphereMaterial, grid.vertices.size);
  grid.instancedVertexSpheres.count = grid.vertices.size;
  grid.instancedVertexSpheres.instanceColor = new THREE.InstancedBufferAttribute(
    new Float32Array(grid.vertices.size * 3), 3
  );

  // Rebuild vertex instances
  const zeroMatrix = new THREE.Matrix4().makeScale(0, 0, 0);

  let vertexIndex = 0;
  for (const [vKey, vertexData] of grid.vertices.entries()) {
    const [x, y, z] = unpackVertex(vKey, grid);

    // VISUAL SPHERES: Visible if user created a sphere OR if "Show All Vertices" is enabled
    if (grid.vertexSpheres && grid.vertexSpheres.has(vKey)) {
      const matrix = new THREE.Matrix4().setPosition(x, y, z);
      grid.instancedVertexSpheres.setMatrixAt(vertexIndex, matrix);

      const sphereData = grid.vertexSpheres.get(vKey);
      const vertexColor = new THREE.Color(sphereData.color || 0x888888);
      grid.instancedVertexSpheres.setColorAt(vertexIndex, vertexColor);
    } else if (showAllVertices) {
      const matrix = new THREE.Matrix4().setPosition(x, y, z);
      grid.instancedVertexSpheres.setMatrixAt(vertexIndex, matrix);
      grid.instancedVertexSpheres.setColorAt(vertexIndex, new THREE.Color(0x888888));
    } else {
      grid.instancedVertexSpheres.setMatrixAt(vertexIndex, zeroMatrix);
    }

    // Update mapping (vertex index only - collision unchanged)
    const existingMapping = grid.vertexToInstanceMap.get(vKey);
    if (!existingMapping) {
      grid.vertexToInstanceMap.set(vKey, vertexIndex);
    }

    vertexIndex++;
  }

  grid.instancedVertexSpheres.instanceMatrix.needsUpdate = true;
  grid.instancedVertexSpheres.instanceColor.needsUpdate = true;

  // Set visibility based on preference
  grid.instancedVertexSpheres.visible = grid.showAllVertices;

  // Add back to scene
  grid.group.add(grid.instancedVertexSpheres);

  // Update authoritative LOD state
  if (grid.lodState) {
    grid.lodState.vertexDetail = newSubdivisions;
    grid.lodState.lastRebuildTime = performance.now();
  }
}


//     =======================================
// 		*** 10.2 Geometry Rebuild Functions ***
//     =======================================

// Rebuild vertex geometry for a single chunk with new radius
function rebuildChunkVerticesWithNewRadius(grid, chunk, chunkKey, newRadius) {
  if (!chunk || !chunk.instancedVertexSpheres) return;

  // Remove old mesh from scene
  grid.group.remove(chunk.instancedVertexSpheres);
  chunk.instancedVertexSpheres.geometry.dispose();
  chunk.instancedVertexSpheres.material.dispose();

  // Create new geometry with new radius
  const sphereGeometry = new THREE.IcosahedronGeometry(newRadius, coloredVertexSubdivisions);
  const sphereMaterial = new THREE.MeshBasicMaterial();

  // Create new instanced mesh
  chunk.instancedVertexSpheres = new THREE.InstancedMesh(sphereGeometry, sphereMaterial, chunk.vertexCount);
  chunk.instancedVertexSpheres.count = chunk.vertexCount;
  chunk.instancedVertexSpheres.instanceColor = new THREE.InstancedBufferAttribute(
    new Float32Array(chunk.vertexCount * 3), 3
  );

  // Rebuild all vertex instances in this chunk
  const zeroMatrix = new THREE.Matrix4().makeScale(0, 0, 0);

  for (const [vKey, vertexIndex] of chunk.vertexToInstanceMap.entries()) {
    const [x, y, z] = unpackVertex(vKey, grid);

    if (grid.vertexSpheres && grid.vertexSpheres.has(vKey)) {
      const matrix = new THREE.Matrix4().setPosition(x, y, z);
      chunk.instancedVertexSpheres.setMatrixAt(vertexIndex, matrix);

      const sphereData = grid.vertexSpheres.get(vKey);
      const vertexColor = new THREE.Color(sphereData.color || 0x888888);
      chunk.instancedVertexSpheres.setColorAt(vertexIndex, vertexColor);
    } else if (grid.showAllVertices) {
      const matrix = new THREE.Matrix4().setPosition(x, y, z);
      chunk.instancedVertexSpheres.setMatrixAt(vertexIndex, matrix);
      chunk.instancedVertexSpheres.setColorAt(vertexIndex, new THREE.Color(0x888888));
    } else {
      chunk.instancedVertexSpheres.setMatrixAt(vertexIndex, zeroMatrix);
    }
  }

  // Update buffers
  chunk.instancedVertexSpheres.instanceMatrix.needsUpdate = true;
  chunk.instancedVertexSpheres.instanceColor.needsUpdate = true;

  // Set visibility based on preference
  chunk.instancedVertexSpheres.visible = grid.showAllVertices;

  // Add back to scene
  grid.group.add(chunk.instancedVertexSpheres);
}

// Rebuild vertices with new radius (keeps same detail level) - chunk-aware version
function rebuildVerticesWithNewRadius(grid, newRadius) {
  // Check for instanced mode
  if (!grid.isInstanced) {
    return;
  }

  // Handle multi-chunk grids: iterate through each chunk
  if (grid.chunks && grid.chunks.size > 0) {
    for (const [chunkKey, chunk] of grid.chunks.entries()) {
      rebuildChunkVerticesWithNewRadius(grid, chunk, chunkKey, newRadius);
    }
    return;
  }

  // Fallback for non-chunked grids (legacy single-mesh mode)
  if (!grid.instancedVertexSpheres) {
    return;
  }

  // Remove old visual sphere mesh
  grid.group.remove(grid.instancedVertexSpheres);
  grid.instancedVertexSpheres.geometry.dispose();
  grid.instancedVertexSpheres.material.dispose();

  // Create new geometry with new radius
  const sphereGeometry = new THREE.IcosahedronGeometry(newRadius, coloredVertexSubdivisions);
  const sphereMaterial = new THREE.MeshBasicMaterial({ depthTest: true });
  grid.instancedVertexSpheres = new THREE.InstancedMesh(sphereGeometry, sphereMaterial, grid.vertices.size);
  grid.instancedVertexSpheres.count = grid.vertices.size;
  grid.instancedVertexSpheres.instanceColor = new THREE.InstancedBufferAttribute(
    new Float32Array(grid.vertices.size * 3), 3
  );

  // Rebuild vertex positions and colors
  const zeroMatrix = new THREE.Matrix4().makeScale(0, 0, 0);
  let vertexIndex = 0;

  for (const [vKey, vertexData] of grid.vertices.entries()) {
    const [x, y, z] = unpackVertex(vKey, grid);

    if (grid.vertexSpheres && grid.vertexSpheres.has(vKey)) {
      const matrix = new THREE.Matrix4().setPosition(x, y, z);
      grid.instancedVertexSpheres.setMatrixAt(vertexIndex, matrix);

      const sphereData = grid.vertexSpheres.get(vKey);
      const vertexColor = new THREE.Color(sphereData.color || 0x888888);
      grid.instancedVertexSpheres.setColorAt(vertexIndex, vertexColor);
    } else if (showAllVertices) {
      const matrix = new THREE.Matrix4().setPosition(x, y, z);
      grid.instancedVertexSpheres.setMatrixAt(vertexIndex, matrix);
      grid.instancedVertexSpheres.setColorAt(vertexIndex, new THREE.Color(0x888888));
    } else {
      grid.instancedVertexSpheres.setMatrixAt(vertexIndex, zeroMatrix);
    }

    vertexIndex++;
  }

  grid.instancedVertexSpheres.instanceMatrix.needsUpdate = true;
  grid.instancedVertexSpheres.instanceColor.needsUpdate = true;

  // Set visibility based on preference
  grid.instancedVertexSpheres.visible = grid.showAllVertices;

  // Add back to scene
  grid.group.add(grid.instancedVertexSpheres);
}

// ==================== FRUSTUM CULLING SYSTEM ====================

// Check if camera is inside the grid bounds
function isInsideGrid(grid, cameraPos) {
  // Use actual grid dimensions, not chunk-based calculation
  // (chunks may extend beyond actual grid when grid size isn't divisible by chunk size)
  const maxX = grid.width;
  const maxY = grid.height;
  const maxZ = grid.depth;

  return cameraPos.x >= 0 && cameraPos.x <= maxX &&
         cameraPos.y >= 0 && cameraPos.y <= maxY &&
         cameraPos.z >= 0 && cameraPos.z <= maxZ;
}

// Get chunk keys for visible surface faces when camera is outside grid
// Uses gradient depth to avoid "jumping" and handle all viewing angles smoothly
function getVisibleSurfaceChunkKeys(grid, cameraPos, depth = 1) {
  const surfaceChunks = new Set();

  // Get far culling depth (for back faces) from grid's LOD state, or global default
  const gridFarCullingDepth = grid.lodState?.farCullingDepth ?? farCullingDepth;

  const maxCx = grid.chunkCounts.x - 1;
  const maxCy = grid.chunkCounts.y - 1;
  const maxCz = grid.chunkCounts.z - 1;

  // Calculate grid center and extents
  const gridCenterX = (grid.width - 1) / 2;
  const gridCenterY = (grid.height - 1) / 2;
  const gridCenterZ = (grid.depth - 1) / 2;

  const gridExtentX = grid.width / 2;
  const gridExtentY = grid.height / 2;
  const gridExtentZ = grid.depth / 2;

  // Calculate dominance for each axis (-1 to +1)
  // Positive = viewing + face, Negative = viewing - face, 0 = centered
  const xDominance = (cameraPos.x - gridCenterX) / gridExtentX;
  const yDominance = (cameraPos.y - gridCenterY) / gridExtentY;
  const zDominance = (cameraPos.z - gridCenterZ) / gridExtentZ;

  // Determine which axis is most dominant (primary viewing direction)
  const absDomX = Math.abs(xDominance);
  const absDomY = Math.abs(yDominance);
  const absDomZ = Math.abs(zDominance);
  const maxDominance = Math.max(absDomX, absDomY, absDomZ);

  // Minimum depth to always show (prevents gaps)
  const minDepth = 1;

  // Calculate camera proximity to boundaries (how edge-on the view is)
  // Distance from camera to each boundary (normalized and clamped 0-1)
  // 0 = at boundary (edge-on view, needs damping), 1 = far from boundary (no damping needed)
  const cameraNearPlusXBoundary = 1 - Math.min(1, Math.abs((gridCenterX + gridExtentX) - cameraPos.x) / gridExtentX);
  const cameraNearMinusXBoundary = 1 - Math.min(1, Math.abs((gridCenterX - gridExtentX) - cameraPos.x) / gridExtentX);
  const cameraNearPlusYBoundary = 1 - Math.min(1, Math.abs((gridCenterY + gridExtentY) - cameraPos.y) / gridExtentY);
  const cameraNearMinusYBoundary = 1 - Math.min(1, Math.abs((gridCenterY - gridExtentY) - cameraPos.y) / gridExtentY);
  const cameraNearPlusZBoundary = 1 - Math.min(1, Math.abs((gridCenterZ + gridExtentZ) - cameraPos.z) / gridExtentZ);
  const cameraNearMinusZBoundary = 1 - Math.min(1, Math.abs((gridCenterZ - gridExtentZ) - cameraPos.z) / gridExtentZ);

  // For each chunk, calculate if it should be visible based on gradient depth
  for (let cx = 0; cx <= maxCx; cx++) {
    for (let cy = 0; cy <= maxCy; cy++) {
      for (let cz = 0; cz <= maxCz; cz++) {
        let isVisible = false;

        // Calculate chunk's normalized position (0 to 1) in grid
        // Handle single-chunk case: if maxCx = 0, treat position as 0.5 (center)
        const chunkPosX = maxCx > 0 ? cx / maxCx : 0.5;
        const chunkPosY = maxCy > 0 ? cy / maxCy : 0.5;
        const chunkPosZ = maxCz > 0 ? cz / maxCz : 0.5;

        // X axis faces - ALWAYS check both, depth varies by dominance
        // +X face (right side, YZ plane at x=max)
        const plusXWeight = Math.max(0, xDominance);
        const nearWeight = plusXWeight / maxDominance;
        const farWeight = gridFarCullingDepth / depth;
        const baseDepthPlusX = depth * Math.max(farWeight, nearWeight);

        // Apply cross-axis boundary proximity damping
        // When camera near +Y boundary, cull chunks with low Y (far from camera)
        // When camera near -Y boundary, cull chunks with high Y (far from camera)
        // Same logic for Z axis
        let chunkDampingPlusX = 1.0;

        // Y-axis contribution: camera near boundary → cull opposite chunks
        const yProximity = cameraNearPlusYBoundary * (1 - chunkPosY) + cameraNearMinusYBoundary * chunkPosY;
        chunkDampingPlusX *= (1 - Math.pow(yProximity, 2) * (plusXWeight / maxDominance));

        // Z-axis contribution: camera near boundary → cull opposite chunks
        const zProximity = cameraNearPlusZBoundary * (1 - chunkPosZ) + cameraNearMinusZBoundary * chunkPosZ;
        chunkDampingPlusX *= (1 - Math.pow(zProximity, 2) * (plusXWeight / maxDominance));

        const depthPlusX = Math.ceil(baseDepthPlusX * chunkDampingPlusX);
        const thresholdPlusX = Math.max(minDepth, depthPlusX);
        if (cx >= maxCx - (thresholdPlusX - 1)) {
          isVisible = true;
        }

        // -X face (left side, YZ plane at x=0)
        const minusXWeight = Math.max(0, -xDominance);
        const baseDepthMinusX = depth * Math.max(farWeight, minusXWeight / maxDominance);

        let chunkDampingMinusX = 1.0;
        chunkDampingMinusX *= (1 - Math.pow(yProximity, 2) * (minusXWeight / maxDominance));
        chunkDampingMinusX *= (1 - Math.pow(zProximity, 2) * (minusXWeight / maxDominance));

        const depthMinusX = Math.ceil(baseDepthMinusX * chunkDampingMinusX);
        const thresholdMinusX = Math.max(minDepth, depthMinusX);
        if (cx <= thresholdMinusX - 1) {
          isVisible = true;
        }

        // Y axis faces - ALWAYS check both
        // +Y face (top, XZ plane at y=max)
        const plusYWeight = Math.max(0, yDominance);
        const baseDepthPlusY = depth * Math.max(farWeight, plusYWeight / maxDominance);

        let chunkDampingPlusY = 1.0;

        // X-axis contribution
        const xProximity = cameraNearPlusXBoundary * (1 - chunkPosX) + cameraNearMinusXBoundary * chunkPosX;
        chunkDampingPlusY *= (1 - Math.pow(xProximity, 2) * (plusYWeight / maxDominance));
        chunkDampingPlusY *= (1 - Math.pow(zProximity, 2) * (plusYWeight / maxDominance));

        const depthPlusY = Math.ceil(baseDepthPlusY * chunkDampingPlusY);
        const thresholdPlusY = Math.max(minDepth, depthPlusY);
        if (cy >= maxCy - (thresholdPlusY - 1)) {
          isVisible = true;
        }

        // -Y face (bottom, XZ plane at y=0)
        const minusYWeight = Math.max(0, -yDominance);
        const baseDepthMinusY = depth * Math.max(farWeight, minusYWeight / maxDominance);

        let chunkDampingMinusY = 1.0;
        chunkDampingMinusY *= (1 - Math.pow(xProximity, 2) * (minusYWeight / maxDominance));
        chunkDampingMinusY *= (1 - Math.pow(zProximity, 2) * (minusYWeight / maxDominance));

        const depthMinusY = Math.ceil(baseDepthMinusY * chunkDampingMinusY);
        const thresholdMinusY = Math.max(minDepth, depthMinusY);
        if (cy <= thresholdMinusY - 1) {
          isVisible = true;
        }

        // Z axis faces - ALWAYS check both
        // +Z face (back, XY plane at z=max)
        const plusZWeight = Math.max(0, zDominance);
        const baseDepthPlusZ = depth * Math.max(farWeight, plusZWeight / maxDominance);

        let chunkDampingPlusZ = 1.0;
        chunkDampingPlusZ *= (1 - Math.pow(xProximity, 2) * (plusZWeight / maxDominance));
        chunkDampingPlusZ *= (1 - Math.pow(yProximity, 2) * (plusZWeight / maxDominance));

        const depthPlusZ = Math.ceil(baseDepthPlusZ * chunkDampingPlusZ);
        const thresholdPlusZ = Math.max(minDepth, depthPlusZ);
        if (cz >= maxCz - (thresholdPlusZ - 1)) {
          isVisible = true;
        }

        // -Z face (front, XY plane at z=0)
        const minusZWeight = Math.max(0, -zDominance);
        const baseDepthMinusZ = depth * Math.max(farWeight, minusZWeight / maxDominance);

        let chunkDampingMinusZ = 1.0;
        chunkDampingMinusZ *= (1 - Math.pow(xProximity, 2) * (minusZWeight / maxDominance));
        chunkDampingMinusZ *= (1 - Math.pow(yProximity, 2) * (minusZWeight / maxDominance));

        const depthMinusZ = Math.ceil(baseDepthMinusZ * chunkDampingMinusZ);
        const thresholdMinusZ = Math.max(minDepth, depthMinusZ);
        if (cz <= thresholdMinusZ - 1) {
          isVisible = true;
        }

        if (isVisible) {
          surfaceChunks.add(getChunkKey(cx, cy, cz));
        }
      }
    }
  }
  return surfaceChunks;
}

// Helper function to update chunk mesh visibility based on culling and LOD state
function updateChunkMeshVisibility(chunk, isVisible) {
  const isLineMode = (chunk.lodState.level === 1);

  if (chunk.instancedEdgesThin) {
    // Hide cylinders in line mode (LOD 1)
    chunk.instancedEdgesThin.visible = isVisible && !isLineMode;
  }
  if (chunk.instancedEdgesThick) {
    chunk.instancedEdgesThick.visible = isVisible && !isLineMode;
  }
  if (chunk.instancedEdgesCollision) {
    // Edge collision helpers use onBeforeRender/onAfterRender for visual hiding
    // Keep them visible for raycasting; mode-based filtering happens in raycast functions
    chunk.instancedEdgesCollision.visible = isVisible;
  }
  if (chunk.instancedBlockCubes) {
    chunk.instancedBlockCubes.visible = isVisible;
  }
  if (chunk.lineEdges) {
    // Show lines only in line mode (LOD 1)
    chunk.lineEdges.visible = isVisible && isLineMode;
  }

  // Update vertex visibility based on culling
  // Show vertices if: showAllVertices is ON, OR if there are any colored vertices
  if (chunk.instancedVertexSpheres) {
    const hasColoredVertices = currentGrid.vertexSpheres && currentGrid.vertexSpheres.size > 0;
    chunk.instancedVertexSpheres.visible = isVisible && !isLineMode && (showAllVertices || hasColoredVertices);
  }
  if (chunk.instancedVertexCollisionHelpers) {
    // Vertex collision helpers use onBeforeRender/onAfterRender for visual hiding
    // Keep them visible for raycasting; mode-based filtering happens in raycast functions
    chunk.instancedVertexCollisionHelpers.visible = isVisible;
  }
  if (chunk.pointVertices) {
    const hasColoredVertices = currentGrid.vertexSpheres && currentGrid.vertexSpheres.size > 0;
    chunk.pointVertices.visible = isVisible && isLineMode && (showAllVertices || hasColoredVertices);
  }
}

// Update frustum culling for all chunks
let lastCullingLogTime = 0;
function updateFrustumCulling() {
  if (!currentGrid || !currentGrid.chunks) return;

  // Check if any culling system is enabled
  if (!frustumCullingEnabled && !sphericalCullingEnabled && !surfaceCullingEnabled) {
    // No culling enabled - make all chunks visible
    for (const chunk of currentGrid.chunks.values()) {
      chunk.isVisible = true;
      updateChunkMeshVisibility(chunk, true);
    }
    return;
  }

  // Update frustum from camera (matrices are already updated by controls.update())
  frustumMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
  frustum.setFromProjectionMatrix(frustumMatrix);

  const cameraPos = camera.position;

  // Determine if camera is inside or outside grid
  const cameraInside = isInsideGrid(currentGrid, cameraPos);

  // Get visible surface chunks if camera is outside and surface culling enabled
  let surfaceChunks = null;
  if (!cameraInside && surfaceCullingEnabled) {
    // Use grid-specific surface depth if available, otherwise use global default
    const gridSurfaceDepth = currentGrid.lodState?.surfaceDepth ?? surfaceDepth;
    surfaceChunks = getVisibleSurfaceChunkKeys(currentGrid, cameraPos, gridSurfaceDepth);
  }

  // Test each chunk against enabled culling systems
  for (const [chunkKey, chunk] of currentGrid.chunks.entries()) {
    if (!chunk.boundingBox) continue;

    // Start with visible = true, each culling system can set to false
    let isVisible = true;

    // Step 1: Frustum culling (if enabled)
    if (frustumCullingEnabled) {
      isVisible = frustum.intersectsBox(chunk.boundingBox);
    }

    // Step 2: Spherical culling (when camera is inside grid, if enabled)
    if (isVisible && sphericalCullingEnabled && cameraInside) {
      const distance = cameraPos.distanceTo(chunk.center);
      const maxRenderDistance = renderRadiusChunks * (currentGrid.chunkSize || 10);
      if (distance > maxRenderDistance) {
        isVisible = false;
      }
    }

    // Step 3: Surface culling (when camera is outside grid, if enabled)
    if (isVisible && surfaceCullingEnabled && !cameraInside) {
      if (!surfaceChunks.has(chunkKey)) {
        isVisible = false;
      }
    }

    // Step 4: Proximity override - "peek inside" effect
    // If chunk is within spherical render radius from camera, force it visible
    // This creates smooth transition when approaching the grid from outside
    if (sphericalCullingEnabled && !cameraInside) {
      const distance = cameraPos.distanceTo(chunk.center);
      const maxRenderDistance = renderRadiusChunks * (currentGrid.chunkSize || 10);
      if (distance <= maxRenderDistance) {
        isVisible = true; // Override previous culling - light it up!
      }
    }

    chunk.isVisible = isVisible;

    // Update mesh visibility based on culling result
    updateChunkMeshVisibility(chunk, isVisible);
  }

  // === GLOBAL MESH CULLING (arrows, switch boxes) ===
  // These are not per-chunk, so hide them if no chunks are visible

  let anyChunkVisible = false;
  for (const chunk of currentGrid.chunks.values()) {
    if (chunk.isVisible) {
      anyChunkVisible = true;
      break;
    }
  }

  // Arrows: visible if any chunk is visible
  if (currentGrid.instancedArrowsForward) {
    currentGrid.instancedArrowsForward.visible = anyChunkVisible;
  }
  if (currentGrid.instancedArrowsBackward) {
    currentGrid.instancedArrowsBackward.visible = anyChunkVisible;
  }

  // Switch boxes (edge selection planes): visible if any chunk is visible
  if (currentGrid.instancedBoxesXY) {
    currentGrid.instancedBoxesXY.visible = anyChunkVisible;
  }
  if (currentGrid.instancedBoxesXZ) {
    currentGrid.instancedBoxesXZ.visible = anyChunkVisible;
  }
  if (currentGrid.instancedBoxesYZ) {
    currentGrid.instancedBoxesYZ.visible = anyChunkVisible;
  }
}

// ==================== LOD (Level of Detail) SYSTEM ====================

// Rebuild edge geometry for a single chunk with new segment count
function rebuildChunkEdgesWithNewSegments(grid, chunk, chunkKey, newSegments) {
  if (!chunk || !chunk.instancedEdgesThin) return;

  const oldSegments = chunk.lodState.edgeSegments;
  if (oldSegments === newSegments) return;

  // Remove old mesh from scene
  grid.group.remove(chunk.instancedEdgesThin);
  chunk.instancedEdgesThin.geometry.dispose();
  chunk.instancedEdgesThin.material.dispose();

  // Create new geometry with new segment count
  const thinGeometry = new THREE.CylinderGeometry(thinEdgeRadius, thinEdgeRadius, 1, newSegments);
  const thinMaterial = new THREE.MeshBasicMaterial();

  // Create new instanced mesh
  chunk.instancedEdgesThin = new THREE.InstancedMesh(thinGeometry, thinMaterial, chunk.edgeCount);
  chunk.instancedEdgesThin.instanceColor = new THREE.InstancedBufferAttribute(
    new Float32Array(chunk.edgeCount * 3), 3
  );

  // Rebuild all edge instances in this chunk
  const up = new THREE.Vector3(0, 1, 0);
  const matrix = new THREE.Matrix4();
  const quaternion = new THREE.Quaternion();
  const zeroMatrix = new THREE.Matrix4().makeScale(0, 0, 0);

  // Apply dimming based on current background color
  const backgroundHex = scene.background.getHex();
  const opacity = backgroundHex === 0x000000 ? 0.3 : 1.0;
  const grayValue = Math.floor(0x88 * opacity);
  const simulatedColor = (grayValue << 16) | (grayValue << 8) | grayValue;
  const grayColor = new THREE.Color(simulatedColor);

  // Iterate through edges that belong to this chunk
  for (const [eKey, mapping] of chunk.edgeToInstanceMap.entries()) {
    const edge = grid.edges.get(eKey);
    if (!edge) continue;

    const [a, b] = unpackEdge(eKey);

    const start = new THREE.Vector3(...a);
    const end = new THREE.Vector3(...b);
    const direction = new THREE.Vector3().subVectors(end, start);
    const length = direction.length();
    const midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);

    // Build transform matrix
    matrix.makeScale(1, length, 1);
    quaternion.setFromUnitVectors(up, direction.normalize());
    const rotationMatrix = new THREE.Matrix4().makeRotationFromQuaternion(quaternion);
    matrix.premultiply(rotationMatrix);
    matrix.setPosition(midpoint);

    // Determine color based on edge state
    let threeColor;
    if (edge.color === UNCOLORED_COLOR) {
      threeColor = grayColor;
    } else {
      threeColor = new THREE.Color(edge.color);
    }

    // Set thin mesh
    chunk.instancedEdgesThin.setMatrixAt(mapping.thin, matrix);
    chunk.instancedEdgesThin.setColorAt(mapping.thin, threeColor);
  }

  // Update buffers
  chunk.instancedEdgesThin.instanceMatrix.needsUpdate = true;
  chunk.instancedEdgesThin.instanceColor.needsUpdate = true;

  // Add back to scene
  grid.group.add(chunk.instancedEdgesThin);

  // Update chunk LOD state
  chunk.lodState.edgeSegments = newSegments;
  chunk.lodState.lastRebuildTime = performance.now();
}

// Rebuild thick edge geometry for a single chunk with new segment count
function rebuildChunkThickEdgesWithNewSegments(grid, chunk, chunkKey, newSegments) {
  if (!chunk || !chunk.instancedEdgesThick) return;

  const oldSegments = chunk.lodState.thickEdgeSegments || thickEdgeSegments;
  if (oldSegments === newSegments) return;

  // Remove old mesh from scene
  grid.group.remove(chunk.instancedEdgesThick);
  chunk.instancedEdgesThick.geometry.dispose();
  chunk.instancedEdgesThick.material.dispose();

  // Create new geometry with new segment count
  const thickGeometry = new THREE.CylinderGeometry(thickEdgeRadius, thickEdgeRadius, 1, newSegments);

  // Create material - use ShaderMaterial if arrow textures exist, otherwise basic
  let thickMaterial;
  if (arrowTextureForward) {
    thickMaterial = createThickEdgeShaderMaterial();
  } else {
    thickMaterial = new THREE.MeshBasicMaterial();
  }

  // Create new instanced mesh
  chunk.instancedEdgesThick = new THREE.InstancedMesh(thickGeometry, thickMaterial, chunk.edgeCount);
  chunk.instancedEdgesThick.instanceColor = new THREE.InstancedBufferAttribute(
    new Float32Array(chunk.edgeCount * 3), 3
  );

  // If using shader material, add arrowState attribute
  if (arrowTextureForward) {
    const arrowStateArray = new Float32Array(chunk.edgeCount);
    chunk.instancedEdgesThick.geometry.setAttribute('arrowState',
      new THREE.InstancedBufferAttribute(arrowStateArray, 1)
    );
  }

  // Rebuild all edge instances in this chunk
  const up = new THREE.Vector3(0, 1, 0);
  const matrix = new THREE.Matrix4();
  const quaternion = new THREE.Quaternion();
  const zeroMatrix = new THREE.Matrix4().makeScale(0, 0, 0);

  // Iterate through edges that belong to this chunk
  for (const [eKey, mapping] of chunk.edgeToInstanceMap.entries()) {
    const edge = grid.edges.get(eKey);
    if (!edge) continue;

    const [a, b] = unpackEdge(eKey);

    const start = new THREE.Vector3(...a);
    const end = new THREE.Vector3(...b);
    const direction = new THREE.Vector3().subVectors(end, start);
    const length = direction.length();
    const midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);

    // Build transform matrix
    matrix.makeScale(1, length, 1);
    quaternion.setFromUnitVectors(up, direction.normalize());
    const rotationMatrix = new THREE.Matrix4().makeRotationFromQuaternion(quaternion);
    matrix.premultiply(rotationMatrix);
    matrix.setPosition(midpoint);

    // Thick edges only visible when colored
    if (edge.color !== UNCOLORED_COLOR) {
      chunk.instancedEdgesThick.setMatrixAt(mapping.thick, matrix);
      chunk.instancedEdgesThick.setColorAt(mapping.thick, new THREE.Color(edge.color));
    } else {
      chunk.instancedEdgesThick.setMatrixAt(mapping.thick, zeroMatrix);
      chunk.instancedEdgesThick.setColorAt(mapping.thick, new THREE.Color(0x888888));
    }

    // Update arrow state if using shader
    if (arrowTextureForward && chunk.instancedEdgesThick.geometry.attributes.arrowState) {
      const arrowState = edge.arrowDirection || 0;
      chunk.instancedEdgesThick.geometry.attributes.arrowState.setX(mapping.thick, arrowState);
    }
  }

  // Update buffers
  chunk.instancedEdgesThick.instanceMatrix.needsUpdate = true;
  chunk.instancedEdgesThick.instanceColor.needsUpdate = true;
  if (chunk.instancedEdgesThick.geometry.attributes.arrowState) {
    chunk.instancedEdgesThick.geometry.attributes.arrowState.needsUpdate = true;
  }

  // Add back to scene
  grid.group.add(chunk.instancedEdgesThick);

  // Update chunk LOD state
  chunk.lodState.thickEdgeSegments = newSegments;
  chunk.lodState.lastRebuildTime = performance.now();
}

// Rebuild all thick edges in a grid with new segment count
function rebuildThickEdgesWithNewSegments(grid, newSegments) {
  if (!grid || !grid.isInstanced) return;

  // Handle multi-chunk grids
  if (grid.chunks && grid.chunks.size > 0) {
    for (const [chunkKey, chunk] of grid.chunks.entries()) {
      rebuildChunkThickEdgesWithNewSegments(grid, chunk, chunkKey, newSegments);
    }
    return;
  }

  // Fallback for non-chunked grids (legacy)
  if (!grid.instancedEdgesThick) return;

  // Remove old mesh
  grid.group.remove(grid.instancedEdgesThick);
  grid.instancedEdgesThick.geometry.dispose();
  grid.instancedEdgesThick.material.dispose();

  // Create new geometry
  const thickGeometry = new THREE.CylinderGeometry(thickEdgeRadius, thickEdgeRadius, 1, newSegments);
  const thickMaterial = new THREE.MeshBasicMaterial();
  grid.instancedEdgesThick = new THREE.InstancedMesh(thickGeometry, thickMaterial, grid.edges.size);
  grid.instancedEdgesThick.instanceColor = new THREE.InstancedBufferAttribute(
    new Float32Array(grid.edges.size * 3), 3
  );

  // Rebuild instances...
  const up = new THREE.Vector3(0, 1, 0);
  const matrix = new THREE.Matrix4();
  const quaternion = new THREE.Quaternion();
  const zeroMatrix = new THREE.Matrix4().makeScale(0, 0, 0);

  let thickIndex = 0;
  for (const [eKey, edge] of grid.edges.entries()) {
    const [a, b] = unpackEdge(eKey);

    const start = new THREE.Vector3(...a);
    const end = new THREE.Vector3(...b);
    const direction = new THREE.Vector3().subVectors(end, start);
    const length = direction.length();
    const midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);

    matrix.makeScale(1, length, 1);
    quaternion.setFromUnitVectors(up, direction.normalize());
    const rotationMatrix = new THREE.Matrix4().makeRotationFromQuaternion(quaternion);
    matrix.premultiply(rotationMatrix);
    matrix.setPosition(midpoint);

    if (edge.color !== UNCOLORED_COLOR) {
      grid.instancedEdgesThick.setMatrixAt(thickIndex, matrix);
      grid.instancedEdgesThick.setColorAt(thickIndex, new THREE.Color(edge.color));
    } else {
      grid.instancedEdgesThick.setMatrixAt(thickIndex, zeroMatrix);
    }
    thickIndex++;
  }

  grid.instancedEdgesThick.instanceMatrix.needsUpdate = true;
  grid.instancedEdgesThick.instanceColor.needsUpdate = true;
  grid.group.add(grid.instancedEdgesThick);
}

// Rebuild vertex geometry for a single chunk with new subdivision level
function rebuildChunkVerticesWithNewDetail(grid, chunk, chunkKey, newSubdivisions) {
  if (!chunk || !chunk.instancedVertexSpheres) return;

  // Skip check here - parent function already validated the change is needed
  // This avoids race condition with global vertexSubdivisions being updated before call

  // Remove old mesh from scene
  grid.group.remove(chunk.instancedVertexSpheres);
  chunk.instancedVertexSpheres.geometry.dispose();
  chunk.instancedVertexSpheres.material.dispose();

  // Create new geometry with new subdivision level
  const sphereGeometry = new THREE.IcosahedronGeometry(vertexRadius, newSubdivisions);
  const sphereMaterial = new THREE.MeshBasicMaterial();

  // Create new instanced mesh
  chunk.instancedVertexSpheres = new THREE.InstancedMesh(sphereGeometry, sphereMaterial, chunk.vertexCount);
  chunk.instancedVertexSpheres.count = chunk.vertexCount;
  chunk.instancedVertexSpheres.instanceColor = new THREE.InstancedBufferAttribute(
    new Float32Array(chunk.vertexCount * 3), 3
  );

  // Rebuild all vertex instances in this chunk
  const zeroMatrix = new THREE.Matrix4().makeScale(0, 0, 0);

  // Iterate through vertices that belong to this chunk
  for (const [vKey, vertexIndex] of chunk.vertexToInstanceMap.entries()) {
    const [x, y, z] = unpackVertex(vKey, grid);

    // Check if vertex should be visible
    if (grid.vertexSpheres && grid.vertexSpheres.has(vKey)) {
      // User created sphere - make it visible with user's color
      const matrix = new THREE.Matrix4().setPosition(x, y, z);
      chunk.instancedVertexSpheres.setMatrixAt(vertexIndex, matrix);

      const sphereData = grid.vertexSpheres.get(vKey);
      const vertexColor = new THREE.Color(sphereData.color || 0x888888);
      chunk.instancedVertexSpheres.setColorAt(vertexIndex, vertexColor);
    } else if (showAllVertices) {
      // "Show All Vertices" preference is ON
      const matrix = new THREE.Matrix4().setPosition(x, y, z);
      chunk.instancedVertexSpheres.setMatrixAt(vertexIndex, matrix);
      chunk.instancedVertexSpheres.setColorAt(vertexIndex, new THREE.Color(0x888888));
    } else {
      // Hide vertex
      chunk.instancedVertexSpheres.setMatrixAt(vertexIndex, zeroMatrix);
    }
  }

  // Update buffers
  chunk.instancedVertexSpheres.instanceMatrix.needsUpdate = true;
  chunk.instancedVertexSpheres.instanceColor.needsUpdate = true;

  // Set visibility based on preference
  chunk.instancedVertexSpheres.visible = grid.showAllVertices;

  // Add back to scene
  grid.group.add(chunk.instancedVertexSpheres);

  // Update chunk LOD state
  if (!chunk.lodState) chunk.lodState = {};
  chunk.lodState.vertexDetail = newSubdivisions;
  chunk.lodState.lastRebuildTime = performance.now();
}

// Get edge segments for a given LOD level
function getEdgeSegmentsForChunkLOD(lodLevel) {
  switch (lodLevel) {
    case 3: return edgeSegments;                           // Full detail
    case 2: return Math.max(3, Math.floor(edgeSegments / 2)); // Reduced
    case 1: return 3;                                      // Minimal (for lines mode)
    default: return edgeSegments;
  }
}

// Rebuild all geometry at full detail (when LOD is disabled)
function rebuildAllGeometryAtFullDetail(grid) {
  if (!grid) return;

  console.log('[rebuildAllGeometryAtFullDetail] Rebuilding all chunks at full detail');

  // For chunked grids, rebuild all chunks at full detail (LOD level 3)
  if (grid.chunks && grid.chunks.size > 0) {
    const targetLevel = 3; // Full detail
    const requiredSegments = getEdgeSegmentsForChunkLOD(targetLevel);

    for (const [chunkKey, chunk] of grid.chunks.entries()) {
      if (!chunk.lodState) continue;

      const previousLevel = chunk.lodState.level;
      const wasLineMode = (previousLevel === 1);
      const useLineMode = false; // Level 3 never uses line mode

      // Rebuild edges if needed (not in line mode and segments differ)
      if (!wasLineMode && chunk.lodState.edgeSegments !== requiredSegments) {
        rebuildChunkEdgesWithNewSegments(grid, chunk, chunkKey, requiredSegments);
      }

      // If switching from line mode (level 1) to cylinders (level 3)
      if (wasLineMode && !useLineMode) {
        rebuildChunkEdgesWithNewSegments(grid, chunk, chunkKey, requiredSegments);

        // Make cylinders visible, hide lines
        if (chunk.instancedEdgesThin) chunk.instancedEdgesThin.visible = true;
        if (chunk.instancedEdgesThick) chunk.instancedEdgesThick.visible = true;
        if (chunk.lineEdges) chunk.lineEdges.visible = false;

        // Show proper vertices (spheres instead of points)
        if (chunk.instancedVertexSpheres) chunk.instancedVertexSpheres.visible = grid.showAllVertices;
        if (chunk.pointVertices) chunk.pointVertices.visible = false;
      }

      // Update chunk LOD state
      chunk.lodState.level = targetLevel;
      chunk.lodState.edgeSegments = requiredSegments;
      chunk.lodState.lastRebuildTime = performance.now();
    }
    console.log('[rebuildAllGeometryAtFullDetail] All chunks rebuilt at full detail (level 3)');
  }
  // Legacy non-chunked system (fallback)
  else if (grid.isInstanced) {
    if (grid.instancedEdgesThin) {
      rebuildEdgesWithNewSegments(grid, edgeSegments);
    }
    if (grid.instancedVertexSpheres) {
      rebuildVerticesWithNewDetail(grid, vertexSubdivisions);
    }
  }
}

// Calculate distance from camera to a point
function getDistanceFromCamera(point) {
  if (!camera) return Infinity;

  const cameraPos = camera.position;
  const dx = cameraPos.x - point.x;
  const dy = cameraPos.y - point.y;
  const dz = cameraPos.z - point.z;
  return Math.sqrt(dx * dx + dy * dy + dz * dz);
}

// Check if an edge should always render at full detail (special cases)
function shouldEdgeUseFullDetail(edge, eKey) {
  // Always render at full detail if:
  // 1. Edge has arrows
  if (edge.arrows) return true;

  // 2. Edge is colored (not default gray)
  if (edge.color && edge.color !== UNCOLORED_COLOR) return true;

  // 3. Edge is part of current path being generated (future check)
  // if (currentGrid && currentGrid.currentPath && currentGrid.currentPath.includes(eKey)) return true;

  return false;
}

// Check if a vertex should always render at full detail (special cases)
function shouldVertexUseFullDetail(vertexData, vKey) {
  // Always render at full detail if:
  // 1. Vertex has decoration
  if (currentGrid.vertexSpheres && currentGrid.vertexSpheres.has(vKey)) {
    const sphereData = currentGrid.vertexSpheres.get(vKey);
    if (sphereData.decoration) return true;
  }
  if (currentGrid.standaloneDecorations && currentGrid.standaloneDecorations.has(vKey)) {
    return true;
  }

  // 2. Vertex is colored (not default gray)
  if (vertexData.color && vertexData.color !== 0x888888) return true;

  return false;
}

// Main LOD update function - called each frame from animate()
function updateLOD() {
  if (!currentGrid || !currentGrid.isInstanced || !lodEnabled || !camera) return;

  // Skip if grid rebuild is in progress (forceImmediateLODUpdate will handle it)
  if (lodRebuildInProgress) return;

  const currentTime = performance.now();

  // Rate limiting: Only update LOD if enough time has passed
  const timeSinceLastUpdate = currentTime - lodLastUpdateTime;
  if (timeSinceLastUpdate < lodUpdateInterval) return;

  // Check if we have chunks for per-chunk LOD
  if (!currentGrid.chunks || currentGrid.chunks.size === 0) return;

  // Calculate scaled LOD thresholds based on grid size
  const gridDiagonal = Math.sqrt(
    currentGrid.width * currentGrid.width +
    currentGrid.height * currentGrid.height +
    currentGrid.depth * currentGrid.depth
  );
  const scaleFactor = Math.max(1, gridDiagonal / 20);

  const scaledThresholds = {
    lod3: lodDistanceThresholds.lod3 * scaleFactor,
    lod2: lodDistanceThresholds.lod2 * scaleFactor,
    lod1: lodDistanceThresholds.lod1 * scaleFactor
  };

  // Process each chunk for LOD updates
  for (const [chunkKey, chunk] of currentGrid.chunks.entries()) {
    if (!chunk.center) continue;

    // Skip chunks that are culled (not visible)
    if (frustumCullingEnabled && chunk.isVisible === false) continue;

    // Calculate distance from camera to this chunk's center
    const distance = getDistanceFromCamera(chunk.center);

    // Determine LOD level for this chunk with hysteresis
    let targetLevel;
    const currentLevel = chunk.lodState.level;

    if (distance < scaledThresholds.lod3) {
      targetLevel = 3; // Full detail
    } else if (distance < scaledThresholds.lod2) {
      targetLevel = 2; // Reduced detail
    } else {
      targetLevel = 1; // Lines mode
    }

    // Apply hysteresis to prevent flickering at boundaries
    if (targetLevel !== currentLevel) {
      let threshold;
      if (targetLevel > currentLevel) {
        // Upgrading quality (moving closer) - use lower threshold
        threshold = targetLevel === 3 ? scaledThresholds.lod3 :
                    targetLevel === 2 ? scaledThresholds.lod2 : scaledThresholds.lod1;
        if (distance > threshold * (1 - lodHysteresis)) {
          targetLevel = currentLevel; // Stay at current level
        }
      } else {
        // Downgrading quality (moving farther) - use higher threshold
        threshold = currentLevel === 3 ? scaledThresholds.lod3 :
                    currentLevel === 2 ? scaledThresholds.lod2 : scaledThresholds.lod1;
        if (distance < threshold * (1 + lodHysteresis)) {
          targetLevel = currentLevel; // Stay at current level
        }
      }
    }

    // Queue chunk for rebuild if LOD level changed
    if (targetLevel !== currentLevel) {
      // Check if chunk is already in queue
      const alreadyQueued = lodChunkRebuildQueue.some(
        item => item.chunkKey === chunkKey
      );

      if (!alreadyQueued) {
        lodChunkRebuildQueue.push({
          chunk: chunk,
          chunkKey: chunkKey,
          targetLevel: targetLevel
        });
      }
    }
  }

  // Process rebuild queue (limited per frame to prevent stuttering)
  const rebuildsThisFrame = Math.min(lodMaxChunkRebuildsPerFrame, lodChunkRebuildQueue.length);

  for (let i = 0; i < rebuildsThisFrame; i++) {
    const { chunk, chunkKey, targetLevel } = lodChunkRebuildQueue.shift();

    // Get required segments for target LOD level
    const requiredSegments = getEdgeSegmentsForChunkLOD(targetLevel);

    // Handle LOD 1 (lines mode) vs LOD 2/3 (cylinders)
    const useLineMode = (targetLevel === 1);
    const wasLineMode = (chunk.lodState.level === 1);

    // Rebuild geometry if switching between cylinder LOD levels (2 and 3)
    if (!useLineMode && !wasLineMode) {
      rebuildChunkEdgesWithNewSegments(currentGrid, chunk, chunkKey, requiredSegments);
    }

    // Switch visibility between cylinders and lines
    if (useLineMode !== wasLineMode) {
      if (chunk.instancedEdgesThin) {
        chunk.instancedEdgesThin.visible = !useLineMode;
      }
      if (chunk.instancedEdgesThick) {
        chunk.instancedEdgesThick.visible = !useLineMode;
      }
      if (chunk.lineEdges) {
        chunk.lineEdges.visible = useLineMode;
      }

      // Toggle vertex visibility for this chunk
      if (chunk.instancedVertexSpheres) {
        chunk.instancedVertexSpheres.visible = !useLineMode && showAllVertices;
      }
      if (chunk.pointVertices) {
        chunk.pointVertices.visible = useLineMode && showAllVertices;
      }
    }

    // Update chunk LOD state
    chunk.lodState.level = targetLevel;
    chunk.lodState.lastRebuildTime = currentTime;
  }

  // Update tracking variables
  lodLastUpdateTime = currentTime;
}

// Force immediate LOD evaluation - bypasses cooldowns and hysteresis
// Call this when grid is created or switched to ensure correct initial state
function forceImmediateLODUpdate() {
  if (!currentGrid || !currentGrid.isInstanced || !lodEnabled || !camera) return;

  // Clear any pending rebuild queue
  lodChunkRebuildQueue = [];

  // Check if we have chunks for per-chunk LOD
  if (!currentGrid.chunks || currentGrid.chunks.size === 0) return;

  // Update frustum culling first to establish visibility
  updateFrustumCulling();

  // Calculate scaled LOD thresholds based on grid size
  const gridDiagonal = Math.sqrt(
    currentGrid.width * currentGrid.width +
    currentGrid.height * currentGrid.height +
    currentGrid.depth * currentGrid.depth
  );
  const scaleFactor = Math.max(1, gridDiagonal / 20);

  const scaledThresholds = {
    lod3: lodDistanceThresholds.lod3 * scaleFactor,
    lod2: lodDistanceThresholds.lod2 * scaleFactor,
    lod1: lodDistanceThresholds.lod1 * scaleFactor
  };

  const currentTime = performance.now();

  // Apply LOD to each chunk immediately (no queue)
  for (const [chunkKey, chunk] of currentGrid.chunks.entries()) {
    if (!chunk.center) continue;

    // Skip chunks that are culled (not visible)
    if (frustumCullingEnabled && chunk.isVisible === false) continue;

    // Calculate distance from camera to this chunk's center
    const distance = getDistanceFromCamera(chunk.center);

    // Determine LOD level WITHOUT hysteresis
    let targetLevel;
    if (distance < scaledThresholds.lod3) {
      targetLevel = 3; // Full detail
    } else if (distance < scaledThresholds.lod2) {
      targetLevel = 2; // Reduced detail
    } else {
      targetLevel = 1; // Lines mode
    }

    // Get required segments for target LOD level
    const requiredSegments = getEdgeSegmentsForChunkLOD(targetLevel);

    // Handle LOD 1 (lines mode) vs LOD 2/3 (cylinders)
    const useLineMode = (targetLevel === 1);

    // Rebuild geometry if needed
    if (chunk.lodState.edgeSegments !== requiredSegments && !useLineMode) {
      rebuildChunkEdgesWithNewSegments(currentGrid, chunk, chunkKey, requiredSegments);
    }

    // Set visibility
    if (chunk.instancedEdgesThin) {
      chunk.instancedEdgesThin.visible = !useLineMode;
    }
    if (chunk.instancedEdgesThick) {
      chunk.instancedEdgesThick.visible = !useLineMode;
    }
    if (chunk.lineEdges) {
      chunk.lineEdges.visible = useLineMode;
    }

    // Toggle vertex visibility for this chunk
    if (chunk.instancedVertexSpheres) {
      chunk.instancedVertexSpheres.visible = !useLineMode && showAllVertices;
    }
    if (chunk.pointVertices) {
      chunk.pointVertices.visible = useLineMode && showAllVertices;
    }

    // Update chunk LOD state
    chunk.lodState.level = targetLevel;
    chunk.lodState.lastRebuildTime = currentTime;
  }

  // Reset timing to allow normal updates
  lodLastUpdateTime = currentTime;
}

// Calculate center point of the grid
function calculateGridCenter() {
  if (!currentGrid || !currentGrid.vertices || currentGrid.vertices.size === 0) {
    return null;
  }

  let sumX = 0, sumY = 0, sumZ = 0;
  let count = 0;

  for (const vKey of currentGrid.vertices.keys()) {
    const [x, y, z] = unpackVertex(vKey, currentGrid);
    sumX += x;
    sumY += y;
    sumZ += z;
    count++;
  }

  return {
    x: sumX / count,
    y: sumY / count,
    z: sumZ / count
  };
}


//     ----- Vertex Operations -----

// Vertex sphere undo/redo functions
function undoVertexSphere(actionData) {
  const { vertexKey, beforeState } = actionData;
  
  if (beforeState === null) {
    // Sphere was added, so remove it
    removeVertexSphere(currentGrid, vertexKey);
  } else {
    // Sphere was removed or changed, so restore it
    if (currentGrid.vertexSpheres.has(vertexKey)) {
      removeVertexSphere(currentGrid, vertexKey);
    }
    
    createVertexSphere(currentGrid, vertexKey, beforeState.color);
    
    if (beforeState.hasDecoration) {
      addVertexDecoration(currentGrid, vertexKey, beforeState.decorationColor);
    }
  }
}

function redoVertexSphere(actionData) {
  const { vertexKey, afterState } = actionData;
  
  if (afterState === null) {
    // Remove the sphere
    removeVertexSphere(currentGrid, vertexKey);
  } else {
    // Add or modify the sphere
    if (currentGrid.vertexSpheres.has(vertexKey)) {
      removeVertexSphere(currentGrid, vertexKey);
    }
    
    createVertexSphere(currentGrid, vertexKey, afterState.color);
    
    if (afterState.hasDecoration) {
      addVertexDecoration(currentGrid, vertexKey, afterState.decorationColor);
    }
  }
}

// Vertex decoration undo/redo functions
function undoVertexDecoration(actionData) {
  const { vertexKey, beforeState } = actionData;

  // Handle both vertex-attached and standalone decorations
  let hasExistingDecoration = false;
  let existingDecorationGroup = null;

  // Check if decoration is on an existing vertex sphere
  if (currentGrid.vertexSpheres.has(vertexKey)) {
    const sphereData = currentGrid.vertexSpheres.get(vertexKey);
    if (sphereData.decoration) {
      hasExistingDecoration = true;
      existingDecorationGroup = sphereData.decoration;
    }
  } else if (currentGrid.standaloneDecorations.has(vertexKey)) {
    // Check if decoration is standalone (on non-existing vertex)
    hasExistingDecoration = true;
    existingDecorationGroup = currentGrid.standaloneDecorations.get(vertexKey).decorationGroup;
  }

  // Remove current decoration if exists
  if (hasExistingDecoration && existingDecorationGroup) {
    currentGrid.group.remove(existingDecorationGroup);
    if (existingDecorationGroup.children) {
      existingDecorationGroup.children.forEach(child => {
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
      });
    }

    // Clean up tracking
    if (currentGrid.vertexSpheres.has(vertexKey)) {
      currentGrid.vertexSpheres.get(vertexKey).decoration = null;
    } else if (currentGrid.standaloneDecorations.has(vertexKey)) {
      currentGrid.standaloneDecorations.delete(vertexKey);
    }
  }

  // Restore previous decoration state
  if (beforeState && beforeState.hasDecoration) {
    addVertexDecoration(currentGrid, vertexKey, beforeState.decorationColor);
  }
}

function redoVertexDecoration(actionData) {
  const { vertexKey, afterState } = actionData;

  // Handle both vertex-attached and standalone decorations
  let hasExistingDecoration = false;
  let existingDecorationGroup = null;

  // Check if decoration is on an existing vertex sphere
  if (currentGrid.vertexSpheres.has(vertexKey)) {
    const sphereData = currentGrid.vertexSpheres.get(vertexKey);
    if (sphereData.decoration) {
      hasExistingDecoration = true;
      existingDecorationGroup = sphereData.decoration;
    }
  } else if (currentGrid.standaloneDecorations.has(vertexKey)) {
    // Check if decoration is standalone (on non-existing vertex)
    hasExistingDecoration = true;
    existingDecorationGroup = currentGrid.standaloneDecorations.get(vertexKey).decorationGroup;
  }

  // Remove current decoration if exists
  if (hasExistingDecoration && existingDecorationGroup) {
    currentGrid.group.remove(existingDecorationGroup);
    if (existingDecorationGroup.children) {
      existingDecorationGroup.children.forEach(child => {
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
      });
    }

    // Clean up tracking
    if (currentGrid.vertexSpheres.has(vertexKey)) {
      currentGrid.vertexSpheres.get(vertexKey).decoration = null;
    } else if (currentGrid.standaloneDecorations.has(vertexKey)) {
      currentGrid.standaloneDecorations.delete(vertexKey);
    }
  }

  // Apply new decoration state
  if (afterState && afterState.hasDecoration) {
    addVertexDecoration(currentGrid, vertexKey, afterState.decorationColor);
  }
}



// Add a new action type for BB Distance batch operations
function recordBBDistanceBatch(vertexKeys, refVertexKey) {
  if (!currentGrid) return;
  
  const action = {
    type: 'BB_DISTANCE_BATCH',
    data: {
      vertexKeys: [...vertexKeys], // All vertices colored at distance
      refVertexKey: refVertexKey,   // The v* vertex
      mainColor: selectedColor,
      secondColor: selectedColor2
    },
    timestamp: Date.now()
  };
  
  currentGrid.undoStack.push(action);
  currentGrid.redoStack = [];
  
  if (currentGrid.undoStack.length > currentGrid.maxUndoSteps) {
    currentGrid.undoStack.shift();
  }
}

// Undo/redo functions for BB Distance batches
function undoBBDistanceBatch(actionData) {
  const { vertexKeys, refVertexKey } = actionData;
  
  // Remove all colored vertices
  for (const vKey of vertexKeys) {
    removeVertexSphere(currentGrid, vKey);
  }
  
  // Remove the reference vertex
  removeVertexSphere(currentGrid, refVertexKey);
}

function redoBBDistanceBatch(actionData) {
  const { vertexKeys, refVertexKey, mainColor, secondColor } = actionData;
  
  // Restore reference vertex with second color
  createVertexSphere(currentGrid, refVertexKey, secondColor);
  
  // Restore all distance vertices with main color
  for (const vKey of vertexKeys) {
    createVertexSphere(currentGrid, vKey, mainColor);
  }
}


function undoClearAllVertices(actionData) {
  const { clearedVertices } = actionData;
  
  // Restore all cleared vertices
  for (const vertexData of clearedVertices) {
    createVertexSphere(currentGrid, vertexData.vertexKey, vertexData.color);
    // Note: decorations aren't restored (they're created separately via decoration tool)
  }
  
  console.log(`Restored ${clearedVertices.length} vertex spheres`);
}

function redoClearAllVertices(actionData) {
  const { clearedVertices } = actionData;
  
  // Clear them all again
  for (const vertexData of clearedVertices) {
    removeVertexSphere(currentGrid, vertexData.vertexKey);
  }
  
  console.log(`Re-cleared ${clearedVertices.length} vertex spheres`);
}


//     ----- Edge Operations -----

// Edge state undo/redo functions
function undoEdgeState(actionData) {
  const { edgeKey, beforeState } = actionData;
  const [a, b] = unpackEdge(edgeKey, currentGrid);

  const edge = currentGrid.edges.get(edgeKey);
  if (!edge) return;

  // Remove current arrows
  if (edge.arrows) {
    removeArrowsFromEdge(edge);
  }

  // Remove current block cube
  if (edge.blockCube) {
    if (currentGrid.isInstanced) {
      removeBlockCubeInstanced(currentGrid, edge, edgeKey);
    } else {
      removeBlockCube(edge);
    }
  }

  // Restore previous state
  colorEdge(currentGrid, a, b, beforeState.color, beforeState.color === UNCOLORED_COLOR ? thinEdgeRadius : thickEdgeRadius);

  if (beforeState.hasArrows && beforeState.arrowDirection) {
    addArrowsToEdge(edge, beforeState.arrowDirection);
  }

  if (beforeState.hasBlockCube) {
    if (currentGrid.isInstanced) {
      addBlockCubeInstanced(currentGrid, edge, edgeKey);
    } else {
      addBlockCube(edge);
    }
  }
}

function redoEdgeState(actionData) {
  const { edgeKey, afterState } = actionData;
  const [a, b] = unpackEdge(edgeKey, currentGrid);

  const edge = currentGrid.edges.get(edgeKey);
  if (!edge) return;

  // Remove current arrows
  if (edge.arrows) {
    removeArrowsFromEdge(edge);
  }

  // Remove current block cube
  if (edge.blockCube) {
    if (currentGrid.isInstanced) {
      removeBlockCubeInstanced(currentGrid, edge, edgeKey);
    } else {
      removeBlockCube(edge);
    }
  }

  // Apply new state
  colorEdge(currentGrid, a, b, afterState.color, afterState.color === UNCOLORED_COLOR ? thinEdgeRadius : thickEdgeRadius);

  if (afterState.hasArrows && afterState.arrowDirection) {
    addArrowsToEdge(edge, afterState.arrowDirection);
  }

  if (afterState.hasBlockCube) {
    if (currentGrid.isInstanced) {
      addBlockCubeInstanced(currentGrid, edge, edgeKey);
    } else {
      addBlockCube(edge);
    }
  }
}


//     ----- Layer Operations -----

// Layer operation undo/redo functions
async function undoLayerOperation(actionData) {
  console.log('[undoLayerOperation] *** UNDO LAYER CALLED ***', actionData);
  const { beforeState } = actionData;

  // Save current camera state
  const currentCameraPos = camera.position.clone();
  const currentCameraTarget = controls.target.clone();

  // Clear current grid contents
  clearCurrentGridContents();

  // Restore from complete state snapshot
  console.log('[undoLayerOperation] About to call restoreGridFromSnapshot...');
  await restoreGridFromSnapshot(beforeState);
  console.log('[undoLayerOperation] restoreGridFromSnapshot completed');

  // Restore camera
  camera.position.copy(currentCameraPos);
  controls.target.copy(currentCameraTarget);
  controls.update();
}

async function redoLayerOperation(actionData) {
  const { afterState } = actionData;

  // Save current camera state
  const currentCameraPos = camera.position.clone();
  const currentCameraTarget = controls.target.clone();

  // Clear current grid contents
  clearCurrentGridContents();

  // Restore from complete state snapshot
  await restoreGridFromSnapshot(afterState);

  // Restore camera
  camera.position.copy(currentCameraPos);
  controls.target.copy(currentCameraTarget);
  controls.update();
}


//     ----- Path Operations -----

// Backbite undo/redo handlers
function undoBackbite(data) {
  currentGrid.path = [...data.oldPath];
  currentPath = currentGrid.path;

  // Rebuild subgraph and update visuals in batch mode
  batchMode = true;  // Use GLOBAL batchMode, not currentGrid.batchMode
  currentGrid.activeSubgraph.clear();
  for (let i = 0; i < currentGrid.path.length - 1; i++) {
    const a = unpackVertex(currentGrid.path[i], currentGrid);
    const b = unpackVertex(currentGrid.path[i + 1], currentGrid);
    currentGrid.activeSubgraph.addEdge(a, b);
  }

  // Update visuals (still in batch mode)
  if (gradientMode) {
    applyGradientToPath();
  } else {
    updateEdgeMeshesFromSubgraph(currentGrid, currentGrid.activeSubgraph);
  }

  batchMode = false;

  // Sync GPU once after all batch operations
  if (currentGrid.chunks) {
    for (const chunk of currentGrid.chunks.values()) {
      if (chunk.instancedEdgesThin) {
        chunk.instancedEdgesThin.instanceMatrix.needsUpdate = true;
        chunk.instancedEdgesThin.instanceColor.needsUpdate = true;
      }
      if (chunk.instancedEdgesThick) {
        chunk.instancedEdgesThick.instanceMatrix.needsUpdate = true;
        chunk.instancedEdgesThick.instanceColor.needsUpdate = true;
      }
    }
  }

  updateEndpointMarkers();

  if (arrowMode && currentGrid.path) {
    // OPTIMIZATION: Only remove arrows from path edges, not all grid edges
    currentGrid.batchMode = true;
    if (currentGrid.edgeToArrowInstanceMap && currentGrid.edgeToArrowInstanceMap.size > 0) {
      const arrowEdgeKeys = Array.from(currentGrid.edgeToArrowInstanceMap.keys());
      for (const eKey of arrowEdgeKeys) {
        const edge = currentGrid.edges.get(eKey);
        if (edge) {
          removeArrowsFromEdge(edge, eKey);
        }
      }
    }

    addDirectionalArrowsToPath(currentGrid.path);
    currentGrid.batchMode = false;

    // Sync GPU once after batch operation
    if (currentGrid.instancedArrowsForward) {
      currentGrid.instancedArrowsForward.instanceMatrix.needsUpdate = true;
    }
    if (currentGrid.instancedArrowsBackward) {
      currentGrid.instancedArrowsBackward.instanceMatrix.needsUpdate = true;
    }
    updateArrowInstanceCounts(currentGrid);
  }
}

function redoBackbite(data) {
  currentGrid.path = [...data.newPath];
  currentPath = currentGrid.path;

  // Rebuild subgraph and update visuals in batch mode
  batchMode = true;  // Use GLOBAL batchMode, not currentGrid.batchMode
  currentGrid.activeSubgraph.clear();
  for (let i = 0; i < currentGrid.path.length - 1; i++) {
    const a = unpackVertex(currentGrid.path[i], currentGrid);
    const b = unpackVertex(currentGrid.path[i + 1], currentGrid);
    currentGrid.activeSubgraph.addEdge(a, b);
  }

  // Update visuals (still in batch mode)
  if (gradientMode) {
    applyGradientToPath();
  } else {
    updateEdgeMeshesFromSubgraph(currentGrid, currentGrid.activeSubgraph);
  }

  batchMode = false;

  // Sync GPU once after all batch operations
  if (currentGrid.chunks) {
    for (const chunk of currentGrid.chunks.values()) {
      if (chunk.instancedEdgesThin) {
        chunk.instancedEdgesThin.instanceMatrix.needsUpdate = true;
        chunk.instancedEdgesThin.instanceColor.needsUpdate = true;
      }
      if (chunk.instancedEdgesThick) {
        chunk.instancedEdgesThick.instanceMatrix.needsUpdate = true;
        chunk.instancedEdgesThick.instanceColor.needsUpdate = true;
      }
    }
  }

  updateEndpointMarkers();

  if (arrowMode && currentGrid.path) {
    // OPTIMIZATION: Only remove arrows from path edges, not all grid edges
    currentGrid.batchMode = true;
    if (currentGrid.edgeToArrowInstanceMap && currentGrid.edgeToArrowInstanceMap.size > 0) {
      const arrowEdgeKeys = Array.from(currentGrid.edgeToArrowInstanceMap.keys());
      for (const eKey of arrowEdgeKeys) {
        const edge = currentGrid.edges.get(eKey);
        if (edge) {
          removeArrowsFromEdge(edge, eKey);
        }
      }
    }

    addDirectionalArrowsToPath(currentGrid.path);
    currentGrid.batchMode = false;

    // Sync GPU once after batch operation
    if (currentGrid.instancedArrowsForward) {
      currentGrid.instancedArrowsForward.instanceMatrix.needsUpdate = true;
    }
    if (currentGrid.instancedArrowsBackward) {
      currentGrid.instancedArrowsBackward.instanceMatrix.needsUpdate = true;
    }
    updateArrowInstanceCounts(currentGrid);
  }
}



// Switch undo/redo handlers (EFFICIENT VERSION)
function undoSwitch(data) {
  // Restore old path
  currentGrid.path = [...data.oldPath];
  currentPath = currentGrid.path;
  
  // Update subgraph: remove what was added, add back what was removed
  for (const eKey of data.edgesAdded) {
    currentGrid.activeSubgraph.edges.delete(eKey);
    const [a, b] = unpackEdge(eKey, currentGrid);
    const v1 = vertexKey(a[0], a[1], a[2], currentGrid);
    const v2 = vertexKey(b[0], b[1], b[2], currentGrid);
    // Check if vertices should be removed
    if (currentGrid.activeSubgraph.getNeighbors(v1).length === 0) {
      currentGrid.activeSubgraph.vertices.delete(v1);
    }
    if (currentGrid.activeSubgraph.getNeighbors(v2).length === 0) {
      currentGrid.activeSubgraph.vertices.delete(v2);
    }
  }

  for (const eKey of data.edgesRemoved) {
    currentGrid.activeSubgraph.edges.add(eKey);
    const [a, b] = unpackEdge(eKey, currentGrid);
    currentGrid.activeSubgraph.vertices.add(vertexKey(a[0], a[1], a[2], currentGrid));
    currentGrid.activeSubgraph.vertices.add(vertexKey(b[0], b[1], b[2], currentGrid));
  }
  
  // Update only the 4 edges that changed (not all edges)
  const changedEdges = [...data.edgesAdded, ...data.edgesRemoved];
  for (const eKey of changedEdges) {
    const edge = currentGrid.edges.get(eKey);
    if (!edge) continue;
    
    // Check if this edge is now in the subgraph
    const isInSubgraph = currentGrid.activeSubgraph.edges.has(eKey);
    const color = isInSubgraph ? selectedColor : UNCOLORED_COLOR;
    const width = isInSubgraph ? thickEdgeRadius : thinEdgeRadius;
    
    edge.color = color;
    
    const [a, b] = unpackEdge(eKey, currentGrid);

    if (currentGrid.isInstanced) {
      colorEdgeInstanced(currentGrid, a, b, color, width);
    } else {
      if (edge.mesh) {
        currentGrid.group.remove(edge.mesh);
        edge.mesh.geometry.dispose();
        edge.mesh.material.dispose();
      }
      const newMesh = makeEdgeMesh(a, b, color, width);
      edge.mesh = newMesh;
      currentGrid.group.add(newMesh);
    }
  }
  
  // Update cycle reference
  currentGrid.cycle = currentGrid.activeSubgraph;
  
  // Update endpoint markers (only for paths, not cycles)
  const totalVertices = currentGrid.width * currentGrid.height * currentGrid.depth;
  const totalEdges = currentGrid.activeSubgraph.edges.size;
  const isCycle = (totalEdges === totalVertices);
  
  if (isCycle) {
    clearEndpointMarkers(currentGrid);
  } else {
    updateEndpointMarkers(currentGrid);
  }
  
  // Reapply gradient if active
  if (gradientMode) {
    applyGradientToPath();
  }
  
  // Update arrows if active
  if (arrowMode && currentGrid.path) {
    for (const [key, edge] of currentGrid.edges.entries()) {
      removeArrowsFromEdge(edge);
    }
    addDirectionalArrowsToPath(currentGrid.path);
  }
  
  // Component coloring (if enabled)
  if (componentColoringEnabled) {
    const adj = buildAdjacencyFromEdgeSet(currentGrid, currentGrid.activeSubgraph.getEdgeKeys());
    const vertexComponent = labelComponents(adj);
    const numComponents = new Set(vertexComponent.values()).size;
    
    if (numComponents >= 2) {
      // Multiple components - color by component
      const componentColors = [selectedColor, selectedColor2];

      for (const eKey of currentGrid.activeSubgraph.getEdgeKeys()) {
        const [a, b] = unpackEdge(eKey, currentGrid);
        const aKey = vertexKey(a[0], a[1], a[2], currentGrid);
        const componentId = vertexComponent.get(aKey);
        const color = componentColors[componentId % componentColors.length];

        if (currentGrid.isInstanced) {
          colorEdgeInstanced(currentGrid, a, b, color, thickEdgeRadius);
        } else {
          colorEdge(currentGrid, a, b, color, thickEdgeRadius);
        }
      }
    } else {
      // Single component - restore uniform coloring
      for (const eKey of currentGrid.activeSubgraph.getEdgeKeys()) {
        const [a, b] = unpackEdge(eKey, currentGrid);
        
        if (currentGrid.isInstanced) {
          colorEdgeInstanced(currentGrid, a, b, selectedColor, thickEdgeRadius);
        } else {
          colorEdge(currentGrid, a, b, selectedColor, thickEdgeRadius);
        }
      }
    }
  }
  
  // Box highlighting (if enabled)
  if (boxHighlightingEnabled && currentGrid.isInstanced) {
    if (currentGrid.highlightDebounceTimer) clearTimeout(currentGrid.highlightDebounceTimer);
    
    currentGrid.highlightDebounceTimer = setTimeout(() => {
      clearBoxHighlights();
      
      const adj = buildAdjacencyFromEdgeSet(currentGrid, currentGrid.activeSubgraph.getEdgeKeys());
      const vertexComponent = labelComponents(adj);
      const numComponents = new Set(vertexComponent.values()).size;
      
      if (numComponents >= 2) {
        const borderBoxes = getGeneralBorderBoxes(currentGrid, vertexComponent, currentGrid.activeSubgraph);
        if (borderBoxes.length > 0) {
          highlightBoxes(borderBoxes, boxHighlightColor);
          currentGrid.highlightedBoxes = borderBoxes;
        }
      } else {
        clearBoxHighlights();
      }
    }, 150);
  }
  
  console.log("Switch undone");
}

function redoSwitch(data) {
  // Restore new path
  currentGrid.path = [...data.newPath];
  currentPath = currentGrid.path;
  
  // Update subgraph: add what was added, remove what was removed
  for (const eKey of data.edgesRemoved) {
    currentGrid.activeSubgraph.edges.delete(eKey);
    const [a, b] = unpackEdge(eKey, currentGrid);
    const v1 = vertexKey(a[0], a[1], a[2], currentGrid);
    const v2 = vertexKey(b[0], b[1], b[2], currentGrid);
    // Check if vertices should be removed
    if (currentGrid.activeSubgraph.getNeighbors(v1).length === 0) {
      currentGrid.activeSubgraph.vertices.delete(v1);
    }
    if (currentGrid.activeSubgraph.getNeighbors(v2).length === 0) {
      currentGrid.activeSubgraph.vertices.delete(v2);
    }
  }

  for (const eKey of data.edgesAdded) {
    currentGrid.activeSubgraph.edges.add(eKey);
    const [a, b] = unpackEdge(eKey, currentGrid);
    currentGrid.activeSubgraph.vertices.add(vertexKey(a[0], a[1], a[2], currentGrid));
    currentGrid.activeSubgraph.vertices.add(vertexKey(b[0], b[1], b[2], currentGrid));
  }
  
  // Update only the 4 edges that changed (not all edges)
  const changedEdges = [...data.edgesAdded, ...data.edgesRemoved];
  for (const eKey of changedEdges) {
    const edge = currentGrid.edges.get(eKey);
    if (!edge) continue;
    
    // Check if this edge is now in the subgraph
    const isInSubgraph = currentGrid.activeSubgraph.edges.has(eKey);
    const color = isInSubgraph ? selectedColor : UNCOLORED_COLOR;
    const width = isInSubgraph ? thickEdgeRadius : thinEdgeRadius;
    
    edge.color = color;
    
    const [a, b] = unpackEdge(eKey, currentGrid);

    if (currentGrid.isInstanced) {
      colorEdgeInstanced(currentGrid, a, b, color, width);
    } else {
      if (edge.mesh) {
        currentGrid.group.remove(edge.mesh);
        edge.mesh.geometry.dispose();
        edge.mesh.material.dispose();
      }
      const newMesh = makeEdgeMesh(a, b, color, width);
      edge.mesh = newMesh;
      currentGrid.group.add(newMesh);
    }
  }
  
  // Update cycle reference
  currentGrid.cycle = currentGrid.activeSubgraph;
  
  // Update endpoint markers (only for paths, not cycles)
  const totalVertices = currentGrid.width * currentGrid.height * currentGrid.depth;
  const totalEdges = currentGrid.activeSubgraph.edges.size;
  const isCycle = (totalEdges === totalVertices);
  
  if (isCycle) {
    clearEndpointMarkers(currentGrid);
  } else {
    updateEndpointMarkers(currentGrid);
  }
  
  // Reapply gradient if active
  if (gradientMode) {
    applyGradientToPath();
  }
  
  // Update arrows if active
  if (arrowMode && currentGrid.path) {
    for (const [key, edge] of currentGrid.edges.entries()) {
      removeArrowsFromEdge(edge);
    }
    addDirectionalArrowsToPath(currentGrid.path);
  }
  
  // Component coloring (if enabled)
  if (componentColoringEnabled) {
    const adj = buildAdjacencyFromEdgeSet(currentGrid, currentGrid.activeSubgraph.getEdgeKeys());
    const vertexComponent = labelComponents(adj);
    const numComponents = new Set(vertexComponent.values()).size;
    
    if (numComponents >= 2) {
      // Multiple components - color by component
      const componentColors = [selectedColor, selectedColor2];

      for (const eKey of currentGrid.activeSubgraph.getEdgeKeys()) {
        const [a, b] = unpackEdge(eKey, currentGrid);
        const aKey = vertexKey(a[0], a[1], a[2], currentGrid);
        const componentId = vertexComponent.get(aKey);
        const color = componentColors[componentId % componentColors.length];

        if (currentGrid.isInstanced) {
          colorEdgeInstanced(currentGrid, a, b, color, thickEdgeRadius);
        } else {
          colorEdge(currentGrid, a, b, color, thickEdgeRadius);
        }
      }
    } else {
      // Single component - restore uniform coloring
      for (const eKey of currentGrid.activeSubgraph.getEdgeKeys()) {
        const [a, b] = unpackEdge(eKey, currentGrid);
        
        if (currentGrid.isInstanced) {
          colorEdgeInstanced(currentGrid, a, b, selectedColor, thickEdgeRadius);
        } else {
          colorEdge(currentGrid, a, b, selectedColor, thickEdgeRadius);
        }
      }
    }
  }
  
  // Box highlighting (if enabled)
  if (boxHighlightingEnabled && currentGrid.isInstanced) {
    if (currentGrid.highlightDebounceTimer) clearTimeout(currentGrid.highlightDebounceTimer);
    
    currentGrid.highlightDebounceTimer = setTimeout(() => {
      clearBoxHighlights();
      
      const adj = buildAdjacencyFromEdgeSet(currentGrid, currentGrid.activeSubgraph.getEdgeKeys());
      const vertexComponent = labelComponents(adj);
      const numComponents = new Set(vertexComponent.values()).size;
      
      if (numComponents >= 2) {
        const borderBoxes = getGeneralBorderBoxes(currentGrid, vertexComponent, currentGrid.activeSubgraph);
        if (borderBoxes.length > 0) {
          highlightBoxes(borderBoxes, boxHighlightColor);
          currentGrid.highlightedBoxes = borderBoxes;
        }
      } else {
        clearBoxHighlights();
      }
    }, 150);
  }
  
  console.log("Switch redone");
}
















//     ====================================================================================================================
// 											   2. GRID LAYER EXPANSION/REMOVAL
//     ====================================================================================================================



//     =======================================
// 		*** 2.1 Layer Expansion functions ***
//     =======================================

async function expandCurrentGrid(direction) {
  if (!currentGrid) {
    alert("No grid to expand");
    return;
  }

  // Save old grid dimensions BEFORE rebuilding
  const oldDims = {
    width: currentGrid.width,
    height: currentGrid.height,
    depth: currentGrid.depth
  };

  // Use the existing serialization method that we know works
  const savedSubgraph = serializeCurrentSubgraph();
  const savedCameraPos = camera.position.clone();
  const savedCameraTarget = controls.target.clone();

  // Capture complete state AFTER serialization but BEFORE any changes
  const beforeState = captureCompleteGridState();

  // Calculate new dimensions and translation
  const { newDims, coordTranslation } = calculateExpansion(direction);

  // Store current grid ID for UI preservation
  const currentGridId = getCurrentGridId();

  // Rebuild grid structure - MUST AWAIT for grid to be fully built
  await rebuildGridWithDimensions(newDims);

  // Restore translated subgraph using the working method
  restoreTranslatedSubgraph(savedSubgraph, coordTranslation, oldDims, newDims);

  // Update camera proportionally
  updateCameraForNewDimensions(savedCameraPos, savedCameraTarget, newDims);

  // Capture state after expansion and record action
  const afterState = captureCompleteGridState();
  recordAction('LAYER_OPERATION', { beforeState, afterState });

  console.log(`Grid expanded ${direction}: ${newDims.width}×${newDims.height}×${newDims.depth}`);
}

function calculateExpansion(direction) {
  const oldDims = {
    width: currentGrid.width,
    height: currentGrid.height, 
    depth: currentGrid.depth
  };
  
  const newDims = { ...oldDims };
  const coordTranslation = { x: 0, y: 0, z: 0 };
  
  switch(direction) {
    case "x+": // Far X
      newDims.width += 1;
      break;
    case "x-": // Near X  
      newDims.width += 1;
      coordTranslation.x = 1;
      break;
    case "y+": // Far Y
      newDims.height += 1;
      break;
    case "y-": // Near Y
      newDims.height += 1;
      coordTranslation.y = 1;
      break;
    case "z+": // Far Z
      newDims.depth += 1;
      break;
    case "z-": // Near Z
      newDims.depth += 1;
      coordTranslation.z = 1;
      break;
    default:
      throw new Error(`Invalid direction: ${direction}`);
  }
  
  return { newDims, coordTranslation };
}

function serializeCurrentSubgraph() {
  if (!currentGrid || !currentGrid.edges) return null;
  
  const subgraphData = {
    coloredEdges: [],
    vertexSpheres: new Map(),
    path: currentGrid.path ? [...currentGrid.path] : null,
    hasActiveSubgraph: !!currentGrid.activeSubgraph,
    isCycle: !!currentGrid.cycle
  };
  
  // Save all edges that need saving (colored OR have block cubes OR have arrows OR have arrow direction)
  for (const [edgeKey, edge] of currentGrid.edges.entries()) {
    const needsSaving = edge.color !== UNCOLORED_COLOR ||
                       !!edge.blockCube ||
                       !!edge.arrows ||
                       (edge.arrowDirection !== undefined && edge.arrowDirection !== 0);

    if (needsSaving) {
      subgraphData.coloredEdges.push({
        key: edgeKey,
        color: edge.color,
        arrowDirection: edge.arrowDirection || 0,
        hasArrows: !!edge.arrows,
        hasBlockCube: !!edge.blockCube
      });
    }
  }
  
  // Save vertex spheres - FIXED to handle new format
  if (currentGrid.vertexSpheres) {
    for (const [vertexKey, sphereData] of currentGrid.vertexSpheres.entries()) {
      // Handle both old format (direct sphere) and new format (sphere/decoration object)
      let sphere, decoration, color;
      if (sphereData.sphere) {
        // New format
        sphere = sphereData.sphere;
        decoration = sphereData.decoration;

        // Get color (works for both instanced and individual mode)
        if (currentGrid.isInstanced) {
          color = sphereData.color;
        } else {
          color = sphere.material.color.getHex();
        }
      } else {
        // Old format - sphereData is the sphere itself
        sphere = sphereData;
        decoration = null;
        color = sphere.material.color.getHex();
      }

      const vertexInfo = {
        color: color
      };

      if (decoration) {
        vertexInfo.hasDecoration = true;
        if (decoration.children && decoration.children.length > 0) {
          vertexInfo.decorationColor = decoration.children[0].material.color.getHex();
        }
      }

      subgraphData.vertexSpheres.set(vertexKey, vertexInfo);
    }
  }

  // Save standalone decorations (decorations without vertex spheres)
  if (currentGrid.standaloneDecorations) {
    if (!subgraphData.standaloneDecorations) {
      subgraphData.standaloneDecorations = new Map();
    }

    for (const [vertexKey, decorationData] of currentGrid.standaloneDecorations.entries()) {
      let decorationColor;
      if (decorationData.decorationGroup && decorationData.decorationGroup.children && decorationData.decorationGroup.children.length > 0) {
        decorationColor = decorationData.decorationGroup.children[0].material.color.getHex();
      }

      if (decorationColor !== undefined) {
        subgraphData.standaloneDecorations.set(vertexKey, {
          decorationColor: decorationColor
        });
      }
    }
  }

  // Save arrow continuity tracking
  if (currentGrid.lastArrowedEdgeAtVertex) {
    subgraphData.lastArrowedEdgeAtVertex = new Map(currentGrid.lastArrowedEdgeAtVertex);
  }

  return subgraphData;
}

async function rebuildGridWithDimensions(newDims) {
  // Block LOD updates during rebuild to prevent race conditions
  lodRebuildInProgress = true;

  // Clear current grid visuals but preserve the grid slot
  clearCurrentGridContents();

  // Update global dimensions for rebuilding
  GRID_WIDTH = newDims.width;
  GRID_HEIGHT = newDims.height;
  GRID_DEPTH = newDims.depth;

  // Update grid properties
  currentGrid.width = newDims.width;
  currentGrid.height = newDims.height;
  currentGrid.depth = newDims.depth;

  // Rebuild grid structure - MUST AWAIT since buildGridContent is async!
  await buildGridContent(currentGrid);

  // CRITICAL: Load collision meshes and instanced geometries before restoring states
  // Otherwise edges, block cubes, and vertices won't be clickable after add/remove layer
  if (currentGrid.isInstanced) {
    loadEdgeCollision(currentGrid);
    loadBlockCubes(currentGrid);
    loadVertexSpheres(currentGrid);

    // If arrow mode is ON, load arrow geometries so arrows can be restored
    if (arrowMode && lazyLoadArrows) {
      loadArrows(currentGrid);
    }
  }

  // Apply "Show All Vertices" preference to new layer(s)
  // This ensures newly added vertices respect the checkbox state
  if (currentGrid.isInstanced && showAllVertices) {
    const grayColor = new THREE.Color(0x888888);
    const identityMatrix = new THREE.Matrix4();

    // Handle chunk-based rendering
    if (currentGrid.chunks && currentGrid.chunks.size > 0) {
      for (const chunk of currentGrid.chunks.values()) {
        if (!chunk.instancedVertexSpheres || !chunk.vertexToInstanceMap) continue;

        for (const [vKey, instanceIndex] of chunk.vertexToInstanceMap.entries()) {
          const hasColoredSphere = currentGrid.vertexSpheres?.has(vKey) &&
                                   currentGrid.vertexSpheres.get(vKey).color !== 0x888888;

          if (!hasColoredSphere) {
            const [x, y, z] = unpackVertex(vKey, currentGrid);
            identityMatrix.setPosition(x, y, z);
            chunk.instancedVertexSpheres.setMatrixAt(instanceIndex, identityMatrix);
            chunk.instancedVertexSpheres.setColorAt(instanceIndex, grayColor);
          }
        }

        chunk.instancedVertexSpheres.instanceMatrix.needsUpdate = true;
        chunk.instancedVertexSpheres.instanceColor.needsUpdate = true;
        chunk.instancedVertexSpheres.visible = true;
      }
    } else if (currentGrid.instancedVertexSpheres && currentGrid.vertexToInstanceMap) {
      // Fallback for non-chunked grids
      for (const [vKey, instanceIndex] of currentGrid.vertexToInstanceMap.entries()) {
        const hasColoredSphere = currentGrid.vertexSpheres?.has(vKey) &&
                                 currentGrid.vertexSpheres.get(vKey).color !== 0x888888;

        if (!hasColoredSphere) {
          const [x, y, z] = unpackVertex(vKey, currentGrid);
          identityMatrix.setPosition(x, y, z);
          currentGrid.instancedVertexSpheres.setMatrixAt(instanceIndex, identityMatrix);
          currentGrid.instancedVertexSpheres.setColorAt(instanceIndex, grayColor);
        }
      }

      currentGrid.instancedVertexSpheres.instanceMatrix.needsUpdate = true;
      currentGrid.instancedVertexSpheres.instanceColor.needsUpdate = true;
    }
  }

  // Update dimension UI
  document.getElementById("widthInput").value = newDims.width;
  document.getElementById("heightInput").value = newDims.height;
  document.getElementById("depthInput").value = newDims.depth;

  // Force immediate LOD evaluation synchronously to ensure correct initial state
  // This runs before render loop can process the new chunks with inconsistent state
  forceImmediateLODUpdate();

  // Re-enable LOD updates now that initialization is complete
  lodRebuildInProgress = false;

}

function clearCurrentGridContents() {
  // Preserve endpoint markers while clearing everything else
  const childrenToRemove = [];
  currentGrid.group.traverse((child) => {
    if (child !== currentGrid.startMarker && child !== currentGrid.endMarker && child !== currentGrid.group) {
      childrenToRemove.push(child);
    }
  });
  
  childrenToRemove.forEach(child => {
    if (child.parent) child.parent.remove(child);
    if (child.geometry) child.geometry.dispose();
    if (child.material) {
      if (Array.isArray(child.material)) {
        child.material.forEach(mat => mat.dispose());
      } else {
        child.material.dispose();
      }
    }
  });
  
  // Clear data structures and references
  currentGrid.vertices.clear();
  currentGrid.edges.clear();
  currentGrid.boxesXY.clear();
  currentGrid.boxesXZ.clear();
  currentGrid.boxesYZ.clear();
  currentGrid.vertexSpheres.clear(); // This clears the map but meshes were already removed above
  if (currentGrid.standaloneDecorations) {
    currentGrid.standaloneDecorations.clear(); // Clear standalone decorations too
  }
  currentGrid.path = null;
  currentGrid.activeSubgraph = null;

  // Clear chunk-related data structures
  if (currentGrid.chunks) {
    currentGrid.chunks.clear();
  }
  if (currentGrid.edgeToChunk) {
    currentGrid.edgeToChunk.clear();
  }
  if (currentGrid.vertexToChunk) {
    currentGrid.vertexToChunk.clear();
  }

  // Clear arrow-related data structures
  if (currentGrid.edgeToArrowInstanceMap) {
    currentGrid.edgeToArrowInstanceMap.clear();
  }
  if (currentGrid.arrowInstanceSlots) {
    currentGrid.arrowInstanceSlots = {
      forward: { nextAvailable: 0, freeSlots: [] },
      backward: { nextAvailable: 0, freeSlots: [] }
    };
  }

  // Clear LOD state
  currentGrid.lodState = null;

  // Clear global LOD rebuild queue (may contain stale chunk references)
  lodChunkRebuildQueue = [];

  // Clear global mesh references (these will be recreated by buildGridContent)
  currentGrid.instancedArrowsForward = null;
  currentGrid.instancedArrowsBackward = null;
  currentGrid.instancedBoxesXY = null;
  currentGrid.instancedBoxesXZ = null;
  currentGrid.instancedBoxesYZ = null;

  // Clear UI/hover artifacts
  currentGrid.highlightOverlay = null;
  if (window.highlightedEdge) {
    window.highlightedEdge = null;
  }
}

function restoreTranslatedSubgraph(savedSubgraph, coordTranslation, oldDims, newDims) {
  if (!savedSubgraph || !savedSubgraph.coloredEdges) return;

  // Create new activeSubgraph if needed
  if (savedSubgraph.hasActiveSubgraph) {
    currentGrid.activeSubgraph = new Subgraph(currentGrid);
  }

  // Enable batch mode to prevent GPU sync on each edge
  currentGrid.batchMode = true;

  // Restore each colored edge with translation
  for (const edgeData of savedSubgraph.coloredEdges) {
    const translatedKey = translateEdgeKey(edgeData.key, coordTranslation, oldDims, newDims);
    const [a, b] = unpackEdge(translatedKey, currentGrid);

    // Validate that translated edge exists in new grid
    if (currentGrid.edges.has(translatedKey)) {
      const edge = currentGrid.edges.get(translatedKey);

      // Only color the edge if it was actually colored (not just had a block cube)
      if (edgeData.color !== UNCOLORED_COLOR) {
        colorEdge(currentGrid, a, b, edgeData.color, thickEdgeRadius);

        // Add to activeSubgraph if it existed
        if (currentGrid.activeSubgraph) {
          const aKey = vertexKey(a[0], a[1], a[2], currentGrid);
          const bKey = vertexKey(b[0], b[1], b[2], currentGrid);
          currentGrid.activeSubgraph.edges.add(translatedKey);
          currentGrid.activeSubgraph.vertices.add(aKey);
          currentGrid.activeSubgraph.vertices.add(bKey);
        }
      }
      
      // Restore block cubes (regardless of edge color)
      if (edgeData.hasBlockCube && edge) {
        if (currentGrid.isInstanced) {
		// Use instanced block cubes
		addBlockCubeInstanced(currentGrid, edge, translatedKey);
		} else {
          // Use individual meshes
          const geometry = new THREE.BoxGeometry(blockCubeSize, blockCubeSize, blockCubeSize);
          const material = new THREE.MeshBasicMaterial({ color: selectedColor2 });
          const cube = new THREE.Mesh(geometry, material);
          cube.position.copy(edge.mesh.position);
          cube.raycast = () => {};
          edge.blockCube = cube;
          currentGrid.group.add(cube);
        }
      }
      
      // Restore arrows if they existed (check arrowDirection, not hasArrows, since arrows might be hidden)
      if (edgeData.arrowDirection !== undefined && edgeData.arrowDirection !== 0) {
        if (edge && arrowMode) {
          // Arrow mode is ON: add visual arrows
          addArrowsToEdge(edge, edgeData.arrowDirection, a, b, translatedKey);
        } else if (edge) {
          // Arrow mode is OFF: just store the direction data for later
          edge.arrowDirection = edgeData.arrowDirection;
        }

        // Also store arrow direction in subgraph if it exists
        if (currentGrid.activeSubgraph) {
          currentGrid.activeSubgraph.edgeDirections.set(translatedKey, edgeData.arrowDirection);
        }
      }
    } else {
      console.warn(`Translated edge ${translatedKey} does not exist in new grid`);
    }
  }

  // Disable batch mode and sync GPU buffers
  currentGrid.batchMode = false;

  // Sync GPU buffers for edges (thin, thick, collision)
  if (currentGrid.isInstanced) {
    if (currentGrid.chunks && currentGrid.chunks.size > 0) {
      // Multi-chunk grids
      for (const chunk of currentGrid.chunks.values()) {
        if (chunk.instancedEdgesThin) {
          chunk.instancedEdgesThin.instanceMatrix.needsUpdate = true;
          chunk.instancedEdgesThin.instanceColor.needsUpdate = true;
        }
        if (chunk.instancedEdgesThick) {
          chunk.instancedEdgesThick.instanceMatrix.needsUpdate = true;
          chunk.instancedEdgesThick.instanceColor.needsUpdate = true;
        }
        if (chunk.instancedEdgesCollision) {
          chunk.instancedEdgesCollision.instanceMatrix.needsUpdate = true;
        }
        if (chunk.instancedBlockCubes) {
          chunk.instancedBlockCubes.instanceMatrix.needsUpdate = true;
        }
      }
    } else {
      // Single-chunk grids (fallback)
      if (currentGrid.instancedEdgesThin) {
        currentGrid.instancedEdgesThin.instanceMatrix.needsUpdate = true;
        currentGrid.instancedEdgesThin.instanceColor.needsUpdate = true;
      }
      if (currentGrid.instancedEdgesThick) {
        currentGrid.instancedEdgesThick.instanceMatrix.needsUpdate = true;
        currentGrid.instancedEdgesThick.instanceColor.needsUpdate = true;
      }
      if (currentGrid.instancedEdgesCollision) {
        currentGrid.instancedEdgesCollision.instanceMatrix.needsUpdate = true;
      }
      if (currentGrid.instancedBlockCubes) {
        currentGrid.instancedBlockCubes.instanceMatrix.needsUpdate = true;
      }
    }
  }

  // Restore vertex spheres with translation and bounds checking
  if (savedSubgraph.vertexSpheres) {
    for (const [vertexKey, sphereData] of savedSubgraph.vertexSpheres.entries()) {
      const translatedVertexKey = translateVertexKey(vertexKey, coordTranslation, oldDims, newDims);
      const [x, y, z] = unpackVertex(translatedVertexKey, currentGrid);

      // Only restore if vertex exists AND is within new grid bounds
      if (currentGrid.vertices.has(translatedVertexKey) &&
          x >= 0 && x < currentGrid.width &&
          y >= 0 && y < currentGrid.height &&
          z >= 0 && z < currentGrid.depth) {

        // Create vertex sphere using the new function (creates proper format)
        createVertexSphere(currentGrid, translatedVertexKey, sphereData.color);

        // Add decoration if it existed
        if (sphereData.hasDecoration && sphereData.decorationColor) {
          addVertexDecoration(currentGrid, translatedVertexKey, sphereData.decorationColor);
        }
      }
    }
  }

  // Restore standalone decorations with translation and bounds checking
  if (savedSubgraph.standaloneDecorations) {
    for (const [vertexKey, decorationData] of savedSubgraph.standaloneDecorations.entries()) {
      const translatedVertexKey = translateVertexKey(vertexKey, coordTranslation, oldDims, newDims);
      const [x, y, z] = unpackVertex(translatedVertexKey, currentGrid);

      // Only restore if vertex exists AND is within new grid bounds
      if (currentGrid.vertices.has(translatedVertexKey) &&
          x >= 0 && x < currentGrid.width &&
          y >= 0 && y < currentGrid.height &&
          z >= 0 && z < currentGrid.depth) {

        // Add standalone decoration
        if (decorationData.decorationColor) {
          addVertexDecoration(currentGrid, translatedVertexKey, decorationData.decorationColor);
        }
      }
    }
  }

  // Restore arrow continuity tracking with translation
  if (savedSubgraph.lastArrowedEdgeAtVertex) {
    currentGrid.lastArrowedEdgeAtVertex = new Map();
    for (const [vertexKey, edgeInfo] of savedSubgraph.lastArrowedEdgeAtVertex.entries()) {
      const translatedVertexKey = translateVertexKey(vertexKey, coordTranslation, oldDims, newDims);
      const [x, y, z] = unpackVertex(translatedVertexKey, currentGrid);

      // Only restore if vertex exists AND is within new grid bounds
      if (currentGrid.vertices.has(translatedVertexKey) &&
          x >= 0 && x < currentGrid.width &&
          y >= 0 && y < currentGrid.height &&
          z >= 0 && z < currentGrid.depth) {

        // Translate the edge key using the same function used for edges above
        const translatedEdgeKey = translateEdgeKey(edgeInfo.eKey, coordTranslation, oldDims, newDims);

        // Only restore if the translated edge exists in the new grid
        if (currentGrid.edges.has(translatedEdgeKey)) {
          currentGrid.lastArrowedEdgeAtVertex.set(translatedVertexKey, {
            eKey: translatedEdgeKey,
            timestamp: edgeInfo.timestamp
          });
        }
      }
    }
  }

  // Restore path with translation
  if (savedSubgraph.path) {
    currentGrid.path = savedSubgraph.path.map(vertexKey =>
      translateVertexKey(vertexKey, coordTranslation, oldDims, newDims)
    );

    // Restore cycle reference if it was a cycle
    if (savedSubgraph.isCycle) {
      currentGrid.cycle = currentGrid.activeSubgraph;
    }

    // Sync arrow directions from grid edges to subgraph (Single Source of Truth)
    if (currentGrid.activeSubgraph) {
      currentGrid.activeSubgraph.syncArrowsFromGrid();
    }

    // Use subgraph analysis to detect if this is Hamiltonian after translation
    const analysis = currentGrid.activeSubgraph ? currentGrid.activeSubgraph.analyzeComponentsDetailed() : null;
    const isHamiltonian = analysis ? (analysis.summary.hasHamiltonianPath || analysis.summary.hasHamiltonianCycle) : false;

    // Only show endpoint markers for Hamiltonian paths (not cycles, not partial paths)
    if (isHamiltonian && !savedSubgraph.isCycle && currentGrid.path && currentGrid.path.length >= 2) {
      updateEndpointMarkers(currentGrid);
    }
  }
  
  // Apply gradient if mode is active
  if (gradientMode && currentGrid.path && currentGrid.path.length > 1) {
    applyGradientToPath();
  }
}

function translateEdgeKey(eKey, coordTranslation, oldDims, newDims) {
  const [a, b] = unpackEdgeWithDims(eKey, oldDims.width, oldDims.height, oldDims.depth);
  const newA = [a[0] + coordTranslation.x, a[1] + coordTranslation.y, a[2] + coordTranslation.z];
  const newB = [b[0] + coordTranslation.x, b[1] + coordTranslation.y, b[2] + coordTranslation.z];
  return edgeKeyWithDims(newA, newB, newDims.width, newDims.height, newDims.depth);
}

function translateVertexKey(vKey, coordTranslation, oldDims, newDims) {
  const [x, y, z] = unpackVertexWithDims(vKey, oldDims.width, oldDims.height, oldDims.depth);
  return vertexKeyWithDims(x + coordTranslation.x, y + coordTranslation.y, z + coordTranslation.z, newDims.width, newDims.height, newDims.depth);
}

function updateCameraForNewDimensions(oldPos, oldTarget, newDims) {
  // Scale camera position proportionally with grid growth
  const maxDim = Math.max(newDims.width, newDims.height, newDims.depth);
  
  // Check if this is a 2D grid
  const is2D = newDims.width === 1 || newDims.height === 1 || newDims.depth === 1;
  
  if (is2D) {
    // Fixed overhead position for 2D grids
    const centerX = (newDims.width - 1) / 2;
    const centerY = (newDims.height - 1) / 2; 
    const centerZ = (newDims.depth - 1) / 2;
    
    camera.position.set(centerX, centerY, Math.max(newDims.width, newDims.height, newDims.depth) * 2 + centerZ);
    camera.lookAt(centerX, centerY, centerZ);
    camera.rotateZ(Math.PI / 2);
    
    controls.target.set(centerX, centerY, centerZ);
    controls.enabled = false;
  } else {
    // For 3D grids, maintain relative camera position
    const scaleX = newDims.width / (currentGrid.width || 1);
    const scaleY = newDims.height / (currentGrid.height || 1);
    const scaleZ = newDims.depth / (currentGrid.depth || 1);
    
    camera.position.set(
      oldPos.x * scaleX,
      oldPos.y * scaleY, 
      oldPos.z * scaleZ
    );
    
    controls.target.set(
      oldTarget.x * scaleX,
      oldTarget.y * scaleY,
      oldTarget.z * scaleZ
    );
    controls.enabled = true;
  }
  
  controls.update();
}


//     =====================================
// 		*** 2.2 Layer Removal functions ***
//     =====================================

function canRemoveLayer(direction) {
  if (!currentGrid) return false;
  
  // Check if removal would make any dimension zero
  const { newDims } = calculateContraction(direction);
  if (newDims.width <= 0 || newDims.height <= 0 || newDims.depth <= 0) {
    return false;
  }
  
  // Check for colored edges on the boundary
  for (const [edgeKey, edge] of currentGrid.edges.entries()) {
    if (edge.color !== UNCOLORED_COLOR) {
      const [[ax, ay, az], [bx, by, bz]] = unpackEdge(edgeKey).map(v => v);
      
      switch(direction) {
        case "x-": if (ax === 0 || bx === 0) return false; break;
        case "x+": if (ax === currentGrid.width - 1 || bx === currentGrid.width - 1) return false; break;
        case "y-": if (ay === 0 || by === 0) return false; break;
        case "y+": if (ay === currentGrid.height - 1 || by === currentGrid.height - 1) return false; break;
        case "z-": if (az === 0 || bz === 0) return false; break;
        case "z+": if (az === currentGrid.depth - 1 || bz === currentGrid.depth - 1) return false; break;
      }
    }
  }
  
  // Check for block cubes on the boundary
  for (const [edgeKey, edge] of currentGrid.edges.entries()) {
    if (edge.blockCube) {
      const [[ax, ay, az], [bx, by, bz]] = unpackEdge(edgeKey).map(v => v);
      
      switch(direction) {
        case "x-": if (ax === 0 || bx === 0) return false; break;
        case "x+": if (ax === currentGrid.width - 1 || bx === currentGrid.width - 1) return false; break;
        case "y-": if (ay === 0 || by === 0) return false; break;
        case "y+": if (ay === currentGrid.height - 1 || by === currentGrid.height - 1) return false; break;
        case "z-": if (az === 0 || bz === 0) return false; break;
        case "z+": if (az === currentGrid.depth - 1 || bz === currentGrid.depth - 1) return false; break;
      }
    }
  }
  
  // Check for vertex spheres on the boundary
  if (currentGrid.vertexSpheres) {
    for (const vertexKey of currentGrid.vertexSpheres.keys()) {
      const [x, y, z] = unpackVertex(vertexKey, currentGrid);

      switch(direction) {
        case "x-": if (x === 0) return false; break;
        case "x+": if (x === currentGrid.width - 1) return false; break;
        case "y-": if (y === 0) return false; break;
        case "y+": if (y === currentGrid.height - 1) return false; break;
        case "z-": if (z === 0) return false; break;
        case "z+": if (z === currentGrid.depth - 1) return false; break;
      }
    }
  }

  // Check for standalone decorations on the boundary
  if (currentGrid.standaloneDecorations) {
    for (const vertexKey of currentGrid.standaloneDecorations.keys()) {
      const [x, y, z] = unpackVertex(vertexKey, currentGrid);

      switch(direction) {
        case "x-": if (x === 0) return false; break;
        case "x+": if (x === currentGrid.width - 1) return false; break;
        case "y-": if (y === 0) return false; break;
        case "y+": if (y === currentGrid.height - 1) return false; break;
        case "z-": if (z === 0) return false; break;
        case "z+": if (z === currentGrid.depth - 1) return false; break;
      }
    }
  }

  return true;
}

function calculateContraction(direction) {
  const oldDims = {
    width: currentGrid.width,
    height: currentGrid.height,
    depth: currentGrid.depth
  };
  
  const newDims = { ...oldDims };
  const coordTranslation = { x: 0, y: 0, z: 0 };
  
  switch(direction) {
    case "x+": // Remove far X layer
      newDims.width -= 1;
      break;
    case "x-": // Remove near X layer - shift everything left
      newDims.width -= 1;
      coordTranslation.x = -1;
      break;
    case "y+": // Remove far Y layer
      newDims.height -= 1;
      break;
    case "y-": // Remove near Y layer - shift everything down
      newDims.height -= 1;
      coordTranslation.y = -1;
      break;
    case "z+": // Remove far Z layer
      newDims.depth -= 1;
      break;
    case "z-": // Remove near Z layer - shift everything back
      newDims.depth -= 1;
      coordTranslation.z = -1;
      break;
  }
  
  return { newDims, coordTranslation };
}

async function removeLayer(direction) {
  if (!canRemoveLayer(direction)) {
    alert("Cannot remove layer: contains colored edges");
    return;
  }

  // Capture old dimensions BEFORE any changes
  const oldDims = {
    width: currentGrid.width,
    height: currentGrid.height,
    depth: currentGrid.depth
  };

  // Capture complete state before removal
  const beforeState = captureCompleteGridState();

  // Use same logic as expansion but with contraction calculations
  const savedSubgraph = serializeCurrentSubgraph();
  const savedCameraPos = camera.position.clone();
  const savedCameraTarget = controls.target.clone();

  const { newDims, coordTranslation } = calculateContraction(direction);

  // MUST AWAIT for grid to be fully built before restoring
  await rebuildGridWithDimensions(newDims);
  restoreTranslatedSubgraph(savedSubgraph, coordTranslation, oldDims, newDims);
  updateCameraForNewDimensions(savedCameraPos, savedCameraTarget, newDims);

  // Capture state after removal and record action
  const afterState = captureCompleteGridState();
  recordAction('LAYER_OPERATION', { beforeState, afterState });

  console.log(`Grid contracted ${direction}: ${newDims.width}×${newDims.height}×${newDims.depth}`);
}




//     ====================================================================================================================
// 								    3. HAMILTONIAN PATH/CYCLE GENERATORS AND RELATED FUNCTIONS
//     ====================================================================================================================


//     ============================================
// 		*** 3.1. Generator and Backbite Logic  ***
//     ============================================

async function generatePath() {
  // Set generation flags BEFORE addGrid so overlay knows not to fade out
  isGenerating = true;
  currentGenerationType = 'path';
  shouldStopGeneration = false;

  // Always create a fresh grid using current input dimensions
  // This preserves work on existing grids
  // Note: addGrid will show overlay and handle grid creation progress
  await addGrid();

  // CRITICAL: Ensure collision meshes are loaded for edge clickability
  // On fresh page load, lazy loading might not have triggered yet
  if (lazyLoadEdgeCollision && currentGrid.isInstanced) {
    loadEdgeCollision(currentGrid);
  }

  const totalVertices = currentGrid.width * currentGrid.height * currentGrid.depth;

  // Auto-show flare button for large grids (>30k vertices)
  if (totalVertices > 30000) {
    showFlareButton = true;
    const flareBtn = document.getElementById('flareBtn');
    if (flareBtn) {
      flareBtn.style.display = 'block';
    }
    // Also update the checkbox to reflect this change
    const flareClone = document.getElementById("showFlareButtonCheckboxClone");
    const flareOriginal = document.getElementById("showFlareButtonCheckbox");
    if (flareClone) flareClone.checked = true;
    if (flareOriginal) flareOriginal.checked = true;
  }

  const width = currentGrid.width;
  const height = currentGrid.height;
  const depth = currentGrid.depth;

  // Start path operation (grid completed line will stay, this adds path line)
  ProgressOverlay.startPathCycle('path');

  // Give browser time to render
  await new Promise(resolve => setTimeout(resolve, 50));

  // Calculate backbite moves based on grid type and size
  let backbiteMoves;
  const is2D = (depth === 1);

  if (is2D) {
    // 2D grids use higher multipliers for larger sizes
    if (totalVertices > 15000) {
      // Very large 2D: 0.5 * N^(3/2)
      backbiteMoves = Math.floor(0.5 * Math.pow(totalVertices, 1.5));
    } else if (totalVertices > 5000) {
      backbiteMoves = 40 * totalVertices;  // MULTIPLIER: Change 40 for grids > 5000 vertices
    } else if (totalVertices > 1000) {
      backbiteMoves = 20 * totalVertices;  // MULTIPLIER: Change 20 for grids > 1000 vertices
    } else {
      backbiteMoves = 10 * totalVertices;  // MULTIPLIER: Change 10 for small 2D grids
    }
  } else {
    // 3D grids always use 10x
    backbiteMoves = 10 * totalVertices;    // MULTIPLIER: Change 10 for all 3D grids
  }
  
  const tStart = performance.now();
  
  // Clear any existing path/subgraph first
  if (currentGrid.activeSubgraph) currentGrid.activeSubgraph.clear();
  
  // Clear any existing arrows
  for (const [key, edge] of currentGrid.edges.entries()) {
    removeArrowsFromEdge(edge);
  }
  
  clearEndpointMarkers(currentGrid);
  
  // Enable batch mode BEFORE creating snakey path to prevent visual updates
  batchMode = true;
  
  makeSnakeyPath();

  // IMMEDIATELY clear visual meshes so snakey path doesn't show
  currentGrid.activeSubgraph.clear();
  for (const [key, edge] of currentGrid.edges.entries()) {
    if (edge.mesh) {
      edge.mesh.visible = false;
    }
  }

  console.log(`Performing backbite ${backbiteMoves} times...`);

  // OPTIMIZATION: Convert path to HamiltonianPath for O(log N) reversals
  // This is the key optimization: batch all reversals in the treap,
  // then extract to array only once when visualization is needed
  currentHamPath = new HamiltonianPath(currentGrid.path);

  // Initialize adjacency tracking
  let adjacencyCount = 0;
  let adjacencyHistory = [];
  let lastReportedPercent = 0;

  const tBackbiteStart = performance.now();

  // Chunk size for yielding to browser (update every N moves)
  const chunkSize = Math.max(100, Math.floor(backbiteMoves / 100));

  for (let i = 0; i < backbiteMoves; i++) {
    // Check if user wants to stop
    if (shouldStopGeneration) {
      console.log("Generation stopped by user");
      batchMode = false;
      isGenerating = false;
      ProgressOverlay.hide();
      return;
    }
    
    performBackbite();
    
    // Check if endpoints are adjacent after this backbite
    if (areEndpointsAdjacent()) {
      adjacencyCount++;
      adjacencyHistory.push(i);
    }
    
    // Update progress and yield to browser every chunk
    if (i % chunkSize === 0 || i === backbiteMoves - 1) {
      const currentPercent = Math.floor(((i + 1) / backbiteMoves) * 100);
      if (currentPercent > lastReportedPercent || i === backbiteMoves - 1) {
        lastReportedPercent = currentPercent;
        ProgressOverlay.updatePathCycleProgress('path', currentPercent);

        // Yield to browser to repaint
        await new Promise(resolve => setTimeout(resolve, 0));
      }
    }
  }
  
  const tBackbiteEnd = performance.now();

  // OPTIMIZATION: Extract final path from HamiltonianPath (O(N) once after all moves)
  // This converts the treap back to array format for visualization
  const finalPath = currentHamPath.toArray();
  currentGrid.path = finalPath;
  currentPath = finalPath;
  currentHamPath = null;  // Clear the global reference

  // Rebuild visual representation once at the end
  // NOTE: Keep batchMode = true to prevent dropdown updates during edge loop
  currentGrid.activeSubgraph.clear();

  // OPTIMIZATION: Enable batch mode for edges - don't sync GPU per edge
  currentGrid.batchMode = true;

  const edgeVisualizationStart = performance.now();

  for (let i = 0; i < currentGrid.path.length - 1; i++) {
    const a = unpackVertex(currentGrid.path[i], currentGrid);
    const b = unpackVertex(currentGrid.path[i + 1], currentGrid);
    currentGrid.activeSubgraph.addEdge(a, b);
  }

  // OPTIMIZATION: Disable batch mode and sync GPU once for all edges
  currentGrid.batchMode = false;

  // NOW turn off global batch mode after visualization is complete
  batchMode = false;

  // Sync all edge meshes to GPU (already colored via addEdge loop above)
  // Check if we have chunks (multi-chunk grid) or global meshes (single-chunk)
  if (currentGrid.chunks && currentGrid.chunks.size > 0) {
    // Iterate all chunks and sync their meshes
    for (const chunk of currentGrid.chunks.values()) {
      if (chunk.instancedEdgesThin) {
        chunk.instancedEdgesThin.instanceMatrix.needsUpdate = true;
        chunk.instancedEdgesThin.instanceColor.needsUpdate = true;
      }
      if (chunk.instancedEdgesThick) {
        chunk.instancedEdgesThick.instanceMatrix.needsUpdate = true;
        chunk.instancedEdgesThick.instanceColor.needsUpdate = true;
      }
      if (chunk.lineEdges) {
        chunk.lineEdges.geometry.attributes.color.needsUpdate = true;
      }
      if (chunk.instancedEdgesCollision) {
        chunk.instancedEdgesCollision.instanceMatrix.needsUpdate = true;
      }
    }
  } else {
    // Fallback for single-chunk grids (backwards compatibility)
    if (currentGrid.instancedEdgesThin) {
      currentGrid.instancedEdgesThin.instanceMatrix.needsUpdate = true;
      currentGrid.instancedEdgesThin.instanceColor.needsUpdate = true;
    }
    if (currentGrid.instancedEdgesThick) {
      currentGrid.instancedEdgesThick.instanceMatrix.needsUpdate = true;
      currentGrid.instancedEdgesThick.instanceColor.needsUpdate = true;
    }
    if (currentGrid.lineEdges) {
      currentGrid.lineEdges.geometry.attributes.color.needsUpdate = true;
    }
    if (currentGrid.instancedEdgesCollision) {
      currentGrid.instancedEdgesCollision.instanceMatrix.needsUpdate = true;
    }
  }

  // Trigger render to sync edges to GPU
  renderer.render(scene, camera);

  const edgeVisualizationTime = performance.now() - edgeVisualizationStart;
  console.log(`[Visualization] Edges rendered in ${edgeVisualizationTime.toFixed(0)}ms`);

  if (gradientMode) applyGradientToPath();
  clearEndpointMarkers(currentGrid);
  decoratePathEndpoints(currentGrid.path[0], currentGrid.path[currentGrid.path.length - 1]);

  // Add directional arrows if arrow mode is active
  if (arrowMode) {
    addDirectionalArrowsToPath(currentGrid.path);
  }
  
  const tEnd = performance.now();
  const totalMs = tEnd - tStart;
  const backbiteMs = tBackbiteEnd - tBackbiteStart;
  const perMoveMs = backbiteMs / backbiteMoves;
  const timeInSeconds = (totalMs / 1000).toFixed(2);
  
  // Clear generation flags
  isGenerating = false;
  currentGenerationType = null;

  // Hide blocking overlay

  // Show completion message
ProgressOverlay.completePathCycle('path', timeInSeconds);
  ProgressOverlay.fadeOut(3000);

  console.log(
    `Generated Hamiltonian path.\n` +
    `%cTotal time: ${totalMs.toFixed(2)} ms%c\n` +
    `Backbite phase: ${backbiteMs.toFixed(2)} ms for ${backbiteMoves} moves\n` +
    `%cAvg per backbite: ${perMoveMs.toFixed(4)} ms/move%c\n` +
    `Endpoint adjacencies: ${adjacencyCount} times (${(adjacencyCount/backbiteMoves*100).toFixed(2)}%)\n` +
    `Adjacent at moves: ${adjacencyHistory.slice(0, 10).join(', ')}${adjacencyHistory.length > 10 ? '...' : ''}`,
    "color: blue;", "", // Total time
    "color: blue;", ""  // Avg per backbite
  );
  
  // Check final state
  if (areEndpointsAdjacent()) {
    console.log("Path ends with adjacent endpoints - could be closed into a cycle!");
  }
}


function makeSnakeyPath() {
  const grid = currentGrid;
  const { width: W, height: H, depth: D } = grid;
  const path = new Subgraph(grid);

  console.log(`[DEBUG makeSnakeyPath] Creating snake for ${W}×${H}×${D} grid`);

  // Generate snake path for each layer independently
  for (let z = 0; z < D; z++) {
    const layerPoints = generateLayerSnake(W, H, z);

    // Add edges within this layer
    for (let i = 0; i < layerPoints.length - 1; i++) {
      path.addEdge(layerPoints[i], layerPoints[i + 1]);
    }
  }
  
  // Add vertical connections between layers
  const isWidthEven = W % 2 === 0;

  if (isWidthEven) {
    // For even width: alternate between (0,0) and (W-1,0)
    for (let z = 0; z < D - 1; z++) {
      if (z % 2 === 0) {
        path.addEdge([0, 0, z], [0, 0, z + 1]);
      } else {
        path.addEdge([W - 1, 0, z], [W - 1, 0, z + 1]);
      }
    }
  } else {
    // For odd width: alternate between (0,0) and (W-1,H-1)
    for (let z = 0; z < D - 1; z++) {
      if (z % 2 === 0) {
        path.addEdge([0, 0, z], [0, 0, z + 1]);
      } else {
        path.addEdge([W - 1, H - 1, z], [W - 1, H - 1, z + 1]);
      }
    }
  }

  // Extract the path vertex sequence
  const pathVertices = extractPathFromSubgraph(path);

  // Store the path sequence
  grid.path = pathVertices;
  currentPath = pathVertices;
  
  // Add endpoint decorations
  if (pathVertices.length >= 2) {
    clearEndpointMarkers(grid);
    decoratePathEndpoints(pathVertices[0], pathVertices[pathVertices.length - 1]);
  }
  
  grid.activeSubgraph = path;
  updateEdgeMeshesFromSubgraph(grid, path);
  return path;
}

function generateLayerSnake(W, H, z) {
  const points = [];

  for (let x = 0; x < W; x++) {
    if (x % 2 === 0) {
      // Even columns: go up (y = 0 to H-1)
      for (let y = 0; y < H; y++) {
        points.push([x, y, z]);
      }
    } else {
      // Odd columns: go down (y = H-1 to 0)
      for (let y = H - 1; y >= 0; y--) {
        points.push([x, y, z]);
      }
    }
  }

  return points;
}


function extractPathFromSubgraph(subgraph, startVertex = null) {
  if (!subgraph || subgraph.vertexCount() === 0) return [];
  
  // Build adjacency list ONCE - O(E) instead of O(V*E)
  const adj = new Map();
  for (const vKey of subgraph.vertices) {
    adj.set(vKey, []);
  }
  for (const eKey of subgraph.getEdgeKeys()) {
    const [a, b] = unpackEdge(eKey, subgraph.grid);
    const aKey = vertexKey(a[0], a[1], a[2], subgraph.grid);
    const bKey = vertexKey(b[0], b[1], b[2], subgraph.grid);
    adj.get(aKey).push(bKey);
    adj.get(bKey).push(aKey);
  }
  
  const visited = new Set();
  const path = [];

  // Find start vertex
  if (startVertex === null || startVertex === undefined) {
    for (const vKey of subgraph.vertices) {
      const neighbors = adj.get(vKey);
      if (neighbors.length === 1) {
        startVertex = vKey;
        break;
      }
    }
    if (startVertex === null || startVertex === undefined) {
      startVertex = [...subgraph.vertices][0];
    }
  }

  let current = startVertex;
  let prev = null;

  while (current !== null && current !== undefined && !visited.has(current)) {
    path.push(current);
    visited.add(current);

    const allNeighbors = adj.get(current);
    if (!allNeighbors) {
      console.warn(`[extractPath] Vertex ${current} not found in adjacency list`);
      break;
    }
    const neighbors = allNeighbors.filter(v => v !== prev);

    if (neighbors.length === 0) {
      break;
    }

    prev = current;
    current = neighbors[0];
  }

  return path;
}


function updateEdgeMeshesFromSubgraph(grid, subgraph, color = selectedColor) {
  for (const eKey of subgraph.getEdgeKeys()) {
    const [a, b] = unpackEdge(eKey);
    colorEdge(grid, a, b, color, thickEdgeRadius);
  }
}


/*
 * PERFORMANCE ANALYSIS OF performBackbite()
 * 
 * This function is called thousands to millions of times during path/cycle generation.
 * Analysis of computational costs (ordered from most to least expensive):
 * 
 * 1. **Array reversal (.reverse())** - O(n) where n is path length
 *    Lines 5919, 5923: path.slice(0, idx).reverse() and path.slice(idx + 1).reverse()
 *    - For large grids (e.g., 50×50×50 = 125,000 vertices), reversing can involve 
 *      reversing arrays of 60,000+ elements
 *    - This is the PRIMARY BOTTLENECK, happening twice per backbite in worst case
 *    - Cost: O(path.length) per backbite = O(W×H×D)
 * 
 * 2. **Array spreading and concatenation** - O(n)
 *    Lines 5921, 5925: [...newHead, ...newTail]
 *    - Creating new arrays and copying all elements
 *    - Cost: O(path.length) = O(W×H×D)
 * 
 * 3. **Visual updates (when not in batch mode)** - O(n)
 *    Lines 5935-5949: Rebuilding activeSubgraph, gradient, endpoint markers
 *    - Only happens when batchMode = false
 *    - Avoided during generation by setting batchMode = true
 *    - Cost: O(path.length) but ONLY when batchMode = false
 * 
 * 4. **path.indexOf() calls** - O(n)
 *    Lines 5904, 5914: Finding neighbor index in path
 *    - Linear search through entire path
 *    - Cost: O(path.length) = O(W×H×D)
 * 
 * 5. **Neighbor filtering** - O(1) to O(6)
 *    Lines 5894-5909: Generate and filter 6 neighbors
 *    - Constant time (always checks 6 neighbors)
 *    - Very cheap compared to other operations
 * 
 * TOTAL COST PER BACKBITE: O(3n) ≈ O(n) where n = W×H×D
 * 
 * For a 50×50×50 grid performing 1.25M backbites (10× vertices):
 * - Each backbite processes ~125k elements in arrays
 * - Total operations: 1.25M × 125k = 156 billion array operations
 * 
 * OPTIMIZATION OPPORTUNITIES:
 * 1. Use doubly-linked list instead of array for path storage
 *    - Would reduce reversal from O(n) to O(1) pointer swaps
 *    - Would eliminate array spreading/copying
 * 2. Maintain neighbor-to-index map to eliminate indexOf() calls
 * 3. The visual update skipping (batchMode) is already implemented ✓
 * 
 * CONFIRMED: Array reversal (.reverse()) is the primary bottleneck
 */
// Global reference to HamiltonianPath during generation
// Used to batch reversals efficiently
let currentHamPath = null;

function performBackbite() {
  // If using HamiltonianPath during generation, use optimized path
  if (currentHamPath) {
    performBackbiteOptimized();
  } else {
    // Fallback to array-based approach (for backward compatibility)
    performBackbiteArrayBased();
  }
}

function performBackbiteOptimized() {
  // NEW APPROACH: Vertex-based treap with rank/kth order-statistics
  // This is the TRUE O(log N) per backbite implementation!
  //
  // Key insights:
  // 1. Use treap.rank(vertex) to find position: O(log N)
  // 2. Use treap.kth(k) to get path neighbors: O(log N)
  // 3. Compute directions from coordinates: O(1)
  // 4. Reverse via treap: O(log N)
  // Total per move: O(log N)!

  if (!currentHamPath) return;
  if (!currentGrid.activeSubgraph) return;

  const isHead = Math.random() < 0.5;
  const endpoint = isHead ? currentHamPath.getHead() : currentHamPath.getTail();

  if (endpoint === null || endpoint === undefined) return;

  const [x, y, z] = unpackVertex(endpoint, currentGrid);

  // Generate 6 neighbor coordinates (O(1) - just math)
  const neighborCoords = [
    [x + 1, y, z], [x - 1, y, z],
    [x, y + 1, z], [x, y - 1, z],
    [x, y, z + 1], [x, y, z - 1]
  ];

  // Find valid backbite targets
  // Only store neighborRank - don't call kth() for neighbors we might not use!
  const validMoves = [];

  for (const [nx, ny, nz] of neighborCoords) {
    // Check 0: Bounds check BEFORE computing key (prevent out-of-bounds wrapping)
    if (nx < 0 || nx >= currentGrid.width) continue;
    if (ny < 0 || ny >= currentGrid.height) continue;
    if (nz < 0 || nz >= currentGrid.depth) continue;

    const neighborKey = vertexKey(nx, ny, nz, currentGrid);

    // Check 1: Is this vertex in the grid? (O(1))
    if (!currentGrid.vertices.has(neighborKey)) continue;

    // Check 2: Is this vertex in the path? (O(log N) via rankVertex - uses parent pointers!)
    const neighborRank = currentHamPath.treap.rankVertex(neighborKey);
    if (neighborRank === -1) continue;

    // Check 3: Valid for backbite move (not directly adjacent to endpoint)
    if (isHead && neighborRank === 1) continue;  // Next to head
    if (!isHead && neighborRank === currentHamPath.length - 2) continue;  // Prev to tail

    // Store only the rank - don't compute prev/next yet!
    validMoves.push(neighborRank);
  }

  if (validMoves.length === 0) {
    // DEBUG: Log when no valid moves found
    return;
  }

  // Pick a random valid move
  const selectedRank = validMoves[Math.floor(Math.random() * validMoves.length)];

  // Apply backbite using O(log N) treap reversal
  currentHamPath.applyBackbiteMove(selectedRank, isHead);
}

function performBackbiteArrayBased() {
  // Original implementation - O(N) reversals (for backward compatibility)
  if (!currentGrid.path || currentGrid.path.length < 2) return;
  if (!currentGrid.activeSubgraph) return;

  const path = currentGrid.path;
  const isHead = Math.random() < 0.5;
  const endpoint = isHead ? path[0] : path[path.length - 1];
  const [x, y, z] = unpackVertex(endpoint, currentGrid);

  const neighborCoords = [
    [x + 1, y, z], [x - 1, y, z],
    [x, y + 1, z], [x, y - 1, z],
    [x, y, z + 1], [x, y, z - 1]
  ];

  const neighbors = neighborCoords
    .filter(c => {
      // Bounds check BEFORE computing key
      if (c[0] < 0 || c[0] >= currentGrid.width) return false;
      if (c[1] < 0 || c[1] >= currentGrid.height) return false;
      if (c[2] < 0 || c[2] >= currentGrid.depth) return false;
      return true;
    })
    .map(c => vertexKey(c[0], c[1], c[2], currentGrid))
    .filter(n => {
      if (!currentGrid.vertices.has(n)) return false;
      const idx = path.indexOf(n);
      if (idx === -1) return false;
      if (isHead && idx === 1) return false;
      if (!isHead && idx === path.length - 2) return false;
      return true;
    });

  if (neighbors.length === 0) return;

  const neighbor = neighbors[Math.floor(Math.random() * neighbors.length)];
  const idx = path.indexOf(neighbor);

  // Reconfigure path (array-based, O(N))
  let newPath;
  if (isHead) {
    const newHead = path.slice(0, idx).reverse();
    const newTail = path.slice(idx);
    newPath = [...newHead, ...newTail];
  } else {
    const newTail = path.slice(idx + 1).reverse();
    const newHead = path.slice(0, idx + 1);
    newPath = [...newHead, ...newTail];
  }

  // Update path references
  currentGrid.path = newPath;
  currentPath = newPath;

  // Skip expensive visual updates in batch mode
  if (!batchMode) {
    // Rebuild the activeSubgraph to match the new path
    currentGrid.activeSubgraph.clear();
    for (let i = 0; i < newPath.length - 1; i++) {
      const a = unpackVertex(newPath[i], currentGrid);
      const b = unpackVertex(newPath[i + 1], currentGrid);
      currentGrid.activeSubgraph.addEdge(a, b);
    }

    // Reapply gradient if gradient mode is active
    if (gradientMode) {
      applyGradientToPath();
    }

    // Update endpoint markers
    clearEndpointMarkers(currentGrid);
    decoratePathEndpoints(newPath[0], newPath[newPath.length - 1]);
  }
}


async function generateCycleFromPath() {
  // Set generation flags BEFORE addGrid so overlay knows not to fade out
  isGenerating = true;
  currentGenerationType = 'cycle';
  shouldStopGeneration = false;

  // Always create a fresh grid using current input dimensions
  // This preserves work on existing grids
  await addGrid();

  const totalVertices = currentGrid.width * currentGrid.height * currentGrid.depth;

  // Auto-show flare button for large grids (>30k vertices)
  if (totalVertices > 30000) {
    showFlareButton = true;
    const flareBtn = document.getElementById('flareBtn');
    if (flareBtn) {
      flareBtn.style.display = 'block';
    }
    // Also update the checkbox to reflect this change
    const flareClone = document.getElementById("showFlareButtonCheckboxClone");
    const flareOriginal = document.getElementById("showFlareButtonCheckbox");
    if (flareClone) flareClone.checked = true;
    if (flareOriginal) flareOriginal.checked = true;
  }

  // Check if Hamiltonian cycles are impossible (all dimensions odd)
  if (currentGrid.width % 2 === 1 &&
      currentGrid.height % 2 === 1 &&
      currentGrid.depth % 2 === 1) {
    alert("This grid has no Hamiltonian cycles (all dimensions are odd).");
    // Reset flags since we're exiting early
    isGenerating = false;
    return;
  }

  // Start cycle operation (grid completed line will stay, this adds cycle line)
  ProgressOverlay.startPathCycle('cycle');

  // Give browser time to render
  await new Promise(resolve => setTimeout(resolve, 50));

  const width = currentGrid.width;
  const height = currentGrid.height;
  const depth = currentGrid.depth;
  
  // Calculate backbite moves based on grid type and size (same as generatePath)
  let minimumMoves;
  const is2D = (depth === 1);

  if (is2D) {
    // 2D grids use higher multipliers for larger sizes
    if (totalVertices > 15000) {
      // Very large 2D: 0.5 * N^(3/2)
      minimumMoves = Math.floor(0.5 * Math.pow(totalVertices, 1.5));
    } else if (totalVertices > 5000) {
      minimumMoves = 40 * totalVertices;  // MULTIPLIER: Change 40 for grids > 5000 vertices
    } else if (totalVertices > 1000) {
      minimumMoves = 20 * totalVertices;  // MULTIPLIER: Change 20 for grids > 1000 vertices
    } else {
      minimumMoves = 10 * totalVertices;  // MULTIPLIER: Change 10 for small 2D grids
    }
  } else {
    // 3D grids always use 10x
    minimumMoves = 10 * totalVertices;    // MULTIPLIER: Change 10 for all 3D grids
  }

  const searchMoves = minimumMoves;  // Same as minimum moves
  const totalMoves = minimumMoves + searchMoves;
  
  // Note: Cycle operation already started above, this old line is redundant
  // Give browser time (already done above)
  // await new Promise(resolve => setTimeout(resolve, 50));
  
  const tStart = performance.now();
  
  // Clear any existing path/subgraph first
  if (currentGrid.activeSubgraph) currentGrid.activeSubgraph.clear();
  
  // Clear any existing arrows
  for (const [key, edge] of currentGrid.edges.entries()) {
    removeArrowsFromEdge(edge);
  }
  
  clearEndpointMarkers(currentGrid);
  
  // Enable batch mode BEFORE creating snakey path to prevent visual updates
  batchMode = true;
  
  makeSnakeyPath();

  // IMMEDIATELY clear visual meshes so snakey path doesn't show
  currentGrid.activeSubgraph.clear();
  for (const [key, edge] of currentGrid.edges.entries()) {
    if (edge.mesh) {
      edge.mesh.visible = false;
    }
  }

  console.log(`Performing ${minimumMoves} scrambling moves, then searching for cycle...`);

  // OPTIMIZATION: Convert path to HamiltonianPath for O(log N) reversals
  currentHamPath = new HamiltonianPath(currentGrid.path);

  // Initialize tracking
  let adjacencyCount = 0;
  let movesPerformed = 0;
  let cycleFound = false;
  let lastReportedPercent = 0;

  const tBackbiteStart = performance.now();

  // Chunk size for yielding to browser
  const chunkSize = Math.max(100, Math.floor(totalMoves / 100));

  // Phase 1: Do the full scrambling without looking for cycles (0-98% progress)
  for (let i = 0; i < minimumMoves; i++) {
    // Check if user wants to stop
    if (shouldStopGeneration) {
      console.log("Generation stopped by user during Phase 1");
      batchMode = false;
      isGenerating = false;
      ProgressOverlay.hide();
          return;
    }

    performBackbite();
    movesPerformed++;

    // Count adjacencies (for statistics)
    if (areEndpointsAdjacent()) {
      adjacencyCount++;
    }

    // Update progress and yield to browser every chunk
    // Phase 1 represents 0-98% of total progress
    if (movesPerformed % chunkSize === 0) {
      const phase1Progress = (movesPerformed / minimumMoves) * 98; // 0-98%
      const currentPercent = Math.floor(phase1Progress);
      if (currentPercent > lastReportedPercent) {
        lastReportedPercent = currentPercent;
        ProgressOverlay.updatePathCycleProgress('cycle', currentPercent);

        // Yield to browser to repaint
        await new Promise(resolve => setTimeout(resolve, 0));
      }
    }
  }

  console.log(`Scrambling complete (${minimumMoves} moves). Now searching for cycle opportunity...`);

  // Reset counter for Phase 2
  let phase2Moves = 0;

  // Phase 2: Look for cycle opportunities (98-100% progress)
  for (let i = 0; i < searchMoves; i++) {
    // Check if user wants to stop
    if (shouldStopGeneration) {
      console.log("Generation stopped by user during Phase 2");
      batchMode = false;
      isGenerating = false;
      ProgressOverlay.hide();
          return;
    }

    performBackbite();
    movesPerformed++;
    phase2Moves++;

    // Check if endpoints are adjacent (count for statistics AND check if we should stop)
    const isAdjacent = areEndpointsAdjacent();
    if (isAdjacent) {
      adjacencyCount++;
      if (!cycleFound) {
        // First time finding adjacency - mark as found and break
        cycleFound = true;
        console.log(`Found cycle opportunity at move ${movesPerformed}!`);
        // Don't break yet - let the progress update happen below
      }
    }

    // Update progress and yield to browser every chunk
    // Phase 2 represents 98-100% of total progress
    if (movesPerformed % chunkSize === 0) {
      const phase2Progress = (phase2Moves / searchMoves) * 2; // 0-2% of phase 2
      const currentPercent = Math.floor(98 + phase2Progress); // Add 98% from phase 1
      if (currentPercent > lastReportedPercent) {
        lastReportedPercent = currentPercent;
        ProgressOverlay.updatePathCycleProgress('cycle', currentPercent);

        // Yield to browser to repaint
        await new Promise(resolve => setTimeout(resolve, 0));
      }
    }

    // Break if we found a cycle
    if (cycleFound) {
      break;
    }
  }
  
  const tBackbiteEnd = performance.now();

  // OPTIMIZATION: Extract final path from HamiltonianPath (O(N) once)
  const finalPath = currentHamPath.toArray();
  currentGrid.path = finalPath;
  currentPath = finalPath;
  currentHamPath = null;  // Clear the global reference

  if (cycleFound) {
    // Convert path to actual cycle
    const start = unpackVertex(currentGrid.path[0], currentGrid);
    const end = unpackVertex(currentGrid.path[currentGrid.path.length - 1], currentGrid);

    // Add the end vertex to the beginning to close the cycle
    const cycleVertices = [...currentGrid.path, currentGrid.path[0]];
    currentGrid.path = cycleVertices;
    currentPath = cycleVertices;

    // Rebuild activeSubgraph with all edges including the closing edge
    currentGrid.activeSubgraph.clear();
    currentGrid.batchMode = true;
    for (let i = 0; i < cycleVertices.length - 1; i++) {
      const a = unpackVertex(cycleVertices[i], currentGrid);
      const b = unpackVertex(cycleVertices[i + 1], currentGrid);
      currentGrid.activeSubgraph.addEdge(a, b);
    }
    currentGrid.batchMode = false;

    // Mark as cycle
    currentGrid.cycle = currentGrid.activeSubgraph;

    // Visual updates for cycle
    updateEdgeMeshesFromSubgraph(currentGrid, currentGrid.activeSubgraph);

    if (gradientMode) applyGradientToPath();

    // No endpoint markers for cycles
    clearEndpointMarkers(currentGrid);

    // Add directional arrows if arrow mode is active
    if (arrowMode) {
      addDirectionalArrowsToPath(currentGrid.path, true); // closed=true for cycle
    }

  } else {
    // No cycle found - show alert and return path
    alert("Bad luck, just a path this time!");
    console.log("No cycle found within search limit, creating regular path");

    currentGrid.activeSubgraph.clear();
    currentGrid.batchMode = true;
    for (let i = 0; i < currentGrid.path.length - 1; i++) {
      const a = unpackVertex(currentGrid.path[i], currentGrid);
      const b = unpackVertex(currentGrid.path[i + 1], currentGrid);
      currentGrid.activeSubgraph.addEdge(a, b);
    }
    currentGrid.batchMode = false;

    if (gradientMode) applyGradientToPath();
    clearEndpointMarkers(currentGrid);
    decoratePathEndpoints(currentGrid.path[0], currentGrid.path[currentGrid.path.length - 1]);
    
    if (arrowMode) {
      addDirectionalArrowsToPath(currentGrid.path, false);
    }
  }

  // Disable batch mode
  batchMode = false;

  const tEnd = performance.now();
  const totalMs = tEnd - tStart;
  const backbiteMs = tBackbiteEnd - tBackbiteStart;
  const perMoveMs = backbiteMs / movesPerformed;
  const timeInSeconds = (totalMs / 1000).toFixed(2);
  
  // Clear generation flags
  isGenerating = false;
  currentGenerationType = null;

  // Hide blocking overlay

  // Show completion message
ProgressOverlay.completePathCycle('cycle', timeInSeconds);
  ProgressOverlay.fadeOut(3000);
  
  // Calculate adjacency statistics
  const adjacencyPercentage = ((adjacencyCount / movesPerformed) * 100).toFixed(2);

  console.log(
    `Generated Hamiltonian ${cycleFound ? 'CYCLE' : 'path'}.\n` +
    `%cTotal time: ${totalMs.toFixed(2)} ms%c\n` +
    `Backbite phase: ${backbiteMs.toFixed(2)} ms for ${movesPerformed} moves\n` +
    `%cAvg per backbite: ${perMoveMs.toFixed(4)} ms/move%c\n` +
    `%cEndpoints adjacent: ${adjacencyCount} times (${adjacencyPercentage}% of moves)%c\n` +
    `${cycleFound ? 'Cycle found!' : 'No cycle found within limit'}`,
    "color: blue;", "", // Total time
    "color: blue;", "", // Avg per backbite
    "color: green;", "" // Adjacency stats
  );
}


function areEndpointsAdjacent() {
  // During cycle generation, use HamiltonianPath treap for accurate endpoint checking
  // The treap is the actual source of truth during backbite moves
  if (currentHamPath) {
    if (currentHamPath.length < 2) return false;

    const start = currentHamPath.getHead();
    const end = currentHamPath.getTail();

    const [x1, y1, z1] = unpackVertex(start, currentGrid);
    const [x2, y2, z2] = unpackVertex(end, currentGrid);

    // Check if they're unit distance apart (adjacent)
    const dx = Math.abs(x1 - x2);
    const dy = Math.abs(y1 - y2);
    const dz = Math.abs(z1 - z2);

    return (dx + dy + dz === 1);
  }

  // Fallback to currentGrid.path if not using HamiltonianPath
  if (!currentGrid.path || currentGrid.path.length < 2) return false;

  const start = currentGrid.path[0];
  const end = currentGrid.path[currentGrid.path.length - 1];

  const [x1, y1, z1] = unpackVertex(start, currentGrid);
  const [x2, y2, z2] = unpackVertex(end, currentGrid);

  // Check if they're unit distance apart (adjacent)
  const dx = Math.abs(x1 - x2);
  const dy = Math.abs(y1 - y2);
  const dz = Math.abs(z1 - z2);

  return (dx + dy + dz === 1);
}




//     ================================
// 		*** 3.2. Endpoint Markers  ***
//     ================================
 
function updateEndpointMarkers(grid = currentGrid) {
  if (!grid || !grid.path || grid.path.length < 2) return;
  
  const path = grid.path;
  const startKey = path[0];
  const endKey = path[path.length - 1];
  
  // Clear existing markers
  clearEndpointMarkers(grid);

  // Parse coordinates
  const [sx, sy, sz] = unpackVertex(startKey, grid);
  const [ex, ey, ez] = unpackVertex(endKey, grid);
  
  // Create markers with green for active, red for inactive
  const startColor = activeEndpoint === 'start' ? 0x00ff00 : 0xff0000;
  const endColor = activeEndpoint === 'end' ? 0x00ff00 : 0xff0000;
  
  const startSphere = new THREE.Mesh(
    new THREE.SphereGeometry(0.15, 16, 16),
    new THREE.MeshBasicMaterial({ color: startColor })
  );
  startSphere.position.set(sx, sy, sz);
  grid.group.add(startSphere);
  grid.startMarker = startSphere;
  
  const endSphere = new THREE.Mesh(
    new THREE.SphereGeometry(0.15, 16, 16),
    new THREE.MeshBasicMaterial({ color: endColor })
  );
  endSphere.position.set(ex, ey, ez);
  grid.group.add(endSphere);
  grid.endMarker = endSphere;
}

function decoratePathEndpoints(startKey, endKey) {
  // Set default active endpoint to start when creating new path
  activeEndpoint = 'start';
  updateEndpointMarkers();
}

function clearEndpointMarkers(grid) {
  if (grid.startMarker) {
    grid.group.remove(grid.startMarker);
    grid.startMarker = null;
  }
  if (grid.endMarker) {
    grid.group.remove(grid.endMarker);
    grid.endMarker = null;
  }
}



//     =======================================
// 		*** 3.3. Arrow Related functions  ***
//     =======================================

function createArrowTexture(direction = 1) {
  const canvas = document.createElement('canvas');
  canvas.width = 128;
  canvas.height = 32;
  const ctx = canvas.getContext('2d');
  
  // Clear canvas
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fillRect(0, 0, 128, 32);
  
  // Draw shorter, fatter arrow with bigger head
  ctx.fillStyle = 'black';
  ctx.beginPath();
  
  if (direction === 1) {
    // Arrow pointing forward - shorter and fatter
    ctx.moveTo(95, 16);   // Arrow tip (moved closer to center)
    ctx.lineTo(70, 4);    // Top of bigger arrowhead (wider)
    ctx.lineTo(70, 10);   // Top of fatter shaft
    ctx.lineTo(35, 10);   // Shorter shaft top
    ctx.lineTo(35, 22);   // Fatter shaft bottom
    ctx.lineTo(70, 22);   // Bottom of fatter shaft
    ctx.lineTo(70, 28);   // Bottom of bigger arrowhead (wider)
  } else {
    // Arrow pointing backward - shorter and fatter
    ctx.moveTo(33, 16);   // Arrow tip (moved closer to center)
    ctx.lineTo(58, 4);    // Top of bigger arrowhead (wider)
    ctx.lineTo(58, 10);   // Top of fatter shaft
    ctx.lineTo(93, 10);   // Shorter shaft top
    ctx.lineTo(93, 22);   // Fatter shaft bottom
    ctx.lineTo(58, 22);   // Bottom of fatter shaft
    ctx.lineTo(58, 28);   // Bottom of bigger arrowhead (wider)
  }
  
  ctx.closePath();
  ctx.fill();
  
  return new THREE.CanvasTexture(canvas);
}

// Create arrow texture for "normal" mode (3 arrows baked into texture for edge shader)
function createArrowTextureForShader(direction = 1) {
  const canvas = document.createElement('canvas');
  canvas.width = 128;
  canvas.height = 96;  // 3x height for 3 arrows baked in
  const ctx = canvas.getContext('2d');

  // Clear canvas
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fillRect(0, 0, 128, 96);

  // Draw 3 arrows, each in its own 128x32 section
  ctx.fillStyle = 'black';

  for (let i = 0; i < 3; i++) {
    const yOffset = i * 32;
    ctx.beginPath();

    if (direction === 1) {
      // Arrow pointing forward
      ctx.moveTo(95, yOffset + 16);
      ctx.lineTo(70, yOffset + 4);
      ctx.lineTo(70, yOffset + 10);
      ctx.lineTo(35, yOffset + 10);
      ctx.lineTo(35, yOffset + 22);
      ctx.lineTo(70, yOffset + 22);
      ctx.lineTo(70, yOffset + 28);
    } else {
      // Arrow pointing backward
      ctx.moveTo(33, yOffset + 16);
      ctx.lineTo(58, yOffset + 4);
      ctx.lineTo(58, yOffset + 10);
      ctx.lineTo(93, yOffset + 10);
      ctx.lineTo(93, yOffset + 22);
      ctx.lineTo(58, yOffset + 22);
      ctx.lineTo(58, yOffset + 28);
    }

    ctx.closePath();
    ctx.fill();
  }

  return new THREE.CanvasTexture(canvas);
}

// Initialize arrow textures for normal mode (lazy - called when first needed)
function initializeArrowTextures() {
  if (arrowTextureForward) return; // Already initialized

  arrowTextureForward = createArrowTextureForShader(1);
  arrowTextureForward.wrapS = THREE.ClampToEdgeWrapping;
  arrowTextureForward.wrapT = THREE.RepeatWrapping;
  arrowTextureForward.center.set(0.5, 0.5);
  arrowTextureForward.rotation = Math.PI / 2;
  arrowTextureForward.repeat.set(1, 3);

  arrowTextureBackward = createArrowTextureForShader(-1);
  arrowTextureBackward.wrapS = THREE.ClampToEdgeWrapping;
  arrowTextureBackward.wrapT = THREE.RepeatWrapping;
  arrowTextureBackward.center.set(0.5, 0.5);
  arrowTextureBackward.rotation = Math.PI / 2;
  arrowTextureBackward.repeat.set(1, 3);
}

// Create shader material for thick edges with arrow support (normal mode)
function createThickEdgeShaderMaterial() {
  initializeArrowTextures();

  return new THREE.ShaderMaterial({
    uniforms: {
      arrowTextureForward: { value: arrowTextureForward },
      arrowTextureBackward: { value: arrowTextureBackward }
    },
    vertexShader: `
      attribute float arrowState;

      varying vec3 vColor;
      varying vec2 vUv;
      varying float vArrowState;
      varying vec3 vNormal;

      void main() {
        vColor = instanceColor;
        vUv = uv;
        vArrowState = arrowState;
        vNormal = normalize(mat3(instanceMatrix) * normal);
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform sampler2D arrowTextureForward;
      uniform sampler2D arrowTextureBackward;

      varying vec3 vColor;
      varying vec2 vUv;
      varying float vArrowState;
      varying vec3 vNormal;

      void main() {
        vec3 color = vColor;

        // Detect cap faces using normal variation
        float normalVariation = length(fwidth(vNormal));
        float isCapFace = step(normalVariation, 0.01);

        // Only draw arrows on cylinder body (not caps)
        if ((vArrowState > 0.5 || vArrowState < -0.5) && isCapFace < 0.5) {
          vec2 transformedUv = vUv;

          // Rotate 90 degrees around center
          vec2 centered = transformedUv - vec2(0.5);
          float cosA = 0.0;
          float sinA = 1.0;
          transformedUv = vec2(
            centered.x * cosA - centered.y * sinA,
            centered.x * sinA + centered.y * cosA
          ) + vec2(0.5);

          vec4 arrow;
          if (vArrowState > 0.5) {
            // Flip UV for forward arrows (so arrows point from start toward end of path)
            vec2 flippedUv = vec2(1.0 - transformedUv.x, transformedUv.y);
            arrow = texture2D(arrowTextureForward, flippedUv);
            color = mix(color, vec3(0.0, 0.0, 0.0), arrow.a); // Black arrows
          } else {
            // No flip for backward arrows
            arrow = texture2D(arrowTextureForward, transformedUv);
            color = mix(color, vec3(0.0, 0.0, 0.0), arrow.a); // Black arrows
          }
        }

        gl_FragColor = vec4(color, 1.0);
      }
    `
  });
}

// ============ NORMAL MODE ARROW FUNCTIONS (texture on thick edges) ============

// Add arrow in normal mode - sets arrowState attribute on thick edge
function addArrowNormal(grid, edge, eKey, direction, from, to) {
  if (!grid.isInstanced) return;

  // Determine actual arrow direction based on traversal vs canonical edge direction
  // The edge geometry is oriented from v1 to v2 (canonical order in eKey)
  // We need to account for whether traversal matches geometry orientation
  // BUT only when actually traversing (from/to don't match canonical a/b order)
  let actualDirection = direction;
  if (from && to) {
    const [v1, v2] = unpackEdge(eKey);
    const fromMatchesV1 = from[0] === v1[0] && from[1] === v1[1] && from[2] === v1[2];
    const toMatchesV2 = to[0] === v2[0] && to[1] === v2[1] && to[2] === v2[2];

    // If from/to exactly match v1/v2 (canonical order), this is a direct edge click
    // not a path traversal - use direction as-is
    // If from/to are swapped relative to canonical, we're traversing opposite to geometry
    if (fromMatchesV1 && toMatchesV2) {
      // Direct click or traversing in canonical direction - use direction as-is
      actualDirection = direction;
    } else {
      // Traversing opposite to canonical direction - flip
      actualDirection = -direction;
    }
  }

  // Find chunk and instance index for this edge
  if (grid.chunks && grid.chunks.size > 0) {
    const chunkKey = grid.edgeToChunk.get(eKey);
    if (!chunkKey) return;
    const chunk = grid.chunks.get(chunkKey);
    if (!chunk || !chunk.instancedEdgesThick) return;

    const mapping = chunk.edgeToInstanceMap.get(eKey);
    if (!mapping) return;
    const instanceIndex = mapping.thick;

    // Update arrowState attribute
    const arrowStateAttr = chunk.instancedEdgesThick.geometry.getAttribute('arrowState');
    if (arrowStateAttr) {
      arrowStateAttr.setX(instanceIndex, actualDirection);
      if (!grid.batchMode) {
        arrowStateAttr.needsUpdate = true;
      }
    }
  } else if (grid.instancedEdgesThick) {
    // Single chunk fallback
    const mapping = grid.edgeToInstanceMap.get(eKey);
    if (!mapping) return;
    const instanceIndex = mapping.thick;

    const arrowStateAttr = grid.instancedEdgesThick.geometry.getAttribute('arrowState');
    if (arrowStateAttr) {
      arrowStateAttr.setX(instanceIndex, actualDirection);
      if (!grid.batchMode) {
        arrowStateAttr.needsUpdate = true;
      }
    }
  }

  // Update edge data
  edge.arrowDirection = actualDirection;
  edge.arrows = 'normal';
}

// Remove arrow in normal mode - clears arrowState attribute
function removeArrowNormal(grid, edge, providedKey = null) {
  if (!grid.isInstanced) return;

  // Use provided key or find it
  let eKey = providedKey;
  if (!eKey) {
    for (const [key, e] of grid.edges.entries()) {
      if (e === edge) {
        eKey = key;
        break;
      }
    }
  }
  if (!eKey) return;

  if (grid.chunks && grid.chunks.size > 0) {
    const chunkKey = grid.edgeToChunk.get(eKey);
    if (!chunkKey) return;
    const chunk = grid.chunks.get(chunkKey);
    if (!chunk || !chunk.instancedEdgesThick) return;

    const mapping = chunk.edgeToInstanceMap.get(eKey);
    if (!mapping) return;

    const arrowStateAttr = chunk.instancedEdgesThick.geometry.getAttribute('arrowState');
    if (arrowStateAttr) {
      arrowStateAttr.setX(mapping.thick, 0);
      if (!grid.batchMode) {
        arrowStateAttr.needsUpdate = true;
      }
    }
  } else if (grid.instancedEdgesThick) {
    const mapping = grid.edgeToInstanceMap.get(eKey);
    if (!mapping) return;

    const arrowStateAttr = grid.instancedEdgesThick.geometry.getAttribute('arrowState');
    if (arrowStateAttr) {
      arrowStateAttr.setX(mapping.thick, 0);
      if (!grid.batchMode) {
        arrowStateAttr.needsUpdate = true;
      }
    }
  }

  edge.arrows = null;
}

// Clear all arrows in normal mode
function clearArrowsNormal(grid) {
  if (!grid || !grid.isInstanced) return;

  if (grid.chunks && grid.chunks.size > 0) {
    for (const chunk of grid.chunks.values()) {
      if (chunk.instancedEdgesThick) {
        const arrowStateAttr = chunk.instancedEdgesThick.geometry.getAttribute('arrowState');
        if (arrowStateAttr) {
          for (let i = 0; i < arrowStateAttr.count; i++) {
            arrowStateAttr.setX(i, 0);
          }
          arrowStateAttr.needsUpdate = true;
        }
      }
    }
  } else if (grid.instancedEdgesThick) {
    const arrowStateAttr = grid.instancedEdgesThick.geometry.getAttribute('arrowState');
    if (arrowStateAttr) {
      for (let i = 0; i < arrowStateAttr.count; i++) {
        arrowStateAttr.setX(i, 0);
      }
      arrowStateAttr.needsUpdate = true;
    }
  }

  // Clear edge arrow markers
  for (const edge of grid.edges.values()) {
    if (edge.arrows === 'normal') {
      edge.arrows = null;
    }
  }
}

// Clear all arrows in transcendent mode
function clearArrowsTranscendent(grid) {
  if (!grid) return;

  // Hide all arrow instances
  const zeroMatrix = new THREE.Matrix4().makeScale(0, 0, 0);

  if (grid.instancedArrowsForward) {
    for (let i = 0; i < grid.instancedArrowsForward.count; i++) {
      grid.instancedArrowsForward.setMatrixAt(i, zeroMatrix);
    }
    grid.instancedArrowsForward.instanceMatrix.needsUpdate = true;
    grid.instancedArrowsForward.count = 0;
  }

  if (grid.instancedArrowsBackward) {
    for (let i = 0; i < grid.instancedArrowsBackward.count; i++) {
      grid.instancedArrowsBackward.setMatrixAt(i, zeroMatrix);
    }
    grid.instancedArrowsBackward.instanceMatrix.needsUpdate = true;
    grid.instancedArrowsBackward.count = 0;
  }

  // Reset slots
  if (grid.arrowInstanceSlots) {
    grid.arrowInstanceSlots.forward = { nextAvailable: 0, freeSlots: [] };
    grid.arrowInstanceSlots.backward = { nextAvailable: 0, freeSlots: [] };
  }

  // Clear mapping
  if (grid.edgeToArrowInstanceMap) {
    grid.edgeToArrowInstanceMap.clear();
  }

  // Clear edge arrow markers
  for (const edge of grid.edges.values()) {
    if (edge.arrows === 'instanced') {
      edge.arrows = null;
    }
  }
}

// Switch arrow rendering mode
function setArrowRenderMode(newMode) {
  if (newMode === arrowRenderMode) return;
  if (!currentGrid) {
    arrowRenderMode = newMode;
    return;
  }

  console.log(`Switching arrow mode from ${arrowRenderMode} to ${newMode}`);

  // Clear current mode's visuals
  if (arrowRenderMode === 'transcendent') {
    clearArrowsTranscendent(currentGrid);
  } else {
    clearArrowsNormal(currentGrid);
  }

  // Switch mode
  arrowRenderMode = newMode;

  // If we have a path, use addDirectionalArrowsToPath for correct orientation
  // Otherwise, rebuild arrows edge by edge using stored arrowDirection
  if (currentGrid.path && currentGrid.path.length > 1 && arrowMode) {
    addDirectionalArrowsToPath(currentGrid.path);
  } else {
    // Rebuild arrows edge by edge for manually added arrows (no path)
    const edgesWithArrows = [];
    for (const [eKey, edge] of currentGrid.edges.entries()) {
      if (edge.arrowDirection && edge.arrowDirection !== 0) {
        edgesWithArrows.push({ eKey, edge, direction: edge.arrowDirection });
      }
    }

    currentGrid.batchMode = true;
    for (const { eKey, edge, direction } of edgesWithArrows) {
      const [from, to] = unpackEdge(eKey);

      if (arrowRenderMode === 'transcendent') {
        addArrowInstanced(currentGrid, edge, direction, from, to);
      } else {
        addArrowNormal(currentGrid, edge, eKey, direction, from, to);
      }
    }
    currentGrid.batchMode = false;

    // Sync GPU
    if (arrowRenderMode === 'transcendent') {
      if (currentGrid.instancedArrowsForward) {
        currentGrid.instancedArrowsForward.instanceMatrix.needsUpdate = true;
      }
      if (currentGrid.instancedArrowsBackward) {
        currentGrid.instancedArrowsBackward.instanceMatrix.needsUpdate = true;
      }
      updateArrowInstanceCounts(currentGrid);
    } else {
      // Sync arrowState attributes
      if (currentGrid.chunks && currentGrid.chunks.size > 0) {
        for (const chunk of currentGrid.chunks.values()) {
          if (chunk.instancedEdgesThick) {
            const attr = chunk.instancedEdgesThick.geometry.getAttribute('arrowState');
            if (attr) attr.needsUpdate = true;
          }
        }
      } else if (currentGrid.instancedEdgesThick) {
        const attr = currentGrid.instancedEdgesThick.geometry.getAttribute('arrowState');
        if (attr) attr.needsUpdate = true;
      }
    }
  }

  console.log(`Arrow mode switch complete.`);
}

function addArrowsToEdge(edge, direction = 1, from = null, to = null, providedKey = null) {
  if (edge.arrows) removeArrowsFromEdge(edge, providedKey);

  // Get edge coordinates - either from parameters or derive from edge key in currentGrid
  let edgeLength, edgeRadius, startPos, endPos;

  if (from && to) {
    // Calculate from provided coordinates
    startPos = new THREE.Vector3(from[0], from[1], (from[2] ?? 0));
    endPos = new THREE.Vector3(to[0], to[1], (to[2] ?? 0));
    edgeLength = startPos.distanceTo(endPos);
  } else if (edge.mesh) {
    // Individual mesh mode - use existing mesh properties
    edgeLength = edge.mesh.geometry.parameters.height;
    edgeRadius = edge.mesh.geometry.parameters.radiusTop;
    startPos = edge.mesh.position.clone();
    endPos = edge.mesh.position.clone();
  } else {
    // Instanced mode - find coordinates from edge data in grid
    // Use provided key or search for it (but search should be rare now)
    let foundKey = providedKey;
    if (foundKey === null || foundKey === undefined) {
      // Fallback: only search if key not provided
      for (const [key, e] of currentGrid.edges.entries()) {
        if (e === edge) {
          foundKey = key;
          break;
        }
      }
    }

    if (foundKey === null || foundKey === undefined) {
      console.error("Cannot add arrows: edge not found in grid");
      return;
    }

    [from, to] = unpackEdge(foundKey);

    startPos = new THREE.Vector3(from[0], from[1], (from[2] ?? 0));
    endPos = new THREE.Vector3(to[0], to[1], (to[2] ?? 0));
    edgeLength = startPos.distanceTo(endPos);
  }
  
  // Use instanced rendering if enabled - dispatch to appropriate mode
  if (currentGrid.isInstanced && from && to) {
    const eKey = providedKey || edgeKey(from, to);
    if (arrowRenderMode === 'normal') {
      addArrowNormal(currentGrid, edge, eKey, direction, from, to);
    } else {
      addArrowInstanced(currentGrid, edge, direction, from, to);
    }
    return;
  }
  
  // === INDIVIDUAL MESH MODE (existing code) ===

  // Determine radius based on whether edge is colored
  // SLEDGEHAMMER: In unified mode, always use thin radius
  if (edgeRadius === undefined) {
    edgeRadius = unifiedEdgeSize ? thinEdgeRadius : ((edge.color !== UNCOLORED_COLOR) ? thickEdgeRadius : thinEdgeRadius);
  }

  const texture = createArrowTexture(direction);
  texture.wrapS = THREE.ClampToEdgeWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.center.set(0.5, 0.5);
  texture.rotation = Math.PI / 2;
  const arrowsAlongHeight = 3;
  texture.repeat.set(1, arrowsAlongHeight);

  const arrowMaterial = new THREE.MeshBasicMaterial({
    map: texture,
    transparent: true,
    depthTest: false
  });

  const geometry = new THREE.CylinderGeometry(
    edgeDecorationRadius, // Use absolute decoration radius
    edgeDecorationRadius, // Use absolute decoration radius
    edgeLength,
    6,
    1,
    true
  );

  const arrowMesh = new THREE.Mesh(geometry, arrowMaterial);
  
  // Calculate position and orientation from coordinates
  const midpoint = new THREE.Vector3().addVectors(startPos, endPos).multiplyScalar(0.5);
  arrowMesh.position.copy(midpoint);

  if (from && to) {
    // Align +Y to (to - from)
    const start = new THREE.Vector3(from[0], from[1], (from[2] ?? 0));
    const end   = new THREE.Vector3(to[0],   to[1],   (to[2]   ?? 0));
    const dir = new THREE.Vector3().subVectors(end, start);
    if (dir.lengthSq() > 0) {
      dir.normalize();
      const q = new THREE.Quaternion().setFromUnitVectors(
        new THREE.Vector3(0, 1, 0), dir
      );
      arrowMesh.quaternion.copy(q);
    } else if (edge.mesh) {
      // Degenerate safety: fall back to base edge orientation if available
      arrowMesh.quaternion.copy(edge.mesh.quaternion);
    }
  } else if (edge.mesh) {
    // Back-compat for existing callers (copy edge's orientation)
    arrowMesh.quaternion.copy(edge.mesh.quaternion);
  }

  // Ignore raycasting so clicks hit the base edge
  arrowMesh.raycast = () => {};

  edge.arrows = arrowMesh;
  edge.arrowDirection = direction;
  currentGrid.group.add(arrowMesh);
}


function removeArrowsFromEdge(edge, providedKey = null) {
  if (!edge.arrows) return;

  if (currentGrid.isInstanced && edge.arrows === 'instanced') {
    // Transcendent mode (instanced 3D cones) - pass the key to avoid O(n) edge lookup
    removeArrowInstanced(currentGrid, edge, providedKey);
    // Clear visual marker but PRESERVE direction for toggle
    edge.arrows = null;
    // edge.arrowDirection stays set!
  } else if (currentGrid.isInstanced && edge.arrows === 'normal') {
    // Normal mode (texture on edges) - clear arrowState attribute
    removeArrowNormal(currentGrid, edge, providedKey);
    // Clear visual marker but PRESERVE direction for toggle
    edge.arrows = null;
    // edge.arrowDirection stays set!
  } else {
    // Individual mesh mode
    if (edge.arrows && edge.arrows !== 'instanced' && edge.arrows !== 'normal') {
      currentGrid.group.remove(edge.arrows);
    }
    edge.arrows = null;
    // edge.arrowDirection stays set!
  }
}


function addDirectionalArrowsToPath(path, closed = false) {
  if (!arrowMode || !currentGrid || !Array.isArray(path) || path.length < 2) return;

  // Determine base direction (respect arrowReverse toggle)
  const baseDirection = arrowReverse ? -1 : 1;

  // Do not mutate the original path
  const ordered = arrowReverse ? [...path].reverse() : path;

  console.log(`[Arrows] Adding arrows: arrowReverse=${arrowReverse}, baseDirection=${baseDirection}, pathLength=${path.length}`);

  // OPTIMIZATION: Enable batch mode for arrows - don't sync GPU per arrow
  currentGrid.batchMode = true;

  const arrowVisualizationStart = performance.now();
  const limit = closed ? ordered.length : (ordered.length - 1);
  for (let i = 0; i < limit; i++) {
    const vKeyA = ordered[i];
    const vKeyB = closed
      ? ordered[(i + 1) % ordered.length]
      : ordered[i + 1];

    const a = unpackVertex(vKeyA, currentGrid);
    const b = unpackVertex(vKeyB, currentGrid);

    const eKey = edgeKey(a, b, currentGrid);
    const edge = currentGrid.edges.get(eKey);
    if (edge) {
      addArrowsToEdge(edge, baseDirection, a, b);
    }
  }

  // OPTIMIZATION: Disable batch mode and sync GPU once for all arrows
  currentGrid.batchMode = false;

  // Sync GPU based on arrow mode
  if (arrowRenderMode === 'transcendent') {
    if (currentGrid.instancedArrowsForward) {
      currentGrid.instancedArrowsForward.instanceMatrix.needsUpdate = true;
    }
    if (currentGrid.instancedArrowsBackward) {
      currentGrid.instancedArrowsBackward.instanceMatrix.needsUpdate = true;
    }
    // Update arrow instance counts to reflect actual active arrows
    updateArrowInstanceCounts(currentGrid);
  } else {
    // Normal mode: sync arrowState attributes
    if (currentGrid.chunks && currentGrid.chunks.size > 0) {
      for (const chunk of currentGrid.chunks.values()) {
        if (chunk.instancedEdgesThick) {
          const attr = chunk.instancedEdgesThick.geometry.getAttribute('arrowState');
          if (attr) attr.needsUpdate = true;
        }
      }
    } else if (currentGrid.instancedEdgesThick) {
      const attr = currentGrid.instancedEdgesThick.geometry.getAttribute('arrowState');
      if (attr) attr.needsUpdate = true;
    }
  }

  // Trigger render to sync arrows to GPU
  renderer.render(scene, camera);

  const arrowVisualizationTime = performance.now() - arrowVisualizationStart;
  console.log(`[Visualization] Arrows rendered in ${arrowVisualizationTime.toFixed(0)}ms`);
}


//     ========================================
// 		*** 3.4.Manual Backbite Functions  ***
//     ========================================

function getValidBackbiteEdges(endpointKey) {
  if (!currentGrid.path || currentGrid.path.length < 3) return [];
  
  const path = currentGrid.path;
  const isStart = path[0] === endpointKey;
  const isEnd = path[path.length - 1] === endpointKey;
  
  // Only proceed if this is the active endpoint
  const isActiveEndpoint = (activeEndpoint === 'start' && isStart) || 
                          (activeEndpoint === 'end' && isEnd);
  
  if (!isActiveEndpoint) return [];

  const [x, y, z] = unpackVertex(endpointKey, currentGrid);
  const neighborCoords = [
    [x + 1, y, z], [x - 1, y, z],
    [x, y + 1, z], [x, y - 1, z],
    [x, y, z + 1], [x, y, z - 1]
  ];

  const validEdges = [];

  for (const coord of neighborCoords) {
    // Bounds check BEFORE computing key
    if (coord[0] < 0 || coord[0] >= currentGrid.width) continue;
    if (coord[1] < 0 || coord[1] >= currentGrid.height) continue;
    if (coord[2] < 0 || coord[2] >= currentGrid.depth) continue;

    const neighborKey = vertexKey(coord[0], coord[1], coord[2], currentGrid);

    // Check if neighbor exists in grid
    if (!currentGrid.vertices.has(neighborKey)) continue;
    
    // Check if neighbor is in the path
    const idx = path.indexOf(neighborKey);
    if (idx === -1) continue;
    
    // For start: can't connect to the adjacent vertex (path[1])
    // For end: can't connect to the adjacent vertex (path[path.length - 2])
    if (isStart && idx === 1) continue;
    if (isEnd && idx === path.length - 2) continue;

    // This is a valid backbite edge
    const eKey = edgeKey([x, y, z], coord, currentGrid);
    validEdges.push({
      edgeKey: eKey,
      neighborKey,
      neighborIndex: idx,
      isHead: isStart
    });
  }

  return validEdges;
}

let activeEndpoint = 'start'; // 'start' or 'end'



function toggleActiveEndpoint() {
  if (!currentGrid || !currentGrid.path || currentGrid.path.length < 2) {
    console.warn("No valid path to toggle endpoints");
    return;
  }
  
  // DON'T toggle activeEndpoint - let the path reversal handle it
  // activeEndpoint = activeEndpoint === 'start' ? 'end' : 'start';
  
  // Reverse the entire path array
  currentGrid.path.reverse();
  currentPath = currentGrid.path; // Keep currentPath in sync
  
  // Update visual markers - green at path[0], red at path[path.length-1]
  updateEndpointMarkers();
  
  // If arrows are enabled, redraw them (they'll automatically point in the reversed direction)
  if (arrowMode && currentGrid && currentGrid.path && currentGrid.path.length > 1) {
    // OPTIMIZATION: Only remove arrows from path edges, not all grid edges
    // Use edgeToArrowInstanceMap which tracks only edges with arrows
    currentGrid.batchMode = true;
    if (currentGrid.edgeToArrowInstanceMap && currentGrid.edgeToArrowInstanceMap.size > 0) {
      const arrowEdgeKeys = Array.from(currentGrid.edgeToArrowInstanceMap.keys());
      for (const eKey of arrowEdgeKeys) {
        const edge = currentGrid.edges.get(eKey);
        if (edge) {
          removeArrowsFromEdge(edge, eKey);
        }
      }
    }

    // Redraw arrows in the new path direction (still in batch mode)
    addDirectionalArrowsToPath(currentGrid.path);

    currentGrid.batchMode = false;

    // Sync GPU once after batch removal and addition
    if (currentGrid.instancedArrowsForward) {
      currentGrid.instancedArrowsForward.instanceMatrix.needsUpdate = true;
    }
    if (currentGrid.instancedArrowsBackward) {
      currentGrid.instancedArrowsBackward.instanceMatrix.needsUpdate = true;
    }
    updateArrowInstanceCounts(currentGrid);
  }
  
  // Reapply gradient if active
  if (gradientMode) {
    applyGradientToPath();
  }
  
  console.log(`Path reversed, active endpoint remains: ${activeEndpoint}`);
}



function performManualBackbite(clickedEdgeKey) {
  if (!currentGrid.path || currentGrid.path.length < 2) return false;
  if (!currentGrid.activeSubgraph) return false;

  const path = currentGrid.path;

  // Check if this is a cycle (first vertex equals last vertex)
  const isCycle = path.length > 1 && path[0] === path[path.length - 1];
  const expectedVertexCount = isCycle ? path.length - 1 : path.length;

  // Check if activeSubgraph is non-Hamiltonian and warn user
  if (!dontShowBackbiteWarning && currentGrid.activeSubgraph.vertices.size !== expectedVertexCount) {
    showBackbiteWarning();
    return false;
  }

  const activeEndpointKey = activeEndpoint === 'start' ? path[0] : path[path.length - 1];

  const validEdges = getValidBackbiteEdges(activeEndpointKey);
  const matchingEdge = validEdges.find(edge => edge.edgeKey === clickedEdgeKey);

  if (!matchingEdge) {
    console.warn("Invalid backbite edge selected for active endpoint");
    return false;
  }
  
  // SAVE OLD PATH FOR UNDO
  const oldPath = [...currentGrid.path];
  
  const isHead = matchingEdge.isHead;
  const idx = matchingEdge.neighborIndex;
  
  // Reconfigure path
  let newPath;
  if (isHead) {
    const newHead = path.slice(0, idx).reverse();
    const newTail = path.slice(idx);
    newPath = [...newHead, ...newTail];
  } else {
    const newTail = path.slice(idx + 1).reverse();
    const newHead = path.slice(0, idx + 1);
    newPath = [...newHead, ...newTail];
  }

  // Update path references
  currentGrid.path = newPath;
  currentPath = newPath;
  
  // RECORD UNDO ACTION
  recordAction('BACKBITE', {
    oldPath: oldPath,
    newPath: [...newPath]
  });
  
  // Clear redo stack
  currentGrid.redoStack = [];

  // Rebuild the activeSubgraph to match the new path
  // Enable batch mode to prevent expensive DOM updates on each edge
  batchMode = true;
  currentGrid.activeSubgraph.clear();
  for (let i = 0; i < newPath.length - 1; i++) {
    const a = unpackVertex(newPath[i], currentGrid);
    const b = unpackVertex(newPath[i + 1], currentGrid);
    currentGrid.activeSubgraph.addEdge(a, b);
  }
  batchMode = false;

  // Update dropdowns once after batch operation
  if (typeof updateSubgraphComponentDropdowns === 'function') {
    updateSubgraphComponentDropdowns();
  }

  // Reapply gradient if gradient mode is active
  if (gradientMode) {
    applyGradientToPath();
  }

  // Update endpoint markers
  updateEndpointMarkers();

  // Handle arrows if arrow mode is active
  if (arrowMode && currentGrid.path) {
    // A backbite reverses a portion of the path, which changes arrow directions
    // for multiple edges. Simplest fix: clear and redraw all arrows.
    if (arrowRenderMode === 'transcendent') {
      clearArrowsTranscendent(currentGrid);
    } else {
      clearArrowsNormal(currentGrid);
    }
    addDirectionalArrowsToPath(currentGrid.path);
  }

  return true;
}


//     =================================
// 		*** 3.5.Gradient Functions  ***
//     =================================

function hexToRgb(hex) {
  const r = (hex >> 16) & 255;
  const g = (hex >> 8) & 255;
  const b = hex & 255;
  return { r, g, b };
}

function rgbToHex(r, g, b) {
  return (r << 16) | (g << 8) | b;
}

function interpolateColor(color1, color2, factor) {
  factor = Math.max(0, Math.min(1, factor));
  
  // Curve that rushes through the muddy middle
  factor = factor < 0.5 ? 2 * factor * factor : 1 - 2 * (1 - factor) * (1 - factor);
  
  const rgb1 = hexToRgb(color1);
  const rgb2 = hexToRgb(color2);
  
  const r = Math.round(rgb1.r + (rgb2.r - rgb1.r) * factor);
  const g = Math.round(rgb1.g + (rgb2.g - rgb1.g) * factor);
  const b = Math.round(rgb1.b + (rgb2.b - rgb1.b) * factor);
  
  return rgbToHex(r, g, b);
}

function colorEdgeWithColor(grid, a, b, color, radius = thickEdgeRadius) {
  if (grid.isInstanced) {
    colorEdgeInstanced(grid, a, b, color, radius);
  } else {
    const eKey = edgeKey(a, b);
    const edge = grid.edges.get(eKey);
    if (!edge) return;
    
    // ALWAYS remove arrows when coloring (they'll be re-added if needed)
    if (edge.arrows) {
      removeArrowsFromEdge(edge);
    }
    
    grid.group.remove(edge.mesh);
    
    const start = new THREE.Vector3(...a);
    const end = new THREE.Vector3(...b);
    const direction = new THREE.Vector3().subVectors(end, start);
    const length = direction.length();
    const midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
    const axis = new THREE.Vector3(0, 1, 0);
    
    const material = new THREE.MeshBasicMaterial({ color });
    const geometry = new THREE.CylinderGeometry(radius, radius, length, 8);
    const mesh = new THREE.Mesh(geometry, material);
    mesh.quaternion.setFromUnitVectors(axis, direction.clone().normalize());
    mesh.position.copy(midpoint);
    
    edge.mesh = mesh;
    edge.color = color;
    grid.group.add(mesh);
  }
}

function applyGradientToPath() {
  if (!currentGrid || !currentGrid.path || currentGrid.path.length < 2) return;
  
  const path = currentGrid.path;
  const pathLength = path.length - 1;
  const color1 = selectedColor;
  const color2 = selectedColor2;
  
  // Calculate the mix color (50% blend)
  const colorMix = interpolateColor(color1, color2, 0.5);
  
  // Store arrow information BEFORE coloring
  const arrowInfo = new Map();
  for (let i = 0; i < pathLength; i++) {
    const a = unpackVertex(path[i], currentGrid);
    const b = unpackVertex(path[i + 1], currentGrid);
    const eKey = edgeKey(a, b, currentGrid);
    const edge = currentGrid.edges.get(eKey);

    if (edge && edge.arrows) {
      arrowInfo.set(eKey, {
        direction: edge.arrows.direction,
        a: a,
        b: b
      });
    }
  }

  // Apply gradient colors
  for (let i = 0; i < pathLength; i++) {
    const factor = pathLength > 1 ? i / (pathLength - 1) : 0;

    let edgeColor;
    if (factor < 0.5) {
      // First half: color1 to colorMix
      edgeColor = interpolateColor(color1, colorMix, factor * 2);
    } else {
      // Second half: colorMix to color2
      edgeColor = interpolateColor(colorMix, color2, (factor - 0.5) * 2);
    }

    const a = unpackVertex(path[i], currentGrid);
    const b = unpackVertex(path[i + 1], currentGrid);
    
    colorEdgeWithColor(currentGrid, a, b, edgeColor, thickEdgeRadius);
  }
  
  // Re-add arrows AFTER coloring - pass the key to avoid O(n) edge lookup
  for (const [eKey, info] of arrowInfo.entries()) {
    const edge = currentGrid.edges.get(eKey);
    if (edge) {
      addArrowsToEdge(edge, info.direction, info.a, info.b, eKey);  // ← PASS THE KEY!
    }
  }
}


Subgraph.prototype.addEdgeWithGradient = function(a, b, pathIndex, totalEdges) {
  const eKey = edgeKey(a, b);
  if (this.edges.has(eKey)) return;

  this.edges.add(eKey);
  this.vertices.add(vertexKey(...a));
  this.vertices.add(vertexKey(...b));

  const factor = totalEdges > 1 ? pathIndex / (totalEdges - 1) : 0;
  const color1 = selectedColor;
  const color2 = selectedColor2;
  const colorMix = interpolateColor(color1, color2, 0.5);
  
  let edgeColor;
  if (factor < 0.5) {
    edgeColor = interpolateColor(color1, colorMix, factor * 2);
  } else {
    edgeColor = interpolateColor(colorMix, color2, (factor - 0.5) * 2);
  }

  colorEdgeWithColor(this.grid, a, b, edgeColor, thickEdgeRadius);
};



//     ============================================
// 		*** 3.6.Hamiltonian Path/Cycle Checker ***
//     ============================================

function buildColoredEdgeAdjacency() {
  const adj = new Map();
  for (const [key, edge] of currentGrid.edges.entries()) {
    if (edge.color !== UNCOLORED_COLOR) {
      const [a, b] = unpackEdge(key);
      const aKey = vertexKey(a[0], a[1], a[2]);
      const bKey = vertexKey(b[0], b[1], b[2]);
      if (!adj.has(aKey)) adj.set(aKey, []);
      if (!adj.has(bKey)) adj.set(bKey, []);
      adj.get(aKey).push(bKey);
      adj.get(bKey).push(aKey);
    }
  }
  return adj;
}

function checkConnectivity(adj, totalVertices) {
  if (adj.size === 0) return false;
  
  const visited = new Set();
  const stack = [adj.keys().next().value];
  
  while (stack.length > 0) {
    const v = stack.pop();
    if (visited.has(v)) continue;
    visited.add(v);
    for (const nbr of adj.get(v) || []) {
      if (!visited.has(nbr)) stack.push(nbr);
    }
  }
  
  return visited.size === totalVertices;
}

function checkHamiltonianCycle() {
  if (!currentGrid) {
    alert("No grid selected.");
    return;
  }
  
  const adj = buildColoredEdgeAdjacency();
  const totalVertices = currentGrid.vertices.size;
  
  // Check if any colored edges exist
  if (adj.size === 0) {
    alert("❌ The colored subgraph is not a Hamiltonian cycle. ");
    console.log("No colored edges found.");
    return;
  }
  
  // Check degree condition (each vertex must have degree 2)
  for (const v of currentGrid.vertices.keys()) {
    const deg = adj.get(v)?.length || 0;
    if (deg !== 2) {
      alert("❌ The colored subgraph is not a Hamiltonian cycle.");
      console.log(`Failing vertex: ${v} (degree: ${deg})`);
      return;
    }
  }
  
  // Check connectivity
  if (!checkConnectivity(adj, totalVertices)) {
    alert("❌ The colored subgraph is not a Hamiltonian cycle.");
    console.log("Graph is not connected.");
    return;
  }
  
  alert("✅ The colored subgraph is a Hamiltonian cycle.");
}

function isHamiltonianPath() {
  if (!currentGrid) return false;
  
  const adj = buildColoredEdgeAdjacency();
  const totalVertices = currentGrid.vertices.size;
  
  // Check if any colored edges exist
  if (adj.size === 0) {
    console.log("No colored edges found.");
    return false;
  }
  
  // Check degree counts - must have exactly 2 endpoints (degree 1) and rest degree 2
  const endpoints = [];
  for (const [v, neighbors] of adj.entries()) {
    const deg = neighbors.length;
    if (deg === 1) {
      endpoints.push(v);
    } else if (deg !== 2) {
      console.log(`Failing vertex: ${v} (degree: ${deg})`);
      return false;
    }
  }
  
  if (endpoints.length !== 2) {
    console.log(`Expected 2 endpoints, found: ${endpoints.length}`);
    return false;
  }
  
  // Check connectivity by walking the path
  const visited = new Set();
  const path = [];
  let current = endpoints[0];
  let prev = null;

  while (current !== null && current !== undefined) {
    path.push(current);
    visited.add(current);
    const neighbors = adj.get(current) || [];
    const next = neighbors.find(v => v !== prev && !visited.has(v));
    prev = current;
    current = next;
  }
  
  if (path.length !== totalVertices) {
    console.log(`Path incomplete: covers ${path.length}/${totalVertices} vertices`);
    return false;
  }
  
  currentPath = path; // Save it globally
  return true;
}

function checkHamiltonianCombined() {
  if (!currentGrid) return;
  
  // First try to check if it's a Hamiltonian path
  if (isHamiltonianPath()) {
    alert(" ✅ The colored subgraph is a Hamiltonian path. ");
  } else {
    // If not a path, check for Hamiltonian cycle
    checkHamiltonianCycle();
  }
}




//     ====================================================================================================================
// 						      4. EDGE COLORING, EDGE MESH FUNCTIONS, AND ISSWITCHABLE FUNCTIONS
//     ====================================================================================================================

// I.E.R. UPDATED
function colorEdge(grid, a, b, color = selectedColor, radius = thickEdgeRadius) {
  if (grid.isInstanced) {
    colorEdgeInstanced(grid, a, b, color, radius);
  } else {
    colorEdgeIndividual(grid, a, b, color, radius);
  }
}

// I.E.R. ADDED FUNCTION

function colorEdgeIndividual(grid, a, b, color, radius) {
  const eKey = edgeKey(a, b, grid);
  const edge = grid.edges.get(eKey);
  if (!edge) return;

  // ALWAYS remove arrows when coloring (they'll be re-added if needed)
  if (edge.arrows) {
    removeArrowsFromEdge(edge);
  }

  grid.group.remove(edge.mesh);

  const start = new THREE.Vector3(...a);
  const end = new THREE.Vector3(...b);
  const direction = new THREE.Vector3().subVectors(end, start);
  const length = direction.length();
  const midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
  const axis = new THREE.Vector3(0, 1, 0);

  const material = new THREE.MeshBasicMaterial({ color });
  const geometry = new THREE.CylinderGeometry(radius, radius, length, 8);
  const mesh = new THREE.Mesh(geometry, material);
  mesh.quaternion.setFromUnitVectors(axis, direction.clone().normalize());
  mesh.position.copy(midpoint);

  // Apply current grid opacity if uncoloring
  if (color === UNCOLORED_COLOR) {
    // Read actual slider value
    const opacity = parseFloat(document.getElementById("gridOpacitySlider").value);
    
    const grayValue = Math.floor(0x88 * opacity);
    const simulatedColor = (grayValue << 16) | (grayValue << 8) | grayValue;
    mesh.material.color.setHex(simulatedColor);
    mesh.material.needsUpdate = true;
    
    // Hide if grid is not visible
    if (!gridVisible) {
      mesh.visible = false;
    }
  }

  edge.mesh = mesh;
  edge.color = color;
  grid.group.add(mesh);
}


function makeEdgeMesh(a, b, color, radius) {
  const start = new THREE.Vector3(...a);
  const end = new THREE.Vector3(...b);
  const direction = new THREE.Vector3().subVectors(end, start);
  const length = direction.length();
  const midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
  const axis = new THREE.Vector3(0, 1, 0);
  const geometry = new THREE.CylinderGeometry(radius, radius, length, 8);
  const material = new THREE.MeshBasicMaterial({ color });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.quaternion.setFromUnitVectors(axis, direction.clone().normalize());
  mesh.position.copy(midpoint);
  
  // Apply grid visibility to uncolored edges
  if (color === UNCOLORED_COLOR && !gridVisible) {
    mesh.visible = false;
  }
  
  return mesh;
}

function isSwitchable(box) {
  if (!box || !box.edges || box.edges.length !== 4) return false;

  // Step 1: Filter colored edges
  const sgEdges = box.edges.filter(eKey => {
    const edge = currentGrid.edges.get(eKey);
    return edge && edge.color !== UNCOLORED_COLOR;
  });

  if (sgEdges.length !== 2) return false;

  // Step 2: Compute direction vectors
  const dirs = sgEdges.map(eKey => {
    const [a, b] = unpackEdge(eKey, currentGrid);
    return [
      Math.abs(a[0] - b[0]),
      Math.abs(a[1] - b[1]),
      Math.abs(a[2] - b[2])
    ]; // direction vector as absolute axis difference
  });

  // Step 3: Check if both directions match and are axis-aligned
  const [d1, d2] = dirs;

  const sameDirection = d1[0] === d2[0] && d1[1] === d2[1] && d1[2] === d2[2];
  const axisAligned = (d1[0] + d1[1] + d1[2]) === 1;

  return sameDirection && axisAligned;
}




//     ====================================================================================================================
// 										      5. GRID EDITING AND RELATED FUNCTIONS
//     ====================================================================================================================

//     ==========================================
// 		*** 5.1. Grid Duplication Functions  ***
//     ==========================================
async function duplicateCurrentGrid() {
  if (!currentGrid) {
    alert("No grid to duplicate");
    return;
  }

  // Store reference to source grid for copying
  const sourceGrid = currentGrid;

  // Capture the current camera state from the source grid
  const sourceCameraPosition = camera.position.clone();
  const sourceCameraTarget = controls.target.clone();

  // Find the original grid's name, ID, and position in DOM
  let originalId = null;
  let originalButton = null;
  for (const [id, grid] of allGrids.entries()) {
    if (grid === sourceGrid) {
      originalId = id;
      // Find the corresponding button in the DOM
      const gridButtons = document.querySelectorAll('.grid-btn');
      for (const button of gridButtons) {
        const textSpan = button.querySelector('span');
        if (textSpan) {
          const fullName = textSpan.getAttribute('data-fullname') || textSpan.textContent;
          if (fullName === id) {
            originalButton = button;
            break;
          }
        }
      }
      break;
    }
  }

  if (!originalId || !originalButton) {
    console.error("Could not find original grid ID or button");
    return;
  }

  // Generate unique duplicate ID
  let duplicateId = originalId + "'";
  while (allGrids.has(duplicateId)) {
    duplicateId = duplicateId + "'";
  }

  // Create new grid data structure
  const duplicateGrid = createEmptyGridData();
  duplicateGrid.width = sourceGrid.width;
  duplicateGrid.height = sourceGrid.height;
  duplicateGrid.depth = sourceGrid.depth;

  // Build the basic grid structure - MUST AWAIT!
  await buildGridContent(duplicateGrid);

  // Copy arrow continuity tracking from source grid
  if (sourceGrid.lastArrowedEdgeAtVertex) {
    duplicateGrid.lastArrowedEdgeAtVertex = new Map(sourceGrid.lastArrowedEdgeAtVertex);
  }

  // Set camera position for the duplicate
  duplicateGrid.cameraPosition = sourceCameraPosition;
  duplicateGrid.cameraTarget = sourceCameraTarget;

  // Add to grids collection
  allGrids.set(duplicateId, duplicateGrid);

  // Create UI button and insert it AFTER the original button
  const newButton = createGridButtonElement(duplicateId);
  const gridList = document.getElementById("gridList");

  // Insert after the original button
  if (originalButton.nextSibling) {
    gridList.insertBefore(newButton, originalButton.nextSibling);
  } else {
    gridList.appendChild(newButton);
  }

  // Switch to the duplicate
  switchToGrid(duplicateId);

  // CRITICAL: Load collision meshes and instanced geometries before copying states
  // Otherwise edges, block cubes, and vertices won't be clickable in the duplicate
  if (duplicateGrid.isInstanced) {
    loadEdgeCollision(duplicateGrid);
    loadBlockCubes(duplicateGrid);
    loadVertexSpheres(duplicateGrid);
  }

  // Copy states to the duplicate - now grid is fully built
  copyEdgeStates(sourceGrid, duplicateGrid);
  copySubgraphData(sourceGrid, duplicateGrid);

  // Apply showAllVertices setting to the duplicate grid
  if (duplicateGrid.isInstanced) {
    const grayColor = new THREE.Color(0x888888);
    const identityMatrix = new THREE.Matrix4();
    const zeroMatrix = new THREE.Matrix4().makeScale(0, 0, 0);
    const hasColoredVertices = duplicateGrid.vertexSpheres && duplicateGrid.vertexSpheres.size > 0;

    // Helper function to process vertices in a chunk or global context
    const processVertices = (vertexToInstanceMap, instancedVertexSpheres) => {
      if (!vertexToInstanceMap || !instancedVertexSpheres) return;

      if (showAllVertices) {
        instancedVertexSpheres.visible = true;
        for (const [vKey, instanceIndex] of vertexToInstanceMap.entries()) {
          const hasColoredSphere = duplicateGrid.vertexSpheres?.has(vKey) && duplicateGrid.vertexSpheres.get(vKey).color !== 0x888888;
          if (!hasColoredSphere) {
            const [x, y, z] = unpackVertex(vKey, duplicateGrid);
            identityMatrix.setPosition(x, y, z);
            instancedVertexSpheres.setMatrixAt(instanceIndex, identityMatrix);
            instancedVertexSpheres.setColorAt(instanceIndex, grayColor);
          }
        }
      } else {
        for (const [vKey, instanceIndex] of vertexToInstanceMap.entries()) {
          const hasColoredSphere = duplicateGrid.vertexSpheres?.has(vKey) && duplicateGrid.vertexSpheres.get(vKey).color !== 0x888888;
          if (!hasColoredSphere) {
            instancedVertexSpheres.setMatrixAt(instanceIndex, zeroMatrix);
          }
        }
        instancedVertexSpheres.visible = hasColoredVertices;
      }
      instancedVertexSpheres.instanceMatrix.needsUpdate = true;
      instancedVertexSpheres.instanceColor.needsUpdate = true;
    };

    // Check if we have chunks (multi-chunk grid) or global meshes (single-chunk)
    if (duplicateGrid.chunks && duplicateGrid.chunks.size > 0) {
      for (const chunk of duplicateGrid.chunks.values()) {
        processVertices(chunk.vertexToInstanceMap, chunk.instancedVertexSpheres);
      }
    } else {
      processVertices(duplicateGrid.vertexToInstanceMap, duplicateGrid.instancedVertexSpheres);
    }
  }

  console.log(`Grid duplicated: ${originalId} -> ${duplicateId}`);
}



// Drag and drop handlers for grid buttons
let draggedButton = null;

function handleDragStart(e) {
  draggedButton = this;
  this.classList.add('dragging');
  e.dataTransfer.effectAllowed = 'move';
  e.dataTransfer.setData('text/html', this.innerHTML);
}

function handleDragEnd(e) {
  this.classList.remove('dragging');
  
  // Remove drag-over class from all buttons
  document.querySelectorAll('.grid-btn').forEach(btn => {
    btn.classList.remove('drag-over');
  });
  
  draggedButton = null;
}

function handleDragOver(e) {
  if (e.preventDefault) {
    e.preventDefault();
  }
  e.dataTransfer.dropEffect = 'move';
  return false;
}

function handleDrop(e) {
  if (e.stopPropagation) {
    e.stopPropagation();
  }
  
  if (draggedButton !== this) {
    // Get parent container
    const gridList = document.getElementById('gridList');
    const allButtons = [...gridList.children];
    
    const draggedIndex = allButtons.indexOf(draggedButton);
    const targetIndex = allButtons.indexOf(this);
    
    // Reorder in DOM
    if (draggedIndex < targetIndex) {
      this.parentNode.insertBefore(draggedButton, this.nextSibling);
    } else {
      this.parentNode.insertBefore(draggedButton, this);
    }
  }
  
  this.classList.remove('drag-over');
  return false;
}



function handleDragLeave(e) {
  this.classList.remove('drag-over');
}

// Automatically attach drag handlers whenever a grid button is added to the DOM
const gridListObserver = new MutationObserver((mutations) => {
  mutations.forEach((mutation) => {
    mutation.addedNodes.forEach((node) => {
      if (node.classList && node.classList.contains('grid-btn')) {
        attachGridButtonDnD(node);
      }
    });
  });

  // Update minimizer visibility based on whether grids exist
  const gridList = document.getElementById('gridList');
  const minimizer = document.getElementById('gridListMinimizer');
  if (gridList && minimizer) {
    minimizer.style.display = gridList.children.length > 0 ? 'flex' : 'none';
  }
});

// Start observing #gridList
const gridList = document.getElementById('gridList');
if (gridList) {
  gridListObserver.observe(gridList, { childList: true });
}

// Also run once immediately for any existing buttons
document.querySelectorAll('.grid-btn').forEach(btn => {
  attachGridButtonDnD(btn);
});

// Grid list minimize/expand functionality
let gridListMinimized = false;

document.getElementById('gridListMinimizer').addEventListener('click', () => {
  const container = document.getElementById('gridListContainer');
  const minimizedBlob = document.getElementById('gridListMinimized');
  const gridList = document.getElementById('gridList');

  // Only minimize if there are grids
  if (gridList.children.length > 0) {
    container.style.display = 'none';
    minimizedBlob.style.display = 'block';
    gridListMinimized = true;
  }
});

document.getElementById('gridListMinimized').addEventListener('click', () => {
  const container = document.getElementById('gridListContainer');
  const minimizedBlob = document.getElementById('gridListMinimized');

  container.style.display = 'block';
  minimizedBlob.style.display = 'none';
  gridListMinimized = false;
});

// Camera sensitivity panel close functionality
document.getElementById('cameraSensitivityCloser').addEventListener('click', () => {
  const panel = document.getElementById('cameraSensitivityPanel');
  const checkbox = document.getElementById('showCameraSensitivityCheckbox');

  // Hide the panel
  if (panel) panel.style.display = 'none';

  // Uncheck the checkbox in preferences
  if (checkbox) checkbox.checked = false;

  // Update the global variable
  showCameraSensitivityInMain = false;
});

// Helper function to attach drag-and-drop handlers to grid buttons
function attachGridButtonDnD(btn) {
  btn.draggable = true;
  btn.addEventListener('dragstart', handleDragStart);
  btn.addEventListener('dragend', handleDragEnd);
  btn.addEventListener('dragover', handleDragOver);
  btn.addEventListener('drop', handleDrop);
  btn.addEventListener('dragleave', handleDragLeave);
}

function createGridButtonElement(gridId) {
  const button = document.createElement("div");
  button.className = "grid-btn";
  button.dataset.gridId = gridId;
  
  const grid = allGrids.get(gridId);
  
  const textSpan = document.createElement("span");
  textSpan.style.pointerEvents = "none";

  // Show only first word, but preserve trailing apostrophes for duplicates
  // Store full name in data attribute
  const firstWord = gridId.split(' ')[0];
  // Count trailing apostrophes in the full gridId
  const apostropheMatch = gridId.match(/'*$/);
  const trailingApostrophes = apostropheMatch ? apostropheMatch[0] : '';
  // If the first word doesn't end with the apostrophes, add them
  const displayName = firstWord.endsWith(trailingApostrophes) ? firstWord : firstWord + trailingApostrophes;
  textSpan.textContent = displayName;
  textSpan.setAttribute('data-fullname', gridId);
  
  // Add hover tooltip
  button.title = gridId;
  
  // Add grid info (dimensions only - all grids use instanced rendering now)
  const infoSpan = document.createElement("div");
  infoSpan.className = "grid-info";
  infoSpan.style.pointerEvents = "none";
  infoSpan.textContent = `${grid.width}×${grid.height}×${grid.depth}`;
  
  const close = document.createElement("span");
  close.className = "close";
  close.innerHTML = "&times;";
  close.onclick = e => {
    e.stopPropagation();
    
    // Confirm deletion before proceeding
    if (!confirm("Delete this grid? This cannot be undone.")) {
      return; // User cancelled, do nothing
    }

    const grid = allGrids.get(gridId);
    if (currentGrid === grid) {
      clearEndpointMarkers(grid);
      currentGrid = null;
    }
    disposeGrid(grid);
    scene.remove(grid.group);
    allGrids.delete(gridId);
    button.remove();
  };
  
  button.appendChild(textSpan);
  button.appendChild(infoSpan);
  button.appendChild(close);
  
  button.onclick = (e) => {
    if (e.target !== close) {
      switchToGrid(gridId);
    }
  };
  
  // Double-click to rename
  button.ondblclick = (e) => {
    e.stopPropagation();
    textSpan.style.pointerEvents = "auto";
    textSpan.style.cursor = "text";
    textSpan.textContent = gridId;
    startGridRename(gridId, textSpan, button);
  };
  
  // Attach drag-and-drop handlers
  attachGridButtonDnD(button);
  
  return button;
}





// Update existing grid buttons to be draggable
(function updateExistingButtons() {
  document.querySelectorAll('.grid-btn').forEach(btn => {
    if (!btn.draggable) {
      btn.draggable = true;
      btn.addEventListener('dragstart', handleDragStart);
      btn.addEventListener('dragend', handleDragEnd);
      btn.addEventListener('dragover', handleDragOver);
      btn.addEventListener('drop', handleDrop);
      btn.addEventListener('dragleave', handleDragLeave);
    }
  });
})();

// Also run after a short delay to catch any buttons created during initialization
setTimeout(() => {
  document.querySelectorAll('.grid-btn').forEach(btn => {
    if (!btn.draggable) {
      btn.draggable = true;
      btn.addEventListener('dragstart', handleDragStart);
      btn.addEventListener('dragend', handleDragEnd);
      btn.addEventListener('dragover', handleDragOver);
      btn.addEventListener('drop', handleDrop);
      btn.addEventListener('dragleave', handleDragLeave);
    }
  });
}, 500);


function copyEdgeStates(sourceGrid, targetGrid) {
  // Enable batch mode for edge coloring and block cubes
  targetGrid.batchMode = true;

  // Copy edge colors and block cubes
  for (const [edgeKey, sourceEdge] of sourceGrid.edges.entries()) {
    if (sourceEdge.color !== UNCOLORED_COLOR) {
      const [a, b] = unpackEdge(edgeKey, sourceGrid);
      colorEdge(targetGrid, a, b, sourceEdge.color, thickEdgeRadius);
    }

    // Copy block cubes
    if (sourceEdge.blockCube) {
      const targetEdge = targetGrid.edges.get(edgeKey);
      if (targetEdge) {
        const cubeColor = sourceEdge.blockCubeColor || selectedColor2; // Preserve original color
        if (targetGrid.isInstanced) {
          addBlockCubeInstanced(targetGrid, targetEdge, edgeKey, cubeColor);
        } else {
          addBlockCube(targetEdge, cubeColor);
        }
      }
    }
  }

  // Disable batch mode and sync GPU buffers for edges
  targetGrid.batchMode = false;
  if (targetGrid.isInstanced) {
    if (targetGrid.chunks && targetGrid.chunks.size > 0) {
      for (const chunk of targetGrid.chunks.values()) {
        if (chunk.instancedEdgesThin) {
          chunk.instancedEdgesThin.instanceMatrix.needsUpdate = true;
          chunk.instancedEdgesThin.instanceColor.needsUpdate = true;
        }
        if (chunk.instancedEdgesThick) {
          chunk.instancedEdgesThick.instanceMatrix.needsUpdate = true;
          chunk.instancedEdgesThick.instanceColor.needsUpdate = true;
        }
        if (chunk.instancedEdgesCollision) {
          chunk.instancedEdgesCollision.instanceMatrix.needsUpdate = true;
        }
        if (chunk.instancedBlockCubes) {
          chunk.instancedBlockCubes.instanceMatrix.needsUpdate = true;
        }
      }
    } else {
      if (targetGrid.instancedEdgesThin) {
        targetGrid.instancedEdgesThin.instanceMatrix.needsUpdate = true;
        targetGrid.instancedEdgesThin.instanceColor.needsUpdate = true;
      }
      if (targetGrid.instancedEdgesThick) {
        targetGrid.instancedEdgesThick.instanceMatrix.needsUpdate = true;
        targetGrid.instancedEdgesThick.instanceColor.needsUpdate = true;
      }
      if (targetGrid.instancedEdgesCollision) {
        targetGrid.instancedEdgesCollision.instanceMatrix.needsUpdate = true;
      }
      if (targetGrid.instancedBlockCubes) {
        targetGrid.instancedBlockCubes.instanceMatrix.needsUpdate = true;
      }
    }
  }

  // Copy arrows using the path to preserve direction
  // No setTimeout needed - grid is already fully built with await
  {
    // Check if source grid actually has arrows to copy
    const hasArrows = sourceGrid.edgeToArrowInstanceMap && sourceGrid.edgeToArrowInstanceMap.size > 0;

    // OPTIMIZATION: Use path to copy arrows with correct direction, not all edges
    if (sourceGrid.path && sourceGrid.path.length > 1 && hasArrows) {
      // Copy arrows respecting path direction
      targetGrid.batchMode = true;
      const pathLength = sourceGrid.path.length;
      const isCycle = sourceGrid.path[0] === sourceGrid.path[pathLength - 1];
      const limit = isCycle ? pathLength - 1 : pathLength - 1;

      for (let i = 0; i < limit; i++) {
        const vKeyA = sourceGrid.path[i];
        const vKeyB = sourceGrid.path[i + 1];
        const a = unpackVertex(vKeyA, sourceGrid);
        const b = unpackVertex(vKeyB, sourceGrid);
        const eKey = edgeKey(a, b, targetGrid);

        const sourceEdge = sourceGrid.edges.get(eKey);
        const targetEdge = targetGrid.edges.get(eKey);

        if (sourceEdge && targetEdge && sourceEdge.arrows) {
          // Temporarily set arrow render mode to match the source arrow type
          const originalMode = arrowRenderMode;
          arrowRenderMode = sourceEdge.arrows; // 'normal' or 'transcendent'

          // Pass path-order coordinates to preserve direction
          addArrowsToEdge(targetEdge, sourceEdge.arrowDirection, a, b, eKey);

          // Restore original mode
          arrowRenderMode = originalMode;
        }
      }

      targetGrid.batchMode = false;

      // Sync GPU once after batch - for transcendent arrows
      if (targetGrid.instancedArrowsForward) {
        targetGrid.instancedArrowsForward.instanceMatrix.needsUpdate = true;
      }
      if (targetGrid.instancedArrowsBackward) {
        targetGrid.instancedArrowsBackward.instanceMatrix.needsUpdate = true;
      }
      updateArrowInstanceCounts(targetGrid);

      // Sync GPU for normal arrows - update arrowState attribute on thick edges
      if (targetGrid.chunks && targetGrid.chunks.size > 0) {
        for (const chunk of targetGrid.chunks.values()) {
          if (chunk.instancedEdgesThick) {
            const arrowStateAttr = chunk.instancedEdgesThick.geometry.getAttribute('arrowState');
            if (arrowStateAttr) {
              arrowStateAttr.needsUpdate = true;
            }
          }
        }
      } else if (targetGrid.instancedEdgesThick) {
        const arrowStateAttr = targetGrid.instancedEdgesThick.geometry.getAttribute('arrowState');
        if (arrowStateAttr) {
          arrowStateAttr.needsUpdate = true;
        }
      }

      // CRITICAL: Sync collision mesh buffers for clickability
      if (targetGrid.chunks && targetGrid.chunks.size > 0) {
        for (const chunk of targetGrid.chunks.values()) {
          if (chunk.instancedEdgesCollision) {
            chunk.instancedEdgesCollision.instanceMatrix.needsUpdate = true;
          }
        }
      } else if (targetGrid.instancedEdgesCollision) {
        targetGrid.instancedEdgesCollision.instanceMatrix.needsUpdate = true;
      }

      console.log(`[Duplication] Copied arrows from path (${limit} edges)`);
    } else {
      // Fallback: copy all arrows from all edges (no path available)
      let arrowCount = 0;
      targetGrid.batchMode = true;

      for (const [eKey, sourceEdge] of sourceGrid.edges.entries()) {
        if (sourceEdge.arrows && sourceEdge.arrowDirection !== undefined) {
          const targetEdge = targetGrid.edges.get(eKey);
          if (targetEdge) {
            // Temporarily set arrow render mode to match the source arrow type
            const originalMode = arrowRenderMode;
            arrowRenderMode = sourceEdge.arrows; // 'normal' or 'transcendent'

            addArrowsToEdge(targetEdge, sourceEdge.arrowDirection, null, null, eKey);
            arrowCount++;

            // Restore original mode
            arrowRenderMode = originalMode;
          }
        }
      }

      targetGrid.batchMode = false;

      // Sync GPU once after batch - for transcendent arrows
      if (targetGrid.instancedArrowsForward) {
        targetGrid.instancedArrowsForward.instanceMatrix.needsUpdate = true;
      }
      if (targetGrid.instancedArrowsBackward) {
        targetGrid.instancedArrowsBackward.instanceMatrix.needsUpdate = true;
      }
      updateArrowInstanceCounts(targetGrid);

      // Sync GPU for normal arrows - update arrowState attribute on thick edges
      if (targetGrid.chunks && targetGrid.chunks.size > 0) {
        for (const chunk of targetGrid.chunks.values()) {
          if (chunk.instancedEdgesThick) {
            const arrowStateAttr = chunk.instancedEdgesThick.geometry.getAttribute('arrowState');
            if (arrowStateAttr) {
              arrowStateAttr.needsUpdate = true;
            }
          }
        }
      } else if (targetGrid.instancedEdgesThick) {
        const arrowStateAttr = targetGrid.instancedEdgesThick.geometry.getAttribute('arrowState');
        if (arrowStateAttr) {
          arrowStateAttr.needsUpdate = true;
        }
      }

      // CRITICAL: Sync collision mesh buffers for clickability
      if (targetGrid.chunks && targetGrid.chunks.size > 0) {
        for (const chunk of targetGrid.chunks.values()) {
          if (chunk.instancedEdgesCollision) {
            chunk.instancedEdgesCollision.instanceMatrix.needsUpdate = true;
          }
        }
      } else if (targetGrid.instancedEdgesCollision) {
        targetGrid.instancedEdgesCollision.instanceMatrix.needsUpdate = true;
      }

      if (arrowCount > 0) {
        console.log(`[Duplication] Copied ${arrowCount} arrows (fallback mode)`);
      }
    }
  }

  // Copy vertex spheres and their decorations
  if (sourceGrid.vertexSpheres && sourceGrid.vertexSpheres.size > 0) {
    for (const [vertexKey, sphereData] of sourceGrid.vertexSpheres.entries()) {
      // Handle both old format (direct sphere) and new format (sphere/decoration object)
      let sphere, decoration, color;
      if (sphereData.sphere) {
        // New format
        sphere = sphereData.sphere;
        decoration = sphereData.decoration;

        // Get color (works for both instanced and individual mode)
        if (sourceGrid.isInstanced) {
          color = sphereData.color;
        } else {
          color = sphere.material.color.getHex();
        }
      } else {
        // Old format - sphereData is the sphere itself
        sphere = sphereData;
        decoration = null;
        color = sphere.material.color.getHex();
      }

      createVertexSphere(targetGrid, vertexKey, color);

      // Copy decoration if it exists
      if (decoration) {
        // Extract decoration color from the decoration
        let decorationColor;
        if (decoration.children && decoration.children.length > 0) {
          decorationColor = decoration.children[0].material.color.getHex();
        } else if (decoration.material) {
          decorationColor = decoration.material.color.getHex();
        }

        if (decorationColor !== undefined) {
          addVertexDecoration(targetGrid, vertexKey, decorationColor);
        }
      }
    }
  }

  // Copy standalone decorations (decorations without vertex spheres)
  if (sourceGrid.standaloneDecorations) {
    for (const [vertexKey, decorationData] of sourceGrid.standaloneDecorations.entries()) {
      // Extract decoration color
      let decorationColor;
      if (decorationData.decorationGroup && decorationData.decorationGroup.children && decorationData.decorationGroup.children.length > 0) {
        decorationColor = decorationData.decorationGroup.children[0].material.color.getHex();
      }

      if (decorationColor !== undefined) {
        addVertexDecoration(targetGrid, vertexKey, decorationColor);
      }
    }
  }

  // Note: All arrows (including path arrows) are already copied in the loop above
  // No need for additional arrow processing - verbatim copy preserves exact arrow directions
}

function copySubgraphData(sourceGrid, targetGrid) {
  if (!sourceGrid.activeSubgraph) return;

  // Create new subgraph for target
  const newSubgraph = new Subgraph(targetGrid);

  // Copy all edges from source subgraph
  for (const edgeKey of sourceGrid.activeSubgraph.getEdgeKeys()) {
    const [a, b] = unpackEdge(edgeKey, sourceGrid);
    const aKey = vertexKey(a[0], a[1], a[2], targetGrid);
    const bKey = vertexKey(b[0], b[1], b[2], targetGrid);

    // Add edge to new subgraph (this will also handle coloring)
    newSubgraph.edges.add(edgeKey);
    newSubgraph.vertices.add(aKey);
    newSubgraph.vertices.add(bKey);
  }

  // Copy arrow directions from source subgraph
  for (const [edgeKey, direction] of sourceGrid.activeSubgraph.edgeDirections.entries()) {
    newSubgraph.edgeDirections.set(edgeKey, direction);
  }

  // Sync arrow directions to target grid edges
  newSubgraph.syncArrowsToGrid();

  targetGrid.activeSubgraph = newSubgraph;

  // Copy path data if it exists
  if (sourceGrid.path) {
    targetGrid.path = [...sourceGrid.path]; // Create a copy of the array

    // Copy cycle reference if source has a cycle
    if (sourceGrid.cycle) {
      targetGrid.cycle = targetGrid.activeSubgraph;
    }

    // Only add endpoint markers if this is a PATH (not a cycle)
    // Check if source grid has a cycle - if so, don't add markers
    if (!sourceGrid.cycle && targetGrid.path.length >= 2) {
      const startKey = targetGrid.path[0];
      const endKey = targetGrid.path[targetGrid.path.length - 1];

      // Clear any existing markers first
      clearEndpointMarkers(targetGrid);

      // Parse coordinates and create markers
      const [sx, sy, sz] = unpackVertex(startKey, targetGrid);
      const [ex, ey, ez] = unpackVertex(endKey, targetGrid);

      // Create start marker (green for active, red for inactive)
      const startColor = activeEndpoint === 'start' ? 0x00ff00 : 0xff0000;
      const startSphere = new THREE.Mesh(
        new THREE.SphereGeometry(0.15, 16, 16),
        new THREE.MeshBasicMaterial({ color: startColor })
      );
      startSphere.position.set(sx, sy, sz);
      targetGrid.group.add(startSphere);
      targetGrid.startMarker = startSphere;

      // Create end marker
      const endColor = activeEndpoint === 'end' ? 0x00ff00 : 0xff0000;
      const endSphere = new THREE.Mesh(
        new THREE.SphereGeometry(0.15, 16, 16),
        new THREE.MeshBasicMaterial({ color: endColor })
      );
      endSphere.position.set(ex, ey, ez);
      targetGrid.group.add(endSphere);
      targetGrid.endMarker = endSphere;
    }
  }
}


//     =============================================
// 		*** 5.2. Grid Tabs and Naming Functions ***
//     =============================================
function createGridButton(gridId) {
  const button = createGridButtonElement(gridId);
  document.getElementById("gridList").appendChild(button);
  
  if (currentGrid && allGrids.get(gridId) === currentGrid) {
    button.classList.add('active');
  }
}

function startGridRename(oldId, textSpan, button) {
  const input = document.createElement("input");
  input.type = "text";
  input.value = oldId;
  input.style.width = "80px";
  input.style.fontSize = "14px";
  input.style.border = "1px solid #ccc";
  input.style.borderRadius = "3px";
  input.style.padding = "2px 4px";
  
  let isFinishing = false; // Prevent multiple calls
  
  const finishRename = () => {
    if (isFinishing || !input.parentNode) return; // Already processing or removed
    isFinishing = true;
    
    const newId = input.value.trim();
    if (newId && newId !== oldId && !allGrids.has(newId)) {
      // Update grid collection
      const grid = allGrids.get(oldId);
      allGrids.delete(oldId);
      allGrids.set(newId, grid);
      
      // Update current grid reference if needed
      if (currentGrid === grid) {
        button.onclick = () => switchToGrid(newId);
      }
      
      // Update display: show up to second space
      const getDisplayName = (fullName) => {
        const parts = fullName.split(' ');
        return parts.length <= 2 ? fullName : parts.slice(0, 2).join(' ');
      };
      
      const displayName = getDisplayName(newId);
      textSpan.textContent = displayName;
      textSpan.setAttribute('data-fullname', newId);
      button.title = newId;
      textSpan.onclick = (e) => {
        e.stopPropagation();
        textSpan.textContent = newId;
        startGridRename(newId, textSpan, button);
      };
    } else {
      // Revert to display name if invalid
      const getDisplayName = (fullName) => {
        const parts = fullName.split(' ');
        return parts.length <= 2 ? fullName : parts.slice(0, 2).join(' ');
      };
      const displayName = getDisplayName(oldId);
      textSpan.textContent = displayName;
    }
    
    textSpan.style.display = "inline";
    if (input.parentNode) input.remove();
  };
  
  input.onblur = finishRename;
  input.onkeydown = (e) => {
    if (e.key === "Enter") finishRename();
    if (e.key === "Escape") {
      if (isFinishing) return;
      isFinishing = true;
      
      const getDisplayName = (fullName) => {
        const parts = fullName.split(' ');
        return parts.length <= 2 ? fullName : parts.slice(0, 2).join(' ');
      };
      const displayName = getDisplayName(oldId);
      textSpan.textContent = displayName;
      textSpan.style.display = "inline";
      if (input.parentNode) input.remove();
    }
  };
  
  textSpan.style.display = "none";
  button.insertBefore(input, textSpan);
  input.focus();
  input.select();
}




//     ===================================================
// 		*** 5.3. Add/Remove Edge/Cube/Arrow Functions ***
//     ===================================================


function handleEdgeClick(intersects) {
  const clicked = intersects[0].object;
  
  // Check if we clicked on a collision helper first
  if (clicked.userData.parentEdge) {
    const eKey = clicked.userData.parentEdge;
    const edge = currentGrid.edges.get(eKey);
    
    if (!edge) return;
    
    const [a, b] = unpackEdge(eKey);
    
    const beforeState = captureEdgeState(eKey);
    
    // ARROW MODE GETS PRIORITY
    if (arrowMode) {
      if (edge.arrowDirection === 0 || edge.arrowDirection === undefined) {
        edge.arrowDirection = 1;
        colorEdge(currentGrid, a, b, selectedColor, thickEdgeRadius);
        addArrowsToEdge(edge, 1);
        
        if (!currentGrid.activeSubgraph) {
          currentGrid.activeSubgraph = new Subgraph(currentGrid);
        }
        currentGrid.activeSubgraph.addEdge(a, b);
      } else if (edge.arrowDirection === 1) {
        edge.arrowDirection = -1;
        addArrowsToEdge(edge, -1);
      } else if (edge.arrowDirection === -1) {
        edge.arrowDirection = 0;
        removeArrowsFromEdge(edge);
        colorEdge(currentGrid, a, b, UNCOLORED_COLOR, thinEdgeRadius);
        
        if (currentGrid.activeSubgraph) {
          currentGrid.activeSubgraph.removeEdge(a, b);
        }
      }
      
      const afterState = captureEdgeState(eKey);
      recordAction('EDGE_STATE', { edgeKey: eKey, beforeState, afterState });
      return;
    }
    
    // Simple toggle: uncolored <-> colored (no cube logic)
    const isColored = edge.color !== UNCOLORED_COLOR;
    if (isColored) {
      colorEdge(currentGrid, a, b, UNCOLORED_COLOR, thinEdgeRadius);
      if (currentGrid.activeSubgraph) {
        currentGrid.activeSubgraph.removeEdge(a, b);
      }
    } else {
      colorEdge(currentGrid, a, b, selectedColor, thickEdgeRadius);
      if (!currentGrid.activeSubgraph) {
        currentGrid.activeSubgraph = new Subgraph(currentGrid);
      }
      currentGrid.activeSubgraph.addEdge(a, b);
    }
    
    const afterState = captureEdgeState(eKey);
    recordAction('EDGE_STATE', { edgeKey: eKey, beforeState, afterState });
    return;
  }
  
  // Direct mesh clicks (same logic as above)
  for (const [key, edge] of currentGrid.edges.entries()) {
    if (edge.mesh === clicked) {
      const [a, b] = unpackEdge(key);
      
      const beforeState = captureEdgeState(key);
      
      // ARROW MODE GETS PRIORITY
      if (arrowMode) {
        if (edge.arrowDirection === 0 || edge.arrowDirection === undefined) {
          edge.arrowDirection = 1;
          colorEdge(currentGrid, a, b, selectedColor, thickEdgeRadius);
          addArrowsToEdge(edge, 1);
          
          if (!currentGrid.activeSubgraph) {
            currentGrid.activeSubgraph = new Subgraph(currentGrid);
          }
          currentGrid.activeSubgraph.addEdge(a, b);
        } else if (edge.arrowDirection === 1) {
          edge.arrowDirection = -1;
          addArrowsToEdge(edge, -1);
        } else if (edge.arrowDirection === -1) {
          edge.arrowDirection = 0;
          removeArrowsFromEdge(edge);
          colorEdge(currentGrid, a, b, UNCOLORED_COLOR, thinEdgeRadius);
          
          if (currentGrid.activeSubgraph) {
            currentGrid.activeSubgraph.removeEdge(a, b);
          }
        }
        
        const afterState = captureEdgeState(key);
        recordAction('EDGE_STATE', { edgeKey: key, beforeState, afterState });
        return;
      }
      
      // Simple toggle: uncolored <-> colored (no cube logic)
      const isColored = edge.color !== UNCOLORED_COLOR;
      if (isColored) {
        colorEdge(currentGrid, a, b, UNCOLORED_COLOR, thinEdgeRadius);
        if (currentGrid.activeSubgraph) {
          currentGrid.activeSubgraph.removeEdge(a, b);
        }
      } else {
        colorEdge(currentGrid, a, b, selectedColor, thickEdgeRadius);
        if (!currentGrid.activeSubgraph) {
          currentGrid.activeSubgraph = new Subgraph(currentGrid);
        }
        currentGrid.activeSubgraph.addEdge(a, b);
      }
      
      const afterState = captureEdgeState(key);
      recordAction('EDGE_STATE', { edgeKey: key, beforeState, afterState });
      break;
    }
  }
}


function handleCubeClick() {
  const edgeMeshes = Array.from(currentGrid.edges.values()).map(e => e.mesh).filter(m => m);
  const intersects = raycaster.intersectObjects(edgeMeshes);
  
  if (intersects.length > 0) {
    const clicked = intersects[0].object;
    
    // Find the edge
    let targetEdge = null;
    let targetEdgeKey = null;
    
    // Check collision helper first
    if (clicked.userData.parentEdge) {
      targetEdgeKey = clicked.userData.parentEdge;
      targetEdge = currentGrid.edges.get(targetEdgeKey);
    } else {
      // Direct mesh click
      for (const [key, edge] of currentGrid.edges.entries()) {
        if (edge.mesh === clicked) {
          targetEdgeKey = key;
          targetEdge = edge;
          break;
        }
      }
    }
    
    if (targetEdge && targetEdgeKey) {
      const beforeState = captureEdgeState(targetEdgeKey);
      
      // Toggle cube
      if (targetEdge.blockCube) {
        removeBlockCube(targetEdge);
      } else {
        addBlockCube(targetEdge);
      }
      
      const afterState = captureEdgeState(targetEdgeKey);
      recordAction('EDGE_STATE', { edgeKey: targetEdgeKey, beforeState, afterState });
    }
  }
}

function addBlockCube(edge, color = null) {
  if (edge.blockCube) return; // Already has one

  const cubeColorHex = color !== null ? color : selectedColor2;
  const geometry = new THREE.BoxGeometry(blockCubeSize, blockCubeSize, blockCubeSize);
  const material = new THREE.MeshBasicMaterial({ color: cubeColorHex });
  const cube = new THREE.Mesh(geometry, material);

  // Position at edge midpoint
  cube.position.copy(edge.mesh.position);
  cube.raycast = () => {}; // Ignore raycasting

  edge.blockCube = cube;
  edge.blockCubeColor = cubeColorHex; // Store color on edge
  currentGrid.group.add(cube);
}

function removeBlockCube(edge) {
  if (!edge.blockCube) return;
  
  currentGrid.group.remove(edge.blockCube);
  edge.blockCube.geometry.dispose();
  edge.blockCube.material.dispose();
  edge.blockCube = null;
}


//     ===============================================
// 		*** 5.4. Add/Remove Vertex/Decorate Functions ***
//     ===============================================
function toggleVertexSphere(vertexKey) {
  const hasDecoration = decorationEnabled;
  const beforeState = captureVertexSphereState(vertexKey);
  
  if (!currentGrid.vertexSpheres.has(vertexKey)) {
    // First click: create uncolored sphere
    createVertexSphere(currentGrid, vertexKey, 0x888888);
    const afterState = captureVertexSphereState(vertexKey);
    recordAction('VERTEX_SPHERE', { vertexKey, beforeState, afterState });
  } else {
    const sphereData = currentGrid.vertexSpheres.get(vertexKey);
    const sphere = sphereData.sphere;
    const decoration = sphereData.decoration;
    
    // Get current color (works for both instanced and individual mode)
    const currentColor = currentGrid.isInstanced 
      ? sphereData.color 
      : sphere.material.color.getHex();
    
    if (currentColor === 0x888888 && !decoration) {
      // Second click: color with selected color
      if (currentGrid.isInstanced) {
        createVertexSphere(currentGrid, vertexKey, selectedColor);
      } else {
        sphere.material.color.setHex(selectedColor);
      }
      const afterState = captureVertexSphereState(vertexKey);
      recordAction('VERTEX_SPHERE', { vertexKey, beforeState, afterState });
    } else if (currentColor !== 0x888888 && !decoration && hasDecoration) {
      // Third click (if decorations enabled): add decoration
      addVertexDecoration(currentGrid, vertexKey, selectedColor2);
      const afterState = captureVertexSphereState(vertexKey);
      recordAction('VERTEX_DECORATION', { vertexKey, beforeState, afterState });
    } else {
      // Final click: remove sphere (and decoration if present)
      removeVertexSphere(currentGrid, vertexKey);
      const afterState = null;
      recordAction('VERTEX_SPHERE', { vertexKey, beforeState, afterState });
    }
  }
}


function createVertexSphereInstanced(grid, vertexKey, color) {
  // Find the chunk this vertex belongs to
  const chunkKey = grid.vertexToChunk ? grid.vertexToChunk.get(vertexKey) : null;
  let chunk, instanceIndex;

  if (chunkKey && grid.chunks) {
    chunk = grid.chunks.get(chunkKey);
    instanceIndex = chunk ? chunk.vertexToInstanceMap.get(vertexKey) : undefined;
  } else {
    // Fallback for single-chunk grids (backwards compatibility)
    chunk = null;
    instanceIndex = grid.vertexToInstanceMap ? grid.vertexToInstanceMap.get(vertexKey) : undefined;
  }

  if (instanceIndex === undefined) {
    console.error('[createVertexSphereInstanced] instanceIndex undefined for vertexKey:', vertexKey);
    console.error('[createVertexSphereInstanced] chunkKey:', chunkKey);
    console.error('[createVertexSphereInstanced] Has vertexToChunk:', !!grid.vertexToChunk);
    console.error('[createVertexSphereInstanced] Has vertexToInstanceMap:', !!grid.vertexToInstanceMap);
    console.error('[createVertexSphereInstanced] Vertex exists in grid.vertices:', grid.vertices.has(vertexKey));
    return;
  }

  const [x, y, z] = unpackVertex(vertexKey, grid);
  const position = new THREE.Vector3(x, y, z);

  // Create transform matrix (identity scale at position)
  const matrix = new THREE.Matrix4().setPosition(position);

  // Get the appropriate meshes (from chunk or global)
  const instancedVertexSpheres = chunk ? chunk.instancedVertexSpheres : grid.instancedVertexSpheres;
  const instancedVertexCollisionHelpers = chunk ? chunk.instancedVertexCollisionHelpers : grid.instancedVertexCollisionHelpers;
  const pointVertices = chunk ? chunk.pointVertices : grid.pointVertices;

  // CRITICAL FIX: Make visual spheres visible only if "Show All Vertices" is ON
  // OR if there are any colored vertices
  // Check if we need to make mesh visible
  const hasColoredVertices = grid.vertexSpheres.size > 0 || color !== 0x888888;
  if (hasColoredVertices && instancedVertexSpheres) {
    instancedVertexSpheres.visible = true;
  }

  // Set visual sphere
  if (instancedVertexSpheres) {
    instancedVertexSpheres.setMatrixAt(instanceIndex, matrix);
    instancedVertexSpheres.setColorAt(instanceIndex, new THREE.Color(color));
    instancedVertexSpheres.instanceMatrix.needsUpdate = true;
    instancedVertexSpheres.instanceColor.needsUpdate = true;
  }

  // Sync color to point geometry for LOD level 3
  if (pointVertices) {
    const colorArray = pointVertices.geometry.attributes.color.array;
    const threeColor = new THREE.Color(color);
    colorArray[instanceIndex * 3 + 0] = threeColor.r;
    colorArray[instanceIndex * 3 + 1] = threeColor.g;
    colorArray[instanceIndex * 3 + 2] = threeColor.b;
    pointVertices.geometry.attributes.color.needsUpdate = true;
  }

  // Set collision helper
  if (instancedVertexCollisionHelpers) {
    instancedVertexCollisionHelpers.setMatrixAt(instanceIndex, matrix);
    instancedVertexCollisionHelpers.instanceMatrix.needsUpdate = true;
  }

  // Store in vertexSpheres map for compatibility
  if (!grid.vertexSpheres.has(vertexKey)) {
    // Check if there's a standalone decoration for this coordinate
    let decoration = null;
    if (grid.standaloneDecorations.has(vertexKey)) {
      decoration = grid.standaloneDecorations.get(vertexKey).decorationGroup;
      grid.standaloneDecorations.delete(vertexKey);
    }

    grid.vertexSpheres.set(vertexKey, {
      sphere: 'instanced',  // Marker
      decoration: decoration,
      collisionHelper: 'instanced',  // Marker
      color: color
    });
  } else {
    const sphereData = grid.vertexSpheres.get(vertexKey);
    sphereData.color = color;
  }
}

function removeVertexSphereInstanced(grid, vertexKey) {
  // Find the chunk this vertex belongs to
  const chunkKey = grid.vertexToChunk ? grid.vertexToChunk.get(vertexKey) : null;
  let chunk, instanceIndex;

  if (chunkKey && grid.chunks) {
    chunk = grid.chunks.get(chunkKey);
    instanceIndex = chunk ? chunk.vertexToInstanceMap.get(vertexKey) : undefined;
  } else {
    // Fallback for single-chunk grids (backwards compatibility)
    chunk = null;
    instanceIndex = grid.vertexToInstanceMap ? grid.vertexToInstanceMap.get(vertexKey) : undefined;
  }

  if (instanceIndex === undefined) return;

  // Remove decoration if present (keep individual)
  const sphereData = grid.vertexSpheres.get(vertexKey);
  if (sphereData && sphereData.decoration) {
    grid.group.remove(sphereData.decoration);
    if (sphereData.decoration.children) {
      sphereData.decoration.children.forEach(child => {
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
      });
    } else {
      if (sphereData.decoration.geometry) sphereData.decoration.geometry.dispose();
      if (sphereData.decoration.material) sphereData.decoration.material.dispose();
    }
  }

  // Remove from tracking
  grid.vertexSpheres.delete(vertexKey);

  // Get the appropriate meshes (from chunk or global)
  const instancedVertexSpheres = chunk ? chunk.instancedVertexSpheres : grid.instancedVertexSpheres;
  const instancedVertexCollisionHelpers = chunk ? chunk.instancedVertexCollisionHelpers : grid.instancedVertexCollisionHelpers;
  const pointVertices = chunk ? chunk.pointVertices : grid.pointVertices;

  // Behavior like gray edges: restore gray vertex if showAllVertices is ON
  if (grid.showAllVertices) {
    // Show gray sphere at this position
    const [x, y, z] = unpackVertex(vertexKey, grid);
    const matrix = new THREE.Matrix4().setPosition(x, y, z);
    const grayColor = new THREE.Color(0x888888);

    if (instancedVertexSpheres) {
      instancedVertexSpheres.setMatrixAt(instanceIndex, matrix);
      instancedVertexSpheres.setColorAt(instanceIndex, grayColor);
      instancedVertexSpheres.instanceMatrix.needsUpdate = true;
      instancedVertexSpheres.instanceColor.needsUpdate = true;
    }
  } else {
    // Hide by scaling to zero
    const zeroMatrix = new THREE.Matrix4().makeScale(0, 0, 0);
    if (instancedVertexSpheres) {
      instancedVertexSpheres.setMatrixAt(instanceIndex, zeroMatrix);
      instancedVertexSpheres.instanceMatrix.needsUpdate = true;
    }
  }

  // Reset point color to gray for LOD level 3
  if (pointVertices) {
    const colorArray = pointVertices.geometry.attributes.color.array;
    colorArray[instanceIndex * 3 + 0] = 0.533; // 0x88/255
    colorArray[instanceIndex * 3 + 1] = 0.533;
    colorArray[instanceIndex * 3 + 2] = 0.533;
    pointVertices.geometry.attributes.color.needsUpdate = true;
  }

  // Collision helper always stays at vertex position (for clicking)
  const [x, y, z] = unpackVertex(vertexKey, grid);
  const collisionMatrix = new THREE.Matrix4().setPosition(x, y, z);
  if (instancedVertexCollisionHelpers) {
    instancedVertexCollisionHelpers.setMatrixAt(instanceIndex, collisionMatrix);
    instancedVertexCollisionHelpers.instanceMatrix.needsUpdate = true;
  }
}

function createVertexSphere(grid, vertexKey, color) {
  // Remove existing sphere if present
  if (grid.vertexSpheres.has(vertexKey)) {
    removeVertexSphere(grid, vertexKey);
  }
  
  // Dispatch to instanced or individual mode
  if (grid.isInstanced) {
    createVertexSphereInstanced(grid, vertexKey, color);
    return;
  }
  
  // Individual mode (original code)
  const [x, y, z] = unpackVertex(vertexKey, grid);

  const geometry = new THREE.SphereGeometry(vertexRadius, 16, 16);
  const material = new THREE.MeshBasicMaterial({ color });
  const sphere = new THREE.Mesh(geometry, material);
  sphere.position.set(x, y, z);
  
  grid.group.add(sphere);

  const existingCollisionHelper = grid.vertices.get(vertexKey)?.collisionHelper;

  // Check if there's a standalone decoration for this coordinate
  let decoration = null;
  if (grid.standaloneDecorations.has(vertexKey)) {
    decoration = grid.standaloneDecorations.get(vertexKey).decorationGroup;
    grid.standaloneDecorations.delete(vertexKey);
  }

  grid.vertexSpheres.set(vertexKey, {
    sphere: sphere,
    decoration: decoration,
    collisionHelper: existingCollisionHelper
  });

  return sphere;
}


function addVertexDecoration(grid, vertexKey, decorationColor) {
  // Check if decoration already exists (on vertex sphere or standalone)
  if (grid.vertexSpheres.has(vertexKey)) {
    const sphereData = grid.vertexSpheres.get(vertexKey);
    if (sphereData.decoration) return; // Already has decoration on this vertex
  }

  if (grid.standaloneDecorations.has(vertexKey)) {
    return; // Already has standalone decoration at this coordinate
  }

  const [x, y, z] = unpackVertex(vertexKey, grid);
  const sphereRadius = vertexRadius; // Use current vertex radius setting

  const decorationGroup = new THREE.Group();
  decorationGroup.position.set(x, y, z);

  const segments = 32;

  // === Equatorial band (unchanged) ===
  const equatorGeometry = new THREE.SphereGeometry(
    vertexDecorationRadius, // Use absolute decoration radius
    segments, segments,
    0, Math.PI * 2,                    // full phi range
    Math.PI/2 - 0.15, 0.3              // thin theta band around equator
  );
  const equatorMaterial = new THREE.MeshBasicMaterial({
    color: decorationColor,
    transparent: true,
    opacity: 0.8,
    depthTest: false,
    depthWrite: false
  });
  const equatorBand = new THREE.Mesh(equatorGeometry, equatorMaterial);
  equatorBand.renderOrder = 10;
  decorationGroup.add(equatorBand);

  // === Second band (rotated around Z-axis) ===
  const band2Geometry = new THREE.SphereGeometry(
    vertexDecorationRadius, // Use absolute decoration radius
    segments, segments,
    0, Math.PI * 2,                    // full phi range
    Math.PI/2 - 0.15, 0.3              // thin theta band around equator
  );
  const band2Material = new THREE.MeshBasicMaterial({
    color: decorationColor,
    transparent: true,
    opacity: 0.8,
    depthTest: false,
    depthWrite: false
  });
  const band2 = new THREE.Mesh(band2Geometry, band2Material);
  band2.rotation.z = Math.PI / 2;  // Rotate 90 degrees around Z-axis
  band2.renderOrder = 10;
  decorationGroup.add(band2);

  // === Third band (rotated around X-axis) ===
  const band3Geometry = new THREE.SphereGeometry(
    vertexDecorationRadius, // Use absolute decoration radius
    segments, segments,
    0, Math.PI * 2,                    // full phi range
    Math.PI/2 - 0.15, 0.3              // thin theta band around equator
  );
  const band3Material = new THREE.MeshBasicMaterial({
    color: decorationColor,
    transparent: true,
    opacity: 0.8,
    depthTest: false,
    depthWrite: false
  });
  const band3 = new THREE.Mesh(band3Geometry, band3Material);
  band3.rotation.x = Math.PI / 2;  // Rotate 90 degrees around X-axis
  band3.renderOrder = 10;
  decorationGroup.add(band3);

  grid.group.add(decorationGroup);

  // If vertex sphere exists, attach to it; otherwise store as standalone
  if (grid.vertexSpheres.has(vertexKey)) {
    grid.vertexSpheres.get(vertexKey).decoration = decorationGroup;
  } else {
    grid.standaloneDecorations.set(vertexKey, {
      decorationGroup: decorationGroup,
      color: decorationColor
    });
  }
}

function rebuildVertexDecorationsWithNewSize(grid, newDecoRadius) {
  console.log(`[rebuildVertexDecorations] Rebuilding decorations with size ${newDecoRadius.toFixed(4)}`);

  // Rebuild decorations attached to vertex spheres
  for (const [vertexKey, sphereData] of grid.vertexSpheres.entries()) {
    if (sphereData.decoration) {
      const oldDecoration = sphereData.decoration;
      const decorationColor = oldDecoration.children[0].material.color.getHex();

      // Remove old decoration
      grid.group.remove(oldDecoration);
      // Dispose geometries and materials
      oldDecoration.children.forEach(child => {
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
      });

      // Create new decoration with new size
      const [x, y, z] = unpackVertex(vertexKey, grid);
      const decorationGroup = new THREE.Group();
      decorationGroup.position.set(x, y, z);

      const segments = 32;

      // Create three bands with new radius
      const createBand = (rotationAxis, rotationAngle) => {
        const geometry = new THREE.SphereGeometry(
          newDecoRadius, // Use new decoration radius
          segments, segments,
          0, Math.PI * 2,
          Math.PI/2 - 0.15, 0.3
        );
        const material = new THREE.MeshBasicMaterial({
          color: decorationColor,
          transparent: true,
          opacity: 0.8,
          depthTest: false,
          depthWrite: false
        });
        const band = new THREE.Mesh(geometry, material);
        if (rotationAxis === 'x') band.rotation.x = rotationAngle;
        if (rotationAxis === 'z') band.rotation.z = rotationAngle;
        band.renderOrder = 10;
        return band;
      };

      decorationGroup.add(createBand(null, 0)); // Equatorial
      decorationGroup.add(createBand('z', Math.PI / 2)); // Second band
      decorationGroup.add(createBand('x', Math.PI / 2)); // Third band

      grid.group.add(decorationGroup);
      sphereData.decoration = decorationGroup;
    }
  }

  // Rebuild standalone decorations
  for (const [vertexKey, decorationData] of grid.standaloneDecorations.entries()) {
    const oldDecoration = decorationData.decorationGroup;
    const decorationColor = decorationData.color;

    // Remove old decoration
    grid.group.remove(oldDecoration);
    // Dispose geometries and materials
    oldDecoration.children.forEach(child => {
      if (child.geometry) child.geometry.dispose();
      if (child.material) child.material.dispose();
    });

    // Create new decoration with new size
    const [x, y, z] = unpackVertex(vertexKey, grid);
    const decorationGroup = new THREE.Group();
    decorationGroup.position.set(x, y, z);

    const segments = 32;

    const createBand = (rotationAxis, rotationAngle) => {
      const geometry = new THREE.SphereGeometry(
        newDecoRadius,
        segments, segments,
        0, Math.PI * 2,
        Math.PI/2 - 0.15, 0.3
      );
      const material = new THREE.MeshBasicMaterial({
        color: decorationColor,
        transparent: true,
        opacity: 0.8,
        depthTest: false,
        depthWrite: false
      });
      const band = new THREE.Mesh(geometry, material);
      if (rotationAxis === 'x') band.rotation.x = rotationAngle;
      if (rotationAxis === 'z') band.rotation.z = rotationAngle;
      band.renderOrder = 10;
      return band;
    };

    decorationGroup.add(createBand(null, 0));
    decorationGroup.add(createBand('z', Math.PI / 2));
    decorationGroup.add(createBand('x', Math.PI / 2));

    grid.group.add(decorationGroup);
    decorationData.decorationGroup = decorationGroup;
  }

  console.log(`[rebuildVertexDecorations] Rebuilt ${grid.vertexSpheres.size + grid.standaloneDecorations.size} decorations`);
}

function removeVertexSphere(grid, vertexKey) {
  if (!grid.vertexSpheres.has(vertexKey)) return;
  
  // Dispatch to instanced or individual mode
  if (grid.isInstanced) {
    removeVertexSphereInstanced(grid, vertexKey);
    return;
  }
  
  // Individual mode (original code)
  const sphereData = grid.vertexSpheres.get(vertexKey);
  
  grid.group.remove(sphereData.sphere);
  sphereData.sphere.geometry.dispose();
  sphereData.sphere.material.dispose();
  
  if (sphereData.decoration) {
    grid.group.remove(sphereData.decoration);
    if (sphereData.decoration.children) {
      sphereData.decoration.children.forEach(child => {
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
      });
    } else {
      if (sphereData.decoration.geometry) sphereData.decoration.geometry.dispose();
      if (sphereData.decoration.material) sphereData.decoration.material.dispose();
    }
  }
  
  grid.vertexSpheres.delete(vertexKey);
}





//     ===============================================
// 		*** 5.4.½. Add/Remove Vertex/Decorate Functions ***
//     ===============================================

// Backbite distance calculation
function calculateBackbiteDistance(x1, y1, z1, x2, y2, z2) {
  return 0.5 * (Math.abs(x1 - x2) + Math.abs(y1 - y2) + Math.abs(z1 - z2));
}


// Updated colorVerticesAtBBDistance function with undo support
function colorVerticesAtBBDistance(refX, refY, refZ, targetDistance) {
  if (!currentGrid) {
    alert("No active grid to color vertices on");
    return;
  }

  // CRITICAL: Ensure vertex spheres are loaded for instanced grids with lazy loading
  if (currentGrid.isInstanced && lazyLoadVertexSpheres) {
    let needsLoading = false;
    if (currentGrid.chunks && currentGrid.chunks.size > 0) {
      const firstChunk = currentGrid.chunks.values().next().value;
      if (!firstChunk.instancedVertexSpheres) {
        needsLoading = true;
      }
    } else if (!currentGrid.instancedVertexSpheres) {
      needsLoading = true;
    }

    if (needsLoading) {
      console.log('[colorVerticesAtBBDistance] Loading vertex spheres first...');
      loadVertexSpheres(currentGrid);
    }
  }

  const refVertexKey = vertexKey(refX, refY, refZ);
  const coloredVertices = [];
  
  // First, color the reference vertex v^* with the Second Color
  createVertexSphere(currentGrid, refVertexKey, selectedColor2);
  
  // Collect all vertices at target distance
  for (const [vertexKey, vertexData] of currentGrid.vertices.entries()) {
    const [x, y, z] = vertexData.coords;
    const distance = calculateBackbiteDistance(refX, refY, refZ, x, y, z);
    
    if (Math.abs(distance - targetDistance) < 0.001) {
      if (Math.abs(distance - Math.round(distance)) < 0.001) {
        createVertexSphere(currentGrid, vertexKey, selectedColor);
        coloredVertices.push(vertexKey);
      }
    }
  }
  
  // Record the batch action for undo/redo
  recordBBDistanceBatch(coloredVertices, refVertexKey);

  // Force visibility update for instanced meshes
  if (currentGrid.isInstanced) {
    if (currentGrid.chunks) {
      // Multi-chunk grid: update all chunks
      for (const chunk of currentGrid.chunks.values()) {
        if (chunk.instancedVertexSpheres) {
          chunk.instancedVertexSpheres.visible = true;
          chunk.instancedVertexSpheres.instanceMatrix.needsUpdate = true;
          chunk.instancedVertexSpheres.instanceColor.needsUpdate = true;
        }
      }
    } else {
      // Single-chunk grid
      if (currentGrid.instancedVertexSpheres) {
        currentGrid.instancedVertexSpheres.visible = true;
        currentGrid.instancedVertexSpheres.instanceMatrix.needsUpdate = true;
        currentGrid.instancedVertexSpheres.instanceColor.needsUpdate = true;
      }
    }
  }

  console.log(`Colored v^* at (${refX},${refY},${refZ}) with Second Color`);
  console.log(`Colored ${coloredVertices.length} vertices at backbite distance ${targetDistance} from v^*`);
  return coloredVertices.length;
}

// Clear all vertex spheres from current grid
function clearAllVertexSpheres() {
  if (!currentGrid || !currentGrid.vertexSpheres) {
    console.log("No vertex spheres to clear");
    return;
  }
  
  // Capture state BEFORE clearing
  const clearedVertices = [];
  for (const [vertexKey, sphereData] of currentGrid.vertexSpheres.entries()) {
    // Get color (works for both instanced and individual mode)
    const color = currentGrid.isInstanced 
      ? sphereData.color 
      : sphereData.sphere.material.color.getHex();
    
    clearedVertices.push({
      vertexKey: vertexKey,
      color: color,
      hasDecoration: !!sphereData.decoration
    });
  }
  
  // Record action for undo
  if (clearedVertices.length > 0) {
    recordAction('CLEAR_ALL_VERTICES', { clearedVertices });
  }
  
  // Now clear them
  let clearedCount = 0;
  const vertexKeys = [...currentGrid.vertexSpheres.keys()];
  
  for (const vertexKey of vertexKeys) {
    removeVertexSphere(currentGrid, vertexKey);
    clearedCount++;
  }
  
  console.log(`Cleared ${clearedCount} vertex spheres`);
}

// Validate backbite distance inputs
function validateBBDistanceInputs(refX, refY, refZ, distance) {
  if (!currentGrid) {
    console.error("[GridLab::ERR-001] No current grid available for validation");
    return false;
  }
  
  // Check if reference vertex is within grid bounds
  if (refX < 0 || refX >= currentGrid.width ||
      refY < 0 || refY >= currentGrid.height ||
      refZ < 0 || refZ >= currentGrid.depth) {
    console.error("[GridLab::ERR-002] Reference vertex out of bounds:", {refX, refY, refZ});
    alert(`Reference vertex (${refX},${refY},${refZ}) is outside grid bounds`);
    return false;
  }
  
  // Check if reference vertex exists in grid
  const refKey = vertexKey(refX, refY, refZ);
  if (!currentGrid.vertices.has(refKey)) {
    console.error("[GridLab::ERR-003] Reference vertex not found in grid:", refKey);
    alert(`Reference vertex (${refX},${refY},${refZ}) does not exist in current grid`);
    return false;
  }
  
  // Check if distance is non-negative
  if (distance < 0) {
    console.error("[GridLab::ERR-004] Invalid distance value:", distance);
    alert("Distance must be non-negative");
    return false;
  }
  
  return true;
}





//     ========================================
// 		*** 5.5. Coorinate Hover Functions ***
//     ========================================
function showCoordinateTooltip(event, text) {
  // Remove existing tooltip
  const existingTooltip = document.getElementById('coordinateTooltip');
  if (existingTooltip) existingTooltip.remove();
  
  if (!text) return;
  
  // Create new tooltip
  const tooltip = document.createElement('div');
  tooltip.id = 'coordinateTooltip';
  tooltip.textContent = text;
  tooltip.style.cssText = `
    position: absolute;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    font-family: monospace;
    pointer-events: none;
    z-index: 1000;
    white-space: nowrap;
  `;
  
  // Position near cursor with offset
  tooltip.style.left = (event.clientX + 10) + 'px';
  tooltip.style.top = (event.clientY - 25) + 'px';
  
  document.body.appendChild(tooltip);
}

function hideCoordinateTooltip() {
  const tooltip = document.getElementById('coordinateTooltip');
  if (tooltip) {
    tooltip.style.display = 'none';
  }
}


function handleCoordinateHover(event) {
  let tooltipText = null;
  let hasHighlight = false;
  
  let edgeHit = null;
  let vertexHit = null;
  let edgeDistance = Infinity;
  let vertexDistance = Infinity;
  
  // STEP 1: Raycast edges (if enabled)
  if (hoverEdges) {
    if (currentGrid.isInstanced) {
      // Check if we have chunks (multi-chunk grid) or global meshes (single-chunk)
      if (currentGrid.chunks && currentGrid.chunks.size > 0) {
        // Iterate all chunks and find closest edge hit
        for (const [chunkKey, chunk] of currentGrid.chunks.entries()) {
          // SLEDGEHAMMER: Use thin mesh for collision in unified mode
          const edgeMesh = unifiedEdgeSize ? chunk.instancedEdgesThin : chunk.instancedEdgesCollision;
          if (edgeMesh) {
            const collisionHits = raycaster.intersectObject(edgeMesh, false);
            if (collisionHits.length > 0 && collisionHits[0].distance < edgeDistance) {
              edgeHit = collisionHits[0];
              edgeHit.chunkKey = chunkKey;  // Store which chunk was hit
              edgeDistance = edgeHit.distance;
            }
          }
        }
      } else {
        // Fallback for single-chunk grids (backwards compatibility)
        // SLEDGEHAMMER: Use thin mesh for collision in unified mode
        const edgeMesh = unifiedEdgeSize ? currentGrid.instancedEdgesThin : currentGrid.instancedEdgesCollision;
        if (edgeMesh) {
          const collisionHits = raycaster.intersectObject(edgeMesh, false);
          if (collisionHits.length > 0) {
            edgeHit = collisionHits[0];
            edgeDistance = edgeHit.distance;
          }
        }
      }
    } else {
      const edgeMeshes = Array.from(currentGrid.edges.values()).map(e => e.mesh).filter(m => m);
      const intersects = raycaster.intersectObjects(edgeMeshes);
      if (intersects.length > 0) {
        edgeHit = intersects[0];
        edgeDistance = edgeHit.distance;
      }
    }
  }
  
  // STEP 2: Raycast vertices (if enabled)
  if (hoverVertices) {
    if (currentGrid.isInstanced) {
      // Check if we have chunks (multi-chunk grid) or global meshes (single-chunk)
      if (currentGrid.chunks && currentGrid.chunks.size > 0) {
        // Iterate all chunks and find closest vertex hit
        for (const [chunkKey, chunk] of currentGrid.chunks.entries()) {
          if (chunk.instancedVertexCollisionHelpers) {
            const vertexCollisionHits = raycaster.intersectObject(chunk.instancedVertexCollisionHelpers);
            if (vertexCollisionHits.length > 0 && vertexCollisionHits[0].distance < vertexDistance) {
              vertexHit = vertexCollisionHits[0];
              vertexHit.chunkKey = chunkKey;  // Store which chunk was hit
              vertexDistance = vertexHit.distance;
            }
          }
        }
      } else {
        // Fallback for single-chunk grids (backwards compatibility)
        const vertexCollisionHits = raycaster.intersectObject(currentGrid.instancedVertexCollisionHelpers);
        if (vertexCollisionHits.length > 0) {
          vertexHit = vertexCollisionHits[0];
          vertexDistance = vertexHit.distance;
        }
      }
    } else {
      const vertexHelpers = [];
      for (const [vKey, vertexData] of currentGrid.vertices.entries()) {
        if (vertexData.collisionHelper) {
          vertexHelpers.push(vertexData.collisionHelper);
        }
      }
      const vertexIntersects = raycaster.intersectObjects(vertexHelpers);
      if (vertexIntersects.length > 0) {
        vertexHit = vertexIntersects[0];
        vertexDistance = vertexHit.distance;
      }
    }
  }
  
  // STEP 3: Pick the closest hit
  const showVertex = vertexHit && vertexDistance < edgeDistance;
  
  if (showVertex) {
    // SHOW VERTEX
    if (currentGrid.isInstanced) {
      const instanceId = vertexHit.instanceId;
      let vertexKey = null;

      // Use chunk's mapping if available, otherwise fallback to global
      let vertexToInstanceMap;
      if (vertexHit.chunkKey && currentGrid.chunks) {
        const chunk = currentGrid.chunks.get(vertexHit.chunkKey);
        vertexToInstanceMap = chunk ? chunk.vertexToInstanceMap : currentGrid.vertexToInstanceMap;
      } else {
        vertexToInstanceMap = currentGrid.vertexToInstanceMap;
      }

      for (const [vKey, instanceIdx] of vertexToInstanceMap.entries()) {
        if (instanceIdx === instanceId) {
          vertexKey = vKey;
          break;
        }
      }

      if (vertexKey !== null && vertexKey !== undefined) {
        const [x, y, z] = unpackVertex(vertexKey, currentGrid);
        tooltipText = `Vertex: ${formatCoordinates(x, y, z)}`;

        const highlightGeometry = new THREE.SphereGeometry(vertexRadius, 16, 16);
        const highlightMaterial = new THREE.MeshBasicMaterial({ 
          color: 0x00ffff,
          transparent: true, 
          opacity: 0.6,
          depthTest: false
        });
        currentGrid.vertexHighlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
        currentGrid.vertexHighlight.position.set(x, y, z);
        currentGrid.group.add(currentGrid.vertexHighlight);
        hasHighlight = true;
      }
    } else {
      const hoveredHelper = vertexHit.object;
      const vertexKey = hoveredHelper.userData.vertexKey;
      const [x, y, z] = unpackVertex(vertexKey, currentGrid);
      tooltipText = `Vertex: ${formatCoordinates(x, y, z)}`;

      const highlightGeometry = new THREE.SphereGeometry(vertexRadius, 16, 16);
      const highlightMaterial = new THREE.MeshBasicMaterial({ 
        color: 0x00ffff,
        transparent: true, 
        opacity: 0.6,
        depthTest: false
      });
      currentGrid.vertexHighlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
      currentGrid.vertexHighlight.position.set(x, y, z);
      currentGrid.group.add(currentGrid.vertexHighlight);
      hasHighlight = true;
    }
  } else if (edgeHit) {
    // SHOW EDGE
    if (currentGrid.isInstanced) {
      const instanceId = edgeHit.instanceId;

      let edgeKey = null;

      // Use chunk's mapping if available, otherwise fallback to global
      let edgeToInstanceMap;
      if (edgeHit.chunkKey && currentGrid.chunks) {
        const chunk = currentGrid.chunks.get(edgeHit.chunkKey);
        edgeToInstanceMap = chunk ? chunk.edgeToInstanceMap : currentGrid.edgeToInstanceMap;
      } else {
        edgeToInstanceMap = currentGrid.edgeToInstanceMap;
      }

      for (const [eKey, mapping] of edgeToInstanceMap.entries()) {
        if (mapping.collision === instanceId) {
          edgeKey = eKey;
          break;
        }
      }
      
      if (edgeKey) {
        const [[ax, ay, az], [bx, by, bz]] = unpackEdge(edgeKey);
        tooltipText = `${formatEdgeCoordinates(ax, ay, az, bx, by, bz)}`;
        
        const edge = currentGrid.edges.get(edgeKey);
        
        if (edge) {
          if (!currentGrid.highlightOverlay) {
            // SLEDGEHAMMER: Use thin radius in unified mode
            const radius = unifiedEdgeSize ? thinEdgeRadius : thickEdgeRadius;
            const highlightGeometry = new THREE.CylinderGeometry(radius, radius, 1, 8);
            const highlightMaterial = new THREE.MeshBasicMaterial({
              color: 0x00ffff,
              transparent: true,
              opacity: 0.5,
              depthTest: false
            });
            currentGrid.highlightOverlay = new THREE.Mesh(highlightGeometry, highlightMaterial);
            currentGrid.group.add(currentGrid.highlightOverlay);
          }
          
          const matrix = new THREE.Matrix4();

          // Get the appropriate mesh (from chunk or global)
          let instancedEdgesThin, instancedEdgesThick;
          if (edgeHit.chunkKey && currentGrid.chunks) {
            const chunk = currentGrid.chunks.get(edgeHit.chunkKey);
            instancedEdgesThin = chunk ? chunk.instancedEdgesThin : currentGrid.instancedEdgesThin;
            instancedEdgesThick = chunk ? chunk.instancedEdgesThick : currentGrid.instancedEdgesThick;
          } else {
            instancedEdgesThin = currentGrid.instancedEdgesThin;
            instancedEdgesThick = currentGrid.instancedEdgesThick;
          }

          // SLEDGEHAMMER: In unified mode, always use thin mesh
          if (unifiedEdgeSize) {
            instancedEdgesThin.getMatrixAt(instanceId, matrix);
          } else {
            const isThick = (edge.color !== UNCOLORED_COLOR);
            if (isThick) {
              instancedEdgesThick.getMatrixAt(instanceId, matrix);
            } else {
              instancedEdgesThin.getMatrixAt(instanceId, matrix);
            }
          }
          
          const position = new THREE.Vector3();
          const quaternion = new THREE.Quaternion();
          const scale = new THREE.Vector3();
          matrix.decompose(position, quaternion, scale);
          
          currentGrid.highlightOverlay.position.copy(position);
          currentGrid.highlightOverlay.quaternion.copy(quaternion);
          currentGrid.highlightOverlay.scale.y = scale.y;
          
          const cameraDirection = new THREE.Vector3();
          camera.getWorldDirection(cameraDirection);
          currentGrid.highlightOverlay.position.add(cameraDirection.multiplyScalar(-0.001));
          
          currentGrid.highlightOverlay.visible = true;
          hasHighlight = true;
        }
      }
    } else {
      const hoveredMesh = edgeHit.object;
      
      for (const [key, edge] of currentGrid.edges.entries()) {
        if (edge.mesh === hoveredMesh) {
          const [a, b] = unpackEdge(key);
          const [[ax, ay, az], [bx, by, bz]] = [a, b];
          tooltipText = `${formatEdgeCoordinates(ax, ay, az, bx, by, bz)}`;
          
          if (edge.color === UNCOLORED_COLOR) {
            if (!currentGrid.highlightOverlay) {
              // SLEDGEHAMMER: Use thin radius in unified mode
              const radius = unifiedEdgeSize ? thinEdgeRadius : thickEdgeRadius;
              const highlightGeometry = new THREE.CylinderGeometry(radius, radius, 1, 8);
              const highlightMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.5,
                depthTest: false
              });
              currentGrid.highlightOverlay = new THREE.Mesh(highlightGeometry, highlightMaterial);
              currentGrid.group.add(currentGrid.highlightOverlay);
            }
            
            const length = hoveredMesh.geometry.parameters.height;
            currentGrid.highlightOverlay.scale.y = length;
            currentGrid.highlightOverlay.position.copy(hoveredMesh.position);
            currentGrid.highlightOverlay.quaternion.copy(hoveredMesh.quaternion);
            
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            currentGrid.highlightOverlay.position.add(cameraDirection.multiplyScalar(-0.001));
            currentGrid.highlightOverlay.visible = true;
            hasHighlight = true;
          } else {
            hoveredMesh.userData.originalColor = hoveredMesh.material.color.getHex();
            hoveredMesh.userData.originalOpacity = hoveredMesh.material.opacity;
            hoveredMesh.material.color.setHex(0x00ffff);
            hoveredMesh.material.opacity = 1;
            window.highlightedEdge = hoveredMesh;
            hasHighlight = true;
          }
          break;
        }
      }
    }
  }
  
  // Show/hide tooltip
  showCoordinateTooltip(event, tooltipText);
  
  if (hasHighlight) {
    document.body.style.cursor = 'pointer';
  }
}


function formatCoordinates(x, y, z) {
  const relativeMode = document.getElementById("relativeCoordinatesCheckbox")?.checked || false;
  
  if (relativeMode) {
    const k = parseInt(document.getElementById("refK").value) || 0;
    const l = parseInt(document.getElementById("refL").value) || 0; 
    const h = parseInt(document.getElementById("refH").value) || 0;
    
    const offsetX = x - k;
    const offsetY = y - l;
    const offsetZ = z - h;
    
    // Format each coordinate with k,ℓ,h notation
    const formatOffset = (base, offset) => {
      if (offset === 0) return base;
      if (offset > 0) return `${base}+${offset}`;
      return `${base}${offset}`;
    };
    
    const xStr = formatOffset('k', offsetX);
    const yStr = formatOffset('ℓ', offsetY);
    const zStr = formatOffset('h', offsetZ);
    
    return `v(${xStr},${yStr},${zStr})`;
  }
  
  return `v(${x},${y},${z})`;
}

function formatEdgeCoordinates(x1, y1, z1, x2, y2, z2) {
  const relativeMode = document.getElementById("relativeCoordinatesCheckbox")?.checked || false;
  
  if (relativeMode) {
    const k = parseInt(document.getElementById("refK").value) || 0;
    const l = parseInt(document.getElementById("refL").value) || 0; 
    const h = parseInt(document.getElementById("refH").value) || 0;
    
    const formatOffset = (base, offset) => {
      if (offset === 0) return base;
      if (offset > 0) return `${base}+${offset}`;
      return `${base}${offset}`;
    };
    
    const x1Str = formatOffset('k', x1 - k);
    const y1Str = formatOffset('ℓ', y1 - l);
    const z1Str = formatOffset('h', z1 - h);
    const x2Str = formatOffset('k', x2 - k);
    const y2Str = formatOffset('ℓ', y2 - l);
    const z2Str = formatOffset('h', z2 - h);
    
    // Determine which coordinate differs
    if (x1 !== x2) {
      return `e(${x1Str},${x2Str};${y1Str};${z1Str})`;
    } else if (y1 !== y2) {
      return `e(${x1Str};${y1Str},${y2Str};${z1Str})`;
    } else if (z1 !== z2) {
      return `e(${x1Str};${y1Str};${z1Str},${z2Str})`;
    } else {
      return `e(${x1Str};${y1Str};${z1Str})`;
    }
  }
  
  // Non-relative mode
  if (x1 !== x2) {
    return `e(${x1},${x2};${y1};${z1})`;
  } else if (y1 !== y2) {
    return `e(${x1};${y1},${y2};${z1})`;
  } else if (z1 !== z2) {
    return `e(${x1};${y1};${z1},${z2})`;
  } else {
    return `e(${x1};${y1};${z1})`;
  }
}


//     =======================================================================
// 		*** 5.6. Toggle Underlying Grid, Toggle Coordinate Axis Functions ***
//     =======================================================================
function toggleUnderlyingGrid() {
  // Toggle the global state first
  gridVisible = !gridVisible;

  // Ensure current grid is in the scene when toggling back on
  if (gridVisible && currentGrid && !scene.children.includes(currentGrid.group)) {
    scene.add(currentGrid.group);
  }

  // Apply to all grids
  for (const [gridId, grid] of allGrids.entries()) {
    if (!grid || !grid.edges) continue;
    
    if (grid.isInstanced) {
      // Instanced rendering mode
      const zeroMatrix = new THREE.Matrix4().makeScale(0, 0, 0);

      for (const [eKey, edge] of grid.edges.entries()) {
        if (edge.color === UNCOLORED_COLOR) {
          // Find the chunk this edge belongs to
          const chunkKey = grid.edgeToChunk ? grid.edgeToChunk.get(eKey) : null;
          let mapping, instancedEdgesThin;

          if (chunkKey && grid.chunks) {
            const chunk = grid.chunks.get(chunkKey);
            mapping = chunk ? chunk.edgeToInstanceMap.get(eKey) : null;
            instancedEdgesThin = chunk ? chunk.instancedEdgesThin : null;
          } else {
            mapping = grid.edgeToInstanceMap ? grid.edgeToInstanceMap.get(eKey) : null;
            instancedEdgesThin = grid.instancedEdgesThin;
          }

          if (!mapping || !instancedEdgesThin) continue;

          if (gridVisible) {
            // Show the edge - restore its proper transform
            const [a, b] = unpackEdge(eKey, grid);
            const aVec = new THREE.Vector3(...a);
            const bVec = new THREE.Vector3(...b);
            const direction = new THREE.Vector3().subVectors(bVec, aVec);
            const length = direction.length();
            const midpoint = new THREE.Vector3().addVectors(aVec, bVec).multiplyScalar(0.5);

            const matrix = new THREE.Matrix4();
            const quaternion = new THREE.Quaternion();
            const up = new THREE.Vector3(0, 1, 0);

            matrix.makeScale(1, length, 1);
            quaternion.setFromUnitVectors(up, direction.normalize());
            const rotationMatrix = new THREE.Matrix4().makeRotationFromQuaternion(quaternion);
            matrix.premultiply(rotationMatrix);
            matrix.setPosition(midpoint);

            instancedEdgesThin.setMatrixAt(mapping.thin, matrix);
          } else {
            // Hide the edge
            instancedEdgesThin.setMatrixAt(mapping.thin, zeroMatrix);
          }
        }
      }

      // Sync all chunk meshes
      if (grid.chunks && grid.chunks.size > 0) {
        for (const chunk of grid.chunks.values()) {
          if (chunk.instancedEdgesThin) {
            chunk.instancedEdgesThin.instanceMatrix.needsUpdate = true;
          }
        }
      } else if (grid.instancedEdgesThin) {
        grid.instancedEdgesThin.instanceMatrix.needsUpdate = true;
      }
      
    } else {
      // Individual mesh mode
      grid.edges.forEach(edge => {
        const isColored = edge.color !== UNCOLORED_COLOR;
        if (!isColored && edge.mesh) {
          edge.mesh.visible = gridVisible;
        }
      });
    }
  }
}

function formatAxisLabel(coordinate, axisType) {
  const relativeMode = document.getElementById("relativeCoordinatesCheckbox")?.checked || false;
  
  if (relativeMode) {
    const k = parseInt(document.getElementById("refK").value) || 0;
    const l = parseInt(document.getElementById("refL").value) || 0;
    const h = parseInt(document.getElementById("refH").value) || 0;
    
    let refValue, baseLetter;
    if (axisType === 'x') {
      refValue = k;
      baseLetter = 'k';
    } else if (axisType === 'y') {
      refValue = l;
      baseLetter = 'ℓ';  // Changed to ℓ
    } else {
      refValue = h;
      baseLetter = 'h';
    }
    
    const offset = coordinate - refValue;
    if (offset === 0) return baseLetter;
    if (offset > 0) return `${baseLetter}+${offset}`;
    return `${baseLetter}${offset}`;
  }
  
  return `${coordinate}`;
}


function toggleCoordinateAxes() {
 // Create a persistent holder the first time it's called
 if (!scene.userData.coordGroup) {
   scene.userData.coordGroup = new THREE.Group();
   scene.userData.coordGroup.visible = false; // Initialize as hidden
   scene.add(scene.userData.coordGroup);
 }
 const group = scene.userData.coordGroup;
 
 // If already visible, hide it
 if (group.visible) {
   group.visible = false;
   console.log("Coordinate axes hidden.");
   return;
 }
 
 // Clear existing children and recreate them (this ensures labels update)
 while (group.children.length > 0) {
   const child = group.children[0];
   group.remove(child);
   if (child.material && child.material.map) {
     child.material.map.dispose();
   }
   if (child.material) {
     child.material.dispose();
   }
   if (child.geometry) {
     child.geometry.dispose();
   }
 }
 
 // Use fallback values when no grid is present
 const width = currentGrid ? currentGrid.width : 6;
 const height = currentGrid ? currentGrid.height : 6;
 const depth = currentGrid ? currentGrid.depth : 6;
 
 // Determine which axes to show based on grid dimensions
 const showX = width > 1;
 const showY = height > 1;
 const showZ = depth > 1;
 
 // If all dimensions are 1, don't show any axes
 if (!showX && !showY && !showZ) {
   console.log("Grid is 1×1×1 - no axes to display.");
   return;
 }
 
 const axisLength = Math.max(width, height, depth) + 2;
 
 // Label helper function - updated to handle background color
 function makeLabel(text, position, color = null) {
   // Auto-select text color based on background if no color specified
   if (!color) {
     const bgColor = scene.background.getHex();
     color = bgColor < 0x808080 ? 'rgba(200,200,200,0.8)' : 'rgba(50,50,50,0.8)';
   }
   
   const canvas = document.createElement('canvas');
   canvas.width = 128;
   canvas.height = 64;
   const ctx = canvas.getContext('2d');
   ctx.fillStyle = color;
   ctx.font = '24px sans-serif';
   ctx.textAlign = 'center';
   ctx.textBaseline = 'middle';
   ctx.fillText(text, 64, 32);
   const texture = new THREE.CanvasTexture(canvas);
   const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
   const sprite = new THREE.Sprite(material);
   sprite.scale.set(1.5, 0.75, 1);
   sprite.position.copy(position);
   group.add(sprite);
 }
 
 // X-axis (Red) - only if width > 1
 if (showX) {
   const xGeometry = new THREE.BufferGeometry().setFromPoints([
     new THREE.Vector3(0, 0, 0),
     new THREE.Vector3(axisLength, 0, 0)
   ]);
   const xMaterial = new THREE.LineBasicMaterial({ 
     color: 0xff0000,
     depthTest: false,
     transparent: true,
     opacity: 0.7
   });
   const xAxis = new THREE.Line(xGeometry, xMaterial);
   group.add(xAxis);
   
   // X coordinate labels
   const offset = 0.3;
   for (let x = 0; x <= width; x++) {
     makeLabel(formatAxisLabel(x, 'x'), new THREE.Vector3(x, -offset, -offset));
   }
   
   // X axis label at end
   const endOffset = 0.5;
   makeLabel('X', new THREE.Vector3(axisLength + endOffset, 0, 0), 'red');
 }
 
 // Y-axis (Green) - only if height > 1
 if (showY) {
   const yGeometry = new THREE.BufferGeometry().setFromPoints([
     new THREE.Vector3(0, 0, 0),
     new THREE.Vector3(0, axisLength, 0)
   ]);
   const yMaterial = new THREE.LineBasicMaterial({ 
     color: 0x00ff00,
     depthTest: false,
     transparent: true,
     opacity: 0.7
   });
   const yAxis = new THREE.Line(yGeometry, yMaterial);
   group.add(yAxis);
   
   // Y coordinate labels
   const offset = 0.3;
   for (let y = 0; y <= height; y++) {
     makeLabel(formatAxisLabel(y, 'y'), new THREE.Vector3(-offset, y, -offset));
   }
   
   // Y axis label at end
   const endOffset = 0.5;
   makeLabel('Y', new THREE.Vector3(0, axisLength + endOffset, 0), 'lime');
 }
 
 // Z-axis (Blue) - only if depth > 1
 if (showZ) {
   const zGeometry = new THREE.BufferGeometry().setFromPoints([
     new THREE.Vector3(0, 0, 0),
     new THREE.Vector3(0, 0, axisLength)
   ]);
   const zMaterial = new THREE.LineBasicMaterial({ 
     color: 0x0000ff,
     depthTest: false,
     transparent: true,
     opacity: 0.7
   });
   const zAxis = new THREE.Line(zGeometry, zMaterial);
   group.add(zAxis);
   
   // Z coordinate labels
   const offset = 0.3;
   for (let z = 0; z <= depth; z++) {
     makeLabel(formatAxisLabel(z, 'z'), new THREE.Vector3(-offset, -offset, z));
   }
   
   // Z axis label at end
   const endOffset = 0.5;
   makeLabel('Z', new THREE.Vector3(0, 0, axisLength + endOffset), 'blue');
 }
 
 group.visible = true;
 console.log(`Coordinate axes shown (X:${showX}, Y:${showY}, Z:${showZ}).`);
}

function adjustCoordinateLabelColors(backgroundColor) {
  // Check if background is dark or light
  const isDarkBackground = backgroundColor < 0x808080; // Threshold for dark vs light
  
  // If coordinate axes are visible, update them with appropriate colors
  if (scene.userData.coordGroup && scene.userData.coordGroup.visible) {
    // Hide current axes and recreate with appropriate colors
    scene.userData.coordGroup.visible = false;
    scene.userData.coordGroup.children.length = 0; // Clear children
    
    // Force recreation with new colors on next toggle
    toggleCoordinateAxes();
    toggleCoordinateAxes(); // Show them again
  }
}


//     ==========================================
// 		*** 5.6. Transparent plane Functions ***
//     ==========================================
function addTransparentPlane(a, b, c, d, color = null, opacity = 0.05) {
  // Use plane color picker if no color specified
  if (!color) {
    const colorPicker = document.getElementById('planeColorPicker');
    color = colorPicker ? colorPicker.value : '#3498db';
  }
  if (!currentGrid) {
    console.warn("No current grid to add plane to");
    return;
  }
  
  // Grid boundaries
  const minX = 0, maxX = currentGrid.width - 1;
  const minY = 0, maxY = currentGrid.height - 1;
  const minZ = 0, maxZ = currentGrid.depth - 1;
  
  // Normalize plane equation
  const normal = new THREE.Vector3(a, b, c);
  const normalLength = normal.length();
  
  if (normalLength === 0) {
    console.error("Invalid plane equation: normal vector cannot be zero");
    return;
  }
  
  normal.normalize();
  const distance = d / normalLength;
  
  // Find intersection points with grid edges
  const intersectionPoints = [];
  
  // Check all 12 edges of the grid bounding box
  const edges = [
    // Bottom face edges
    [[minX, minY, minZ], [maxX, minY, minZ]],
    [[maxX, minY, minZ], [maxX, maxY, minZ]],
    [[maxX, maxY, minZ], [minX, maxY, minZ]],
    [[minX, maxY, minZ], [minX, minY, minZ]],
    // Top face edges
    [[minX, minY, maxZ], [maxX, minY, maxZ]],
    [[maxX, minY, maxZ], [maxX, maxY, maxZ]],
    [[maxX, maxY, maxZ], [minX, maxY, maxZ]],
    [[minX, maxY, maxZ], [minX, minY, maxZ]],
    // Vertical edges
    [[minX, minY, minZ], [minX, minY, maxZ]],
    [[maxX, minY, minZ], [maxX, minY, maxZ]],
    [[maxX, maxY, minZ], [maxX, maxY, maxZ]],
    [[minX, maxY, minZ], [minX, maxY, maxZ]]
  ];
  
  // Find intersections with each edge
  for (const [start, end] of edges) {
    const startVec = new THREE.Vector3(...start);
    const endVec = new THREE.Vector3(...end);
    const direction = new THREE.Vector3().subVectors(endVec, startVec);
    
    // Check if line intersects plane
    const denominator = normal.dot(direction);
    if (Math.abs(denominator) > 1e-6) { // Not parallel
      const t = (distance - normal.dot(startVec)) / denominator;
      if (t >= 0 && t <= 1) { // Intersection within edge
        const intersection = startVec.clone().add(direction.multiplyScalar(t));
        intersectionPoints.push(intersection);
      }
    }
  }
  
  if (intersectionPoints.length < 3) {
    console.warn("Plane does not intersect grid boundaries sufficiently");
    return;
  }
  
  // More robust duplicate removal
  const uniquePoints = [];
  const tolerance = 1e-4;
  for (const point of intersectionPoints) {
    if (!uniquePoints.some(p => p.distanceTo(point) < tolerance)) {
      uniquePoints.push(point);
    }
  }
  
  if (uniquePoints.length < 3) {
    console.warn("Not enough unique intersection points");
    return;
  }
  
  // Project points onto plane for 2D sorting
  const center = uniquePoints.reduce((acc, p) => acc.add(p), new THREE.Vector3()).divideScalar(uniquePoints.length);
  
  // Create two orthogonal vectors in the plane
  const planeNormal = normal.clone();
  const tempVec = Math.abs(planeNormal.x) < 0.9 ? new THREE.Vector3(1, 0, 0) : new THREE.Vector3(0, 1, 0);
  const u = new THREE.Vector3().crossVectors(planeNormal, tempVec).normalize();
  const v = new THREE.Vector3().crossVectors(planeNormal, u).normalize();
  
  // Convert to 2D coordinates and sort by angle
  const points2D = uniquePoints.map(p => {
    const relative = new THREE.Vector3().subVectors(p, center);
    return {
      point: p,
      u: relative.dot(u),
      v: relative.dot(v),
      angle: Math.atan2(relative.dot(v), relative.dot(u))
    };
  });
  
  points2D.sort((a, b) => a.angle - b.angle);
  const sortedPoints = points2D.map(p => p.point);
  
  // Create simple polygon (no triangulation issues)
  const vertices = [];
  const indices = [];
  
  // Add center point
  vertices.push(center.x, center.y, center.z);
  
  // Add sorted perimeter points
  for (const point of sortedPoints) {
    vertices.push(point.x, point.y, point.z);
  }
  
  // Create triangles from center to each edge
  for (let i = 0; i < sortedPoints.length; i++) {
    const next = (i + 1) % sortedPoints.length;
    indices.push(0, i + 1, next + 1);
  }
  
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setIndex(indices);
  geometry.computeVertexNormals();
  
  const material = new THREE.MeshBasicMaterial({
    color: new THREE.Color(color),
    transparent: true,
    opacity: opacity,
    side: THREE.DoubleSide,
    depthWrite: false,
    depthTest: false
  });
  
  const plane = new THREE.Mesh(geometry, material);
  plane.renderOrder = -1;
  plane.raycast = () => {};
  
  // Store plane data for management
  const planeData = {
    mesh: plane,
    equation: { a, b, c, d },
    color: color,
    opacity: opacity,
    id: Date.now() // Simple unique ID
  };
  
  currentGrid.customPlanes.push(planeData);
  currentGrid.group.add(plane);
  
  // Update plane list UI
  updatePlaneListUI();
  
  console.log(`Added bounded cutting plane: ${a}x + ${b}y + ${c}z = ${d}`);
  return planeData;
}

function removeTransparentPlane(planeId) {
  if (!currentGrid || !currentGrid.customPlanes.length) {
    console.warn("No planes to remove");
    return;
  }
  
  // If no planeId provided, remove all (backward compatibility)
  if (planeId === undefined) {
    while (currentGrid.customPlanes.length > 0) {
      const planeData = currentGrid.customPlanes[0];
      removeTransparentPlane(planeData.id);
    }
    return;
  }
  
  const planeIndex = currentGrid.customPlanes.findIndex(p => p.id === planeId);
  if (planeIndex === -1) {
    console.warn("Plane not found");
    return;
  }
  
  const planeData = currentGrid.customPlanes[planeIndex];
  currentGrid.group.remove(planeData.mesh);
  planeData.mesh.geometry.dispose();
  planeData.mesh.material.dispose();
  
  currentGrid.customPlanes.splice(planeIndex, 1);
  updatePlaneListUI();
  
  console.log("Removed transparent plane");
}

function updatePlaneListUI() {
  if (!currentGrid) return;
  
  // Remove existing list
  const existingList = document.getElementById('planeList');
  if (existingList) existingList.remove();
  
  if (!currentGrid.customPlanes || currentGrid.customPlanes.length === 0) return;
  
  // Create plane list
  const list = document.createElement('div');
  list.id = 'planeList';
  list.style.cssText = `
    margin-top: 8px;
    border-top: 1px solid #556677;
    padding-top: 8px;
    max-height: 120px;
    overflow-y: auto;
  `;
  
  currentGrid.customPlanes.forEach((planeData, index) => {
    const item = document.createElement('div');
    item.className = 'plane-item';
    item.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 4px;
      margin: 2px 0;
      background: rgba(0,0,0,0.2);
      border-radius: 4px;
      font-size: 11px;
      color: #ecf0f1;
    `;
    
    const label = document.createElement('span');
    label.textContent = `${planeData.equation.a}x + ${planeData.equation.b}y + ${planeData.equation.c}z = ${planeData.equation.d}`;
    
    const controls = document.createElement('div');
    controls.style.cssText = 'display: flex; gap: 4px;';
    
    // Visibility toggle
    const visBtn = document.createElement('button');
    visBtn.textContent = planeData.mesh.visible ? '👁' : '👁‍🗨';
    visBtn.style.cssText = `
      background: transparent;
      border: none;
      cursor: pointer;
      font-size: 14px;
      padding: 0 4px;
    `;
    visBtn.onclick = () => {
      planeData.mesh.visible = !planeData.mesh.visible;
      updatePlaneListUI();
    };
    
    // Remove button
    const removeBtn = document.createElement('button');
    removeBtn.textContent = '×';
    removeBtn.style.cssText = `
      background: #e74c3c;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      padding: 0 6px;
      font-size: 16px;
    `;
    removeBtn.onclick = () => removeTransparentPlane(planeData.id);
    
    controls.appendChild(visBtn);
    controls.appendChild(removeBtn);
    
    item.appendChild(label);
    item.appendChild(controls);
    list.appendChild(item);
  });
  
  // Add to plane controls panel (now in right sidebar)
  const planeBody = document.getElementById('planeBody');
  if (planeBody) {
    planeBody.appendChild(list);
  }
}




//     ====================================================================================================================
// 										  6. DOUBLESWITCH, CANONICAL FORMS, AND RELATED FUNCTIONS
//     ====================================================================================================================

function colorSubgraphComponent(grid, vertexComponent, targetCompId, color = 0x005500) {
  const vertices = new Set();
  for (const [v, c] of vertexComponent.entries()) {
    if (c === targetCompId) vertices.add(v);
  }

  const subgraph = grid.activeSubgraph;
  if (!subgraph) return;

  for (const edgeKey of subgraph.getEdgeKeys()) {
    const [aCoords, bCoords] = unpackEdge(edgeKey);
    const aKey = vertexKey(...aCoords);
    const bKey = vertexKey(...bCoords);
    if (vertices.has(aKey) && vertices.has(bKey)) {
      const edge = grid.edges.get(edgeKey);
      if (!edge) continue;

      grid.group.remove(edge.mesh);

      const newMesh = makeEdgeMesh(
        aCoords,
        bCoords,
        color,
        thickEdgeRadius
      );

      grid.edges.set(edgeKey, { ...edge, color, mesh: newMesh });
      grid.group.add(newMesh);
    }
  }
}


function restoreEdgeColor() {
  if (currentGrid.isInstanced) {
    // For instanced mode, nothing to restore - edges maintain their own state
    return;
  }
  
  // Non-instanced mode only
  for (const [key, edge] of currentGrid.edges.entries()) {
    if (edge.color !== UNCOLORED_COLOR) {
      const [a, b] = unpackEdge(key);
      currentGrid.group.remove(edge.mesh);
      currentGrid.edges.set(key, {
        ...edge,
        color: selectedColor,
        mesh: makeEdgeMesh(a, b, selectedColor, thickEdgeRadius)
      });
      currentGrid.group.add(currentGrid.edges.get(key).mesh);
    }
  }
}


function getBorderCandidateBoxes(grid, vertexComponent, subgraph) {
  const allBoxes = [
    ...grid.boxesXY.values(),
    ...grid.boxesXZ.values(),
    ...grid.boxesYZ.values()
  ];

  return allBoxes.filter(box => {
    const includedEdges = box.edges.filter(eKey => subgraph.edges.has(eKey));
    if (includedEdges.length !== 2) return false;

    const [e1, e2] = includedEdges.map(edgeKey => {
      const [aCoords, bCoords] = unpackEdge(edgeKey, grid);
      const aKey = vertexKey(aCoords[0], aCoords[1], aCoords[2], grid);
      const bKey = vertexKey(bCoords[0], bCoords[1], bCoords[2], grid);
      return [vertexComponent.get(aKey), vertexComponent.get(bKey)];
    });

    const components = new Set([...e1, ...e2]);
    return components.size > 1;
  });
}

function getGeneralBorderBoxes(grid, vertexComponent, subgraph) {
  const allBoxes = [
    ...grid.boxesXY.values(),
    ...grid.boxesXZ.values(),
    ...grid.boxesYZ.values()
  ];

  return allBoxes.filter(box => {
    const componentSet = new Set();

    for (const eKey of box.edges) {
      if (!subgraph.edges.has(eKey)) continue;

      const [a, b] = unpackEdge(eKey, grid);
      const aKey = vertexKey(a[0], a[1], a[2], grid);
      const bKey = vertexKey(b[0], b[1], b[2], grid);
      componentSet.add(vertexComponent.get(aKey));
      componentSet.add(vertexComponent.get(bKey));
    }

    return componentSet.size > 1;
  });
}

function buildAdjacencyFromEdgeSet(grid, edgeSet) {
  const adj = new Map();
  for (const key of [...edgeSet]) {
    const edge = grid.edges.get(key);
    if (!edge) continue;
    const [a, b] = unpackEdge(key, grid);
    const aKey = vertexKey(a[0], a[1], a[2], grid);
    const bKey = vertexKey(b[0], b[1], b[2], grid);
    if (!adj.has(aKey)) adj.set(aKey, []);
    if (!adj.has(bKey)) adj.set(bKey, []);
    adj.get(aKey).push(bKey);
    adj.get(bKey).push(aKey);
  }
  return adj;
}






function getFilteredBoxMeshes() {
  if (!currentGrid) return [];

  // Get camera direction
  const cameraDirection = new THREE.Vector3();
  camera.getWorldDirection(cameraDirection);
  
  // Determine which axis the camera is most aligned with
  const absX = Math.abs(cameraDirection.x);
  const absY = Math.abs(cameraDirection.y);
  const absZ = Math.abs(cameraDirection.z);
  
  let meshes = [];

  // Check if we're in 2D mode - if so, return all box meshes without filtering
  const ones = (currentGrid.width === 1 ? 1 : 0) +
               (currentGrid.height === 1 ? 1 : 0) +
               (currentGrid.depth === 1 ? 1 : 0);
  const is2D = ones === 1;

  if (currentGrid.isInstanced) {
    if (is2D) {
      // 2D mode - return all box meshes without camera-based filtering
      meshes = [
        currentGrid.instancedBoxesXY,
        currentGrid.instancedBoxesXZ,
        currentGrid.instancedBoxesYZ
      ].filter(m => m);
    } else {
      // 3D mode - return instanced meshes based on camera direction
      if (absZ > absX && absZ > absY) {
        // Looking mostly in Z direction - include XZ and YZ boxes
        meshes = [currentGrid.instancedBoxesXZ, currentGrid.instancedBoxesYZ].filter(m => m);
      } else if (absY > absX && absY > absZ) {
        // Looking mostly in Y direction - include XY and YZ boxes
        meshes = [currentGrid.instancedBoxesXY, currentGrid.instancedBoxesYZ].filter(m => m);
      } else {
        // Looking mostly in X direction - include XY and XZ boxes
        meshes = [currentGrid.instancedBoxesXY, currentGrid.instancedBoxesXZ].filter(m => m);
      }
    }
  } else {
    // Individual mesh mode
    if (absZ > absX && absZ > absY) {
      // Looking mostly in Z direction - include XZ and YZ boxes (filter out XY)
      meshes = [
        ...Array.from(currentGrid.boxesXZ.values()).map(b => b.mesh),
        ...Array.from(currentGrid.boxesYZ.values()).map(b => b.mesh)
      ].filter(m => m);
    } else if (absY > absX && absY > absZ) {
      // Looking mostly in Y direction - include XY and YZ boxes (filter out XZ)
      meshes = [
        ...Array.from(currentGrid.boxesXY.values()).map(b => b.mesh),
        ...Array.from(currentGrid.boxesYZ.values()).map(b => b.mesh)
      ].filter(m => m);
    } else {
      // Looking mostly in X direction - include XY and XZ boxes (filter out YZ)
      meshes = [
        ...Array.from(currentGrid.boxesXY.values()).map(b => b.mesh),
        ...Array.from(currentGrid.boxesXZ.values()).map(b => b.mesh)
      ].filter(m => m);
    }
  }
  
  return meshes;
}





function highlightBoxes(boxes, color = boxHighlightColor) {
  console.log('[highlightBoxes] CALLED with', boxes.length, 'boxes');
  
  // Clear any existing highlights
  clearBoxHighlights();
  
  if (boxes.length === 0) return;
  
  // Group boxes by type
  const boxesByType = {
    XY: boxes.filter(b => (b.plane === 'XY' || b.instanceType === 'XY')),
    XZ: boxes.filter(b => (b.plane === 'XZ' || b.instanceType === 'XZ')),
    YZ: boxes.filter(b => (b.plane === 'YZ' || b.instanceType === 'YZ'))
  };
  
  const highlightColor = new THREE.Color(color);
  
  // Create separate instanced meshes for each plane type
  if (boxesByType.XY.length > 0) {
    currentGrid.highlightInstancedBoxesXY = createHighlightInstancedMesh(
      boxesByType.XY, 'XY', highlightColor
    );
    currentGrid.group.add(currentGrid.highlightInstancedBoxesXY);
  }
  
  if (boxesByType.XZ.length > 0) {
    currentGrid.highlightInstancedBoxesXZ = createHighlightInstancedMesh(
      boxesByType.XZ, 'XZ', highlightColor
    );
    currentGrid.group.add(currentGrid.highlightInstancedBoxesXZ);
  }
  
  if (boxesByType.YZ.length > 0) {
    currentGrid.highlightInstancedBoxesYZ = createHighlightInstancedMesh(
      boxesByType.YZ, 'YZ', highlightColor
    );
    currentGrid.group.add(currentGrid.highlightInstancedBoxesYZ);
  }
  
  console.log('[highlightBoxes] Created highlight meshes:', {
    XY: boxesByType.XY.length,
    XZ: boxesByType.XZ.length,
    YZ: boxesByType.YZ.length
  });
}

function createHighlightInstancedMesh(boxes, planeType, color) {
  // Create geometry based on plane type
  let geometry;
  if (planeType === 'XY') {
    geometry = new THREE.BoxGeometry(1, 1, 0.01);
  } else if (planeType === 'XZ') {
    geometry = new THREE.BoxGeometry(1, 0.01, 1);
  } else { // YZ
    geometry = new THREE.BoxGeometry(0.01, 1, 1);
  }
  
  // Create material - semi-transparent
  const material = new THREE.MeshBasicMaterial({
    color: color,
    opacity: boxHighlightOpacity,
    transparent: true,
    depthTest: false
  });
  
  // Create instanced mesh
  const mesh = new THREE.InstancedMesh(geometry, material, boxes.length);
  
  // Set transforms for each box
  const matrix = new THREE.Matrix4();
  for (let i = 0; i < boxes.length; i++) {
    const box = boxes[i];
    const [x, y, z] = box.coords;
    
    // Position based on plane type
    if (planeType === 'XY') {
      matrix.makeTranslation(x + 0.5, y + 0.5, z);
    } else if (planeType === 'XZ') {
      matrix.makeTranslation(x + 0.5, y, z + 0.5);
    } else { // YZ
      matrix.makeTranslation(x, y + 0.5, z + 0.5);
    }
    
    mesh.setMatrixAt(i, matrix);
  }
  
  mesh.instanceMatrix.needsUpdate = true;
  
  return mesh;
}

function clearBoxHighlights() {
  console.log('[clearBoxHighlights] CALLED');

  // Early exit if no grid exists
  if (!currentGrid) {
    console.log('[clearBoxHighlights] No grid exists, skipping');
    return;
  }

  // Remove and dispose highlight meshes
  if (currentGrid.highlightInstancedBoxesXY) {
    currentGrid.group.remove(currentGrid.highlightInstancedBoxesXY);
    currentGrid.highlightInstancedBoxesXY.geometry.dispose();
    currentGrid.highlightInstancedBoxesXY.material.dispose();
    currentGrid.highlightInstancedBoxesXY = null;
  }

  if (currentGrid.highlightInstancedBoxesXZ) {
    currentGrid.group.remove(currentGrid.highlightInstancedBoxesXZ);
    currentGrid.highlightInstancedBoxesXZ.geometry.dispose();
    currentGrid.highlightInstancedBoxesXZ.material.dispose();
    currentGrid.highlightInstancedBoxesXZ = null;
  }

  if (currentGrid.highlightInstancedBoxesYZ) {
    currentGrid.group.remove(currentGrid.highlightInstancedBoxesYZ);
    currentGrid.highlightInstancedBoxesYZ.geometry.dispose();
    currentGrid.highlightInstancedBoxesYZ.material.dispose();
    currentGrid.highlightInstancedBoxesYZ = null;
  }

  console.log('[clearBoxHighlights] DONE');
}









function labelComponents(adj) {
  const vertexComponent = new Map();
  let compId = 0;
  for (const v of adj.keys()) {
    if (vertexComponent.has(v)) continue;
    const queue = [v];
    vertexComponent.set(v, compId);
    while (queue.length > 0) {
      const u = queue.shift();
      for (const nbr of adj.get(u) || []) {
        if (!vertexComponent.has(nbr)) {
          vertexComponent.set(nbr, compId);
          queue.push(nbr);
        }
      }
    }
    compId++;
  }
  return vertexComponent;
}


function highlightHoveredBox(box) {
  // Reset previous highlight
  clearHoveredBoxHighlight();

  const isHot = isSwitchable(box);

  // Create a temporary highlight mesh
  const [x, y, z] = box.coords;
  let size, center;
  
  if (box.plane === "XY") {
    size = new THREE.Vector3(1, 1, 0.01);
    center = new THREE.Vector3(x + 0.5, y + 0.5, z);
  } else if (box.plane === "XZ") {
    size = new THREE.Vector3(1, 0.01, 1);
    center = new THREE.Vector3(x + 0.5, y, z + 0.5);
  } else if (box.plane === "YZ") {
    size = new THREE.Vector3(0.01, 1, 1);
    center = new THREE.Vector3(x, y + 0.5, z + 0.5);
  }

  const geometry = new THREE.BoxGeometry(size.x, size.y, size.z);
  const material = new THREE.MeshBasicMaterial({
    color: isHot ? 0x00ffff : 0xffff00,
    opacity: 0.8,
    transparent: true,
    depthTest: false
  });

  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.copy(center);
  mesh.userData.box = box;

  currentGrid.group.add(mesh);
  lastHighlighted = mesh;
}

function clearHoveredBoxHighlight() {
  if (lastHighlighted) {
    currentGrid.group.remove(lastHighlighted);
    lastHighlighted.geometry.dispose();
    lastHighlighted.material.dispose();
    lastHighlighted = null;
  }
}


function switchBox(box) {
  const t0 = performance.now();
  
  // Ensure switchMode is synced with global mode
  switchMode = (mode === "switch");
  
  
  // CRITICAL: Cancel any pending async operations to prevent state corruption
  if (currentGrid && currentGrid.highlightDebounceTimer) {
    clearTimeout(currentGrid.highlightDebounceTimer);
    currentGrid.highlightDebounceTimer = null;
  }

  // Step 1: Parse box edges into coords
  const edgePairs = box.edges.map(eKey => {
    const [a, b] = unpackEdge(eKey, currentGrid);
    return { eKey, a, b };
  });

  // Step 2: Create activeSubgraph if it doesn't exist, or use existing one
  let subgraph = currentGrid.activeSubgraph;
  if (!subgraph) {
    subgraph = new Subgraph(currentGrid);
    for (const [eKey, edge] of currentGrid.edges.entries()) {
      if (edge.color !== UNCOLORED_COLOR) {
        const [a, b] = unpackEdge(eKey, currentGrid);
        const aKey = vertexKey(a[0], a[1], a[2], currentGrid);
        const bKey = vertexKey(b[0], b[1], b[2], currentGrid);
        subgraph.edges.add(eKey);
        subgraph.vertices.add(aKey);
        subgraph.vertices.add(bKey);
      }
    }
    currentGrid.activeSubgraph = subgraph;
  }

  const inSubgraph = edgePairs.filter(e => subgraph.hasEdge(e.a, e.b));
  const notInSubgraph = edgePairs.filter(e => !subgraph.hasEdge(e.a, e.b));

  if (inSubgraph.length !== 2 || notInSubgraph.length !== 2) {
    if (!batchMode) console.warn("Box is not switchable – requires 2 parallel edges in subgraph.");
    return false;
  }
  
  // SAVE STATE FOR UNDO
  const oldPath = currentGrid.path ? [...currentGrid.path] : [];
  const oldSubgraphEdges = Array.from(subgraph.edges);

  // Step 3: Mutate the subgraph AND sync edge.color immediately
  for (const e of inSubgraph) {
    const eKey = edgeKey(e.a, e.b, currentGrid);
    subgraph.edges.delete(eKey);

    const edge = currentGrid.edges.get(eKey);
    if (edge) edge.color = UNCOLORED_COLOR;

    const v1 = vertexKey(e.a[0], e.a[1], e.a[2], currentGrid);
    const v2 = vertexKey(e.b[0], e.b[1], e.b[2], currentGrid);
    if (subgraph.getNeighbors(v1).length === 0) {
      subgraph.vertices.delete(v1);
    }
    if (subgraph.getNeighbors(v2).length === 0) {
      subgraph.vertices.delete(v2);
    }
  }

  for (const e of notInSubgraph) {
    const eKey = edgeKey(e.a, e.b, currentGrid);
    subgraph.edges.add(eKey);

    const edge = currentGrid.edges.get(eKey);
    if (edge) edge.color = selectedColor;

    subgraph.vertices.add(vertexKey(e.a[0], e.a[1], e.a[2], currentGrid));
    subgraph.vertices.add(vertexKey(e.b[0], e.b[1], e.b[2], currentGrid));
  }

  const t1 = performance.now();
  console.log(`Steps 1-3 (mutation): ${(t1-t0).toFixed(2)}ms`);

  // Skip expensive operations in batch mode
  if (batchMode) {
    const pathVertices = extractPathFromSubgraph(currentGrid.activeSubgraph);
    if (pathVertices.length > 1) {
      currentGrid.path = pathVertices;
      currentPath = pathVertices;
    }

    // Detect if subgraph is a cycle: E = V in the subgraph
    const subgraphVertexCount = currentGrid.activeSubgraph.vertices.size;
    const subgraphEdgeCount = currentGrid.activeSubgraph.edges.size;
    const isCycle = (subgraphEdgeCount === subgraphVertexCount);

    // Only set cycle reference if it's actually a cycle
    if (isCycle) {
      currentGrid.cycle = currentGrid.activeSubgraph;
    } else {
      currentGrid.cycle = null;
    }

    return true;
  }

  // Step 4: Reconstruct path from modified subgraph
  const pathVertices = extractPathFromSubgraph(currentGrid.activeSubgraph);
  if (pathVertices.length > 1) {
    currentGrid.path = pathVertices;
    currentPath = pathVertices;
  }
  
  // RECORD UNDO ACTION
  const newSubgraphEdges = Array.from(subgraph.edges);
  const switchedEdges = box.edges; // All 4 edges of the switch box
  
	// RECORD UNDO ACTION (EFFICIENT VERSION - only store what changed)
	recordAction('SWITCH', {
	  oldPath: oldPath,
	  newPath: currentGrid.path ? [...currentGrid.path] : [],
	  edgesAdded: notInSubgraph.map(e => e.eKey),    // The 2 edges added to subgraph
	  edgesRemoved: inSubgraph.map(e => e.eKey)      // The 2 edges removed from subgraph
	});

	// Clear redo stack
	currentGrid.redoStack = [];


  const t2 = performance.now();
  console.log(`Step 4 (extractPath): ${(t2-t1).toFixed(2)}ms`);

  // Step 5: Apply appropriate coloring
  if (currentGrid.isInstanced) {
    for (const e of edgePairs) {
      const inGraph = subgraph.hasEdge(e.a, e.b);
      const color = inGraph ? selectedColor : UNCOLORED_COLOR;
      const width = inGraph ? thickEdgeRadius : thinEdgeRadius;

      const edge = currentGrid.edges.get(e.eKey);
      if (!edge) continue;
      
      edge.color = color;
      colorEdgeInstanced(currentGrid, e.a, e.b, color, width);
    }
  } else {
    // Individual mesh mode
    for (const e of edgePairs) {
      const inGraph = subgraph.hasEdge(e.a, e.b);
      const color = inGraph ? selectedColor : UNCOLORED_COLOR;
      const width = inGraph ? thickEdgeRadius : thinEdgeRadius;

      const edge = currentGrid.edges.get(e.eKey);
      if (!edge) continue;

      edge.color = color;

      if (edge.mesh) {
        currentGrid.group.remove(edge.mesh);
        edge.mesh.geometry.dispose();
        edge.mesh.material.dispose();
      }
      const newMesh = makeEdgeMesh(e.a, e.b, color, width);
      edge.mesh = newMesh;
      currentGrid.group.add(newMesh);
    }
  }

  const t3 = performance.now();
  console.log(`Step 5 (coloring 4 edges): ${(t3-t2).toFixed(2)}ms`);

  // Step 6: Detect if subgraph is still a cycle after the switch
  // A cycle has E = V (edges equals vertices in subgraph, not grid)
  const subgraphVertexCount = currentGrid.activeSubgraph.vertices.size;
  const subgraphEdgeCount = currentGrid.activeSubgraph.edges.size;
  const isCycle = (subgraphEdgeCount === subgraphVertexCount);

  // Only set cycle reference if it's actually a cycle
  if (isCycle) {
    currentGrid.cycle = currentGrid.activeSubgraph;
  } else {
    currentGrid.cycle = null;
  }

  // Step 7: Update endpoint markers (only for paths, not cycles)
  if (isCycle) {
    clearEndpointMarkers(currentGrid);
  } else {
    updateEndpointMarkers(currentGrid);
  }
  
  const t4 = performance.now();
  
  console.log(`Steps 6-7 (cleanup): ${(t4-t3).toFixed(2)}ms`);
  console.log(`Total sync time: ${(t4-t0).toFixed(2)}ms`);


// Step 8: Component coloring (SYNCHRONOUS)
if (componentColoringEnabled) {
  const adj = buildAdjacencyFromEdgeSet(currentGrid, subgraph.getEdgeKeys());
  const vertexComponent = labelComponents(adj);
  const numComponents = new Set(vertexComponent.values()).size;
  
  if (numComponents >= 2) {
    // Multiple components - color by component
    const componentColors = [selectedColor, selectedColor2];

    for (const eKey of subgraph.getEdgeKeys()) {
      const [a, b] = unpackEdge(eKey, currentGrid);
      const aKey = vertexKey(a[0], a[1], a[2], currentGrid);

      const componentId = vertexComponent.get(aKey);
      const color = componentColors[componentId % componentColors.length];

      if (currentGrid.isInstanced) {
        colorEdgeInstanced(currentGrid, a, b, color, thickEdgeRadius);
      } else {
        colorEdge(currentGrid, a, b, color, thickEdgeRadius);
      }
    }
    console.log('Component coloring: multiple components');
  } else {
    // Single component - restore uniform coloring
    for (const eKey of subgraph.getEdgeKeys()) {
      const [a, b] = unpackEdge(eKey, currentGrid);

      if (currentGrid.isInstanced) {
        colorEdgeInstanced(currentGrid, a, b, selectedColor, thickEdgeRadius);
      } else {
        colorEdge(currentGrid, a, b, selectedColor, thickEdgeRadius);
      }
    }
    console.log('Single component - uniform coloring restored');
  }
}
// Step 9: Box highlighting (ASYNC - only this delayed)
if (boxHighlightingEnabled && currentGrid.isInstanced) {
  if (currentGrid.highlightDebounceTimer) clearTimeout(currentGrid.highlightDebounceTimer);

  currentGrid.highlightDebounceTimer = setTimeout(() => {
    clearBoxHighlights();

    const adj = buildAdjacencyFromEdgeSet(currentGrid, subgraph.getEdgeKeys());
    const vertexComponent = labelComponents(adj);
    const numComponents = new Set(vertexComponent.values()).size;

    if (numComponents >= 2) {
      const borderBoxes = getGeneralBorderBoxes(currentGrid, vertexComponent, subgraph);
      if (borderBoxes.length > 0) {
        highlightBoxes(borderBoxes, boxHighlightColor);
        currentGrid.highlightedBoxes = borderBoxes;
      }
    } else {
      clearBoxHighlights();
    }
  }, 150);
}

// Step 10: Update arrows to reflect the new path
if (arrowMode && currentGrid.path && currentGrid.path.length > 1) {
  // Remove old arrows from ALL edges first
  for (const [key, edge] of currentGrid.edges.entries()) {
    if (edge.arrows) {
      removeArrowsFromEdge(edge, key);
    }
  }

  // Add arrows back based on the new path
  addDirectionalArrowsToPath(currentGrid.path);
}

}


function performDoubleSwitch() {
  if (!currentGrid || !currentGrid.activeSubgraph) {
    if (!batchMode) console.warn("No currentGrid or activeSubgraph");
    return false;
  }

  const subgraph = currentGrid.activeSubgraph;

  // Step 1: Collect all boxes
  const allBoxes = [
    ...currentGrid.boxesXY.values(),
    ...currentGrid.boxesXZ.values(),
    ...currentGrid.boxesYZ.values()
  ];

  // Step 2: Choose a random switchable box X
  const switchableBoxes = allBoxes.filter(box => isSwitchable(box, subgraph));
  
  if (switchableBoxes.length === 0) {
    if (!batchMode) console.warn("No switchable boxes found");
    return false;
  }

  const X = switchableBoxes[Math.floor(Math.random() * switchableBoxes.length)];
  switchBox(X);

  // Step 3: Use updated subgraph from switchBox
  const newSubgraph = currentGrid.activeSubgraph;

  // Step 4: Build adjacency and label components (only when needed)
  const adj = buildAdjacencyFromEdgeSet(currentGrid, newSubgraph.edges);
  const vertexComponent = labelComponents(adj);
  const numComponents = new Set(vertexComponent.values()).size;
  
  if (numComponents !== 2) {
    if (!batchMode) console.warn("Not exactly two components after first switch");
    return false;
  }

  // Step 5: Get border candidates
  const borderCandidates = getBorderCandidateBoxes(currentGrid, vertexComponent, newSubgraph);
  
  if (borderCandidates.length === 0) {
    if (!batchMode) console.warn("No border candidate boxes found");
    return false;
  }

  // Step 6: Do second switch
  const Y = borderCandidates[Math.floor(Math.random() * borderCandidates.length)];
  switchBox(Y);

  return true;
}




//     ====================================================================================================================
// 										    6.½. MODE AND OTHER GENERAL UI HELPER FUNCTIONS
//     ====================================================================================================================


// Mode management helper function
function setMode(newMode) {
  const oldMode = mode;
  mode = newMode;

  // Handle vertex sphere loading/unloading for vertex editing modes
  if (lazyLoadVertexSpheres && currentGrid && currentGrid.isInstanced) {
    const oldModeNeedsVertices = (oldMode === 'addVertex' || oldMode === 'addDecoration');
    const newModeNeedsVertices = (newMode === 'addVertex' || newMode === 'addDecoration');

    // Entering a vertex editing mode - load vertex spheres if not already loaded
    if (newModeNeedsVertices && !oldModeNeedsVertices) {
      // Check if vertex spheres need loading
      let needsLoading = false;
      if (currentGrid.chunks && currentGrid.chunks.size > 0) {
        const firstChunk = currentGrid.chunks.values().next().value;
        if (!firstChunk.instancedVertexSpheres && !firstChunk.instancedVertexCollisionHelpers) {
          needsLoading = true;
        }
      }

      if (needsLoading) {
        console.log(`[setMode] Entering vertex editing mode "${newMode}", loading vertex spheres`);
        loadVertexSpheres(currentGrid);
      }
    }

    // Leaving a vertex editing mode - potentially unload vertex spheres
    if (oldModeNeedsVertices && !newModeNeedsVertices) {
      // Only unload if ALL conditions are met:
      // 1. showAllVertices is OFF
      // 2. No colored vertices exist
      // 3. No vertex operations in history
      const shouldUnload =
        !showAllVertices &&
        !hasColoredVertices(currentGrid) &&
        !hasVertexOperationsInHistory(currentGrid);

      if (shouldUnload) {
        console.log(`[setMode] Leaving vertex editing mode "${oldMode}", unloading vertex spheres`);
        unloadVertexSpheres(currentGrid);
      } else {
        console.log(`[setMode] Leaving vertex editing mode "${oldMode}", keeping vertex spheres loaded (needed by other systems)`);
      }
    }
  }

  // Handle edge collision loading/unloading for edge editing modes
  if (lazyLoadEdgeCollision && currentGrid && currentGrid.isInstanced) {
    const oldModeNeedsEdges = (oldMode === 'addEdge' || oldMode === 'addCube' || oldMode === 'backbite');
    const newModeNeedsEdges = (newMode === 'addEdge' || newMode === 'addCube' || newMode === 'backbite');

    // Entering an edge editing mode - load edge collision if not already loaded
    if (newModeNeedsEdges && !oldModeNeedsEdges) {
      // Check if edge collision needs loading
      let needsLoading = false;
      if (currentGrid.chunks && currentGrid.chunks.size > 0) {
        const firstChunk = currentGrid.chunks.values().next().value;
        if (!firstChunk.instancedEdgesCollision) {
          needsLoading = true;
        }
      }

      if (needsLoading) {
        console.log(`[setMode] Entering edge editing mode "${newMode}", loading edge collision`);
        loadEdgeCollision(currentGrid);
      }
    }

    // Leaving an edge editing mode - potentially unload edge collision
    if (oldModeNeedsEdges && !newModeNeedsEdges) {
      // Only unload if ALL conditions are met:
      // 1. No manually colored edges exist
      // 2. No edge operations in history
      const shouldUnload =
        !hasManuallyColoredEdges(currentGrid) &&
        !hasEdgeOperationsInHistory(currentGrid);

      if (shouldUnload) {
        console.log(`[setMode] Leaving edge editing mode "${oldMode}", unloading edge collision`);
        unloadEdgeCollision(currentGrid);
      } else {
        console.log(`[setMode] Leaving edge editing mode "${oldMode}", keeping edge collision loaded (needed by manually added/colored edges or history)`);
      }
    }
  }

  // Handle block cube loading/unloading for addCube mode
  if (lazyLoadBlockCubes && currentGrid && currentGrid.isInstanced) {
    const oldModeNeedsCubes = (oldMode === 'addCube');
    const newModeNeedsCubes = (newMode === 'addCube');

    // Entering addCube mode - load block cubes if not already loaded
    if (newModeNeedsCubes && !oldModeNeedsCubes) {
      // Check if block cubes need loading
      let needsLoading = false;
      if (currentGrid.chunks && currentGrid.chunks.size > 0) {
        const firstChunk = currentGrid.chunks.values().next().value;
        if (!firstChunk.instancedBlockCubes) {
          needsLoading = true;
        }
      }

      if (needsLoading) {
        console.log(`[setMode] Entering addCube mode, loading block cubes`);
        loadBlockCubes(currentGrid);
      }
    }

    // Leaving addCube mode - potentially unload block cubes
    if (oldModeNeedsCubes && !newModeNeedsCubes) {
      // Only unload if ALL conditions are met:
      // 1. No block cube decorations exist
      // 2. No block cube operations in history
      const shouldUnload =
        !hasBlockCubeDecorations(currentGrid) &&
        !hasBlockCubeOperationsInHistory(currentGrid);

      if (shouldUnload) {
        console.log(`[setMode] Leaving addCube mode, unloading block cubes`);
        unloadBlockCubes(currentGrid);
      } else {
        console.log(`[setMode] Leaving addCube mode, keeping block cubes loaded (decorations or history exist)`);
      }
    }
  }

  // Update UI button states
  updateModeButtonStates();

  // Update collision helper visibility based on new mode
  updateCollisionHelperVisibility();

  console.log(`Mode changed from "${oldMode}" to "${newMode}"`);
}

// Note: Collision helper visibility is now controlled only by frustum culling (isVisible)
// Mode-based filtering is done in the raycast functions, not via the visible flag
// This is because Three.js raycaster skips objects with visible=false
function updateCollisionHelperVisibility() {
  // No longer needed - collision helpers stay visible for raycasting
  // Mode-based filtering is handled in handleEdgeHover/handleVertexHover
}

// Helper function to disable switch/backbite modes when editing functions are activated
function disableSwitchBackbiteModes() {
  if (mode === "switch") {
    mode = "default";
    switchMode = false;
    clearBoxHighlights();
    clearHoveredBoxHighlight(); // Clear any lingering hover highlight

    // Show original box meshes again when leaving switch mode
    if (currentGrid) {
      currentGrid.instancedBoxesXY.visible = true;
      currentGrid.instancedBoxesXZ.visible = true;
      currentGrid.instancedBoxesYZ.visible = true;
    }

    // Update switch pill UI
    const switchPill = document.getElementById("switchPill");
    if (switchPill) switchPill.classList.remove("active");
  } else if (mode === "backbite") {
    mode = "default";
    
    // Update backbite pill UI
    const backbitePill = document.getElementById("backbitePill");
    if (backbitePill) backbitePill.classList.remove("active");
  }
  
  updateGlobalUI();
}

// Helper function to disable editing modes when switch/backbite are activated
function disableEditingModes() {
  const editingModes = ["addEdge", "addVertex", "addDecoration", "addCube"];
  if (editingModes.includes(mode)) {
    mode = "default";
    updateModeButtonStates();
  }
}


function updateModeButtonStates() {
  // Remove active class from all mode buttons
  const modeButtons = [
    'toggleClickBtn',   // addEdge
    'verticesBtn',      // addVertex
    'decorationBtn',    // addDecoration
    'switchBtn',        // switch  
    'backbiteBtn',      // backbite
    'cubeBtn'           // addCube - ADD THIS
  ];
  
  modeButtons.forEach(buttonId => {
    const button = document.getElementById(buttonId);
    if (button) button.classList.remove('active');
  });
  
  // Add active class to current mode button
  switch(mode) {
    case 'addEdge':
      document.getElementById('toggleClickBtn')?.classList.add('active');
      break;
    case 'addVertex':
      document.getElementById('verticesBtn')?.classList.add('active');
      break;
    case 'addDecoration':
      document.getElementById('decorationBtn')?.classList.add('active');
      break;
    case 'switch':
      document.getElementById('switchPill')?.classList.add('active');
      break;
    case 'backbite':
      document.getElementById('backbitePill')?.classList.add('active');
      break;
    case 'addCube':  // ADD THIS CASE
      document.getElementById('cubeBtn')?.classList.add('active');
      break;
    default:
      break;
  }
}













//     ====================================================================================================================
// 										    7. EVENT LISTENERS AND SETUP
//     ====================================================================================================================

// Group 1: Path/Cycle Operations
document.getElementById("genPathBtn").addEventListener("click", generatePath);

document.getElementById("genCycleBtn").addEventListener("click", generateCycleFromPath);

document.getElementById("checkHamBtn").onclick = checkHamiltonianCombined;


document.getElementById("gradientCheckbox").addEventListener("change", (e) => {
  gradientMode = e.target.checked;
  
  if (gradientMode && currentGrid && currentGrid.path && currentGrid.path.length > 1) {
    applyGradientToPath();
  } else if (!gradientMode && currentGrid && currentGrid.activeSubgraph && currentGrid.path && currentGrid.path.length > 1) {
    // Store arrow information by going through PATH (not subgraph edges)
    const arrowInfo = [];
    const path = currentGrid.path;
    
    for (let i = 0; i < path.length - 1; i++) {
      const a = unpackVertex(path[i]);
      const b = unpackVertex(path[i + 1]);
      const eKey = edgeKey(a, b);
      const edge = currentGrid.edges.get(eKey);
      
      if (edge && edge.arrows) {
        arrowInfo.push({
          a: a,
          b: b,
          direction: edge.arrows.direction,
          eKey: eKey
        });
      }
    }
    
    // Recolor edges to single color
    updateEdgeMeshesFromSubgraph(currentGrid, currentGrid.activeSubgraph);
    
    // Re-add arrows AFTER recoloring - in path order with correct a,b coordinates
    // Pass the key to avoid O(n) edge lookup
    for (const info of arrowInfo) {
      const edge = currentGrid.edges.get(info.eKey);
      if (edge) {
        addArrowsToEdge(edge, info.direction, info.a, info.b, info.eKey);
      }
    }
  }
});

document.getElementById("arrowCheckbox").addEventListener("change", (e) => {
 arrowMode = e.target.checked;

 if (!currentGrid) {
   return;
 }

 if (arrowMode) {
   // If lazy loading is enabled and arrows aren't loaded, load them first
   if (lazyLoadArrows && !currentGrid.instancedArrowsForward && !currentGrid.instancedArrowsBackward) {
     loadArrows(currentGrid);
   }

   // Use addDirectionalArrowsToPath if we have a path
   if (currentGrid.path && currentGrid.path.length > 1) {
     addDirectionalArrowsToPath(currentGrid.path);
   }

   // ALSO RESTORE ARROWS FOR MANUALLY ADDED EDGES
   // After restoring Hamiltonian path arrows, restore arrows for any edge that has arrowDirection set
   // This handles manually added edges with arrows that were toggled off
   for (const [eKey, edge] of currentGrid.edges.entries()) {
     // Check if this edge previously had arrows (arrowDirection is set) but no active arrows now
     if (edge.arrowDirection && !edge.arrows) {
       addArrowsToEdge(edge, edge.arrowDirection, null, null, eKey);
     }
   }
 } else {
   // Clear all arrows using the dedicated clear functions
   const arrowRemovalStart = performance.now();

   if (arrowRenderMode === 'transcendent') {
     clearArrowsTranscendent(currentGrid);
   } else {
     clearArrowsNormal(currentGrid);
   }

   renderer.render(scene, camera);

   const arrowRemovalTime = performance.now() - arrowRemovalStart;
   console.log(`[Arrows] Removed all arrows in ${arrowRemovalTime.toFixed(0)}ms`);

   // If lazy loading is enabled, unload arrows to free memory
   if (lazyLoadArrows) {
     unloadArrows(currentGrid);
   }
 }
});

// Group 2: Display Options
document.getElementById('toggleGridCheckbox').addEventListener('change', (e) => {
  toggleUnderlyingGrid();
});

document.getElementById("coordCheckbox").addEventListener("change", (e) => {
  toggleCoordinateAxes();
});

document.getElementById("gridOpacitySlider").addEventListener("input", (e) => {
  const opacity = parseFloat(e.target.value);
  document.getElementById("opacityValue").textContent = Math.round(opacity * 100) + "%";
  
  if (!currentGrid) return;
  
  if (currentGrid.isInstanced) {
    // Instanced rendering mode - update colors for all uncolored edges
    const grayValue = opacity < 1 ? Math.floor(0x88 * opacity) : 0x88;
    const simulatedColor = (grayValue << 16) | (grayValue << 8) | grayValue;
    const color = new THREE.Color(simulatedColor);

    // Handle chunk-based rendering
    if (currentGrid.chunks && currentGrid.chunks.size > 0) {
      for (const [eKey, edge] of currentGrid.edges.entries()) {
        if (edge.color === UNCOLORED_COLOR) {
          // Find which chunk this edge belongs to
          const chunkKey = currentGrid.edgeToChunk ? currentGrid.edgeToChunk.get(eKey) : null;
          if (chunkKey) {
            const chunk = currentGrid.chunks.get(chunkKey);
            if (chunk && chunk.edgeToInstanceMap) {
              const mapping = chunk.edgeToInstanceMap.get(eKey);
              if (mapping && chunk.instancedEdgesThin) {
                chunk.instancedEdgesThin.setColorAt(mapping.thin, color);
              }
            }
          }
        }
      }
      // Update all chunk meshes
      for (const chunk of currentGrid.chunks.values()) {
        if (chunk.instancedEdgesThin) {
          chunk.instancedEdgesThin.instanceColor.needsUpdate = true;
        }
      }
    } else if (currentGrid.edgeToInstanceMap) {
      // Fallback for non-chunked grids
      for (const [eKey, edge] of currentGrid.edges.entries()) {
        if (edge.color === UNCOLORED_COLOR) {
          const mapping = currentGrid.edgeToInstanceMap.get(eKey);
          if (mapping) {
            currentGrid.instancedEdgesThin.setColorAt(mapping.thin, color);
          }
        }
      }
      currentGrid.instancedEdgesThin.instanceColor.needsUpdate = true;
    }
    
  } else {
    // Individual mesh mode
    for (const edge of currentGrid.edges.values()) {
      if (edge.color === UNCOLORED_COLOR && edge.mesh) {
        if (opacity < 1) {
          // Create a new material that forces opaque rendering
          const newMaterial = edge.mesh.material.clone();
          newMaterial.transparent = false;  // Lie to Three.js about transparency
          newMaterial.opacity = 1;
          
          // Manually blend the color with background to simulate transparency
          const grayValue = Math.floor(0x88 * opacity);
          const simulatedColor = (grayValue << 16) | (grayValue << 8) | grayValue;
          newMaterial.color.setHex(simulatedColor);
          
          edge.mesh.material = newMaterial;
        } else {
          // Restore original opaque material
          edge.mesh.material.transparent = false;
          edge.mesh.material.opacity = 1;
          edge.mesh.material.color.setHex(0x888888);
        }
        
        edge.mesh.material.needsUpdate = true;
      }
    }
  }
});


document.getElementById("backgroundSelect").addEventListener("change", (e) => {
  const value = e.target.value;
  
  // Check if it's a hex color (old system) or theme name (new system)
  if (value.startsWith('0x')) {
    // Old system: hex color value
    const colorHex = parseInt(value, 16);
    updateTheme(colorHex);
  } else {
    // New system: theme name
    updateTheme(value);
  }
});

// Generate panel collapse/expand functionality
document.addEventListener('DOMContentLoaded', function() {
  const genHeader = document.getElementById('genHeader');
  const genBody = document.getElementById('genBody');
  const genCaret = document.getElementById('genCaret');
  
  if (genHeader && genBody && genCaret) {
    let genOpen = true;
    
    function updateGenPanel() {
      if (genOpen) {
        genBody.classList.remove('collapsed');
        genCaret.textContent = '▴';
      } else {
        genBody.classList.add('collapsed');
        genCaret.textContent = '▾';
      }
    }
    
    genHeader.addEventListener('click', () => {
      genOpen = !genOpen;
      updateGenPanel();
    });
    
    updateGenPanel();
  }
  
  // BB Distance panel collapse/expand functionality
  const bbHeader = document.getElementById('bbHeader');
  const bbBody = document.getElementById('bbBody');
  const bbCaret = document.getElementById('bbCaret');
  
  if (bbHeader && bbBody && bbCaret) {
    let bbOpen = false;
    
    function updateBBPanel() {
      if (bbOpen) {
        bbBody.classList.remove('collapsed');
        bbCaret.textContent = '▴';
      } else {
        bbBody.classList.add('collapsed');
        bbCaret.textContent = '▾';
      }
    }
    
    bbHeader.addEventListener('click', () => {
      bbOpen = !bbOpen;
      updateBBPanel();
    });
    
    updateBBPanel();
  }
  
  // Plane panel collapse/expand functionality for right sidebar
  const planeHeader = document.getElementById('planeHeader');
  const planeBody = document.getElementById('planeBody');
  const planeCaret = document.getElementById('planeCaret');
  
  if (planeHeader && planeBody && planeCaret) {
    let planeOpen = false;
    
    function updatePlanePanel() {
      if (planeOpen) {
        planeBody.classList.remove('collapsed');
        planeCaret.textContent = '▴';
      } else {
        planeBody.classList.add('collapsed');
        planeCaret.textContent = '▾';
      }
    }
    
    planeHeader.addEventListener('click', () => {
      planeOpen = !planeOpen;
      updatePlanePanel();
    });
    
    updatePlanePanel();
  }
  
// Notes button handler
  const notesBtn = document.getElementById('notesBtn');
  if (notesBtn) {
    notesBtn.addEventListener('click', () => {
      const notesWindow = document.getElementById('notesWindow');
      if (notesWindow) {
        if (notesWindow.style.display === 'block') {
          // Close notes
          saveCurrentGridNotes();
          notesWindow.style.display = 'none';
        } else {
          // Open notes
          notesWindow.style.display = 'block';
          initQuillEditor();
          updateNotesForCurrentGrid();
          setTimeout(() => { if (quillEditor) quillEditor.focus(); }, 50);
        }
      }
    });
  }
  
  // Coordinate hover checkbox handler
  const coordHoverCheckbox = document.getElementById('coordinateHoverCheckbox');
  const relativeCoordRow = document.getElementById('relativeCoordRow');
  const relativeCheckbox = document.getElementById('relativeCoordinatesCheckbox');
  
  if (coordHoverCheckbox && relativeCoordRow && relativeCheckbox) {
    coordHoverCheckbox.addEventListener('change', () => {
      if (coordHoverCheckbox.checked) {
        relativeCoordRow.classList.remove('disabled');
        relativeCoordRow.removeAttribute('title');
        relativeCheckbox.disabled = false;
      } else {
        relativeCoordRow.classList.add('disabled');
        relativeCoordRow.setAttribute('title', "Enable 'Coordinate Hover' first to use this feature");
        relativeCheckbox.disabled = true;
        relativeCheckbox.checked = false;
      }
    });
  }
  
  // Sidebar toggle functionality
  const leftSidebar = document.querySelector('.sidebar');
  const rightSidebar = document.querySelector('.sidebar-right');
  const leftToggle = document.getElementById('leftSidebarToggle');
  const rightToggle = document.getElementById('rightSidebarToggle');
  
  if (leftToggle && leftSidebar) {
    leftToggle.addEventListener('click', () => {
      leftSidebar.classList.toggle('collapsed');
      leftToggle.classList.toggle('sidebar-collapsed');
      // Change chevron direction
      const path = leftToggle.querySelector('path');
      if (path) {
        path.setAttribute('d', leftSidebar.classList.contains('collapsed') ? 'M3 6 L8 12 L3 18' : 'M9 6 L4 12 L9 18');
      }
    });
  }
  
  if (rightToggle && rightSidebar) {
    rightToggle.addEventListener('click', () => {
      rightSidebar.classList.toggle('collapsed');
      rightToggle.classList.toggle('sidebar-collapsed');
      // Change chevron direction
      const path = rightToggle.querySelector('path');
      if (path) {
        path.setAttribute('d', rightSidebar.classList.contains('collapsed') ? 'M9 6 L4 12 L9 18' : 'M3 6 L8 12 L3 18');
      }
    });
  }
  
// Color swatch and label click functionality
  const colorDisks = document.querySelectorAll('.color-swatches .color-disk');
  const colorInput = document.getElementById('colorInput');
  const colorInput2 = document.getElementById('colorInput2');
  const colorInput1Wrapper = colorInput?.parentElement;
  const colorInput2Wrapper = colorInput2?.parentElement;
  const mainColorLabel = document.getElementById('mainColorLabel');
  const secondColorLabel = document.getElementById('secondColorLabel');
  
  // Set initial active state
  if (colorInput1Wrapper) {
    colorInput1Wrapper.classList.add('active');
  }
  
  // Label click handlers
  if (mainColorLabel && colorInput1Wrapper && colorInput2Wrapper) {
    mainColorLabel.addEventListener('click', () => {
      activeColorTarget = 'main';
      colorInput1Wrapper.classList.add('active');
      colorInput2Wrapper.classList.remove('active');
    });
  }
  
  if (secondColorLabel && colorInput1Wrapper && colorInput2Wrapper) {
    secondColorLabel.addEventListener('click', () => {
      activeColorTarget = 'second';
      colorInput2Wrapper.classList.add('active');
      colorInput1Wrapper.classList.remove('active');
    });
  }
  
  // Color disk click handlers
  if (colorDisks && colorInput && colorInput2) {
    colorDisks.forEach(disk => {
      disk.addEventListener('click', (e) => {
        const color = e.target.getAttribute('data-color');
        if (color) {
          if (activeColorTarget === 'second') {
            colorInput2.value = color;
            colorInput2.dispatchEvent(new Event('change'));
          } else {
            colorInput.value = color;
            colorInput.dispatchEvent(new Event('change'));
          }
        }
      });
    });
  }
  // Pills are handled by their specific event handlers below
  // (switchPill, backbitePill, gradientPill handlers manage both visual and functional state)
});

//     ====================================================================================================================
// 										   		   THEME MANAGEMENT
//     ====================================================================================================================

// Get current hour and determine theme based on time of day
function getThemeByTime() {
  const now = new Date();
  const hour = now.getHours();
  // Dark mode: 12am (0) to 8am (8), Light mode: 8am to 12am (0)
  return (hour >= 0 && hour < 8) ? 'dark' : 'paper-white';
}

// Auto-switch theme based on time (called from animate loop)
function checkAndApplyAutoTheme() {
  if (!autoSwitchThemeEnabled) return;

  const currentTime = performance.now();
  if (currentTime - lastAutoSwitchCheck < autoSwitchCheckInterval) return;

  lastAutoSwitchCheck = currentTime;

  const requiredTheme = getThemeByTime();
  const themeSelect = document.getElementById('themeSelect');

  if (themeSelect && themeSelect.value !== requiredTheme) {
    themeSelect.value = requiredTheme;
    updateTheme(requiredTheme);
  }
}

// Theme update function for sidebar and topbar
function updateTheme(themeValue, overrideBackground = null) {
  const root = document.documentElement;
  
  // Remove all theme classes
  root.classList.remove('dark-theme', 'warm-light-theme', 'mist-blue-theme', 'paper-white-theme', 'sandstone-theme');
  
  // Determine theme based on value
  let theme = 'light';
  let colorHex = 0xf7f5e9; // default gradient start
  
  if (typeof themeValue === 'string') {
    // New system: theme name
    theme = themeValue;
    switch(themeValue) {
      case 'dark':
        root.classList.add('dark-theme');
        colorHex = 0x000000;
        break;
      case 'warm-light':
        root.classList.add('warm-light-theme');
        colorHex = 0xFFFDF9;
        break;
      case 'mist-blue':
        root.classList.add('mist-blue-theme');
        colorHex = 0xF8FBFF;
        break;
      case 'paper-white':
        root.classList.add('paper-white-theme');
        colorHex = 0xFFFFFF;
        break;
      case 'sandstone':
        root.classList.add('sandstone-theme');
        colorHex = 0xFEFEFD;
        break;
      case 'light':
      default:
        // Contrast 1 theme (no additional class needed)
        colorHex = 0xf7f5e9;
        break;
    }
  } else {
    // Old system: hex color value (for backward compatibility)
    if (themeValue === 0x000000 || themeValue < 0x808080) {
      root.classList.add('dark-theme');
      theme = 'dark';
      colorHex = 0x000000;
    } else {
      theme = 'light';
      colorHex = 0xf7f5e9;
    }
  }
  
  // Apply background override if specified
  if (overrideBackground && overrideBackground !== 'theme-default') {
    switch(overrideBackground) {
      case 'beige':
        colorHex = 0xFAFBFC; // Beige from old minimal-light
        break;
      case 'light-gradient':
        colorHex = 0xf7f5e9;
        break;
      case 'warm-gradient':
        colorHex = 0xFFFDF9;
        break;
      case 'mist-gradient':
        colorHex = 0xF8FBFF;
        break;
      case 'white':
        colorHex = 0xFFFFFF;
        break;
      case 'black':
        colorHex = 0x000000;
        break;
      case 'custom':
        // Custom color will be handled separately
        const customColor = document.getElementById('customBgColor');
        if (customColor) {
          colorHex = parseInt(customColor.value.replace('#', ''), 16);
        }
        break;
    }
  }
  
  // Update scene background
  if (typeof scene !== 'undefined' && scene.background) {
    scene.background = new THREE.Color(colorHex);
  }
  
  // Set grid opacity based on theme
  const opacitySlider = document.getElementById("gridOpacitySlider");
  const opacityValue = document.getElementById("opacityValue");
  
  if (opacitySlider && opacityValue) {
    if (theme === 'dark') {
      opacitySlider.value = "0.3";
      opacityValue.textContent = "30%";
    } else {
      opacitySlider.value = "1.0";
      opacityValue.textContent = "100%";
    }
    opacitySlider.dispatchEvent(new Event('input'));
  }
  
  // Adjust coordinate label visibility
  adjustCoordinateLabelColors(colorHex);

  return theme;
}




// Group 4: Grid Management
document.getElementById("addGridBtn").addEventListener("click", addGrid);

function updateAddGridSymbolColor() {
  const symbol = document.getElementById("addGridSymbol");
  if (symbol) {
    const colorHex = "#" + selectedColor.toString(16).padStart(6, '0');
    symbol.style.color = colorHex;
  }
}


document.getElementById("duplicateBtn").addEventListener("click", duplicateCurrentGrid);



// Initialize color interface
function initializeColorInterface() {
  updateColorInterfaceState();
  
  // Main color section click handlers
  document.getElementById('mainColorLabel').addEventListener('click', () => setActiveColor('main'));
  document.getElementById('colorInput').addEventListener('click', () => setActiveColor('main'));
  document.getElementById('colorInput').addEventListener('input', handleColorInputChange);
  
  // Second color section click handlers  
  document.getElementById('secondColorLabel').addEventListener('click', () => setActiveColor('second'));
  document.getElementById('colorInput2').addEventListener('click', () => setActiveColor('second'));
  document.getElementById('colorInput2').addEventListener('input', handleColorInputChange);
  
  // Shared color circles
  document.querySelectorAll('.color-disk').forEach(disk => {
    disk.addEventListener('click', (e) => {
      const color = e.target.getAttribute('data-color');
      const colorHex = parseInt(color.replace("#", "0x"), 16);
      
      if (activeColorTarget === 'main') {
        selectedColor = colorHex;
        document.getElementById("colorInput").value = color;
      } else {
        selectedColor2 = colorHex;
        document.getElementById("colorInput2").value = color;
      }
      
      updateAddGridSymbolColor();
      
      if (gradientMode && currentGrid && currentGrid.path && currentGrid.path.length > 1) {
        applyGradientToPath();
      }
    });
  });
}

function setActiveColor(target) {
  activeColorTarget = target;
  updateColorInterfaceState();
  console.log(`Active color switched to: ${target}`);
}

function updateColorInterfaceState() {
  const mainLabel = document.getElementById('mainColorLabel');
  const secondLabel = document.getElementById('secondColorLabel');
  const mainInput = document.getElementById('colorInput');
  const secondInput = document.getElementById('colorInput2');
  
  if (activeColorTarget === 'main') {
    // Main active
    mainLabel.className = 'color-label-active';
    secondLabel.className = 'color-label-inactive';
    mainInput.className = 'color-input-active';
    secondInput.className = 'color-input-inactive';
  } else {
    // Second active
    mainLabel.className = 'color-label-inactive';
    secondLabel.className = 'color-label-active';
    mainInput.className = 'color-input-inactive';
    secondInput.className = 'color-input-active';
  }
}

function handleColorInputChange(e) {
  const colorHex = parseInt(e.target.value.replace("#", "0x"), 16);
  
  if (e.target.id === 'colorInput') {
    setActiveColor('main');
    selectedColor = colorHex;
  } else if (e.target.id === 'colorInput2') {
    setActiveColor('second');
    selectedColor2 = colorHex;
  }
  
  updateAddGridSymbolColor();
  
  if (gradientMode && currentGrid && currentGrid.path && currentGrid.path.length > 1) {
    applyGradientToPath();
  }
}


// Global Event Listeners
window.addEventListener("click", onClick);
window.addEventListener("mousemove", onMouseMove);

// Add mousedown event listener
window.addEventListener("mousedown", onMouseDown);
window.addEventListener("mouseup", onMouseUp);

// Warn users before closing if they have unsaved work
window.addEventListener("beforeunload", (e) => {
  // Only show warning if:
  // 1. There are grids to save
  // 2. User hasn't just saved (within last 2 seconds)
  const timeSinceLastSave = lastSaveTime ? Date.now() - lastSaveTime : Infinity;
  const justSaved = timeSinceLastSave < 2000; // 2 seconds grace period
  
  if (allGrids.size > 0 && !justSaved) {
    // Modern browsers ignore custom messages, but setting returnValue triggers the dialog
    e.preventDefault();
    e.returnValue = ''; // Required for Chrome
    return ''; // For older browsers
  }
});




// Modes
document.getElementById("toggleClickBtn").addEventListener("click", () => {
  disableSwitchBackbiteModes();
  const newMode = mode === "addEdge" ? "default" : "addEdge";
  setMode(newMode);
});

document.getElementById("verticesBtn").addEventListener("click", () => {
  disableSwitchBackbiteModes();
  const newMode = mode === "addVertex" ? "default" : "addVertex";
  setMode(newMode);
});

document.getElementById("decorationBtn").addEventListener("click", () => {
  disableSwitchBackbiteModes();
  const newMode = mode === "addDecoration" ? "default" : "addDecoration";
  setMode(newMode);
});


document.getElementById("switchPill").addEventListener("click", () => {
  // Disable any active editing modes
  disableEditingModes();
  
  // Auto-disable gradient and backbite if active
  if (gradientMode) {
    gradientMode = false;
    const gradientCheckbox = document.getElementById("gradientCheckbox");
    if (gradientCheckbox) gradientCheckbox.checked = false;
    
    
    if (currentGrid && currentGrid.activeSubgraph) {
      updateEdgeMeshesFromSubgraph(currentGrid, currentGrid.activeSubgraph);
    }
  }
  
  if (mode === "switch") {
    mode = "default";
    switchMode = false;
    clearBoxHighlights();
    clearHoveredBoxHighlight(); // Clear any lingering hover highlight

    // Show original box meshes again when leaving switch mode
    if (currentGrid) {
      currentGrid.instancedBoxesXY.visible = true;
      currentGrid.instancedBoxesXZ.visible = true;
      currentGrid.instancedBoxesYZ.visible = true;
    }

    // If lazy loading is enabled, unload switchable boxes when leaving switch mode
    if (lazyLoadSwitchableBoxes && currentGrid) {
      unloadSwitchableBoxes(currentGrid);
    }
  } else {
    // If lazy loading is enabled and boxes aren't loaded, load them first
    if (lazyLoadSwitchableBoxes && currentGrid && !currentGrid.instancedBoxesXY && !currentGrid.instancedBoxesXZ && !currentGrid.instancedBoxesYZ) {
      loadSwitchableBoxes(currentGrid);
    }

    mode = "switch";
    switchMode = true;

    // Check if we're in 2D mode
    const is2D = currentGrid && (
      (currentGrid.width === 1 ? 1 : 0) +
      (currentGrid.height === 1 ? 1 : 0) +
      (currentGrid.depth === 1 ? 1 : 0)
    ) === 1;

    if (is2D) {
      // 2D mode: keep boxes visible for direct hover/click interaction
      if (currentGrid) {
        currentGrid.instancedBoxesXY.visible = true;
        currentGrid.instancedBoxesXZ.visible = true;
        currentGrid.instancedBoxesYZ.visible = true;
      }
      // No border box highlighting in 2D - user hovers directly on boxes
    } else {
      // 3D mode: Hide original box meshes - they're only for raycasting now
      if (currentGrid) {
        currentGrid.instancedBoxesXY.visible = false;
        currentGrid.instancedBoxesXZ.visible = false;
        currentGrid.instancedBoxesYZ.visible = false;
      }

      // Instanced boxes are already created during grid initialization
      // No on-demand creation needed!

      if (currentGrid && currentGrid.activeSubgraph) {
        const adj = buildAdjacencyFromEdgeSet(currentGrid, currentGrid.activeSubgraph.getEdgeKeys());
        const vertexComponent = labelComponents(adj);
        const numComponents = new Set(vertexComponent.values()).size;
        if (numComponents >= 2) {
          const borderBoxes = getGeneralBorderBoxes(currentGrid, vertexComponent, currentGrid.activeSubgraph);
          highlightBoxes(borderBoxes, boxHighlightColor);
          currentGrid.highlightedBoxes = borderBoxes;
        }
      }
    }
  }
  
  updateGlobalUI();
});




document.getElementById("backbitePill").addEventListener("click", () => {
  // Disable any active editing modes
  disableEditingModes();
  
  // Auto-disable switch mode if active
  const newMode = mode === "backbite" ? "default" : "backbite";
  setMode(newMode);
  updateGlobalUI();
});

document.getElementById("cubeBtn").addEventListener("click", () => {
  disableSwitchBackbiteModes();
  const newMode = mode === "addCube" ? "default" : "addCube";
  setMode(newMode);
});


// Add with your other event listeners
document.getElementById("addLayerBtn").addEventListener("click", (event) => {
  disableSwitchBackbiteModes();
  showAddLayerMenu(event);
});
document.getElementById("removeLayerBtn").addEventListener("click", (event) => {
  disableSwitchBackbiteModes();
  showRemoveLayerMenu(event);
});

function showAddLayerMenu(event) {
  const options = [
    { label: "X+ (far)", value: "x+" },
    { label: "X- (near)", value: "x-" },
    { label: "Y+ (far)", value: "y+" }, 
    { label: "Y- (near)", value: "y-" },
    { label: "Z+ (far)", value: "z+" },
    { label: "Z- (near)", value: "z-" }
  ];
  
  showLayerMenu(event, options, expandCurrentGrid);
}

function showRemoveLayerMenu(event) {
  if (!currentGrid) {
    alert("No grid to modify");
    return;
  }
  
  const options = [
    { label: "X+ (far)", value: "x+", enabled: canRemoveLayer("x+") },
    { label: "X- (near)", value: "x-", enabled: canRemoveLayer("x-") },
    { label: "Y+ (far)", value: "y+", enabled: canRemoveLayer("y+") },
    { label: "Y- (near)", value: "y-", enabled: canRemoveLayer("y-") },
    { label: "Z+ (far)", value: "z+", enabled: canRemoveLayer("z+") },
    { label: "Z- (near)", value: "z-", enabled: canRemoveLayer("z-") }
  ];
  
  showLayerMenu(event, options, (direction) => {
    if (canRemoveLayer(direction)) {
      removeLayer(direction);
    } else {
      alert("Cannot remove layer: contains colored edges");
    }
  });
}

function showLayerMenu(event, options, callback) {
  // Remove existing menu
  const existingMenu = document.getElementById('layerMenu');
  if (existingMenu) existingMenu.remove();

  // Check if dark theme is active
  const isDarkTheme = document.documentElement.classList.contains('dark-theme');

  // Create menu
  const menu = document.createElement('div');
  menu.id = 'layerMenu';
  menu.style.cssText = `
    position: absolute;
    background: ${isDarkTheme ? 'rgba(60, 64, 72, 0.95)' : 'white'};
    border: 1px solid ${isDarkTheme ? '#4b5563' : '#ccc'};
    border-radius: 4px;
    box-shadow: 0 2px 8px rgba(0,0,0,${isDarkTheme ? '0.4' : '0.2'});
    z-index: 1000;
    min-width: 120px;
  `;

  // Position menu near button
  const rect = event.target.getBoundingClientRect();
  menu.style.left = (rect.right + 5) + 'px';
  menu.style.top = rect.top + 'px';

  // Add options
  options.forEach(option => {
    const item = document.createElement('div');
    item.textContent = option.label;
    const enabledColor = isDarkTheme ? '#e5e7eb' : '#333';
    const disabledColor = isDarkTheme ? '#6b7280' : '#999';
    const hoverBg = isDarkTheme ? 'rgba(80, 84, 92, 0.8)' : '#f0f0f0';

    item.style.cssText = `
      padding: 8px 12px;
      cursor: ${option.enabled !== false ? 'pointer' : 'not-allowed'};
      color: ${option.enabled !== false ? enabledColor : disabledColor};
      transition: background 0.2s;
    `;

    if (option.enabled !== false) {
      item.addEventListener('mouseenter', () => {
        item.style.background = hoverBg;
      });
      item.addEventListener('mouseleave', () => {
        item.style.background = 'transparent';
      });
      item.addEventListener('click', () => {
        callback(option.value);
        menu.remove();
      });
    }

    menu.appendChild(item);
  });
  
  document.body.appendChild(menu);
  
  // Close menu on outside click
  setTimeout(() => {
    document.addEventListener('click', function closeMenu(e) {
      if (!menu.contains(e.target)) {
        menu.remove();
        document.removeEventListener('click', closeMenu);
      }
    });
  }, 10);
}




// Add these with your other event listeners
document.getElementById("saveBtn").addEventListener("click", saveGrid);
document.getElementById("loadBtn").addEventListener("click", loadGridFromDisk);

// Help dropdown functionality
document.getElementById("helpBtn").addEventListener("click", (e) => {
  e.stopPropagation();
  const dropdown = document.getElementById("helpDropdown");
  dropdown.classList.toggle("show");
});

// Help menu item handlers
document.querySelectorAll('.help-menu-item').forEach(item => {
  item.addEventListener('click', (e) => {
    const action = e.target.getAttribute('data-action');
    const dropdown = document.getElementById("helpDropdown");
    dropdown.classList.remove("show");
    
    if (action === 'about') {
      document.getElementById("aboutModal").style.display = "flex";
    } else if (action === 'shortcuts') {
      document.getElementById("keyboardShortcutsModal").style.display = "flex";
    }
    // README is now handled by the second event listener which opens in new tab
  });
});

// Close dropdown when clicking outside
document.addEventListener('click', (e) => {
  const helpDropdown = document.getElementById("helpDropdown");
  const helpBtn = document.getElementById("helpBtn");
  if (helpDropdown && !helpDropdown.contains(e.target) && e.target !== helpBtn) {
    helpDropdown.classList.remove("show");
  }
});


// Preferences Modal handlers
document.getElementById("preferencesBtn").addEventListener("click", () => {
  // Load current preferences into the modal
  document.getElementById("componentColoringCheckbox").checked = componentColoringEnabled;
  document.getElementById("boxHighlightingCheckbox").checked = boxHighlightingEnabled;
  document.getElementById("boxHighlightColorPicker").value = '#' + boxHighlightColor.toString(16).padStart(6, '0');
  document.getElementById("boxHighlightOpacitySlider").value = Math.round(boxHighlightOpacity * 100);
  document.getElementById("boxHighlightOpacityValue").textContent = `${Math.round(boxHighlightOpacity * 100)}%`;
  document.getElementById("hoverVerticesCheckbox").checked = hoverVertices;
  document.getElementById("hoverEdgesCheckbox").checked = hoverEdges;

  // Load automatic rendering settings preference
  const useAutomaticCheckbox = document.getElementById("useAutomaticRenderingCheckbox");
  const advancedContainer = document.getElementById("advancedRenderingSettings");
  if (useAutomaticCheckbox) {
    useAutomaticCheckbox.checked = useAutomaticRenderingSettings;
    if (advancedContainer) {
      advancedContainer.style.display = useAutomaticRenderingSettings ? 'none' : 'block';
    }
  }
  
  // Load camera sensitivity preferences
  const cameraSensitivitySlider = document.getElementById("cameraSensitivitySlider");
  const cameraSensitivityValue = document.getElementById("cameraSensitivityValue");
  const showCameraSensitivityCheckbox = document.getElementById("showCameraSensitivityCheckbox");
  
  if (cameraSensitivitySlider && cameraSensitivityValue) {
    cameraSensitivitySlider.value = cameraSensitivity;
    cameraSensitivityValue.textContent = cameraSensitivity.toFixed(1);
  }
  
  if (showCameraSensitivityCheckbox) {
    showCameraSensitivityCheckbox.checked = showCameraSensitivityInMain;
  }

  // Load vertex dimmer preference
  const showVertexDimmerCheckbox = document.getElementById("showVertexDimmerCheckbox");
  if (showVertexDimmerCheckbox) {
    showVertexDimmerCheckbox.checked = showVertexDimmerInMain;
  }

  // Load 2D camera mode preference
  const use2DCameraModeCheckbox = document.getElementById("use2DCameraModeCheckbox");
  if (use2DCameraModeCheckbox) {
    use2DCameraModeCheckbox.checked = use2DCameraMode;
  }

  // Load flare preferences
  const flareColorPicker = document.getElementById("flareColorPicker");
  const flareRadiusSlider = document.getElementById("flareRadiusSlider");
  const flareRadiusValue = document.getElementById("flareRadiusValue");
  const showFlareButtonCheckbox = document.getElementById("showFlareButtonCheckbox");

  if (flareColorPicker) {
    flareColorPicker.value = '#' + flareColor.toString(16).padStart(6, '0');
  }

  if (flareRadiusSlider && flareRadiusValue) {
    flareRadiusSlider.value = flareRadius;
    flareRadiusValue.textContent = flareRadius.toFixed(1);
  }

  if (showFlareButtonCheckbox) {
    showFlareButtonCheckbox.checked = showFlareButton;
  }

  // Sync the cloned flare button checkbox in "Show on Main Screen" section
  const showFlareButtonCheckboxClone = document.getElementById("showFlareButtonCheckboxClone");
  if (showFlareButtonCheckboxClone) {
    showFlareButtonCheckboxClone.checked = showFlareButton;
  }

  // Load show all vertices preference (per-grid setting)
  const showAllVerticesCheckbox = document.getElementById("showAllVerticesCheckbox");
  if (showAllVerticesCheckbox && currentGrid) {
    showAllVerticesCheckbox.checked = currentGrid.showAllVertices || false;
  }

  // Load unified edge size preference (sledgehammer)
  const unifiedEdgeSizeCheckbox = document.getElementById("unifiedEdgeSizeCheckbox");
  if (unifiedEdgeSizeCheckbox) {
    unifiedEdgeSizeCheckbox.checked = unifiedEdgeSize;

    // Apply initial state to thick edge radius slider
    const thickContainer = document.getElementById('thickEdgeRadiusContainer');
    const thickSlider = document.getElementById('thickEdgeRadiusSlider');
    if (thickContainer && thickSlider) {
      if (unifiedEdgeSize) {
        thickContainer.style.opacity = '0.5';
        thickContainer.style.pointerEvents = 'none';
        thickSlider.disabled = true;
      } else {
        thickContainer.style.opacity = '1';
        thickContainer.style.pointerEvents = 'auto';
        thickSlider.disabled = false;
      }
    }
  }

  // Load vertex limit preference
  const removeVertexLimitCheckbox = document.getElementById("removeVertexLimitCheckbox");
  if (removeVertexLimitCheckbox) {
    removeVertexLimitCheckbox.checked = !vertexLimitEnabled;
  }

  // Load auto-switch theme preference
  const autoSwitchThemeCheckbox = document.getElementById("autoSwitchThemeCheckbox");
  if (autoSwitchThemeCheckbox) {
    autoSwitchThemeCheckbox.checked = autoSwitchThemeEnabled;
  }

  // Update theme button states
  const themeSelect = document.getElementById("themeSelect");

  // Get current theme from applied class (accounts for auto-switch theme)
  let currentTheme = 'paper-white';
  if (document.documentElement.classList.contains('dark-theme')) {
    currentTheme = 'dark';
  } else {
    currentTheme = 'paper-white';
  }

  // Set dropdown to current theme
  if (themeSelect) {
    themeSelect.value = currentTheme;
  }

  // Set arrow mode dropdown to current value
  const arrowModeSelect = document.getElementById("arrowModeSelect");
  if (arrowModeSelect) {
    arrowModeSelect.value = arrowRenderMode;
  }

  // Show modal
  document.getElementById("preferencesModal").style.display = "flex";

  // Center the modal initially
  const preferencesContent = document.getElementById("preferencesContent");
  if (preferencesContent) {
    preferencesContent.style.left = "50%";
    preferencesContent.style.top = "50%";
    preferencesContent.style.transform = "translate(-50%, -50%)";
  }

  console.log("Preferences modal opened");
});

// Preferences modal drag functionality
let isDraggingPreferences = false;
let dragOffsetX = 0;
let dragOffsetY = 0;

const preferencesDragHandle = document.getElementById("preferencesDragHandle");
const preferencesContent = document.getElementById("preferencesContent");

if (preferencesDragHandle && preferencesContent) {
  preferencesDragHandle.addEventListener("mousedown", (e) => {
    // Don't drag if clicking on the close button
    if (e.target.id === "closePreferencesBtn" || e.target.closest("#closePreferencesBtn")) {
      return;
    }

    isDraggingPreferences = true;

    // Get current position
    const rect = preferencesContent.getBoundingClientRect();
    dragOffsetX = e.clientX - rect.left;
    dragOffsetY = e.clientY - rect.top;

    // Convert from transform-centered to absolute positioning
    if (preferencesContent.style.transform !== "none") {
      preferencesContent.style.left = rect.left + "px";
      preferencesContent.style.top = rect.top + "px";
      preferencesContent.style.transform = "none";
    }

    e.preventDefault();
  });

  document.addEventListener("mousemove", (e) => {
    if (!isDraggingPreferences) return;

    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    const modalWidth = preferencesContent.offsetWidth;
    const modalHeight = preferencesContent.offsetHeight;

    // Calculate new position
    let newLeft = e.clientX - dragOffsetX;
    let newTop = e.clientY - dragOffsetY;

    // Apply boundaries: No more than 70% off screen
    const minLeft = -(modalWidth * 0.7);
    const maxLeft = viewportWidth - (modalWidth * 0.3);
    const minTop = 0; // Top bar can't go above screen
    const maxTop = viewportHeight - (modalHeight * 0.3);

    newLeft = Math.max(minLeft, Math.min(maxLeft, newLeft));
    newTop = Math.max(minTop, Math.min(maxTop, newTop));

    preferencesContent.style.left = newLeft + "px";
    preferencesContent.style.top = newTop + "px";
  });

  document.addEventListener("mouseup", () => {
    isDraggingPreferences = false;
  });
}

// Theme dropdown handler
const themeSelect = document.getElementById('themeSelect');
const backgroundOverrideSelect = document.getElementById('backgroundOverrideSelect');
const customBackgroundPicker = document.getElementById('customBackgroundPicker');
const customBgColor = document.getElementById('customBgColor');

if (themeSelect) {
  themeSelect.addEventListener('change', () => {
    const selectedTheme = themeSelect.value;
    const backgroundOverride = backgroundOverrideSelect ? backgroundOverrideSelect.value : 'theme-default';
    
    // Update hidden background select for compatibility
    const backgroundSelect = document.getElementById('backgroundSelect');
    if (backgroundSelect) {
      backgroundSelect.value = selectedTheme;
    }
    
    // Apply theme with background override
    updateTheme(selectedTheme, backgroundOverride);
  });
}

// Background override dropdown handler
if (backgroundOverrideSelect) {
  backgroundOverrideSelect.addEventListener('change', () => {
    const selectedBg = backgroundOverrideSelect.value;
    
    // Show/hide custom color picker
    if (customBackgroundPicker) {
      customBackgroundPicker.style.display = selectedBg === 'custom' ? 'block' : 'none';
    }
    
    // Apply theme with new background
    const currentTheme = themeSelect ? themeSelect.value : 'light';
    updateTheme(currentTheme, selectedBg);
  });
}

// Custom background color picker handler
if (customBgColor) {
  customBgColor.addEventListener('change', () => {
    const currentTheme = themeSelect ? themeSelect.value : 'light';
    updateTheme(currentTheme, 'custom');
  });
}

document.getElementById("savePreferencesBtn").addEventListener("click", () => {
  // Save preferences from checkboxes
  componentColoringEnabled = document.getElementById("componentColoringCheckbox").checked;
  boxHighlightingEnabled = document.getElementById("boxHighlightingCheckbox").checked;
  boxHighlightColor = parseInt(document.getElementById("boxHighlightColorPicker").value.slice(1), 16);
  boxHighlightOpacity = parseInt(document.getElementById("boxHighlightOpacitySlider").value) / 100;
  hoverVertices = document.getElementById("hoverVerticesCheckbox").checked;
  hoverEdges = document.getElementById("hoverEdgesCheckbox").checked;
  updateCollisionHelperVisibility();

  // Save camera sensitivity preferences
  cameraSensitivity = parseFloat(document.getElementById("cameraSensitivitySlider").value);
  showCameraSensitivityInMain = document.getElementById("showCameraSensitivityCheckbox").checked;
  showVertexDimmerInMain = document.getElementById("showVertexDimmerCheckbox").checked;
  use2DCameraMode = document.getElementById("use2DCameraModeCheckbox").checked;

  // Show/hide vertex dimmer on main screen
  const mainVertexDimmerSection = document.getElementById('mainVertexDimmerSection');
  if (mainVertexDimmerSection) {
    mainVertexDimmerSection.style.display = showVertexDimmerInMain ? 'block' : 'none';
  }

  // Save flare preferences
  flareColor = parseInt(document.getElementById("flareColorPicker").value.slice(1), 16);
  flareRadius = parseFloat(document.getElementById("flareRadiusSlider").value);
  // Read from either checkbox (they should be synced, but try clone first since it's in the main section)
  const flareClone = document.getElementById("showFlareButtonCheckboxClone");
  const flareOriginal = document.getElementById("showFlareButtonCheckbox");
  showFlareButton = flareClone ? flareClone.checked : (flareOriginal ? flareOriginal.checked : false);

  // Show/hide flare button on main screen
  const flareBtn = document.getElementById('flareBtn');
  if (flareBtn) {
    flareBtn.style.display = showFlareButton ? 'block' : 'none';
  }
  showAllVertices = document.getElementById("showAllVerticesCheckbox").checked;
  unifiedEdgeSize = document.getElementById("unifiedEdgeSizeCheckbox").checked;

  // Save LOD preferences
  const newLodEnabled = document.getElementById("lodEnabledCheckbox").checked;
  const lodChanged = newLodEnabled !== lodEnabled;
  lodEnabled = newLodEnabled;

  // Update current grid's LOD state
  if (currentGrid && currentGrid.lodState) {
    currentGrid.lodState.lodEnabled = lodEnabled;
  }

  // If LOD was just disabled, rebuild all geometry at full detail
  if (lodChanged && !lodEnabled && currentGrid) {
    console.log('LOD disabled - rebuilding all geometry at full detail');
    rebuildAllGeometryAtFullDetail(currentGrid);
  }

  // Show/hide LOD distance controls
  const lodControls = document.getElementById('lodDistanceControls');
  if (lodControls) {
    lodControls.style.display = lodEnabled ? 'block' : 'none';
  }

  let showLODIndicators = document.getElementById("lodIndicatorsCheckbox").checked;
  document.documentElement.style.setProperty('--show-lod-indicators', showLODIndicators ? '1' : '0');

  // Save automatic rendering settings preference
  useAutomaticRenderingSettings = document.getElementById("useAutomaticRenderingCheckbox").checked;

  // Save vertex limit preference
  vertexLimitEnabled = !document.getElementById("removeVertexLimitCheckbox").checked;

  // Save culling preferences
  frustumCullingEnabled = document.getElementById("frustumCullingCheckbox").checked;
  sphericalCullingEnabled = document.getElementById("sphericalCullingCheckbox").checked;
  surfaceCullingEnabled = document.getElementById("surfaceCullingCheckbox").checked;

  // If frustum culling was just disabled, make all chunks visible
  if (!frustumCullingEnabled && currentGrid && currentGrid.chunks) {
    for (const chunk of currentGrid.chunks.values()) {
      chunk.isVisible = true;
      const isLineMode = (chunk.lodState.level === 1);
      if (chunk.instancedEdgesThin) chunk.instancedEdgesThin.visible = !isLineMode;
      if (chunk.instancedEdgesThick) chunk.instancedEdgesThick.visible = !isLineMode;
      if (chunk.instancedEdgesCollision) chunk.instancedEdgesCollision.visible = true;
      if (chunk.instancedBlockCubes) chunk.instancedBlockCubes.visible = true;
      if (chunk.lineEdges) chunk.lineEdges.visible = isLineMode;
    }
  }

  // Save arrow mode preference
  const newArrowMode = document.getElementById("arrowModeSelect").value;
  if (newArrowMode !== arrowRenderMode) {
    setArrowRenderMode(newArrowMode);
  }

  // Save auto-switch theme preference
  autoSwitchThemeEnabled = document.getElementById("autoSwitchThemeCheckbox").checked;
  localStorage.setItem('autoSwitchThemeEnabled', autoSwitchThemeEnabled);

  // Save auto-sync view preference
  autoSyncView = document.getElementById("autoSyncViewCheckbox").checked;

// Update controls rotate speed and zoom speed
  if (typeof controls !== 'undefined') {
    controls.rotateSpeed = cameraSensitivity;
    controls.zoomSpeed = 0.5 * cameraSensitivity;
  }
  
  // Apply 2D camera mode immediately if current grid is 2D
  if (currentGrid) {
    const is2D = currentGrid.width === 1 || currentGrid.height === 1 || currentGrid.depth === 1;
    if (is2D && typeof controls !== 'undefined') {
      if (use2DCameraMode) {
        // Enable 2D mode: pan/zoom only, no rotation
        controls.enableRotate = false;
        controls.enablePan = true;
        controls.enableZoom = true;
        controls.screenSpacePanning = true;
      } else {
        // Treat as 3D: enable all controls
        controls.enableRotate = true;
        controls.enablePan = true;
        controls.enableZoom = true;
        controls.screenSpacePanning = false;
      }
      controls.update();
    }
  }
  

  // Show/hide camera sensitivity panel in main UI
  const cameraSensitivityPanel = document.getElementById("cameraSensitivityPanel");
  if (cameraSensitivityPanel) {
    cameraSensitivityPanel.style.display = showCameraSensitivityInMain ? "block" : "none";
  }

  // Show/hide camera coordinates panel in main UI
  const cameraCoordinatesPanel = document.getElementById("cameraCoordinatesPanel");
  if (cameraCoordinatesPanel) {
    cameraCoordinatesPanel.style.display = showCameraCoordinates ? "block" : "none";
  }

  // Show/hide manual camera control panel
  const showManualCameraControl = document.getElementById("showManualCameraControlCheckbox").checked;
  const manualCameraControl = document.getElementById("manualCameraControl");
  if (manualCameraControl) {
    manualCameraControl.style.display = showManualCameraControl ? "block" : "none";
  }

  // Sync main slider with preference slider
  const mainSlider = document.getElementById("mainCameraSensitivitySlider");
  const mainValue = document.getElementById("mainCameraSensitivityValue");
  if (mainSlider && mainValue) {
    mainSlider.value = cameraSensitivity;
    mainValue.textContent = cameraSensitivity.toFixed(1);
  }

  // Close modal
  document.getElementById("preferencesModal").style.display = "none";

  // Log all saved preferences
  console.log('=== Preferences Saved ===');
  console.log(`Vertex Radius: ${vertexRadius.toFixed(2)}`);
  console.log(`Vertex Dimmer: ${(vertexDimmer * 100).toFixed(0)}% (${vertexDimmer.toFixed(2)})`);
  console.log(`Thin Edge Radius: ${thinEdgeRadius.toFixed(3)}`);
  console.log(`Thick Edge Radius: ${thickEdgeRadius.toFixed(3)}`);
  console.log(`Edge Click Radius: ${edgeCollisionRadius.toFixed(2)}`);
  console.log(`Component coloring: ${componentColoringEnabled ? 'ON' : 'OFF'}`);
  console.log(`Box highlighting: ${boxHighlightingEnabled ? 'ON' : 'OFF'}`);
  console.log('========================');

  // Apply show all vertices preference to all grids
  updateAllVerticesVisibility();
});

// Close preferences with X button (without saving)
document.getElementById("closePreferencesBtn").addEventListener("click", () => {
  document.getElementById("preferencesModal").style.display = "none";
  console.log("Preferences closed without saving");
});

// Sync the two flare button checkboxes (clone in "Show on Main Screen" and original in "Other Display Settings")
const showFlareButtonCheckbox = document.getElementById("showFlareButtonCheckbox");
const showFlareButtonCheckboxClone = document.getElementById("showFlareButtonCheckboxClone");

if (showFlareButtonCheckbox && showFlareButtonCheckboxClone) {
  // When clone is clicked, update original
  showFlareButtonCheckboxClone.addEventListener("change", () => {
    showFlareButtonCheckbox.checked = showFlareButtonCheckboxClone.checked;
  });

  // When original is clicked, update clone
  showFlareButtonCheckbox.addEventListener("change", () => {
    showFlareButtonCheckboxClone.checked = showFlareButtonCheckbox.checked;
  });
}

// Manual Camera Position Control
// SET/GO Camera Button - Toggle between display mode and input mode
document.getElementById("setCameraBtn").addEventListener("click", () => {
  const button = document.getElementById("setCameraBtn");
  const inputX = document.getElementById("manualCamX");
  const inputY = document.getElementById("manualCamY");
  const inputZ = document.getElementById("manualCamZ");

  if (button.textContent === "SET") {
    // Switch to input mode - enable inputs for user to type
    inputX.disabled = false;
    inputY.disabled = false;
    inputZ.disabled = false;
    button.textContent = "GO";
    button.style.background = "#e74c3c"; // Red for GO
    console.log("Camera position input mode enabled");
  } else {
    // GO mode - move camera to specified position and switch back to display mode
    const x = parseFloat(inputX.value);
    const y = parseFloat(inputY.value);
    const z = parseFloat(inputZ.value);

    if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
      camera.position.set(x, y, z);
      controls.update();
      console.log(`Camera moved to: (${x.toFixed(1)}, ${y.toFixed(1)}, ${z.toFixed(1)})`);
    } else {
      console.warn("Invalid camera coordinates");
    }

    // Switch back to display mode
    inputX.disabled = true;
    inputY.disabled = true;
    inputZ.disabled = true;
    button.textContent = "SET";
    button.style.background = "#9b59b6"; // Purple for SET
  }
});

// Allow Enter key to trigger SET/GO button
['manualCamX', 'manualCamY', 'manualCamZ'].forEach(id => {
  document.getElementById(id).addEventListener("keypress", (e) => {
    if (e.key === 'Enter') {
      document.getElementById("setCameraBtn").click();
    }
  });
});



  // Initialize Quill editor
  function initQuillEditor() {
    if (!isQuillInitialized) {
      quillEditor = new Quill('#notesEditor', {
        theme: 'snow',
        placeholder: 'Add notes for this grid...',
        modules: {
          toolbar: [
            ['bold', 'italic', 'underline'],
            [{ 'size': ['small', false, 'large', 'huge'] }],
            [{ 'header': [1, 2, 3, false] }],
            [{ 'color': [] }, { 'background': [] }],
            [{ 'list': 'ordered'}, { 'list': 'bullet' }],
            ['clean']
          ]
        }
      });
      
      // Auto-save on text change
      quillEditor.on('text-change', function() {
        saveCurrentGridNotes();
      });
      
      isQuillInitialized = true;
    }
  }

// Initialize notes system
document.addEventListener('DOMContentLoaded', function() {
  const notesWindow = document.getElementById('notesWindow');
  const notesMinimized = document.getElementById('notesMinimized');
  const notesHeader = document.getElementById('notesHeader');
  const notesMinimize = document.getElementById('notesMinimize');

  // Only set up handlers if all elements exist
  if (notesWindow && notesMinimized && notesHeader && notesMinimize) {
    // Show/hide notes window
    notesMinimized.onclick = () => {
      notesWindow.style.display = 'block';
      notesMinimized.style.display = 'none';
      initQuillEditor();
      updateNotesForCurrentGrid();
      // Focus the editor so cursor is ready
      setTimeout(() => quillEditor.focus(), 50);
    };

    notesMinimize.onclick = () => {
      saveCurrentGridNotes();
      notesWindow.style.display = 'none';
      notesMinimized.style.display = 'flex';
    };

    // Make notes window draggable
    notesHeader.onmousedown = (e) => {
      isDraggingNotes = true;
      notesOffset.x = e.clientX - notesWindow.offsetLeft;
      notesOffset.y = e.clientY - notesWindow.offsetTop;
    };

    document.onmousemove = (e) => {
    if (isDraggingNotes) {
      const newLeft = e.clientX - notesOffset.x;
      const newTop = e.clientY - notesOffset.y;
      
      // Get window dimensions
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      const notesWidth = notesWindow.offsetWidth;
      const notesHeight = notesWindow.offsetHeight;
      
      // Define boundaries (keep at least 100px of the window visible)
      const minTop = 60; // Below topbar
      const maxTop = windowHeight - 100; // Keep bottom visible
      const minLeft = -notesWidth + 100; // Keep right edge visible
      const maxLeft = windowWidth - 100; // Keep left edge visible
      
      // Constrain position within bounds
      const constrainedTop = Math.max(minTop, Math.min(maxTop, newTop));
      const constrainedLeft = Math.max(minLeft, Math.min(maxLeft, newLeft));
      
      notesWindow.style.left = constrainedLeft + 'px';
      notesWindow.style.top = constrainedTop + 'px';
    }
  };
    document.onmouseup = () => {
      isDraggingNotes = false;
    };
  }
});


function updateNotesForCurrentGrid() {
  const notesGridName = document.getElementById('notesGridName');
  
  if (currentGrid && quillEditor) {
    // Find current grid ID
    let currentGridId = 'Unknown Grid';
    for (const [id, grid] of allGrids.entries()) {
      if (grid === currentGrid) {
        currentGridId = id;
        break;
      }
    }
    
    notesGridName.textContent = currentGridId;
    
    // Set the rich text content (HTML)
    const savedContent = currentGrid.notes || '';
    quillEditor.root.innerHTML = savedContent;
  } else {
    notesGridName.textContent = 'No Grid';
    if (quillEditor) {
      quillEditor.root.innerHTML = '';
    }
  }
}

function saveCurrentGridNotes() {
  if (currentGrid && quillEditor) {
    // Save as HTML to preserve formatting
    currentGrid.notes = quillEditor.root.innerHTML;
  }
}



// Add these event listeners with your other UI event listeners  TRANSPARENT PLANE
//document.getElementById("planeControlsHeader").addEventListener("click", () => {
//  const content = document.getElementById("planeControlsContent");
//  const header = document.getElementById("planeControlsHeader");
  
//  if (content.style.display === "none") {
    // Expand
//    content.style.display = "flex";
//    header.style.borderRadius = "12px 12px 0 0";
//  } else {
    // Collapse
//    content.style.display = "none";
//    header.style.borderRadius = "12px";
//  }
//});

document.getElementById("addPlaneBtn").addEventListener("click", () => {
  const a = parseFloat(document.getElementById("planeA").value) || 0;
  const b = parseFloat(document.getElementById("planeB").value) || 0;
  const c = parseFloat(document.getElementById("planeC").value) || 0;
  const d = parseFloat(document.getElementById("planeD").value) || 0;
  const opacity = parseFloat(document.getElementById("planeOpacity").value) || 0.15;
  const planeColor = document.getElementById("planeColorPicker").value;

  if (a === 0 && b === 0 && c === 0) {
    alert("Invalid plane equation: at least one coefficient must be non-zero");
    return;
  }

  addTransparentPlane(a, b, c, d, planeColor, opacity);
});

document.getElementById("removePlaneBtn").addEventListener("click", () => {
  if (!currentGrid || !currentGrid.customPlanes || currentGrid.customPlanes.length === 0) {
    alert("No planes to remove");
    return;
  }
  
  // Remove all planes
  while (currentGrid.customPlanes.length > 0) {
    const planeData = currentGrid.customPlanes[0];
    removeTransparentPlane(planeData.id);
  }
});

document.getElementById("planeOpacity").addEventListener("input", (e) => {
  const opacity = parseFloat(e.target.value);
  document.getElementById("planeOpacityValue").textContent = Math.round(opacity * 100) + "%";
  
  // Update existing plane if it exists
  if (currentGrid && currentGrid.customPlane) {
    currentGrid.customPlane.material.opacity = opacity;
  }
});


document.getElementById("syncViewBtn").addEventListener("click", () => {
  if (!currentGrid) {
    alert("No active grid to sync from");
    return;
  }

  // Get current camera state
  const currentPosition = camera.position.clone();
  const currentTarget = controls.target.clone();

  // Apply to all other grids
  let syncedCount = 0;
  for (const [gridId, grid] of allGrids.entries()) {
    if (grid !== currentGrid) {
      grid.cameraPosition = currentPosition.clone();
      grid.cameraTarget = currentTarget.clone();
      syncedCount++;
    }
  }

  console.log(`Synced camera view to ${syncedCount} grids`);

  // Flash the button (blue for light theme, green for dark theme)
  const btn = document.getElementById("syncViewBtn");
  const isDarkTheme = document.documentElement.classList.contains('dark-theme');
  const flashColor = isDarkTheme ? '#4CAF50' : '#3498db';

  btn.classList.add('flashing');
  btn.style.background = flashColor;
  btn.style.color = 'white';
  btn.style.transition = 'background 0.15s ease, color 0.15s ease';

  setTimeout(() => {
    btn.classList.remove('flashing');
    btn.style.background = '';
    btn.style.color = '';
    btn.style.transition = '';
  }, 600);
});

// Flare button - highlights path endpoints with pulsing glow
document.getElementById("flareBtn").addEventListener("click", () => {
  if (!currentGrid) {
    alert("No active grid to highlight");
    return;
  }

  // Check if markers exist
  if (!currentGrid.startMarker || !currentGrid.endMarker) {
    alert("No path endpoints to highlight");
    return;
  }

  triggerFlare();
});

// Create radial gradient texture for flare sprite
function createFlareTexture(isDarkTheme) {
  const canvas = document.createElement('canvas');
  canvas.width = 128;
  canvas.height = 128;
  const ctx = canvas.getContext('2d');

  // Convert hex color to RGB
  const r = (flareColor >> 16) & 0xFF;
  const g = (flareColor >> 8) & 0xFF;
  const b = flareColor & 0xFF;

  // Create radial gradient
  const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);

  if (isDarkTheme) {
    // Dark mode: bright glow (current behavior)
    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 1.0)`);
    gradient.addColorStop(0.25, `rgba(${r}, ${g}, ${b}, 0.9)`);
    gradient.addColorStop(0.6, `rgba(${r}, ${g}, ${b}, 0.35)`);
    gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
  } else {
    // Light mode: dark gradient for multiply blending (darkens the screen)
    // Use black center fading to white edges
    // When multiplied: black (0,0,0) darkens, white (255,255,255) keeps original color
    gradient.addColorStop(0, `rgb(0, 0, 0)`);      // Pure black center - maximum darkening
    gradient.addColorStop(0.25, `rgb(50, 50, 50)`); // Dark gray
    gradient.addColorStop(0.6, `rgb(150, 150, 150)`); // Light gray
    gradient.addColorStop(1, `rgb(255, 255, 255)`);   // White edges - no effect
  }

  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, 128, 128);

  const texture = new THREE.Texture(canvas);
  texture.needsUpdate = true;
  return texture;
}

// Trigger flare animation on endpoints
function triggerFlare() {
  // Clean up any existing flare sprites
  cleanupFlareSprites();

  // Detect current theme
  const isDarkTheme = document.documentElement.classList.contains('dark-theme');

  // Create flare texture (reuse for both sprites)
  const flareTexture = createFlareTexture(isDarkTheme);

  // Create sprite material with theme-appropriate blending
  const material = new THREE.SpriteMaterial({
    map: flareTexture,
    transparent: true,
    opacity: 1.0,
    blending: isDarkTheme ? THREE.AdditiveBlending : THREE.MultiplyBlending,
    depthWrite: false,
    depthTest: false  // Always render on top, even when inside grid
  });

  // Create sprites for start and end markers
  const startSprite = new THREE.Sprite(material.clone());
  const endSprite = new THREE.Sprite(material.clone());

  // Position sprites at marker locations
  const startPos = currentGrid.startMarker.position.clone();
  const endPos = currentGrid.endMarker.position.clone();

  startSprite.position.copy(startPos);
  endSprite.position.copy(endPos);

  // Initial scale (will be animated) - use custom radius
  startSprite.scale.set(flareRadius, flareRadius, 1);
  endSprite.scale.set(flareRadius, flareRadius, 1);

  // Add to scene
  scene.add(startSprite);
  scene.add(endSprite);

  // Store sprites with their initial positions
  flareSprites.push(
    { sprite: startSprite, initialPosition: startPos },
    { sprite: endSprite, initialPosition: endPos }
  );

  // Start animation
  flareActive = true;
  flareStartTime = performance.now();

  console.log(`Flare activated on endpoints (${isDarkTheme ? 'dark' : 'light'} mode)`);
}

// Clean up flare sprites from scene
function cleanupFlareSprites() {
  for (const {sprite} of flareSprites) {
    scene.remove(sprite);
    sprite.material.dispose();
    sprite.material.map.dispose();
  }
  flareSprites = [];
  flareActive = false;
}

// Update flare animation (called from render loop)
function updateFlare() {
  if (!flareActive) return;

  const now = performance.now();
  const dt = (now - flareStartTime) / 1000; // seconds

  const totalDuration = 5.0;

  // End animation after 5 seconds
  if (dt >= totalDuration) {
    cleanupFlareSprites();
    return;
  }

  // Animation math (same as demo, but with 2 pulses instead of 3)
  const pulses = 2;
  const phase = (2 * Math.PI * pulses * dt) / totalDuration;
  const rawWave = Math.sin(phase);

  // Only use the "up" part of the sine wave (0 to 1)
  const wave = Math.max(0, rawWave);

  // Envelope decays from 1 -> 0 over 5 seconds
  const envelope = 1 - dt / totalDuration;

  // Combined strength (0..1, decaying)
  const strength = wave * envelope;

  // Update all sprites
  for (const {sprite} of flareSprites) {
    // Opacity decays with strength
    sprite.material.opacity = strength;

    // Scale: use flareRadius as base, pulse up to ~2x on first pulse, then smaller
    const baseScale = flareRadius;
    const maxExtraScale = flareRadius * 1.2; // Pulse up to 2.2x the base radius
    const scale = baseScale + maxExtraScale * strength;
    sprite.scale.set(scale, scale, 1);
  }
}

document.getElementById("coordinateHoverCheckbox").addEventListener("change", (e) => {
  coordinateHoverMode = e.target.checked;

  // If coordinate hover is being enabled, auto-load collision helpers
  if (coordinateHoverMode && currentGrid && currentGrid.isInstanced) {
    // Load vertex collision helpers if needed (for vertex hover)
    if (hoverVertices && lazyLoadVertexSpheres) {
      let needsVertexLoading = false;
      if (currentGrid.chunks && currentGrid.chunks.size > 0) {
        const firstChunk = currentGrid.chunks.values().next().value;
        if (!firstChunk.instancedVertexCollisionHelpers) {
          needsVertexLoading = true;
        }
      } else if (!currentGrid.instancedVertexCollisionHelpers) {
        needsVertexLoading = true;
      }

      if (needsVertexLoading) {
        console.log('[coordinateHover] Auto-loading vertex collision helpers');
        loadVertexSpheres(currentGrid);
      }
    }

    // Load edge collision helpers if needed (for edge hover)
    if (hoverEdges && lazyLoadEdgeCollision) {
      let needsEdgeLoading = false;
      if (currentGrid.chunks && currentGrid.chunks.size > 0) {
        const firstChunk = currentGrid.chunks.values().next().value;
        if (!firstChunk.instancedEdgesCollision) {
          needsEdgeLoading = true;
        }
      } else if (!currentGrid.instancedEdgesCollision) {
        needsEdgeLoading = true;
      }

      if (needsEdgeLoading) {
        console.log('[coordinateHover] Auto-loading edge collision helpers');
        loadEdgeCollision(currentGrid);
      }
    }
  }

  // Update collision helper visibility based on new setting
  updateCollisionHelperVisibility();

  // Clear any existing tooltip when toggling
  const existingTooltip = document.getElementById('coordinateTooltip');
  if (existingTooltip) existingTooltip.remove();
});

// Hover Vertices Checkbox - load/unload vertex spheres for coordinate hover
document.getElementById("hoverVerticesCheckbox").addEventListener("change", (e) => {
  hoverVertices = e.target.checked;

  if (!currentGrid || !currentGrid.isInstanced) return;

  if (hoverVertices) {
    // Load vertex spheres if not already loaded
    if (lazyLoadVertexSpheres) {
      let needsLoading = false;
      if (currentGrid.chunks && currentGrid.chunks.size > 0) {
        const firstChunk = currentGrid.chunks.values().next().value;
        if (!firstChunk.instancedVertexSpheres && !firstChunk.instancedVertexCollisionHelpers) {
          needsLoading = true;
        }
      }

      if (needsLoading) {
        console.log('[hoverVerticesCheckbox] Loading vertex spheres for coordinate hover');
        loadVertexSpheres(currentGrid);
      }
    }
  } else {
    // Unload vertex spheres ONLY if no manual vertices or vertex operations exist
    if (lazyLoadVertexSpheres) {
      const shouldUnload =
        !showAllVertices &&
        !hasColoredVertices(currentGrid) &&
        !hasVertexOperationsInHistory(currentGrid);

      if (shouldUnload) {
        console.log('[hoverVerticesCheckbox] Unloading vertex spheres');
        unloadVertexSpheres(currentGrid);
      } else {
        console.log('[hoverVerticesCheckbox] Keeping vertex spheres loaded (needed by other systems)');
      }
    }
  }
});

// Hover Edges Checkbox - load/unload edge collision for coordinate hover
document.getElementById("hoverEdgesCheckbox").addEventListener("change", (e) => {
  hoverEdges = e.target.checked;

  if (!currentGrid || !currentGrid.isInstanced) return;

  if (hoverEdges) {
    // Load edge collision if not already loaded
    if (lazyLoadEdgeCollision) {
      let needsLoading = false;
      if (currentGrid.chunks && currentGrid.chunks.size > 0) {
        const firstChunk = currentGrid.chunks.values().next().value;
        if (!firstChunk.instancedEdgesCollision) {
          needsLoading = true;
        }
      }

      if (needsLoading) {
        console.log('[hoverEdgesCheckbox] Loading edge collision for coordinate hover');
        loadEdgeCollision(currentGrid);
      }
    }
  } else {
    // Unload edge collision ONLY if no manual edges or edge operations exist
    if (lazyLoadEdgeCollision) {
      const shouldUnload =
        !hasManuallyColoredEdges(currentGrid) &&
        !hasEdgeOperationsInHistory(currentGrid);

      if (shouldUnload) {
        console.log('[hoverEdgesCheckbox] Unloading edge collision');
        unloadEdgeCollision(currentGrid);
      } else {
        console.log('[hoverEdgesCheckbox] Keeping edge collision loaded (needed by manually added edges)');
      }
    }
  }
});

// Show/hide coordinate hover panel on main screen
document.getElementById("showCoordHoverPanelCheckbox").addEventListener("change", (e) => {
  const coordPanel = document.querySelector('.coord-hover-section');
  if (coordPanel) {
    coordPanel.style.display = e.target.checked ? 'block' : 'none';
  }
});

// Show/hide plane highlighter panel on right sidebar
document.getElementById("showPlaneHighlighterPanelCheckbox").addEventListener("change", (e) => {
  const planePanel = document.querySelector('.plane-panel');
  if (planePanel) {
    planePanel.style.display = e.target.checked ? 'block' : 'none';
  }
});

// Show/hide subgraph panel on right sidebar
document.getElementById("showSubgraphPanelCheckbox").addEventListener("change", (e) => {
  const subgraphPanel = document.getElementById('subgraphPanel');
  if (subgraphPanel) {
    subgraphPanel.style.display = e.target.checked ? 'block' : 'none';

    // Update dropdowns when panel becomes visible
    if (e.target.checked) {
      updateSubgraphComponentDropdowns();
    }
  }
});

// Function to update component dropdowns
// Track last selected component for each dropdown
let lastOrientSelection = 'all';
let lastReverseSelection = 'all';

function updateSubgraphComponentDropdowns() {
  if (!currentGrid || !currentGrid.activeSubgraph) {
    return;
  }

  const components = currentGrid.activeSubgraph._findConnectedComponents();
  const numComponents = components.length;

  // Update both dropdowns
  const orientSelect = document.getElementById('orientTargetSelect');
  const reverseSelect = document.getElementById('reverseTargetSelect');

  if (orientSelect && reverseSelect) {
    // Save current selections
    const currentOrientValue = orientSelect.value;
    const currentReverseValue = reverseSelect.value;

    // Clear existing options
    orientSelect.innerHTML = '<option value="all">All Subgraph</option>';
    reverseSelect.innerHTML = '<option value="all">All Subgraph</option>';

    // Add component options (1-indexed for user friendliness)
    for (let i = 0; i < numComponents; i++) {
      const option1 = document.createElement('option');
      option1.value = i.toString();
      option1.textContent = `Component ${i + 1}`;
      orientSelect.appendChild(option1);

      const option2 = document.createElement('option');
      option2.value = i.toString();
      option2.textContent = `Component ${i + 1}`;
      reverseSelect.appendChild(option2);
    }

    // Restore previous selections if they're still valid
    const orientValueToRestore = lastOrientSelection;
    const reverseValueToRestore = lastReverseSelection;

    // Check if the saved value exists as an option
    const orientOptions = Array.from(orientSelect.options).map(opt => opt.value);
    const reverseOptions = Array.from(reverseSelect.options).map(opt => opt.value);

    if (orientOptions.includes(orientValueToRestore)) {
      orientSelect.value = orientValueToRestore;
    }
    if (reverseOptions.includes(reverseValueToRestore)) {
      reverseSelect.value = reverseValueToRestore;
    }
  }
}

// Subgraph Data button - show analysis popup
document.getElementById("subgraphDataBtn").addEventListener("click", () => {
  if (!currentGrid) {
    alert("No active grid exists");
    return;
  }

  if (!currentGrid.activeSubgraph) {
    console.error("No activeSubgraph found. currentGrid:", currentGrid);
    alert("No active subgraph exists. This should not happen - please report this bug.");
    return;
  }

  // Check if subgraph is empty
  if (currentGrid.activeSubgraph.edges.size === 0) {
    // Show modal with "Subgraph is empty" message
    const modal = document.getElementById('subgraphAnalysisModal');
    const outputDiv = document.getElementById('subgraphAnalysisOutput');

    if (modal && outputDiv) {
      outputDiv.innerHTML = `
        <div style="text-align: center; padding: 40px; color: #888;">
          <p style="font-size: 16px; margin: 0;">Subgraph is empty</p>
          <p style="font-size: 13px; margin-top: 10px;">Add edges to the subgraph to see component data</p>
        </div>
      `;
      modal.style.display = 'flex';
      modal.style.pointerEvents = 'all';

      // Center the modal
      const content = document.getElementById('subgraphAnalysisContent');
      if (content) {
        content.style.left = '50%';
        content.style.top = '50%';
        content.style.transform = 'translate(-50%, -50%)';
      }
    }
    return;
  }

  // Update dropdowns to reflect current component structure
  updateSubgraphComponentDropdowns();

  // Get detailed analysis
  const analysis = currentGrid.activeSubgraph.analyzeComponentsWithArrows();

  // Build HTML table
  const isDarkTheme = document.documentElement.classList.contains('dark-theme');
  const headerBg = isDarkTheme ? 'rgba(60, 64, 72, 0.5)' : '#f5f5f5';
  const borderColor = isDarkTheme ? '#4b5563' : '#e0e0e0';

  let tableHTML = `
    <table style="width: 100%; border-collapse: collapse; font-family: 'Courier New', monospace; font-size: 13px;">
      <thead>
        <tr style="background: ${headerBg}; border-bottom: 2px solid ${borderColor};">
          <th style="padding: 10px; text-align: left; font-weight: 600;">Component</th>
          <th style="padding: 10px; text-align: left; font-weight: 600;">Type</th>
          <th style="padding: 10px; text-align: center; font-weight: 600;">Vertices</th>
          <th style="padding: 10px; text-align: center; font-weight: 600;">Edges</th>
        </tr>
      </thead>
      <tbody>
  `;

  analysis.allComponents.forEach((comp, idx) => {
    // Display "lattice animal" instead of "complex"
    const displayType = comp.type === 'complex' ? 'lattice animal' : comp.type;
    tableHTML += `
      <tr style="border-bottom: 1px solid ${borderColor};">
        <td style="padding: 10px;">Component ${idx + 1}</td>
        <td style="padding: 10px;">${displayType}</td>
        <td style="padding: 10px; text-align: center;">${comp.vertexCount}</td>
        <td style="padding: 10px; text-align: center;">${comp.edgeCount}</td>
      </tr>
    `;

    // NOTE: Sequence calculation is still performed by analyzeComponentsWithArrows() and available
    // in comp.sequence for paths/cycles, but we suppress visual display in the table for clarity.
    // The sequence data can be accessed programmatically when needed for operations like orient().
  });

  tableHTML += `
      </tbody>
    </table>
  `;

  // Show modal with analysis
  const modal = document.getElementById('subgraphAnalysisModal');
  const outputDiv = document.getElementById('subgraphAnalysisOutput');

  if (modal && outputDiv) {
    outputDiv.innerHTML = tableHTML;
    modal.style.display = 'flex';
    modal.style.pointerEvents = 'all';

    // Center the modal
    const content = document.getElementById('subgraphAnalysisContent');
    if (content) {
      content.style.left = '50%';
      content.style.top = '50%';
      content.style.transform = 'translate(-50%, -50%)';
    }
  }
});

// Close subgraph analysis modal
function closeSubgraphAnalysisModal() {
  const modal = document.getElementById('subgraphAnalysisModal');
  if (modal) {
    modal.style.display = 'none';
    modal.style.pointerEvents = 'none';
  }
}

document.getElementById("closeSubgraphAnalysisBtn").addEventListener("click", closeSubgraphAnalysisModal);
document.getElementById("closeSubgraphAnalysisBtn2").addEventListener("click", closeSubgraphAnalysisModal);

// Close modal on Escape key
document.addEventListener("keydown", (e) => {
  if (e.key === "Escape") {
    const modal = document.getElementById('subgraphAnalysisModal');
    if (modal && modal.style.display === 'flex') {
      closeSubgraphAnalysisModal();
    }
  }
});

// Make subgraph analysis modal draggable
(function() {
  const modal = document.getElementById('subgraphAnalysisContent');
  const handle = document.getElementById('subgraphAnalysisDragHandle');

  if (!modal || !handle) return;

  let isDragging = false;
  let currentX;
  let currentY;
  let initialX;
  let initialY;

  handle.addEventListener('mousedown', (e) => {
    // Don't start dragging if clicking on the close button
    if (e.target.id === 'closeSubgraphAnalysisBtn' || e.target.closest('#closeSubgraphAnalysisBtn')) {
      return;
    }

    isDragging = true;

    // Get current position from bounding rect (handles transform correctly)
    const rect = modal.getBoundingClientRect();
    const currentLeft = rect.left;
    const currentTop = rect.top;

    // Calculate offset from mouse to modal's top-left corner
    initialX = e.clientX - currentLeft;
    initialY = e.clientY - currentTop;

    // Remove transform to allow direct positioning
    modal.style.transform = 'none';

    // Set explicit position to maintain current location
    modal.style.left = currentLeft + 'px';
    modal.style.top = currentTop + 'px';
  });

  document.addEventListener('mousemove', (e) => {
    if (isDragging) {
      e.preventDefault();
      currentX = e.clientX - initialX;
      currentY = e.clientY - initialY;

      // Apply drag bounds: reach topbar but not overlap (64px), 1 inch from bottom, 2 inches visible on sides
      const modalRect = modal.getBoundingClientRect();
      const modalWidth = modalRect.width;
      const modalHeight = modalRect.height;
      const minVisibleWidth = 192; // 2 inches must be visible
      const topbarHeight = 64; // Height of the topbar (from sidebar CSS)
      const bottomMargin = 96; // 1 inch from bottom of window

      // Constrain vertical position (header must not overlap topbar, can go above bottom margin)
      const minY = topbarHeight;
      const maxY = window.innerHeight - bottomMargin - 60; // 60px for header height
      currentY = Math.max(minY, Math.min(currentY, maxY));

      // Constrain horizontal position (at least 2 inches visible)
      const minX = -(modalWidth - minVisibleWidth);
      const maxX = window.innerWidth - minVisibleWidth;
      currentX = Math.max(minX, Math.min(currentX, maxX));

      modal.style.left = currentX + 'px';
      modal.style.top = currentY + 'px';
    }
  });

  document.addEventListener('mouseup', () => {
    isDragging = false;
  });
})();

// Orient button handler
document.getElementById("orientBtn").addEventListener("click", () => {
  if (!currentGrid) {
    alert("No active grid exists");
    return;
  }

  if (!currentGrid.activeSubgraph) {
    alert("No active subgraph exists");
    return;
  }

  if (currentGrid.activeSubgraph.edges.size === 0) {
    alert("Subgraph has no edges");
    return;
  }

  const targetSelect = document.getElementById('orientTargetSelect');
  const targetValue = targetSelect ? targetSelect.value : 'all';

  // Remember this selection
  lastOrientSelection = targetValue;

  if (targetValue === 'all') {
    // Orient all subgraph
    currentGrid.activeSubgraph.orient();
  } else {
    // Orient specific component
    const componentIndex = parseInt(targetValue);
    currentGrid.activeSubgraph.orient(componentIndex);
  }

  // Update dropdowns in case component structure changed
  updateSubgraphComponentDropdowns();

  console.log(`✓ Oriented ${targetValue === 'all' ? 'all subgraph' : `component ${parseInt(targetValue) + 1}`}`);
});

// Reverse Arrows button handler
document.getElementById("reverseArrowsBtn").addEventListener("click", () => {
  if (!currentGrid) {
    alert("No active grid exists");
    return;
  }

  if (!currentGrid.activeSubgraph) {
    alert("No active subgraph exists");
    return;
  }

  if (currentGrid.activeSubgraph.edges.size === 0) {
    alert("Subgraph has no edges");
    return;
  }

  const targetSelect = document.getElementById('reverseTargetSelect');
  const targetValue = targetSelect ? targetSelect.value : 'all';

  // Remember this selection
  lastReverseSelection = targetValue;

  if (targetValue === 'all') {
    // Reverse all arrows
    currentGrid.activeSubgraph.reverseArrows();
  } else {
    // Reverse specific component
    const componentIndex = parseInt(targetValue);
    currentGrid.activeSubgraph.reverseArrows(componentIndex);
  }

  // Update dropdowns in case component structure changed
  updateSubgraphComponentDropdowns();

  console.log(`✓ Reversed arrows ${targetValue === 'all' ? 'in all subgraph' : `in component ${parseInt(targetValue) + 1}`}`);
});

// Memory breakdown toggle
document.getElementById("memoryHeader").addEventListener("click", () => {
  const breakdown = document.getElementById('memoryBreakdown');
  const toggle = document.getElementById('memoryToggle');
  if (breakdown.style.display === 'none') {
    breakdown.style.display = 'block';
    toggle.textContent = '▲';
  } else {
    breakdown.style.display = 'none';
    toggle.textContent = '▼';
  }
});





// Backbite Distance Vertex Coloring Event Listeners
document.getElementById("colorBBDistanceBtn").addEventListener("click", () => {
  const refX = parseInt(document.getElementById("bbRefX").value) || 0;
  const refY = parseInt(document.getElementById("bbRefY").value) || 0;
  const refZ = parseInt(document.getElementById("bbRefZ").value) || 0;
  const distance = parseInt(document.getElementById("bbDistance").value) || 0;
  
  if (validateBBDistanceInputs(refX, refY, refZ, distance)) {
    const coloredCount = colorVerticesAtBBDistance(refX, refY, refZ, distance);
    
    if (coloredCount === 0) {
      alert(`No vertices found at backbite distance ${distance} from (${refX},${refY},${refZ}). Check that the distance is reachable given the parity constraints.`);
    }
  }
});

document.getElementById("clearBBDistanceBtn").addEventListener("click", () => {
  clearAllVertexSpheres();
});

// Update reference vertex bounds when grid dimensions change
function updateBBDistanceMaxValues() {
  if (!currentGrid) return;
  
  const bbRefX = document.getElementById("bbRefX");
  const bbRefY = document.getElementById("bbRefY");
  const bbRefZ = document.getElementById("bbRefZ");
  
  if (bbRefX) bbRefX.max = currentGrid.width - 1;
  if (bbRefY) bbRefY.max = currentGrid.height - 1;
  if (bbRefZ) bbRefZ.max = currentGrid.depth - 1;
}





// Undo/Redo event listeners
document.getElementById("undoBtn").addEventListener("click", performUndo);
document.getElementById("redoBtn").addEventListener("click", performRedo);

// Keyboard shortcuts

document.addEventListener('keydown', (event) => {

  // Handle Ctrl+M (notes toggle) first - works even when typing
  if ((event.ctrlKey || event.metaKey) && event.key === 'm') {
    event.preventDefault();
    const notesWindow = document.getElementById('notesWindow');
    const notesMinimized = document.getElementById('notesMinimized');
    
    if (notesWindow.style.display === 'block') {
      // Hide notes window
      saveCurrentGridNotes();
      notesWindow.style.display = 'none';
      notesMinimized.style.display = 'flex';
	} else {
	  // Show notes window
	  notesWindow.style.display = 'block';
	  notesMinimized.style.display = 'none';
	  initQuillEditor();
	  updateNotesForCurrentGrid();
	  // Focus the editor so cursor is ready
	  setTimeout(() => quillEditor.focus(), 50);
	}
    console.log("Notes window toggled");
    return;
  }
  
  // Help / Keyboard Shortcuts (Shift + ?)
  if (event.shiftKey && event.key === '?') {
    event.preventDefault();
    document.getElementById('keyboardShortcutsModal').style.display = 'flex';
    console.log("Keyboard shortcuts modal opened via Shift+?");
    return;
  }
  
  // Preferences (Shift + P)
  if (event.shiftKey && (event.key === 'P' || event.key === 'p')) {
    event.preventDefault();
    document.getElementById('preferencesBtn').click();
    console.log("Preferences modal opened via Shift+P");
    return;
  }
  
  // Camera Sensitivity (Shift + < and Shift + >)
  if (event.shiftKey && (event.key === '<' || event.key === ',')) {
    event.preventDefault();
    // Decrease camera sensitivity
    cameraSensitivity = Math.max(0.1, cameraSensitivity - 0.1);
    if (typeof controls !== 'undefined') {
      controls.rotateSpeed = cameraSensitivity;
      controls.zoomSpeed = 0.5 * cameraSensitivity;
    }
    // Update both sliders
    const prefSlider = document.getElementById('cameraSensitivitySlider');
    const prefValue = document.getElementById('cameraSensitivityValue');
    const mainSlider = document.getElementById('mainCameraSensitivitySlider');
    const mainValue = document.getElementById('mainCameraSensitivityValue');
    if (prefSlider && prefValue) {
      prefSlider.value = cameraSensitivity;
      prefValue.textContent = cameraSensitivity.toFixed(1);
    }
    if (mainSlider && mainValue) {
      mainSlider.value = cameraSensitivity;
      mainValue.textContent = cameraSensitivity.toFixed(1);
    }
    console.log(`Camera sensitivity decreased to ${cameraSensitivity.toFixed(1)}`);
    return;
  }
  
  if (event.shiftKey && (event.key === '>' || event.key === '.')) {
    event.preventDefault();
    // Increase camera sensitivity
    cameraSensitivity = Math.min(2.0, cameraSensitivity + 0.1);
    if (typeof controls !== 'undefined') {
      controls.rotateSpeed = cameraSensitivity;
      controls.zoomSpeed = 0.5 * cameraSensitivity;
    }
    // Update both sliders
    const prefSlider = document.getElementById('cameraSensitivitySlider');
    const prefValue = document.getElementById('cameraSensitivityValue');
    const mainSlider = document.getElementById('mainCameraSensitivitySlider');
    const mainValue = document.getElementById('mainCameraSensitivityValue');
    if (prefSlider && prefValue) {
      prefSlider.value = cameraSensitivity;
      prefValue.textContent = cameraSensitivity.toFixed(1);
    }
    if (mainSlider && mainValue) {
      mainSlider.value = cameraSensitivity;
      mainValue.textContent = cameraSensitivity.toFixed(1);
    }
    console.log(`Camera sensitivity increased to ${cameraSensitivity.toFixed(1)}`);
    return;
  }
  
  
  // Check if user is currently typing in an input field, text area, or Quill editor
  const activeElement = document.activeElement;
  const isTyping = activeElement && (
    activeElement.tagName === 'INPUT' || 
    activeElement.tagName === 'TEXTAREA' ||
    activeElement.contentEditable === 'true' ||
    activeElement.closest('.ql-editor') // Add Quill editor check
  );
  
  // If user is typing, don't process any shortcuts
  if (isTyping) {
    return;
  }
  
  // Undo/Redo/Save/Load/Notes shortcuts
  if (event.ctrlKey || event.metaKey) {
	if (event.key === 'y') {
	  // Ctrl+Y: Redo
	  event.preventDefault();
	  performRedo();
	  return;
	} else if (event.key === 'z' && !event.shiftKey) {
      // Ctrl+Z: Undo
      event.preventDefault();
      performUndo();
      return;
    } else if (event.key === 's') {
      event.preventDefault();
      saveGrid();
      return;
    } else if (event.key === 'l') {
      event.preventDefault();
      loadGridFromDisk();
      return;
    } else if (event.key === 'm') {
      // Ctrl+M: Toggle notes window
      event.preventDefault();
      const notesWindow = document.getElementById('notesWindow');
      const notesMinimized = document.getElementById('notesMinimized');
      
      if (notesWindow.style.display === 'block') {
        // Hide notes window
        saveCurrentGridNotes();
        notesWindow.style.display = 'none';
        notesMinimized.style.display = 'flex';
      } else {
        // Show notes window
        notesWindow.style.display = 'block';
        notesMinimized.style.display = 'none';
        if (!isQuillInitialized) {
          initQuillEditor();
        }
        updateNotesForCurrentGrid();
      }
      console.log("Notes window toggled");
      return;
    }
  }
  
  // Existing 'T' key functionality for toggling active endpoint
  if (event.key === 't' || event.key === 'T') {
    console.log("T key detected");
    if (mode === "backbite") {
      console.log("Calling toggleActiveEndpoint");
      toggleActiveEndpoint();
    }
    return;
  }
  
// Mode toggle shortcuts (only when no modifier keys are pressed)
  if (!event.ctrlKey && !event.metaKey && !event.altKey) {
    switch(event.key.toLowerCase()) {
	  case 'v':
	    if (event.shiftKey) {
		// Shift+V: Toggle decoration mode
		document.getElementById("decorationBtn").click();
		console.log(`Decoration mode: ${mode === 'addDecoration' ? 'ON' : 'OFF'}`);
	    } else {
		// V: Toggle vertices mode
		document.getElementById("verticesBtn").click();
		console.log(`Vertices mode: ${mode === 'addVertex' ? 'ON' : 'OFF'}`);
	    }
	    event.preventDefault();
	    return;
        
      case 'e':
        if (event.shiftKey) {
          // Shift+E: Toggle edge decoration mode
          document.getElementById("cubeBtn").click();
          console.log(`Edge decoration mode: ${mode === 'addCube' ? 'ON' : 'OFF'}`);
        } else {
          // E: Toggle edge coloring mode
          document.getElementById("toggleClickBtn").click();
          console.log(`Edge mode: ${edgeClickEnabled ? 'ON' : 'OFF'}`);
        }
        event.preventDefault();
        return;
        
      case 'a':
        if (event.shiftKey) {
          // Shift+A: Toggle arrow display on/off
          document.getElementById("arrowCheckbox").click();
          console.log(`Arrow display: ${document.getElementById("arrowCheckbox").checked ? 'ON' : 'OFF'}`);
          event.preventDefault();
        }
        // Note: Plain "A" key shortcut removed - arrowBtn element no longer exists
        return;
        
      case 's':
        // S: Sync view
        document.getElementById("syncViewBtn").click();
        console.log("Sync view activated");
        event.preventDefault();
        return;
    }
  }
  // Directional keys for backbite mode
  if (mode === "backbite" && currentGrid && currentGrid.path && currentGrid.path.length >= 2) {
    console.log("In backbite mode with valid path");
    const path = currentGrid.path;
    const activeEndpointKey = activeEndpoint === 'start' ? path[0] : path[path.length - 1];
    console.log(`Active endpoint: ${activeEndpoint}, Key: ${activeEndpointKey}`);
    
    const [x, y, z] = unpackVertex(activeEndpointKey);
    let targetCoord = null;
    
    // Map arrow keys and page keys to directions
    switch(event.key) {
      case 'ArrowUp':
        targetCoord = [x, y + 1, z];
        console.log("Arrow Up pressed, target:", targetCoord);
        break;
      case 'ArrowDown':
        targetCoord = [x, y - 1, z];
        console.log("Arrow Down pressed, target:", targetCoord);
        break;
      case 'ArrowLeft':
        targetCoord = [x - 1, y, z];
        console.log("Arrow Left pressed, target:", targetCoord);
        break;
      case 'ArrowRight':
        targetCoord = [x + 1, y, z];
        console.log("Arrow Right pressed, target:", targetCoord);
        break;
      case 'PageUp':
        targetCoord = [x, y, z + 1];
        console.log("Page Up pressed, target:", targetCoord);
        break;
      case 'PageDown':
        targetCoord = [x, y, z - 1];
        console.log("Page Down pressed, target:", targetCoord);
        break;
      default:
        return;
    }
    
    if (targetCoord) {
      const currentCoord = [x, y, z];
      const clickedEdgeKey = edgeKey(currentCoord, targetCoord);
      console.log(`Attempting backbite with edge key: ${clickedEdgeKey}`);
      
      const success = performManualBackbite(clickedEdgeKey);
      console.log(`Backbite result: ${success}`);
      
      event.preventDefault();
    }
  }
});


// Backbite Warning Modal
function showBackbiteWarning() {
  // Remove any existing warning first
  const existingOverlay = document.getElementById('backbiteWarningOverlay');
  const existingWarning = document.getElementById('backbiteWarningDiv');
  if (existingOverlay) existingOverlay.remove();
  if (existingWarning) existingWarning.remove();

  // Create overlay FIRST
  const overlay = document.createElement('div');
  overlay.id = 'backbiteWarningOverlay';
  overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    z-index: 19999;
    pointer-events: auto;
  `;

  // Create warning div
  const warningDiv = document.createElement('div');
  warningDiv.id = 'backbiteWarningDiv';
  warningDiv.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    padding: 30px;
    border-radius: 12px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    z-index: 20000;
    max-width: 450px;
    text-align: center;
    font-family: inherit;
    pointer-events: auto;
  `;

  warningDiv.innerHTML = `
    <h2 style="margin: 0 0 15px 0; font-size: 20px; color: #d32f2f;">⚠️ Warning</h2>
    <p style="margin: 0 0 20px 0; font-size: 14px; color: #555; line-height: 1.5;">
      Performing backbite moves on non-Hamiltonian subgraphs (partial paths) causes erratic behavior.
    </p>
    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 20px; justify-content: center;">
      <input type="checkbox" id="backbiteWarningCheckbox" style="width: 18px; height: 18px; cursor: pointer;">
      <label for="backbiteWarningCheckbox" style="cursor: pointer; font-size: 13px; color: #666; user-select: none;">
        Don't show this again
      </label>
    </div>
    <button id="backbiteWarningBtn" style="padding: 10px 24px; background: #d32f2f; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500; font-weight: bold;">
      OK
    </button>
  `;

  // Append OVERLAY first, then WARNING so warning appears on top in DOM
  document.body.appendChild(overlay);
  document.body.appendChild(warningDiv);

  // Close function - removes both overlay and warning
  const closeWarning = () => {
    overlay.remove();
    warningDiv.remove();
  };

  // Add event listeners AFTER elements are in DOM
  const checkbox = document.getElementById('backbiteWarningCheckbox');
  if (checkbox) {
    checkbox.addEventListener('change', (e) => {
      dontShowBackbiteWarning = e.target.checked;
    });
  }

  const button = document.getElementById('backbiteWarningBtn');
  if (button) {
    button.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      closeWarning();
    });
  }

  // Close on background/overlay click
  overlay.addEventListener('click', closeWarning);
}


// Keyboard Shortcuts Modal Functionality
// Help Menu and Modals Functionality
(function() {
  const helpBtn = document.getElementById('helpBtn');
  const helpDropdown = document.getElementById('helpDropdown');
  const aboutModal = document.getElementById('aboutModal');
  const shortcutsModal = document.getElementById('keyboardShortcutsModal');
  const closeAboutBtn = document.getElementById('closeAboutModal');
  const closeShortcutsBtn = document.getElementById('closeShortcutsModal');
  
  // Toggle dropdown menu
  helpBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    const isVisible = helpDropdown.style.display === 'block';
    helpDropdown.style.display = isVisible ? 'none' : 'block';
    console.log(`Help dropdown ${isVisible ? 'closed' : 'opened'}`);
  });
  
  // Close dropdown when clicking outside
  document.addEventListener('click', (e) => {
    if (!helpBtn.contains(e.target) && !helpDropdown.contains(e.target)) {
      helpDropdown.style.display = 'none';
    }
  });
  
  // Handle menu item clicks
  document.querySelectorAll('.help-menu-item').forEach(item => {
    item.addEventListener('click', (e) => {
      const action = item.getAttribute('data-action');
      
      // Close dropdown
      helpDropdown.style.display = 'none';
      
      // Open appropriate modal
      if (action === 'about') {
        aboutModal.style.display = 'flex';
        console.log("About modal opened");
      } else if (action === 'shortcuts') {
        shortcutsModal.style.display = 'flex';
        console.log("Keyboard shortcuts modal opened");
      } else if (action === 'readme') {
        console.log("README - Coming soon");
        // Will be implemented later
      }
    });
  });
  
  // Close About modal
  closeAboutBtn.addEventListener('click', () => {
    aboutModal.style.display = 'none';
    console.log("About modal closed");
  });
  
  // Close Shortcuts modal
  closeShortcutsBtn.addEventListener('click', () => {
    shortcutsModal.style.display = 'none';
    console.log("Keyboard shortcuts modal closed");
  });
  
  // Close modals when clicking outside
  aboutModal.addEventListener('click', (e) => {
    if (e.target === aboutModal) {
      aboutModal.style.display = 'none';
      console.log("About modal closed (clicked outside)");
    }
  });
  
  shortcutsModal.addEventListener('click', (e) => {
    if (e.target === shortcutsModal) {
      shortcutsModal.style.display = 'none';
      console.log("Keyboard shortcuts modal closed (clicked outside)");
    }
  });
  
  // Close modals with Escape key
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      // First priority: if adding grid, show quit confirmation
      if (isAddingGrid) {
        e.preventDefault();
        showQuitGridAdditionDialog();
        return;
      }

      // Second priority: if generating path/cycle, show quit confirmation
      if (isGenerating) {
        e.preventDefault();
        const generationType = currentGrid && currentGrid.path && currentGrid.path.length === (currentGrid.width * currentGrid.height * currentGrid.depth) ? 'cycle' : 'path';
        showQuitGenerationDialog(generationType);
        return;
      }
      
      // Second priority: close preferences without saving
      const preferencesModal = document.getElementById('preferencesModal');
      if (preferencesModal && preferencesModal.style.display === 'flex') {
        preferencesModal.style.display = 'none';
        console.log("Preferences modal closed (Escape key - not saved)");
        return;
      }
      
      // Then handle other modals
      if (aboutModal.style.display === 'flex') {
        aboutModal.style.display = 'none';
        console.log("About modal closed (Escape key)");
      }
      if (shortcutsModal.style.display === 'flex') {
        shortcutsModal.style.display = 'none';
        console.log("Keyboard shortcuts modal closed (Escape key)");
      }
      if (helpDropdown.style.display === 'block') {
        helpDropdown.style.display = 'none';
        console.log("Help dropdown closed (Escape key)");
      }
    }
  });
})();


// Quit grid addition dialog
function showQuitGridAdditionDialog() {
  // Prevent multiple dialogs from stacking
  if (isQuitDialogOpen) {
    console.log("Quit dialog already open, ignoring duplicate ESC press");
    return;
  }

  isQuitDialogOpen = true;

  // Create dialog overlay
  const overlay = document.createElement('div');
  overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    z-index: 10002;
    display: flex;
    align-items: center;
    justify-content: center;
  `;

  const dialog = document.createElement('div');
  dialog.style.cssText = `
    background: white;
    border-radius: 12px;
    padding: 30px;
    max-width: 400px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
  `;

  dialog.innerHTML = `
    <h3 style="margin: 0 0 20px 0; color: #2c3e50; font-size: 20px;">Cancel Grid Generation?</h3>
    <p style="margin: 0 0 25px 0; color: #555; font-size: 14px; line-height: 1.6;">
      Are you sure you want to cancel grid generation? The incomplete grid will be discarded.
    </p>
    <div style="display: flex; gap: 12px; justify-content: flex-end;">
      <button id="quitGridNo" style="padding: 10px 24px; background: #95a5a6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">No, Continue</button>
      <button id="quitGridYes" style="padding: 10px 24px; background: #e74c3c; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">Yes, Cancel</button>
    </div>
  `;

  overlay.appendChild(dialog);
  document.body.appendChild(overlay);

  // Event handlers
  document.getElementById('quitGridNo').addEventListener('click', () => {
    document.body.removeChild(overlay);
    isQuitDialogOpen = false; // Reset flag
  });

  document.getElementById('quitGridYes').addEventListener('click', () => {
    shouldStopGridAddition = true;
    document.body.removeChild(overlay);
    isQuitDialogOpen = false; // Reset flag
    console.log("User requested to cancel grid addition");
  });
}

// Quit generation dialog
function showQuitGenerationDialog(generationType) {
  // Prevent multiple dialogs from stacking
  if (isQuitDialogOpen) {
    console.log("Quit dialog already open, ignoring duplicate ESC press");
    return;
  }

  isQuitDialogOpen = true;

  // Create dialog overlay
  const overlay = document.createElement('div');
  overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    z-index: 10002;
    display: flex;
    align-items: center;
    justify-content: center;
  `;

  const dialog = document.createElement('div');
  dialog.style.cssText = `
    background: white;
    border-radius: 12px;
    padding: 30px;
    max-width: 400px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
  `;

  dialog.innerHTML = `
    <h3 style="margin: 0 0 20px 0; color: #2c3e50; font-size: 20px;">Stop Generation?</h3>
    <p style="margin: 0 0 25px 0; color: #555; font-size: 14px; line-height: 1.6;">
      Are you sure you want to stop generating a Hamiltonian ${generationType}?
    </p>
    <div style="display: flex; gap: 12px; justify-content: flex-end;">
      <button id="quitGenNo" style="padding: 10px 24px; background: #95a5a6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">No</button>
      <button id="quitGenYes" style="padding: 10px 24px; background: #e74c3c; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">Yes, Stop</button>
    </div>
  `;

  overlay.appendChild(dialog);
  document.body.appendChild(overlay);

  // Event handlers
  document.getElementById('quitGenNo').addEventListener('click', () => {
    document.body.removeChild(overlay);
    isQuitDialogOpen = false; // Reset flag
  });

  document.getElementById('quitGenYes').addEventListener('click', () => {
    shouldStopGeneration = true;
    document.body.removeChild(overlay);
    isQuitDialogOpen = false; // Reset flag
    console.log("User requested to stop generation");
  });
}


// ===========================================INSTANCED RENDERING TOGGLE=========================================  \\

// ===============================================================================================================  \\


// ============================================================================
// Universal Progress Overlay System
// - Auto-sizing based on content
// - Full-screen UI blocking
// - ESC key cancellation
// - Theme-aware
// ============================================================================
const ProgressOverlay = {
  overlay: null,
  content: null,
  lines: [],           // Array of line objects: {id, text}
  lineMap: {},         // Map of id -> line object for O(1) lookups
  onCancel: null,      // Callback for ESC key
  escHandler: null,    // Reference to ESC key listener

  init() {
    this.overlay = document.getElementById('progressOverlay');
    this.content = document.getElementById('progressContent');
    console.log('ProgressOverlay initialized:', this.overlay !== null);
  },

  updateTheme() {
    if (!this.content) return;

    // Check if dark-theme class is applied to root element (accounts for auto-switch)
    const isDarkMode = document.documentElement.classList.contains('dark-theme');

    // Update content box styling (not the overlay background)
    if (isDarkMode) {
      this.content.style.background = '#0a0f0a';
      this.content.style.color = '#b7f774';
      this.content.style.border = '1px solid #1d2a1d';
    } else {
      this.content.style.background = '#ffffff';
      this.content.style.color = '#0066ff';
      this.content.style.border = '1px solid #cccccc';
    }
  },

  // ============================================================================
  // Main API: show(config)
  // ============================================================================
  show(config) {
    if (!this.overlay) this.init();
    this.updateTheme();

    // Store lines and callback
    this.lines = config.lines.map((line, index) => ({
      id: line.id || `line-${index}`,
      text: line.text || ''
    }));

    // Build map for O(1) lookups
    this.lineMap = {};
    this.lines.forEach(line => {
      this.lineMap[line.id] = line;
    });

    this.onCancel = config.onCancel || null;

    // Calculate overlay width based on longest expected line
    const maxExpectedTexts = config.maxExpectedTexts || config.lines.map(l => l.text);
    const longestText = maxExpectedTexts.reduce((a, b) => a.length > b.length ? a : b, '');

    // Set content box width (approximate: 8px per char + padding)
    const estimatedWidth = Math.max(300, Math.min(600, longestText.length * 8 + 24));
    this.content.style.width = `${estimatedWidth}px`;

    // Render initial content
    this.render();

    // Setup ESC key handler
    if (this.onCancel) {
      this.escHandler = (e) => {
        if (e.key === 'Escape') {
          e.preventDefault();
          e.stopPropagation();
          this.onCancel();
        }
      };
      document.addEventListener('keydown', this.escHandler, true); // Use capture phase for priority
    }

    // Show overlay
    this.overlay.style.display = 'flex';
    this.overlay.offsetHeight;  // Force reflow
    this.overlay.style.opacity = '1';

    // Reset pointer events and cursor to block interaction
    this.overlay.style.pointerEvents = 'auto';
    this.overlay.style.cursor = 'not-allowed';

    // Disable camera controls
    if (window.controls) {
      controls.enabled = false;
    }

    console.log('✅ Progress overlay shown:', this.lines.length, 'lines');
  },

  // Update a specific line by ID
  updateLine(id, text) {
    const line = this.lineMap[id];
    if (line) {
      line.text = text;
      this.render();
    }
  },

  // Render all lines
  render() {
    if (!this.content) return;

    this.content.innerHTML = this.lines.map(line =>
      line.text === '' ? '&nbsp;' : line.text
    ).join('<br>');
  },

  // ============================================================================
  // Convenience methods for common operations
  // ============================================================================

  // Start grid creation (standalone)
  startGrid(gridDimensions) {
    this.show({
      lines: [
        { id: 'grid-progress', text: `Creating ${gridDimensions} grid...` },
        { id: 'esc', text: 'Press ESC to cancel' },
        { id: 'spacer', text: '' }
      ],
      maxExpectedTexts: [
        `Grid created in 999.99s`,
        'Press ESC to cancel',
        ''
      ],
      onCancel: () => showQuitGridAdditionDialog()
    });
  },

  // Start path/cycle generation (includes grid + path/cycle)
  startGridForPathCycle(gridDimensions, operationType) {
    this.show({
      lines: [
        { id: 'grid-progress', text: `Creating ${gridDimensions} grid...` },
        { id: 'pathcycle-progress', text: '' },
        { id: 'pathcycle-complete', text: '' },
        { id: 'esc', text: 'Press ESC to cancel' }
      ],
      maxExpectedTexts: [
        `Grid created in 999.99s`,
        `Generating Hamiltonian ${operationType}... 100% complete`,
        `Hamiltonian ${operationType} generated in 999.99s`,
        'Press ESC to cancel'
      ],
      onCancel: () => {
        if (window.isAddingGrid) {
          showQuitGridAdditionDialog();
        } else if (window.isGenerating) {
          const genType = operationType;
          showQuitGenerationDialog(genType);
        }
      }
    });
  },

  // Start path/cycle operation (after grid is done)
  startPathCycle(operationType) {
    this.updateLine('pathcycle-progress', `Generating Hamiltonian ${operationType}... 0% complete`);
  },

  // Update path/cycle progress
  updatePathCycleProgress(operationType, percentage) {
    this.updateLine('pathcycle-progress', `Generating Hamiltonian ${operationType}... ${Math.round(percentage)}% complete`);
  },

  // Complete path/cycle
  completePathCycle(operationType, timeInSeconds) {
    this.updateLine('pathcycle-progress', `Generating Hamiltonian ${operationType}... 100% complete`);
    this.updateLine('pathcycle-complete', `Hamiltonian ${operationType} generated in ${timeInSeconds}s`);
  },

  // Re-enable user interaction (camera controls, etc.) without hiding overlay
  enableInteraction() {
    if (!this.overlay) return;

    // Remove ESC key handler
    if (this.escHandler) {
      document.removeEventListener('keydown', this.escHandler, true);
      this.escHandler = null;
    }

    // Clear callback
    this.onCancel = null;

    // Allow mouse events to pass through overlay to scene below
    this.overlay.style.pointerEvents = 'none';
    this.overlay.style.cursor = 'auto';

    // Re-enable camera controls
    if (window.controls) {
      controls.enabled = true;
    }

    console.log('✅ User interaction re-enabled');
  },

  // Hide overlay and clean up
  hide() {
    if (!this.overlay) return;

    // Re-enable interaction immediately
    this.enableInteraction();

    // Fade out and clean up visual elements
    this.overlay.style.opacity = '0';
    setTimeout(() => {
      this.overlay.style.display = 'none';
      this.lines = [];
      this.lineMap = {};
      this.content.innerHTML = '';
      this.content.style.width = ''; // Reset width
    }, 300);
  },

  // Fade out after showing completion (used at end of workflow)
  fadeOut(duration = 3000) {
    if (!this.overlay) return;

    // Re-enable interaction immediately (user can interact while overlay fades)
    this.enableInteraction();

    // Hide overlay after delay (visual feedback only, non-blocking)
    setTimeout(() => {
      // Just handle visual cleanup, interaction already enabled
      this.overlay.style.opacity = '0';
      setTimeout(() => {
        this.overlay.style.display = 'none';
        this.lines = [];
        this.lineMap = {};
        this.content.innerHTML = '';
        this.content.style.width = ''; // Reset width
      }, 300);
    }, duration);
  }
};

window.addEventListener('load', () => ProgressOverlay.init());


// Help menu item click handler
document.querySelectorAll('.help-menu-item').forEach(item => {
  item.addEventListener('click', (e) => {
    const action = e.target.dataset.action;
    
    if (action === 'shortcuts') {
      document.getElementById('keyboardShortcutsModal').style.display = 'flex';
      document.getElementById('helpDropdown').style.display = 'none';
    } else if (action === 'about') {
      document.getElementById('aboutModal').style.display = 'flex';
      document.getElementById('helpDropdown').style.display = 'none';
    } else if (action === 'readme') {
      openReadmeInNewTab();
      document.getElementById('helpDropdown').style.display = 'none';
    }
  });
});

// Rebuild edge collision instances after radius change
function rebuildEdgeCollisionInstances(grid) {
  if (!grid) return;

  // Handle chunked grids
  if (grid.chunks && grid.chunks.size > 0) {
    for (const [chunkKey, chunk] of grid.chunks.entries()) {
      if (!chunk.instancedEdgesCollision) continue;
      if (!chunk.edgeToInstanceMap) continue;

      // Recreate collision mesh with new radius
      grid.group.remove(chunk.instancedEdgesCollision);
      chunk.instancedEdgesCollision.geometry.dispose();
      chunk.instancedEdgesCollision.material.dispose();

      const newGeometry = new THREE.CylinderGeometry(edgeCollisionRadius, edgeCollisionRadius, 1, 8);
      const newMaterial = new THREE.MeshBasicMaterial({ visible: false });
      const newMesh = new THREE.InstancedMesh(newGeometry, newMaterial, chunk.edgeToInstanceMap.size);
      newMesh.userData.isEdgeCollisionMesh = true;
      newMesh.visible = true;
      newMesh.material.opacity = 0;
      newMesh.material.transparent = true;
      chunk.instancedEdgesCollision = newMesh;
      grid.group.add(newMesh);

      // Rebuild all edge matrices
      for (const [eKey, mapping] of chunk.edgeToInstanceMap.entries()) {
        const edge = grid.edges.get(eKey);
        if (!edge) continue;

        const [a, b] = unpackEdge(eKey, grid);

        const direction = new THREE.Vector3(b[0] - a[0], b[1] - a[1], b[2] - a[2]);
        const length = direction.length();
        const midpoint = new THREE.Vector3(
          (a[0] + b[0]) / 2,
          (a[1] + b[1]) / 2,
          (a[2] + b[2]) / 2
        );

        const matrix = new THREE.Matrix4();
        matrix.makeScale(1, length, 1);

        const up = new THREE.Vector3(0, 1, 0);
        const quaternion = new THREE.Quaternion();
        quaternion.setFromUnitVectors(up, direction.normalize());
        const rotationMatrix = new THREE.Matrix4().makeRotationFromQuaternion(quaternion);
        matrix.premultiply(rotationMatrix);
        matrix.setPosition(midpoint);

        chunk.instancedEdgesCollision.setMatrixAt(mapping.collision, matrix);
      }

      chunk.instancedEdgesCollision.instanceMatrix.needsUpdate = true;
    }
  }
  // Handle non-chunked grids
  else if (grid.instancedEdgesCollision && grid.edgeToInstanceMap) {
    // Recreate collision mesh with new radius
    grid.group.remove(grid.instancedEdgesCollision);
    grid.instancedEdgesCollision.geometry.dispose();
    grid.instancedEdgesCollision.material.dispose();

    const newGeometry = new THREE.CylinderGeometry(edgeCollisionRadius, edgeCollisionRadius, 1, 8);
    const newMaterial = new THREE.MeshBasicMaterial({ visible: false });
    const newMesh = new THREE.InstancedMesh(newGeometry, newMaterial, grid.edges.size);
    newMesh.userData.isEdgeCollisionMesh = true;
    grid.instancedEdgesCollision = newMesh;
    grid.group.add(newMesh);

    // Rebuild all edge matrices
    for (const [eKey, mapping] of grid.edgeToInstanceMap.entries()) {
      const edge = grid.edges.get(eKey);
      if (!edge) continue;

      const [a, b] = unpackEdge(eKey, grid);

      const direction = new THREE.Vector3(b[0] - a[0], b[1] - a[1], b[2] - a[2]);
      const length = direction.length();
      const midpoint = new THREE.Vector3(
        (a[0] + b[0]) / 2,
        (a[1] + b[1]) / 2,
        (a[2] + b[2]) / 2
      );

      const matrix = new THREE.Matrix4();
      matrix.makeScale(1, length, 1);

      const up = new THREE.Vector3(0, 1, 0);
      const quaternion = new THREE.Quaternion();
      quaternion.setFromUnitVectors(up, direction.normalize());
      const rotationMatrix = new THREE.Matrix4().makeRotationFromQuaternion(quaternion);
      matrix.premultiply(rotationMatrix);
      matrix.setPosition(midpoint);

      grid.instancedEdgesCollision.setMatrixAt(mapping.collision, matrix);
    }

    grid.instancedEdgesCollision.instanceMatrix.needsUpdate = true;
  }
}

// Debounce timer for edge collision radius rebuild
let edgeCollisionRebuildTimeout;

document.getElementById('edgeCollisionRadiusSlider').addEventListener('input', (e) => {
  edgeCollisionRadius = parseFloat(e.target.value);

  // Update display immediately for responsive feedback
  document.getElementById('edgeCollisionRadiusValue').textContent = edgeCollisionRadius.toFixed(2);

  // Debounce the expensive rebuild operation
  clearTimeout(edgeCollisionRebuildTimeout);
  edgeCollisionRebuildTimeout = setTimeout(() => {
    if (currentGrid) {
      rebuildEdgeCollisionInstances(currentGrid);
    }
  }, 300); // Wait 300ms after user stops moving slider
});

// Camera sensitivity slider in preferences
document.getElementById('cameraSensitivitySlider').addEventListener('input', (e) => {
  const value = parseFloat(e.target.value);
  document.getElementById('cameraSensitivityValue').textContent = value.toFixed(1);
  // Preview changes immediately
  if (typeof controls !== 'undefined') {
    controls.rotateSpeed = value;
    controls.zoomSpeed = 0.5 * value;
  }
});

// Flare radius slider in preferences
document.getElementById('flareRadiusSlider').addEventListener('input', (e) => {
  const value = parseFloat(e.target.value);
  document.getElementById('flareRadiusValue').textContent = value.toFixed(1);
});

// Camera sensitivity slider in main UI
document.getElementById('mainCameraSensitivitySlider').addEventListener('input', (e) => {
  const value = parseFloat(e.target.value);
  cameraSensitivity = value;
  document.getElementById('mainCameraSensitivityValue').textContent = value.toFixed(1);

  // Update controls immediately (both rotation and zoom)
  if (typeof controls !== 'undefined') {
    controls.rotateSpeed = cameraSensitivity;
    controls.zoomSpeed = 0.5 * cameraSensitivity;
  }

  // Sync with preferences slider
  const prefSlider = document.getElementById('cameraSensitivitySlider');
  const prefValue = document.getElementById('cameraSensitivityValue');
  if (prefSlider && prefValue) {
    prefSlider.value = value;
    prefValue.textContent = value.toFixed(1);
  }
});

// Main Screen Vertex Dimmer slider handler
document.getElementById('mainVertexDimmerSlider').addEventListener('input', (e) => {
  const dimmerPercent = parseInt(e.target.value);
  vertexDimmer = dimmerPercent / 100.0;
  document.getElementById('mainVertexDimmerValue').textContent = dimmerPercent + '%';

  // Sync with preferences slider
  const prefSlider = document.getElementById('vertexDimmerSlider');
  const prefValue = document.getElementById('vertexDimmerValue');
  if (prefSlider) prefSlider.value = dimmerPercent;
  if (prefValue) prefValue.textContent = dimmerPercent;

  console.log(`Vertex dimmer changed to: ${dimmerPercent}% (${vertexDimmer.toFixed(2)})`);

  // Update brightness for GRAY grid vertices only
  for (const [gridId, grid] of allGrids.entries()) {
    if (!grid) continue;

    if (grid.chunks) {
      for (const chunk of grid.chunks.values()) {
        if (chunk.instancedVertexSpheres && chunk.instancedVertexSpheres.instanceColor && chunk.vertexToInstanceMap) {
          const colors = chunk.instancedVertexSpheres.instanceColor.array;

          for (const [vKey, instanceIndex] of chunk.vertexToInstanceMap.entries()) {
            const sphereData = grid.vertexSpheres ? grid.vertexSpheres.get(vKey) : null;
            const hasCustomColor = sphereData && sphereData.color && sphereData.color !== 0x888888;

            if (!hasCustomColor) {
              const grayValue = 0.533 * vertexDimmer;
              colors[instanceIndex * 3] = grayValue;
              colors[instanceIndex * 3 + 1] = grayValue;
              colors[instanceIndex * 3 + 2] = grayValue;
            }
          }

          chunk.instancedVertexSpheres.instanceColor.needsUpdate = true;
        }
      }
    }

    if (grid.instancedVertexSpheres && grid.instancedVertexSpheres.instanceColor) {
      const colors = grid.instancedVertexSpheres.instanceColor.array;
      let instanceIndex = 0;

      for (const [vKey, vertexData] of grid.vertices.entries()) {
        const sphereData = grid.vertexSpheres ? grid.vertexSpheres.get(vKey) : null;
        const hasCustomColor = sphereData && sphereData.color && sphereData.color !== 0x888888;

        if (!hasCustomColor) {
          const grayValue = 0.533 * vertexDimmer;
          colors[instanceIndex * 3] = grayValue;
          colors[instanceIndex * 3 + 1] = grayValue;
          colors[instanceIndex * 3 + 2] = grayValue;
        }
        instanceIndex++;
      }

      grid.instancedVertexSpheres.instanceColor.needsUpdate = true;
    }
  }
});


// Edge Detail dropdown handler
document.getElementById('edgeDetailSelect').addEventListener('change', async (e) => {
  const newValue = parseInt(e.target.value);
  const oldValue = currentGrid?.lodState?.edgeSegments ?? edgeSegments;

  // Warn if increasing detail on large grid
  if (newValue > oldValue && shouldWarnForPerformance(currentGrid)) {
    const totalVertices = currentGrid.width * currentGrid.height * currentGrid.depth;
    const proceed = await showPerformanceWarning(
      `This grid has ${totalVertices.toLocaleString()} vertices. Increasing thin edge detail from ${oldValue} to ${newValue} segments may significantly impact performance.<br><br>Do you want to proceed?`
    );

    if (!proceed) {
      // Revert dropdown
      e.target.value = oldValue;
      return;
    }
  }

  console.log(`Thin edge detail changed to: ${newValue} segments`);

  // If a grid exists, rebuild edges with new segment count
  // IMPORTANT: Update global AFTER rebuild so old value comparison works correctly
  if (currentGrid) {
    console.log('Rebuilding thin edges with new segment count...');
    console.log(`Current triangles before: ${renderer.info.render.triangles}`);
    rebuildEdgesWithNewSegments(currentGrid, newValue);
    renderer.render(scene, camera);
    console.log(`Current triangles after: ${renderer.info.render.triangles}`);

    // Debug: Check chunk geometry
    if (currentGrid.chunks) {
      for (const [chunkKey, chunk] of currentGrid.chunks.entries()) {
        if (chunk.instancedEdgesThin) {
          const geom = chunk.instancedEdgesThin.geometry;
          console.log(`Chunk ${chunkKey}: thin edges geometry has ${geom.attributes.position.count} vertices, radialSegments=${geom.parameters?.radialSegments}`);
        }
        break; // Just check first chunk
      }
    }
  }

  // Update global after rebuild
  edgeSegments = newValue;
});

// Thick Edge Detail dropdown handler
document.getElementById('thickEdgeDetailSelect').addEventListener('change', async (e) => {
  const newValue = parseInt(e.target.value);
  const oldValue = currentGrid?.lodState?.thickEdgeSegments ?? thickEdgeSegments;

  // Warn if increasing detail on large grid
  if (newValue > oldValue && shouldWarnForPerformance(currentGrid)) {
    const totalVertices = currentGrid.width * currentGrid.height * currentGrid.depth;
    const proceed = await showPerformanceWarning(
      `This grid has ${totalVertices.toLocaleString()} vertices. Increasing thick edge detail from ${oldValue} to ${newValue} segments may significantly impact performance.<br><br>Do you want to proceed?`
    );

    if (!proceed) {
      // Revert dropdown
      e.target.value = oldValue;
      return;
    }
  }

  console.log(`Thick edge detail changed to: ${newValue} segments`);

  // If a grid exists, rebuild thick edges with new segment count
  // IMPORTANT: Update global AFTER rebuild so old value comparison works correctly
  if (currentGrid) {
    console.log('Rebuilding thick edges with new segment count...');
    console.log(`Current triangles before: ${renderer.info.render.triangles}`);
    rebuildThickEdgesWithNewSegments(currentGrid, newValue);
    renderer.render(scene, camera);
    console.log(`Current triangles after: ${renderer.info.render.triangles}`);
  }

  // Update global after rebuild
  thickEdgeSegments = newValue;
});

// Vertex Detail dropdown handler
document.getElementById('vertexDetailSelect').addEventListener('change', async (e) => {
  const newValue = parseInt(e.target.value);
  const oldValue = currentGrid?.lodState?.vertexDetail ?? vertexSubdivisions;

  // Warn if increasing detail on large grid
  if (newValue > oldValue && shouldWarnForPerformance(currentGrid)) {
    const detailNames = ['Low', 'Normal', 'Medium', 'High', 'Ultra'];
    const totalVertices = currentGrid.width * currentGrid.height * currentGrid.depth;
    const proceed = await showPerformanceWarning(
      `This grid has ${totalVertices.toLocaleString()} vertices. Increasing vertex detail from ${detailNames[oldValue]} to ${detailNames[newValue]} may significantly impact performance.<br><br>Do you want to proceed?`
    );

    if (!proceed) {
      // Revert dropdown
      e.target.value = oldValue;
      return;
    }
  }

  const detailNames = ['Low', 'Normal', 'Medium', 'High', 'Ultra'];
  console.log(`Vertex detail changed to: ${detailNames[newValue]} (${newValue} subdivisions)`);

  // If a grid exists, rebuild vertices with new subdivision count
  // IMPORTANT: Update global AFTER rebuild so old value comparison works correctly
  if (currentGrid) {
    console.log('Rebuilding vertices with new subdivision count...');
    rebuildVerticesWithNewDetail(currentGrid, newValue);
  }

  // Update global after rebuild
  vertexSubdivisions = newValue;
});

// Vertex Radius slider handler
document.getElementById('vertexRadiusSlider').addEventListener('input', (e) => {
  const newRadius = parseFloat(e.target.value);
  vertexRadius = newRadius;

  // Update displayed value
  document.getElementById('vertexRadiusValue').textContent = newRadius.toFixed(2);

  // ALWAYS update vertex decoration radius automatically (simplified behavior - always dynamic)
  // Maintain 1% increase over vertex radius
  const newDecoRadius = newRadius * 1.01;
  vertexDecorationRadius = newDecoRadius;

  // Rebuild vertices with new radius for current grid only
  if (currentGrid && currentGrid.isInstanced) {
    rebuildVerticesWithNewRadius(currentGrid, newRadius);
  }

  // Also rebuild vertex decorations in current grid to match new vertex size
  if (currentGrid) {
    rebuildVertexDecorationsWithNewSize(currentGrid, newDecoRadius);
  }
});

// VERTEX DECORATION REMOVED: Manual vertex decoration radius slider
// FORMER FUNCTIONALITY: Allowed manual adjustment of vertex decoration size independent of vertex size
// NOW: Vertex decorations ALWAYS follow vertex size dynamically (simplified - see above)
// To restore: Uncomment this handler and the HTML slider/checkbox elements (search for "VERTEX DECORATION REMOVED")
/*
document.getElementById('vertexDecorationRadiusSlider').addEventListener('input', (e) => {
  const newRadius = parseFloat(e.target.value);
  vertexDecorationRadius = newRadius;

  // Update displayed value
  document.getElementById('vertexDecorationRadiusValue').textContent = newRadius.toFixed(4);

  // TODO: Rebuild vertex decorations with new radius for all grids
  // This would require iterating through all grids and updating decoration sphere sizes
  console.log(`Vertex decoration radius set to ${newRadius.toFixed(4)}`);
});
*/

// VERTEX DECORATION REMOVED: Dynamic Vertex Decoration Shadow checkbox
// FORMER FUNCTIONALITY: Toggle between manual decoration size control and automatic following of vertex size
// NOW: Always automatic (no toggle needed - simplified behavior)
// To restore: Uncomment this handler and the HTML checkbox (search for "VERTEX DECORATION REMOVED")
/*
document.getElementById('dynamicVertexDecoShadowCheckbox').addEventListener('change', (e) => {
  dynamicVertexDecoShadow = e.target.checked;

  const vertexDecoSlider = document.getElementById('vertexDecorationRadiusSlider');

  if (dynamicVertexDecoShadow) {
    // Disable the slider and gray it out
    if (vertexDecoSlider) {
      vertexDecoSlider.disabled = true;
      vertexDecoSlider.style.opacity = '0.5';
      vertexDecoSlider.style.cursor = 'not-allowed';
    }

    // Update decoration radius to match current vertex radius * 1.01
    const newDecoRadius = vertexRadius * 1.01;
    vertexDecorationRadius = newDecoRadius;
    vertexDecoSlider.value = newDecoRadius.toFixed(4);
    document.getElementById('vertexDecorationRadiusValue').textContent = newDecoRadius.toFixed(4);

    console.log('Dynamic vertex decoration shadow enabled - slider disabled');
  } else {
    // Enable the slider
    if (vertexDecoSlider) {
      vertexDecoSlider.disabled = false;
      vertexDecoSlider.style.opacity = '1';
      vertexDecoSlider.style.cursor = 'pointer';
    }

    console.log('Dynamic vertex decoration shadow disabled - slider enabled');
  }
});
*/

// Edge Decoration slider handler
document.getElementById('edgeDecorationRadiusSlider').addEventListener('input', (e) => {
  const newSize = parseFloat(e.target.value);
  blockCubeSize = newSize; // Update global default for future grids

  // Update displayed value
  document.getElementById('edgeDecorationRadiusValue').textContent = newSize.toFixed(4);

  // Rebuild block cubes for current grid only
  if (currentGrid) {
    rebuildBlockCubesWithNewSize(currentGrid, newSize);
  }

  console.log(`Edge decoration (block cube) size set to ${newSize.toFixed(4)}`);
});

// Vertex Dimmer slider handler (preferences) - wrapped in DOMContentLoaded
document.addEventListener('DOMContentLoaded', function() {
  const vertexDimmerSlider = document.getElementById('vertexDimmerSlider');
  if (vertexDimmerSlider) {
    vertexDimmerSlider.addEventListener('input', (e) => {
      const dimmerPercent = parseInt(e.target.value);
      vertexDimmer = dimmerPercent / 100.0;

      // Update displayed value
      document.getElementById('vertexDimmerValue').textContent = dimmerPercent;

      // Sync with main screen slider if it exists
      const mainSlider = document.getElementById('mainVertexDimmerSlider');
      const mainValue = document.getElementById('mainVertexDimmerValue');
      if (mainSlider) mainSlider.value = dimmerPercent;
      if (mainValue) mainValue.textContent = dimmerPercent + '%';

      // Update brightness for GRAY grid vertices only (not colored path vertices)
      for (const [gridId, grid] of allGrids.entries()) {
        if (!grid) continue;

        // Update chunk-based vertex spheres
        if (grid.chunks) {
          for (const chunk of grid.chunks.values()) {
            if (chunk.instancedVertexSpheres && chunk.instancedVertexSpheres.instanceColor && chunk.vertexToInstanceMap) {
              const colors = chunk.instancedVertexSpheres.instanceColor.array;

              // Iterate through each vertex in this chunk
              for (const [vKey, instanceIndex] of chunk.vertexToInstanceMap.entries()) {
                // Check if this vertex has a custom color (colored path vertex)
                const sphereData = grid.vertexSpheres ? grid.vertexSpheres.get(vKey) : null;
                const hasCustomColor = sphereData && sphereData.color && sphereData.color !== 0x888888;

                if (!hasCustomColor) {
                  // Only dim GRAY vertices (default structural vertices)
                  const grayValue = 0.533 * vertexDimmer;
                  colors[instanceIndex * 3] = grayValue;     // R
                  colors[instanceIndex * 3 + 1] = grayValue; // G
                  colors[instanceIndex * 3 + 2] = grayValue; // B
                }
                // Leave colored vertices unchanged
              }

              chunk.instancedVertexSpheres.instanceColor.needsUpdate = true;
            }
          }
        }

        // Update global vertex spheres (old non-chunked system)
        if (grid.instancedVertexSpheres && grid.instancedVertexSpheres.instanceColor) {
          const colors = grid.instancedVertexSpheres.instanceColor.array;
          let instanceIndex = 0;

          for (const [vKey, vertexData] of grid.vertices.entries()) {
            const sphereData = grid.vertexSpheres ? grid.vertexSpheres.get(vKey) : null;
            const hasCustomColor = sphereData && sphereData.color && sphereData.color !== 0x888888;

            if (!hasCustomColor) {
              // Only dim GRAY vertices
              const grayValue = 0.533 * vertexDimmer;
              colors[instanceIndex * 3] = grayValue;
              colors[instanceIndex * 3 + 1] = grayValue;
              colors[instanceIndex * 3 + 2] = grayValue;
            }
            instanceIndex++;
          }

          grid.instancedVertexSpheres.instanceColor.needsUpdate = true;
        }
      }
    });
  }
});

// Thin Edge Radius slider handler
document.getElementById('thinEdgeRadiusSlider').addEventListener('input', (e) => {
  thinEdgeRadius = parseFloat(e.target.value);
  document.getElementById('thinEdgeRadiusValue').textContent = thinEdgeRadius.toFixed(3);

  // Force rebuild by temporarily invalidating LOD state for both grid and chunks
  for (const [gridId, grid] of allGrids.entries()) {
    if (grid && grid.isInstanced) {
      const currentSegments = grid.lodState?.edgeSegments ?? edgeSegments;

      // Invalidate grid-level LOD state
      if (grid.lodState) grid.lodState.edgeSegments = -1;

      // Invalidate chunk-level LOD states
      if (grid.chunks && grid.chunks.size > 0) {
        for (const chunk of grid.chunks.values()) {
          if (chunk.lodState) chunk.lodState.edgeSegments = -1;
        }
      }

      rebuildEdgesWithNewSegments(grid, currentSegments);
    }
  }
});

// Thick Edge Radius slider handler
document.getElementById('thickEdgeRadiusSlider').addEventListener('input', (e) => {
  thickEdgeRadius = parseFloat(e.target.value);
  document.getElementById('thickEdgeRadiusValue').textContent = thickEdgeRadius.toFixed(3);

  // Force rebuild by temporarily invalidating LOD state for both grid and chunks
  for (const [gridId, grid] of allGrids.entries()) {
    if (grid && grid.isInstanced) {
      // Use the global default, not grid state (which we're invalidating)
      const segmentsToUse = thickEdgeSegments;

      // Invalidate chunk-level LOD states to force rebuild
      if (grid.chunks && grid.chunks.size > 0) {
        for (const chunk of grid.chunks.values()) {
          if (chunk.lodState) chunk.lodState.thickEdgeSegments = -1;
        }
      }

      rebuildThickEdgesWithNewSegments(grid, segmentsToUse);
    }
  }
});

// Unified Edge Size checkbox handler - disable thick slider when unified
document.getElementById('unifiedEdgeSizeCheckbox').addEventListener('change', (e) => {
  unifiedEdgeSize = e.target.checked;
  const thickContainer = document.getElementById('thickEdgeRadiusContainer');
  const thickSlider = document.getElementById('thickEdgeRadiusSlider');

  if (unifiedEdgeSize) {
    // Disable thick edge radius slider
    thickContainer.style.opacity = '0.5';
    thickContainer.style.pointerEvents = 'none';
    thickSlider.disabled = true;
  } else {
    // Enable thick edge radius slider
    thickContainer.style.opacity = '1';
    thickContainer.style.pointerEvents = 'auto';
    thickSlider.disabled = false;
  }

  console.log(`Unified edge size ${unifiedEdgeSize ? 'enabled' : 'disabled'}`);
});

// Box highlight color picker handler
document.getElementById('boxHighlightColorPicker').addEventListener('input', (e) => {
  boxHighlightColor = parseInt(e.target.value.slice(1), 16);
  console.log(`Box highlight color changed to: #${boxHighlightColor.toString(16).padStart(6, '0')}`);
});

// Box highlight opacity slider handler
document.getElementById('boxHighlightOpacitySlider').addEventListener('input', (e) => {
  boxHighlightOpacity = parseInt(e.target.value) / 100;
  document.getElementById('boxHighlightOpacityValue').textContent = `${e.target.value}%`;
  console.log(`Box highlight opacity changed to: ${boxHighlightOpacity}`);
});

// Use Automatic Rendering Settings toggle
document.getElementById('useAutomaticRenderingCheckbox').addEventListener('change', (e) => {
  const useAutomatic = e.target.checked;
  const advancedContainer = document.getElementById('advancedRenderingSettings');

  if (advancedContainer) {
    advancedContainer.style.display = useAutomatic ? 'none' : 'block';
  }

  // If switching to automatic, reset all advanced settings to defaults
  if (useAutomatic) {
    // Reset culling to enabled
    document.getElementById('frustumCullingCheckbox').checked = true;
    document.getElementById('surfaceCullingCheckbox').checked = true;
    document.getElementById('sphericalCullingCheckbox').checked = true;

    // Reset surface depth to 2 chunks
    document.getElementById('surfaceDepthSelect').value = '2';

    // Reset far culling depth to 2 chunks
    document.getElementById('farCullingDepthSelect').value = '2';

    // Reset render radius to 4 chunks
    document.getElementById('renderRadiusSelect').value = '4';

    // Reset LOD to disabled (will be auto-enabled for massive grids)
    document.getElementById('lodEnabledCheckbox').checked = false;

    // Reset LOD quality slider to default (10 - maximum quality)
    document.getElementById('lodQualitySlider').value = '10';

    // Reset chunk size to auto (5)
    document.getElementById('chunkSizeInput').value = '5';

    // Reset max rebuilds to 16
    document.getElementById('maxRebuildsInput').value = '16';

    console.log('Rendering settings reset to automatic defaults');
  }
});

// Rendering Settings Header Click - Toggle expand/collapse
document.getElementById('renderingSettingsHeader').addEventListener('click', (e) => {
  const advancedContainer = document.getElementById('advancedRenderingSettings');
  const caret = document.getElementById('renderingSettingsCaret');

  if (advancedContainer && caret) {
    const isHidden = advancedContainer.style.display === 'none';
    advancedContainer.style.display = isHidden ? 'block' : 'none';
    caret.style.transform = isHidden ? 'rotate(-90deg)' : 'rotate(0deg)';
  }
});

// Use Default Switch Mode Settings toggle
document.getElementById('useDefaultSwitchModeSettingsCheckbox').addEventListener('change', (e) => {
  const useDefault = e.target.checked;
  const advancedContainer = document.getElementById('advancedSwitchModeSettings');

  if (advancedContainer) {
    advancedContainer.style.display = useDefault ? 'none' : 'block';
  }

  // If switching to default, reset all switch mode settings to defaults
  if (useDefault) {
    // Reset box highlighting checkbox to enabled (default)
    const boxHighlightCheckbox = document.getElementById('boxHighlightingCheckbox');
    if (boxHighlightCheckbox) {
      boxHighlightCheckbox.checked = true;
      boxHighlightingEnabled = true;
    }

    // Reset box highlight color to default (yellow #ffff00)
    const boxHighlightColorPicker = document.getElementById('boxHighlightColorPicker');
    if (boxHighlightColorPicker) {
      boxHighlightColorPicker.value = '#ffff00';
      boxHighlightColor = 0xffff00;
    }

    // Reset box highlight opacity to default (15%)
    const boxHighlightOpacitySlider = document.getElementById('boxHighlightOpacitySlider');
    if (boxHighlightOpacitySlider) {
      boxHighlightOpacitySlider.value = '15';
      document.getElementById('boxHighlightOpacityValue').textContent = '15%';
      boxHighlightOpacity = 0.15;
    }

    // Reset component coloring to enabled (default)
    const componentColoringCheckbox = document.getElementById('componentColoringCheckbox');
    if (componentColoringCheckbox) {
      componentColoringCheckbox.checked = true;
      componentColoringEnabled = true;
    }

    // Reset show coord hover panel to disabled (default)
    const showCoordHoverCheckbox = document.getElementById('showCoordHoverPanelCheckbox');
    if (showCoordHoverCheckbox) {
      showCoordHoverCheckbox.checked = false;
    }

    // Reset hover vertices to enabled (default)
    const hoverVerticesCheckbox = document.getElementById('hoverVerticesCheckbox');
    if (hoverVerticesCheckbox) {
      hoverVerticesCheckbox.checked = true;
      hoverVertices = true;
    }

    // Reset hover edges to enabled (default)
    const hoverEdgesCheckbox = document.getElementById('hoverEdgesCheckbox');
    if (hoverEdgesCheckbox) {
      hoverEdgesCheckbox.checked = true;
      hoverEdges = true;
    }

    console.log('Switch mode settings reset to defaults');
  }
});

// Switch Mode Settings Header Click - Toggle expand/collapse
document.getElementById('switchModeSettingsHeader').addEventListener('click', (e) => {
  const advancedContainer = document.getElementById('advancedSwitchModeSettings');
  const caret = document.getElementById('switchModeSettingsCaret');

  if (advancedContainer && caret) {
    const isHidden = advancedContainer.style.display === 'none';
    advancedContainer.style.display = isHidden ? 'block' : 'none';
    caret.style.transform = isHidden ? 'rotate(-90deg)' : 'rotate(0deg)';
  }
});

// Use Default Vertex Settings toggle
document.getElementById('useDefaultVertexSettingsCheckbox').addEventListener('change', (e) => {
  const useDefault = e.target.checked;
  const advancedContainer = document.getElementById('advancedVertexSettings');

  if (advancedContainer) {
    advancedContainer.style.display = useDefault ? 'none' : 'block';
  }

  // If switching to default, reset all vertex settings to defaults
  if (useDefault) {
    // Reset vertex radius to default (0.12)
    const vertexRadiusSlider = document.getElementById('vertexRadiusSlider');
    if (vertexRadiusSlider) {
      vertexRadiusSlider.value = '0.12';
      document.getElementById('vertexRadiusValue').textContent = '0.12';
      vertexRadius = 0.12;
    }

    // Reset vertex dimmer to default (100)
    const vertexDimmerSlider = document.getElementById('vertexDimmerSlider');
    if (vertexDimmerSlider) {
      vertexDimmerSlider.value = '100';
      document.getElementById('vertexDimmerValue').textContent = '100';
      vertexDimmer = 1.0;
    }

    console.log('Vertex settings reset to defaults');
  }
});

// Vertex Settings Header Click - Toggle expand/collapse
document.getElementById('vertexSettingsHeader').addEventListener('click', (e) => {
  const advancedContainer = document.getElementById('advancedVertexSettings');
  const caret = document.getElementById('vertexSettingsCaret');

  if (advancedContainer && caret) {
    const isHidden = advancedContainer.style.display === 'none';
    advancedContainer.style.display = isHidden ? 'block' : 'none';
    caret.style.transform = isHidden ? 'rotate(-90deg)' : 'rotate(0deg)';
  }
});

// Use Default Edge Settings toggle
document.getElementById('useDefaultEdgeSettingsCheckbox').addEventListener('change', (e) => {
  const useDefault = e.target.checked;
  const advancedContainer = document.getElementById('advancedEdgeSettings');

  if (advancedContainer) {
    advancedContainer.style.display = useDefault ? 'none' : 'block';
  }

  // If switching to default, reset all edge settings to defaults
  if (useDefault) {
    // Reset thin edge radius to default (0.015)
    const thinEdgeSlider = document.getElementById('thinEdgeRadiusSlider');
    if (thinEdgeSlider) {
      thinEdgeSlider.value = '0.015';
      document.getElementById('thinEdgeRadiusValue').textContent = '0.015';
      thinEdgeRadius = 0.015;
    }

    // Reset thick edge radius to default (0.05)
    const thickEdgeSlider = document.getElementById('thickEdgeRadiusSlider');
    if (thickEdgeSlider) {
      thickEdgeSlider.value = '0.05';
      document.getElementById('thickEdgeRadiusValue').textContent = '0.05';
      thickEdgeRadius = 0.05;
    }

    // Reset edge decoration (block cube) size to default (0.12)
    const edgeDecoSlider = document.getElementById('edgeDecorationRadiusSlider');
    if (edgeDecoSlider) {
      edgeDecoSlider.value = '0.12';
      document.getElementById('edgeDecorationRadiusValue').textContent = '0.12';
      blockCubeSize = 0.12;
    }

    // Reset edge click radius to default (0.08)
    const edgeClickSlider = document.getElementById('edgeCollisionRadiusSlider');
    if (edgeClickSlider) {
      edgeClickSlider.value = '0.08';
      document.getElementById('edgeCollisionRadiusValue').textContent = '0.08';
      edgeCollisionRadius = 0.08;
    }

    // Reset arrow mode to default (normal)
    const arrowModeSelect = document.getElementById('arrowModeSelect');
    if (arrowModeSelect) {
      arrowModeSelect.value = 'normal';
      arrowMode = 'normal';
    }

    console.log('Edge settings reset to defaults');
  }
});

// Edge Settings Header Click - Toggle expand/collapse
document.getElementById('edgeSettingsHeader').addEventListener('click', (e) => {
  const advancedContainer = document.getElementById('advancedEdgeSettings');
  const caret = document.getElementById('edgeSettingsCaret');

  if (advancedContainer && caret) {
    const isHidden = advancedContainer.style.display === 'none';
    advancedContainer.style.display = isHidden ? 'block' : 'none';
    caret.style.transform = isHidden ? 'rotate(-90deg)' : 'rotate(0deg)';
  }
});

// Show on Main Screen settings are now always visible (no "use default" toggle)

// Use Default Other Display Settings toggle
document.getElementById('useDefaultOtherDisplaySettingsCheckbox').addEventListener('change', (e) => {
  const useDefault = e.target.checked;
  const advancedContainer = document.getElementById('advancedOtherDisplaySettings');

  if (advancedContainer) {
    advancedContainer.style.display = useDefault ? 'none' : 'block';
  }

  // If switching to default, reset all other display settings to defaults
  if (useDefault) {
    // Reset show flare button to disabled (default)
    const showFlareButtonCheckbox = document.getElementById('showFlareButtonCheckbox');
    if (showFlareButtonCheckbox) {
      showFlareButtonCheckbox.checked = false;
    }

    // Reset flare color to default (yellow #ffff00)
    const flareColorPicker = document.getElementById('flareColorPicker');
    if (flareColorPicker) {
      flareColorPicker.value = '#ffff00';
      flareColor = 0xffff00;
    }

    // Reset flare radius to default (0.7)
    const flareRadiusSlider = document.getElementById('flareRadiusSlider');
    if (flareRadiusSlider) {
      flareRadiusSlider.value = '0.7';
      document.getElementById('flareRadiusValue').textContent = '0.7';
      flareRadius = 0.7;
    }

    console.log('Other display settings reset to defaults');
  }
});

// Other Display Settings Header Click - Toggle expand/collapse
document.getElementById('otherDisplaySettingsHeader').addEventListener('click', (e) => {
  const advancedContainer = document.getElementById('advancedOtherDisplaySettings');
  const caret = document.getElementById('otherDisplaySettingsCaret');

  if (advancedContainer && caret) {
    const isHidden = advancedContainer.style.display === 'none';
    advancedContainer.style.display = isHidden ? 'block' : 'none';
    caret.style.transform = isHidden ? 'rotate(-90deg)' : 'rotate(0deg)';
  }
});

// LOD Enable/Disable toggle
// Note: This only validates and shows warnings. Actual application happens on "Save Preferences"
// Remove Vertex Limit toggle
document.getElementById('removeVertexLimitCheckbox').addEventListener('change', async (e) => {
  const newValue = e.target.checked;

  // Warn if trying to remove the limit
  if (newValue) {
    const proceed = await showVertexLimitWarning();

    if (!proceed) {
      // Revert checkbox
      e.target.checked = false;
      return;
    }
  }

  // Don't apply changes yet - wait for "Save Preferences"
  console.log(`Vertex limit will be ${newValue ? 'removed' : 'enabled'} when preferences are saved`);
});

document.getElementById('lodEnabledCheckbox').addEventListener('change', async (e) => {
  const newValue = e.target.checked;
  const oldValue = currentGrid?.lodState?.lodEnabled ?? lodEnabled;

  // Warn if disabling LOD on massive grid (≥1M vertices, where LOD is enabled by default)
  if (!newValue && oldValue && currentGrid) {
    const totalVertices = currentGrid.width * currentGrid.height * currentGrid.depth;

    // Only warn for massive grids (≥1M vertices)
    if (totalVertices >= 1000000) {
      const proceed = await showPerformanceWarning(
        `This grid has ${totalVertices.toLocaleString()} vertices. LOD is essential for grids of this size. Disabling it may cause severe performance issues or application unresponsiveness.<br><br>Do you want to proceed?`
      );

      if (!proceed) {
        // Revert checkbox
        e.target.checked = oldValue;
        return;
      }
    }
  }

  // Just show/hide distance controls for UI feedback
  const controls = document.getElementById('lodDistanceControls');
  if (controls) {
    controls.style.display = newValue ? 'block' : 'none';
  }

  // Don't apply changes yet - wait for "Save Preferences"
  console.log(`LOD will be ${newValue ? 'enabled' : 'disabled'} when preferences are saved`);
});

// Lazy Load Arrows toggle
document.getElementById('lazyLoadArrowsCheckbox').addEventListener('change', (e) => {
  lazyLoadArrows = e.target.checked;
  console.log(`Lazy load arrows ${lazyLoadArrows ? 'enabled' : 'disabled'}`);
});

// Lazy Load Switchable Boxes toggle
document.getElementById('lazyLoadSwitchableBoxesCheckbox').addEventListener('change', (e) => {
  lazyLoadSwitchableBoxes = e.target.checked;
  console.log(`Lazy load switchable boxes ${lazyLoadSwitchableBoxes ? 'enabled' : 'disabled'}`);
});

// Lazy Load Vertex Spheres toggle
document.getElementById('lazyLoadVertexSpheresCheckbox').addEventListener('change', (e) => {
  lazyLoadVertexSpheres = e.target.checked;
  console.log(`Lazy load vertex spheres ${lazyLoadVertexSpheres ? 'enabled' : 'disabled'}`);
});

// Lazy Load Edge Collision toggle
document.getElementById('lazyLoadEdgeCollisionCheckbox').addEventListener('change', (e) => {
  lazyLoadEdgeCollision = e.target.checked;
  console.log(`Lazy load edge collision ${lazyLoadEdgeCollision ? 'enabled' : 'disabled'}`);
});

// Lazy Load Block Cubes toggle
document.getElementById('lazyLoadBlockCubesCheckbox').addEventListener('change', (e) => {
  lazyLoadBlockCubes = e.target.checked;
  console.log(`Lazy load block cubes ${lazyLoadBlockCubes ? 'enabled' : 'disabled'}`);
});

// Use Default Lazy Loading toggle
document.getElementById('useDefaultLazyLoadingCheckbox').addEventListener('change', (e) => {
  const useDefault = e.target.checked;
  const settingsContainer = document.getElementById('lazyLoadingSettings');

  if (settingsContainer) {
    settingsContainer.style.display = useDefault ? 'none' : 'block';
  }

  // If switching to default, reset all lazy loading settings to defaults (all checked)
  if (useDefault) {
    document.getElementById('lazyLoadArrowsCheckbox').checked = true;
    lazyLoadArrows = true;

    document.getElementById('lazyLoadSwitchableBoxesCheckbox').checked = true;
    lazyLoadSwitchableBoxes = true;

    document.getElementById('lazyLoadVertexSpheresCheckbox').checked = true;
    lazyLoadVertexSpheres = true;

    document.getElementById('lazyLoadEdgeCollisionCheckbox').checked = true;
    lazyLoadEdgeCollision = true;

    document.getElementById('lazyLoadBlockCubesCheckbox').checked = true;
    lazyLoadBlockCubes = true;

    console.log('Lazy loading settings reset to defaults (all enabled)');
  }
});

// Lazy Loading Header Click - Toggle expand/collapse
document.getElementById('lazyLoadingHeader').addEventListener('click', (e) => {
  const settingsContainer = document.getElementById('lazyLoadingSettings');
  const caret = document.getElementById('lazyLoadingCaret');

  if (settingsContainer && caret) {
    const isHidden = settingsContainer.style.display === 'none';
    settingsContainer.style.display = isHidden ? 'block' : 'none';
    caret.style.transform = isHidden ? 'rotate(-90deg)' : 'rotate(0deg)';
  }
});

// Show All Vertices toggle
document.getElementById('showAllVerticesCheckbox').addEventListener('change', (e) => {
  if (!currentGrid) {
    console.log('[showAllVerticesCheckbox] No current grid!');
    return;
  }

  // Update the per-grid property
  currentGrid.showAllVertices = e.target.checked;

  // Load vertex spheres if needed and lazy loading is enabled
  if (currentGrid.showAllVertices && lazyLoadVertexSpheres && currentGrid.isInstanced) {
    let needsLoading = false;
    if (currentGrid.chunks && currentGrid.chunks.size > 0) {
      const firstChunk = currentGrid.chunks.values().next().value;
      if (!firstChunk.instancedVertexSpheres) {
        needsLoading = true;
      }
    }

    if (needsLoading) {
      loadVertexSpheres(currentGrid);
    }
  }

  // Update all vertex visibility immediately
  updateAllVerticesVisibility();

  // Trigger render to display changes immediately
  renderer.render(scene, camera);
});

// Frustum Culling toggle
// Note: This only validates and shows warnings. Actual application happens on "Save Preferences"
document.getElementById('frustumCullingCheckbox').addEventListener('change', async (e) => {
  const newValue = e.target.checked;
  const oldValue = frustumCullingEnabled;

  // Warn if disabling on large grid
  if (!newValue && oldValue && shouldWarnForPerformance(currentGrid)) {
    const totalVertices = currentGrid.width * currentGrid.height * currentGrid.depth;
    const proceed = await showPerformanceWarning(
      `This grid has ${totalVertices.toLocaleString()} vertices. Disabling frustum culling will render all chunks regardless of camera view, which may severely impact performance.<br><br>Do you want to proceed?`
    );

    if (!proceed) {
      // Revert checkbox
      e.target.checked = oldValue;
      return;
    }
  }

  // Don't apply changes yet - wait for "Save Preferences"
  console.log(`Frustum culling will be ${newValue ? 'enabled' : 'disabled'} when preferences are saved`);
});

// Spherical Culling toggle (when camera is inside grid)
// Note: This only validates and shows warnings. Actual application happens on "Save Preferences"
document.getElementById('sphericalCullingCheckbox').addEventListener('change', async (e) => {
  const newValue = e.target.checked;
  const oldValue = sphericalCullingEnabled;

  // Warn if disabling on large grid
  if (!newValue && oldValue && shouldWarnForPerformance(currentGrid)) {
    const totalVertices = currentGrid.width * currentGrid.height * currentGrid.depth;
    const proceed = await showPerformanceWarning(
      `This grid has ${totalVertices.toLocaleString()} vertices. Disabling spherical culling will render all chunks when inside the grid, which may significantly impact performance.<br><br>Do you want to proceed?`
    );

    if (!proceed) {
      // Revert checkbox
      e.target.checked = oldValue;
      return;
    }
  }

  // Don't apply changes yet - wait for "Save Preferences"
  console.log(`Spherical culling will be ${newValue ? 'enabled' : 'disabled'} when preferences are saved`);
});

// Surface Culling toggle (when camera is outside grid)
// Note: This only validates and shows warnings. Actual application happens on "Save Preferences"
document.getElementById('surfaceCullingCheckbox').addEventListener('change', async (e) => {
  const newValue = e.target.checked;
  const oldValue = surfaceCullingEnabled;

  // Warn if disabling on large grid
  if (!newValue && oldValue && shouldWarnForPerformance(currentGrid)) {
    const totalVertices = currentGrid.width * currentGrid.height * currentGrid.depth;
    const proceed = await showPerformanceWarning(
      `This grid has ${totalVertices.toLocaleString()} vertices. Disabling surface culling will render all chunks when outside the grid, which may significantly impact performance.<br><br>Do you want to proceed?`
    );

    if (!proceed) {
      // Revert checkbox
      e.target.checked = oldValue;
      return;
    }
  }

  // Don't apply changes yet - wait for "Save Preferences"
  console.log(`Surface culling will be ${newValue ? 'enabled' : 'disabled'} when preferences are saved`);
});

// Chunk Size input
document.getElementById('chunkSizeInput').addEventListener('change', (e) => {
  preferredChunkSize = parseInt(e.target.value) || 10;
  console.log(`Chunk size set to ${preferredChunkSize} (rebuild grid to apply)`);
});

// Max Chunk Rebuilds per Frame input
document.getElementById('maxRebuildsInput').addEventListener('change', (e) => {
  lodMaxChunkRebuildsPerFrame = parseInt(e.target.value) || 2;
  console.log(`Max chunk rebuilds per frame set to ${lodMaxChunkRebuildsPerFrame}`);
});

// Render Radius dropdown (in chunks)
document.getElementById('renderRadiusSelect').addEventListener('change', (e) => {
  renderRadiusChunks = parseInt(e.target.value) || 2;
  console.log(`Render radius set to ${renderRadiusChunks} chunks`);
});

// Surface Depth dropdown (near faces)
document.getElementById('surfaceDepthSelect').addEventListener('change', (e) => {
  const depth = parseInt(e.target.value) || 1;

  console.log(`Surface depth (near) set to ${depth} chunks`);

  // Update current grid's surface depth if it exists
  if (currentGrid && currentGrid.lodState) {
    currentGrid.lodState.surfaceDepth = depth;
  }

  // Update global default for future grids
  surfaceDepth = depth;
});

// Optimize Rendering button
const optimizeBtn = document.getElementById('optimizeRenderingBtn');
optimizeBtn.addEventListener('click', () => {
  if (!currentGrid) {
    alert('Please generate a grid first before optimizing settings.');
    return;
  }

  const triangleBudgetInput = document.getElementById('optimizeTriangleBudget');
  const targetTriangles = parseFloat(triangleBudgetInput.value) || 15;

  console.log(`[Optimizer] Running optimization for ${currentGrid.width}x${currentGrid.height}x${currentGrid.depth} grid with ${targetTriangles}M triangle budget`);

  // Run optimization
  const settings = optimizeRenderingSettings(
    currentGrid.width,
    currentGrid.height,
    currentGrid.depth,
    targetTriangles
  );

  // Apply settings
  applyOptimizedSettings(settings);
});

// Add hover effect
optimizeBtn.addEventListener('mouseenter', () => {
  optimizeBtn.style.background = '#2980b9';
});
optimizeBtn.addEventListener('mouseleave', () => {
  optimizeBtn.style.background = '#3498db';
});

// Far Culling Depth dropdown (back faces)
document.getElementById('farCullingDepthSelect').addEventListener('change', (e) => {
  const depth = parseInt(e.target.value) || 0;

  console.log(`Far culling depth set to ${depth} chunks`);

  // Update current grid's far culling depth if it exists
  if (currentGrid && currentGrid.lodState) {
    currentGrid.lodState.farCullingDepth = depth;
  }

  // Update global default for future grids
  farCullingDepth = depth;
});

// LOD Performance Indicators toggle
document.getElementById('lodIndicatorsCheckbox').addEventListener('change', (e) => {
  const showIndicators = e.target.checked;
  const fpsCounter = document.getElementById('fpsCounter');
  if (fpsCounter) {
    fpsCounter.style.display = showIndicators ? 'block' : 'none';
  }
  console.log(`LOD performance indicators ${showIndicators ? 'shown' : 'hidden'}`);
});

// LOD Quality slider handler - calculates all thresholds from single value
document.getElementById('lodQualitySlider').addEventListener('input', (e) => {
  const fullDetailDistance = parseInt(e.target.value);

  // Calculate other thresholds based on full detail distance
  // LOD 3 (full detail) at base distance
  // LOD 2 (reduced) at 1.5x the full detail distance
  // LOD 1 (lines) at 2x the full detail distance
  lodDistanceThresholds.lod3 = fullDetailDistance;
  lodDistanceThresholds.lod2 = Math.round(fullDetailDistance * 1.5);
  lodDistanceThresholds.lod1 = Math.round(fullDetailDistance * 2);
});


function openReadmeInNewTab() {
  const readmeHTML = `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GridLab - README</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 900px;
      margin: 0 auto;
      padding: 40px 20px;
      background: #f8f9fa;
    }
    .container {
      background: white;
      padding: 40px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    h1 {
      color: #2c3e50;
      border-bottom: 3px solid #3498db;
      padding-bottom: 10px;
      margin-top: 0;
    }
    h2 {
      color: #2c3e50;
      margin-top: 30px;
      font-size: 24px;
    }
    h3 {
      color: #34495e;
      margin-top: 20px;
      font-size: 18px;
    }
    h4 {
      color: #2c3e50;
      margin-top: 15px;
      font-size: 16px;
    }
    hr {
      border: none;
      border-top: 2px solid #eee;
      margin: 30px 0;
    }
    ul, ol {
      margin: 10px 0 10px 20px;
    }
    li {
      margin: 5px 0;
    }
    strong {
      color: #2c3e50;
      font-weight: 600;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }
    table th {
      background: #f0f0f0;
      padding: 12px;
      text-align: left;
      border: 1px solid #ddd;
      font-weight: 600;
    }
    table td {
      padding: 10px 12px;
      border: 1px solid #ddd;
    }
    .footer {
      text-align: center;
      color: #7f8c8d;
      font-style: italic;
      margin-top: 40px;
      padding-top: 20px;
      border-top: 2px solid #eee;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>GridLab</h1>
    <p><strong>Interactive 3D Hamiltonian Path & Cycle Generator</strong></p>
    <p>GridLab is a browser-based research tool for generating, visualizing, and manipulating Hamiltonian paths and cycles on 3D lattice grids. Built with Three.js and optimized for scalability, it enables exploration of Hamiltonian structures on grids with up to ~1.5 million vertices.</p>

    <hr>

    <h2>Key Features</h2>

    <h3>Core Functionality</h3>
    <ul>
      <li><strong>Hamiltonian Path/Cycle Generation:</strong> Generate spanning paths and cycles on arbitrary 3D grids using optimized backbite algorithms</li>
      <li><strong>Backbite Mode:</strong> Click edges to perform backbite transformations and explore the space of Hamiltonian paths interactively</li>
      <li><strong>Switch Mode:</strong> Use cursor hover to identify switchable boxes and click to perform a switch move</li>
      <li><strong>Grid Editing Tools:</strong> Add/remove edges, vertices, decorations, and layers with full undo/redo support extending to backbite and switch moves</li>
      <li><strong>Interactive 3D Visualization:</strong> Rotate, pan, and zoom with smooth camera controls</li>
      <li><strong>Additional Functionality:</strong> Grid notes, subgraph component analysis, camera position tracking, flare for endpoint location, and comprehensive display customization options</li>
    </ul>

    <h3>Performance & Scalability</h3>
    <ul>
      <li><strong>Chunked Instanced Rendering:</strong> Refactored geometry system enables efficient rendering of massive grids (tested up to 100×100×100)</li>
      <li><strong>Advanced Culling:</strong> Frustum culling, surface culling, spherical culling, and progressive LOD improve performance on large grids</li>
      <li><strong>Treap Data Structures:</strong> O(log N) path reversals during generation reduce backbite computation time on large grids</li>
      <li><strong>Lazy Object Loading:</strong> Arrows, vertices, collision meshes, and decorations load on-demand</li>
      <li><strong>Numerical Key System:</strong> Replaced string-based keys with numerical keys for improved computational efficiency</li>
      <li><strong>Rendering Optimizer:</strong> Configure culling and LOD settings to target specific triangle budgets for optimal FPS</li>
    </ul>

    <h3>Display & Customization</h3>
    <ul>
      <li><strong>Gradient Coloring:</strong> Apply smooth color gradients along paths for enhanced visualization</li>
      <li><strong>Directional Arrows:</strong> Overlay arrows on path edges to show traversal direction</li>
      <li><strong>Light/Dark Themes:</strong> Automatic time-based switching or manual theme selection</li>
      <li><strong>Multi-Grid Workspace:</strong> Create, duplicate, and switch between multiple grids in a single session</li>
      <li><strong>Save/Load System:</strong> Persist entire workspace including grids, paths, colors, and UI state to JSON</li>
      <li><strong>2D Grid Mode:</strong> Special camera controls for grids with one dimension = 1 (pan/zoom without rotation)</li>
    </ul>

    <h3>Advanced Tools</h3>
    <ul>
      <li><strong>Subgraph Data:</strong> Real-time component data identifying paths, cycles, trees, and lattice animals</li>
      <li><strong>Undo/Redo:</strong> Full history tracking for all path modifications, backbite moves, and switch operations</li>
    </ul>

    <hr>

    <h2>Quick Start</h2>
    <ol>
      <li><strong>Open GridLab:</strong> Open the HTML file in a modern browser (Chrome, Firefox, Edge recommended)</li>
      <li><strong>Create a Grid:</strong> Set dimensions (e.g., 10×10×10) and click "Add Grid"</li>
      <li><strong>Generate Path:</strong> Click "Generate Hamiltonian Path" to create a spanning path</li>
      <li><strong>Explore:</strong>
        <ul>
          <li>Use mouse to rotate/pan/zoom the camera</li>
          <li>Click "Backbite Mode" and click on edges to perform manual transformations</li>
          <li>Press <strong>T</strong> to reverse path direction and toggle active endpoint</li>
          <li>Enable arrows or gradient for better visualization</li>
        </ul>
      </li>
    </ol>

    <hr>

    <h2>Controls & Shortcuts</h2>

    <h3>Mouse Controls</h3>
    <ul>
      <li><strong>Left Click + Drag:</strong> Rotate camera around grid</li>
      <li><strong>Right Click + Drag:</strong> Pan camera</li>
      <li><strong>Scroll Wheel:</strong> Zoom in/out</li>
      <li><strong>Click Edge</strong> (in Backbite Mode): Perform manual backbite transformation</li>
    </ul>

    <h3>Keyboard Shortcuts</h3>
    <ul>
      <li><strong>T:</strong> Toggle path direction (reverse path and swap active endpoint)</li>
      <li><strong>ESC:</strong> Stop generation process</li>
      <li><strong>Arrow Keys / PgUp / PgDn:</strong> Navigate switchable boxes (in Switch Mode)</li>
    </ul>

    <hr>

    <h2>Generation Algorithms</h2>

    <h3>Hamiltonian Path Generation</h3>
    <p>GridLab uses a <strong>backbite-based Markov chain algorithm</strong> optimized with <a href="https://cp-algorithms.com/data_structures/treap.html" target="_blank" style="color: #3498db; text-decoration: underline;">treap</a> data structures:</p>

    <ol>
      <li>Start with an arbitrary initial path</li>
      <li>Repeatedly apply random backbite moves:
        <ul>
          <li>Choose a random endpoint (head or tail)</li>
          <li>Select a non-adjacent neighbor on the path</li>
          <li>Reverse the segment between endpoint and neighbor</li>
        </ul>
      </li>
      <li>Continue until path exhibits desired properties or mixing threshold reached</li>
    </ol>

    <h4>Complexity</h4>
    <p>The backbite operation itself runs in <strong>O(log N)</strong> using treap data structures - a highly efficient feature that enables fast transformations even on massive grids. The N factor in the complexity below represents the number of backbite moves we perform to ensure good mixing of the Markov chain, not the computational cost per move. A larger constant would work fine; we chose these values to ensure reliable mixing:</p>

    <ul>
      <li><strong>3D Grids:</strong> 10N·log(N) where N = total vertices (10N moves, each taking O(log N) time)</li>
      <li><strong>2D Grids:</strong> Adaptive (10N to 0.5N<sup>3/2</sup>)·log(N) based on grid aspect ratio</li>
    </ul>

    <h4>Timing</h4>
    <ul>
      <li>Small grids (5×5×5): Instant</li>
      <li>Medium grids (50×50×50): Few seconds</li>
      <li>Large grids (100×100×100): 1-3 minutes</li>
    </ul>

    <hr>

    <h2>Performance Guidelines</h2>

    <h3>Recommended Settings by Grid Size</h3>
    <p>For grids larger than 50³, we recommend enabling all culling systems for optimal performance. For very large grids (300,000+ vertices), use the Rendering Optimizer or enable Progressive LOD to maintain smooth frame rates.</p>

    <h3>Hardware Considerations</h3>
    <ul>
      <li><strong>GPU:</strong> Rendering performance is the primary bottleneck on very large grids</li>
      <li><strong>RAM:</strong> Memory requirements scale with grid size. For typical grids (under 30×30×30), memory is not a concern. Large grids with 1M+ vertices may require 4GB+ available memory depending on your system.</li>
      <li><strong>Browser:</strong> Chrome and Edge generally provide best WebGL performance</li>
    </ul>

    <hr>

    <h2>Under the Hood</h2>

    <h3>Rendering System</h3>
    <ul>
      <li><strong>Instanced Meshes:</strong> All geometry uses <code>THREE.InstancedMesh</code> for GPU efficiency</li>
      <li><strong>Chunking:</strong> Large grids split into spatial chunks that enable the deployment of culling and LOD systems</li>
      <li><strong>Culling Systems:</strong>
        <ul>
          <li>Frustum Culling: Renders only visible chunks</li>
          <li>Surface Culling: Hides interior geometry</li>
          <li>Spherical Culling: Guarantees full rendering within a fixed radius with peek-inside feature</li>
        </ul>
      </li>
      <li><strong>LOD Levels:</strong>
        <ul>
          <li>Level 3: Full geometry (cylinders for edges, spheres for vertices)</li>
          <li>Level 2: Reduced segment count</li>
          <li>Level 1: Further reduced detail</li>
          <li>Level 0: Line geometry only</li>
        </ul>
      </li>
    </ul>

    <h3>Data Structures</h3>
    <ul>
      <li><strong>HamiltonianPath (Treap):</strong> Self-balancing binary search tree for O(log N) reversals</li>
      <li><strong>Subgraph:</strong> Uses adjacency maps and BFS for component analysis, identifying paths, cycles, trees, and lattice animals</li>
      <li><strong>Vertex/Edge Keys:</strong> Numerical encoding for memory efficiency and fast lookups</li>
    </ul>

    <h3>Path Storage</h3>
    <ul>
      <li><strong>Array Format:</strong> Paths stored as arrays of numerical vertex keys</li>
      <li><strong>Undo System:</strong> Stack-based history with configurable depth</li>
      <li><strong>JSON Export:</strong> Full state serialization including grids, paths, and UI settings</li>
    </ul>

    <hr>

    <h2>Research Applications</h2>
    <p>GridLab is designed for:</p>
    <ul>
      <li><strong>Hamiltonian Path Research:</strong> Exploring properties of Hamiltonian structures on lattices</li>
      <li><strong>Lattice Graph Theory:</strong> Investigating subgraph structures and connectivity</li>
      <li><strong>Statistical Sampling:</strong> Generating diverse samples of Hamiltonian paths for analysis</li>
    </ul>

    <hr>

    <h2>Browser Compatibility</h2>
    <p><strong>Recommended:</strong> Chrome 90+, Edge 90+, Firefox 88+</p>
    <p><strong>Requirements:</strong></p>
    <ul>
      <li>WebGL 2.0 support</li>
      <li>ES6+ JavaScript support</li>
      <li>Hardware acceleration enabled</li>
    </ul>

    <hr>

    <h2>Limitations</h2>
    <ul>
      <li><strong>Maximum Grid Size:</strong> No hard limit - depends on your hardware capabilities. Successfully tested up to ~1.5M vertices on a Lenovo ThinkPad T16 Gen 3 (Intel Core Ultra 7 155U, 16GB RAM). Performance scales with GPU capability and available system memory.</li>
      <li><strong>2D Grid Restrictions:</strong> Camera controls simplified for grids with one dimension = 1</li>
      <li><strong>Save File Size:</strong> Very large grids produce large JSON files (100MB+ for 1M vertices)</li>
      <li><strong>Mobile:</strong> Not optimized for mobile devices; desktop browsers strongly recommended</li>
    </ul>

    <hr>

    <h2>Version History</h2>

    <h3>v3.0 (December 2024)</h3>
    <ul>
      <li>Complete chunked instanced rendering system</li>
      <li>Advanced culling (frustum, surface, spherical, progressive LOD)</li>
      <li>Rendering optimizer with configurable triangle budgets</li>
      <li>Numerical key refactor for improved efficiency</li>
      <li>Lazy object loading system</li>
      <li>Subgraph data panel with component analysis</li>
      <li>Performance monitor (FPS, frame time, visible chunks, LOD level)</li>
      <li>Flare button for endpoint location</li>
      <li>Dual arrow system (normal + transcendent)</li>
    </ul>

    <h3>v2.1 (November 2024)</h3>
    <ul>
      <li>Treap data structures for O(log N) path reversals</li>
      <li>Enhanced LOD system</li>
      <li>Improved camera controls</li>
      <li>Grid opacity controls</li>
    </ul>

    <h3>v1.0 (October 2024)</h3>
    <ul>
      <li>Initial release</li>
      <li>Basic Hamiltonian path generation</li>
      <li>3D visualization</li>
      <li>Manual and automated backbite modes</li>
    </ul>

    <hr>

    <h2>License</h2>
    <p>See <code>GridLab Licencing Reference</code> for licensing information.</p>

    <hr>

    <h2>Credits</h2>
    <p><strong>Author:</strong> Albi Kazazi<br>
    <strong>Built With:</strong> <a href="https://threejs.org/" target="_blank" style="color: #3498db;">Three.js</a> r167<br>
    <strong>Inspired By:</strong> Hamiltonian path research</p>

    <hr>

    <h2>Support & Feedback</h2>
    <p>For bug reports, feature requests, or questions:<br>
    Email: <a href="mailto:albijuventus@yahoo.com" style="color: #3498db;">albijuventus@yahoo.com</a></p>

    <div class="footer">
      <p><strong>GridLab</strong> - Explore the space of Hamiltonian paths</p>
    </div>
  </div>
</body>
</html>
  `;
  
  const newWindow = window.open();
  newWindow.document.write(readmeHTML);
  newWindow.document.close();
  console.log("README opened in new tab");
}







//     ====================================================================================================================
// 										  8. ONCLICK, ONMOUSEMOVE AND RELATED FUNCTIONS
//     ====================================================================================================================

// Helper function to check if click is within sidebar bounds
function isClickInUIArea(clientX, clientY) {
  const leftSidebar = document.querySelector('.sidebar');
  const rightSidebar = document.querySelector('.sidebar-right');
  const gridListContainer = document.getElementById('gridListContainer');

  // Check left sidebar (only if not collapsed)
  if (leftSidebar && !leftSidebar.classList.contains('collapsed')) {
    const leftRect = leftSidebar.getBoundingClientRect();
    if (clientX <= leftRect.right) {
      return true;
    }
  }

  // Check right sidebar (only if not collapsed)
  if (rightSidebar && !rightSidebar.classList.contains('collapsed')) {
    const rightRect = rightSidebar.getBoundingClientRect();
    if (clientX >= rightRect.left) {
      return true;
    }
  }

  // Check grid tabs container at bottom
  if (gridListContainer) {
    const gridRect = gridListContainer.getBoundingClientRect();
    if (clientX >= gridRect.left && clientX <= gridRect.right &&
        clientY >= gridRect.top && clientY <= gridRect.bottom) {
      return true;
    }
  }

  return false;
}

function onClick(event) {
  // Don't process 3D clicks if clicking within UI areas (sidebars or grid tabs)
  if (isClickInUIArea(event.clientX, event.clientY)) {
    return;
  }

  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);

  if (!currentGrid) return;

  // Edge and vertex clicks are now handled exclusively by mouseDown/mouseUp flow
  // onClick only handles modes that don't use the mouseDown/mouseUp system
  
  switch(mode) {
    case "backbite":
      handleBackbiteClick();
      break;
    // NOTE: switch mode now handled by mouseDown/mouseUp system
    // addEdge, addCube, addVertex, and addDecoration cases removed - handled by mouseDown/mouseUp
    default:
      break;
  }
}


function handleInstancedEdgeClick(hits, meshType) {
  const instanceId = hits[0].instanceId;
  
  // Find edge key by checking all mappings (reverse lookup)
  let clickedEdgeKey = null;
  for (const [eKey, mapping] of currentGrid.edgeToInstanceMap.entries()) {
    if ((meshType === 'thin' && mapping.thin === instanceId) ||
        (meshType === 'thick' && mapping.thick === instanceId)) {
      clickedEdgeKey = eKey;
      break;
    }
  }
  
  if (!clickedEdgeKey) {
    return;
  }
  
  const [a, b] = unpackEdge(clickedEdgeKey);
  
  const edge = currentGrid.edges.get(clickedEdgeKey);
  
  // Capture state for undo
  const beforeState = captureEdgeState(clickedEdgeKey);
  
  // Toggle color
  const newColor = edge.color === selectedColor ? UNCOLORED_COLOR : selectedColor;
  
  colorEdgeInstanced(currentGrid, a, b, newColor, newColor === UNCOLORED_COLOR ? thinEdgeRadius : thickEdgeRadius);
  
  // Handle activeSubgraph maintenance
  if (newColor !== UNCOLORED_COLOR) {
    if (!currentGrid.activeSubgraph) {
      currentGrid.activeSubgraph = new Subgraph(currentGrid);
    }
    currentGrid.activeSubgraph.addEdge(a, b);
  } else {
    if (currentGrid.activeSubgraph) {
      currentGrid.activeSubgraph.removeEdge(a, b);
    }
  }
  
  const afterState = captureEdgeState(clickedEdgeKey);
  recordAction('EDGE_STATE', { edgeKey: clickedEdgeKey, beforeState, afterState });
  
  // IMPORTANT: If this edge was being hovered, we need to update the visual to match the new color
  // because the hover system may have applied cyan highlight
  if (currentGrid.instancedHoverState && currentGrid.instancedHoverState.edgeKey === clickedEdgeKey) {
    // Force restore the actual new color (removes cyan highlight)
    const mapping = currentGrid.edgeToInstanceMap.get(clickedEdgeKey);
    const isColored = newColor !== UNCOLORED_COLOR;
    const mesh = isColored ? currentGrid.instancedEdgesThick : currentGrid.instancedEdgesThin;
    const instanceIdx = isColored ? mapping.thick : mapping.thin;
    
    const actualColor = new THREE.Color(newColor);
    mesh.setColorAt(instanceIdx, actualColor);
    mesh.instanceColor.needsUpdate = true;
  }
  
  // Clear hover state after click
  if (currentGrid.instancedHoverState) {
    currentGrid.instancedHoverState.edgeKey = null;
    currentGrid.instancedHoverState.originalColor = null;
  }
}



function onMouseDown(event) {
  // Don't process 3D clicks if clicking within UI areas (sidebars or grid tabs)
  if (isClickInUIArea(event.clientX, event.clientY)) {
    return;
  }

  if (!currentGrid) return;

  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  
  // Store what was clicked on mousedown based on current mode
  switch(mode) {
    case "addEdge":
    case "addCube":
      // Handle instanced edges separately
      if (currentGrid.isInstanced) {
        // Check if we have chunks (multi-chunk grid) or global meshes (single-chunk)
        if (currentGrid.chunks && currentGrid.chunks.size > 0) {
          // Iterate all chunks and find closest edge hit
          let closestHit = null;
          let closestDistance = Infinity;
          let closestChunkKey = null;

          for (const [chunkKey, chunk] of currentGrid.chunks.entries()) {
            const edgeMesh = unifiedEdgeSize ? chunk.instancedEdgesThin : chunk.instancedEdgesCollision;
            if (edgeMesh) {
              const collisionHits = raycaster.intersectObject(edgeMesh);
              if (collisionHits.length > 0 && collisionHits[0].distance < closestDistance) {
                closestHit = collisionHits[0];
                closestDistance = closestHit.distance;
                closestChunkKey = chunkKey;
              }
            }
          }

          if (closestHit) {
            const instanceId = closestHit.instanceId;
            const chunk = currentGrid.chunks.get(closestChunkKey);
            const edgeToInstanceMap = chunk ? chunk.edgeToInstanceMap : null;
            if (edgeToInstanceMap) {
              for (const [eKey, mapping] of edgeToInstanceMap.entries()) {
                if (mapping.thin === instanceId) {
                  mouseDownTarget = eKey;
                  mouseDownType = 'edge';
                  break;
                }
              }
            }
          }
        } else {
          // Fallback for single-chunk grids (backwards compatibility)
          const edgeMesh = unifiedEdgeSize ? currentGrid.instancedEdgesThin : currentGrid.instancedEdgesCollision;
          if (edgeMesh) {
            const collisionHits = raycaster.intersectObject(edgeMesh);

            if (collisionHits.length > 0) {
              const instanceId = collisionHits[0].instanceId;
              // Find edge key using thin/collision index
              for (const [eKey, mapping] of currentGrid.edgeToInstanceMap.entries()) {
                if (mapping.thin === instanceId) {
                  mouseDownTarget = eKey;
                  mouseDownType = 'edge';
                  break;
                }
              }
            }
          }
        }
      } else {
        // Individual edge mode - filter out nulls
        const edgeMeshes = Array.from(currentGrid.edges.values())
          .map(e => e.mesh)
          .filter(m => m !== null && m !== undefined);
        const edgeIntersects = raycaster.intersectObjects(edgeMeshes);
        if (edgeIntersects.length > 0) {
          // Find the edge key
          for (const [key, edge] of currentGrid.edges.entries()) {
            if (edge.mesh === edgeIntersects[0].object) {
              mouseDownTarget = key;
              mouseDownType = 'edge';
              break;
            }
          }
        }
      }
      break;
      
    case "addVertex":
    case "addDecoration":
      // Temporarily disable raycasting on ALL edge meshes (both modes)
      const edgeRaycastBackups = [];

      if (currentGrid.isInstanced) {
        // Check if we have chunks (multi-chunk grid)
        if (currentGrid.chunks && currentGrid.chunks.size > 0) {
          // Disable raycasting on all chunk edge meshes
          for (const chunk of currentGrid.chunks.values()) {
            if (chunk.instancedEdgesThin) {
              edgeRaycastBackups.push({ obj: chunk.instancedEdgesThin, fn: chunk.instancedEdgesThin.raycast });
              chunk.instancedEdgesThin.raycast = () => {};
            }
            if (chunk.instancedEdgesThick) {
              edgeRaycastBackups.push({ obj: chunk.instancedEdgesThick, fn: chunk.instancedEdgesThick.raycast });
              chunk.instancedEdgesThick.raycast = () => {};
            }
            if (chunk.instancedEdgesCollision) {
              edgeRaycastBackups.push({ obj: chunk.instancedEdgesCollision, fn: chunk.instancedEdgesCollision.raycast });
              chunk.instancedEdgesCollision.raycast = () => {};
            }
          }
        } else {
          // Disable global instanced meshes (single-chunk)
          if (currentGrid.instancedEdgesThin) {
            edgeRaycastBackups.push({ obj: currentGrid.instancedEdgesThin, fn: currentGrid.instancedEdgesThin.raycast });
            currentGrid.instancedEdgesThin.raycast = () => {};
          }
          if (currentGrid.instancedEdgesThick) {
            edgeRaycastBackups.push({ obj: currentGrid.instancedEdgesThick, fn: currentGrid.instancedEdgesThick.raycast });
            currentGrid.instancedEdgesThick.raycast = () => {};
          }
          if (currentGrid.instancedEdgesCollision) {
            edgeRaycastBackups.push({ obj: currentGrid.instancedEdgesCollision, fn: currentGrid.instancedEdgesCollision.raycast });
            currentGrid.instancedEdgesCollision.raycast = () => {};
          }
        }
        // Disable raycasting on block cubes (both chunk and global)
        if (currentGrid.chunks && currentGrid.chunks.size > 0) {
          for (const chunk of currentGrid.chunks.values()) {
            if (chunk.instancedBlockCubes) {
              edgeRaycastBackups.push({ obj: chunk.instancedBlockCubes, fn: chunk.instancedBlockCubes.raycast });
              chunk.instancedBlockCubes.raycast = () => {};
            }
          }
        } else if (currentGrid.instancedBlockCubes) {
          edgeRaycastBackups.push({ obj: currentGrid.instancedBlockCubes, fn: currentGrid.instancedBlockCubes.raycast });
          currentGrid.instancedBlockCubes.raycast = () => {};
        }
      } else {
        // Disable individual edge meshes
        for (const [eKey, edge] of currentGrid.edges.entries()) {
          if (edge.mesh) {
            edgeRaycastBackups.push({ obj: edge.mesh, fn: edge.mesh.raycast });
            edge.mesh.raycast = () => {};
          }
        }
      }

      // Force update world matrices
      currentGrid.group.updateMatrixWorld(true);

      // Get vertex collision helpers - use instanced if available
      let vertexHelpers = [];
      if (useInstancedRendering && currentGrid.isInstanced) {
        // Check for chunks
        if (currentGrid.chunks && currentGrid.chunks.size > 0) {
          for (const chunk of currentGrid.chunks.values()) {
            if (chunk.instancedVertexCollisionHelpers) {
              vertexHelpers.push(chunk.instancedVertexCollisionHelpers);
            }
          }
        } else if (currentGrid.instancedVertexCollisionHelpers) {
          vertexHelpers = [currentGrid.instancedVertexCollisionHelpers];
        }
      } else {
        // Non-instanced mode: collect individual collision helpers
        for (const [vKey, vertexData] of currentGrid.vertices.entries()) {
          if (vertexData.collisionHelper) {
            vertexHelpers.push(vertexData.collisionHelper);
          }
        }
      }

      // Raycast against collision helpers and find closest
      let closestVertexHit = null;
      let closestVertexChunkKey = null;
      let closestVertexDistance = Infinity;

      for (let i = 0; i < vertexHelpers.length; i++) {
        const hits = raycaster.intersectObject(vertexHelpers[i], false);
        if (hits.length > 0 && hits[0].distance < closestVertexDistance) {
          closestVertexHit = hits[0];
          closestVertexDistance = hits[0].distance;
          // Track which chunk this hit came from (for multi-chunk)
          if (currentGrid.chunks && currentGrid.chunks.size > 0) {
            const chunkKeys = Array.from(currentGrid.chunks.keys());
            closestVertexChunkKey = chunkKeys[i];
          }
        }
      }

      // Restore raycasting on all edge meshes
      for (const backup of edgeRaycastBackups) {
        backup.obj.raycast = backup.fn;
      }

      if (closestVertexHit) {
        const hit = closestVertexHit;
        let vertexKey = null;

        if (hit.instanceId != null) {
          // Instanced mode: map instance ID to vertex key using chunk's mapping
          if (closestVertexChunkKey && currentGrid.chunks) {
            const chunk = currentGrid.chunks.get(closestVertexChunkKey);
            if (chunk && chunk.vertexToInstanceMap) {
              for (const [vKey, instanceIdx] of chunk.vertexToInstanceMap.entries()) {
                if (instanceIdx === hit.instanceId) {
                  vertexKey = vKey;
                  break;
                }
              }
            }
          } else if (currentGrid.vertexToInstanceMap) {
            // Single-chunk fallback
            for (const [vKey, instanceIdx] of currentGrid.vertexToInstanceMap.entries()) {
              if (instanceIdx === hit.instanceId) {
                vertexKey = vKey;
                break;
              }
            }
          }
        } else {
          // Non-instanced mode: get vertex key from userData
          vertexKey = hit.object.userData.vertexKey;
        }

        if (vertexKey !== null && vertexKey !== undefined) {
          mouseDownTarget = vertexKey;
          mouseDownType = 'vertex';
        }
      }
      break;
      
    case "switch":
      const allMeshes = getFilteredBoxMeshes();
      const boxIntersects = raycaster.intersectObjects(allMeshes);
      if (boxIntersects.length > 0) {
        const hit = boxIntersects[0];
        let box = null;
        
        if (currentGrid.isInstanced && hit.instanceId != null) {
          // Instanced mode
          const obj = hit.object;
          if (obj === currentGrid.instancedBoxesXY) box = currentGrid.instancesXY?.[hit.instanceId];
          else if (obj === currentGrid.instancedBoxesXZ) box = currentGrid.instancesXZ?.[hit.instanceId];
          else if (obj === currentGrid.instancedBoxesYZ) box = currentGrid.instancesYZ?.[hit.instanceId];
        } else {
          // Non-instanced: search the Maps
          box = hit.object?.userData?.box;
          if (!box) {
            for (const [key, b] of [...currentGrid.boxesXY, ...currentGrid.boxesXZ, ...currentGrid.boxesYZ]) {
              if (b.mesh === hit.object) {
                box = b;
                if (box) {
                  mouseDownTarget = box;
                  mouseDownType = 'box';
                  console.log('MOUSEDOWN: Captured box', box.coords, box.plane);
                }
                break;
              }
            }
          }
        }
        
        if (box) {
          mouseDownTarget = box;
          mouseDownType = 'box';
        }
      }
      break;
  }
}

function onMouseUp(event) {
  // Don't process 3D clicks if clicking within UI areas (sidebars or grid tabs)
  if (isClickInUIArea(event.clientX, event.clientY)) {
    mouseDownTarget = null;
    mouseDownType = null;
    return;
  }

  if (!currentGrid || !mouseDownTarget) {
    mouseDownTarget = null;
    mouseDownType = null;
    return;
  }

  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  
  let mouseUpTarget = null;
  
  // Find what was released on based on the stored type
  switch(mouseDownType) {
    case 'edge':
      // Handle instanced edges separately
      if (currentGrid.isInstanced) {
        // Check if we have chunks (multi-chunk grid) or global meshes (single-chunk)
        if (currentGrid.chunks && currentGrid.chunks.size > 0) {
          // Iterate all chunks and find closest edge hit
          let closestHit = null;
          let closestDistance = Infinity;
          let closestChunkKey = null;

          for (const [chunkKey, chunk] of currentGrid.chunks.entries()) {
            // SLEDGEHAMMER: Use thin mesh for collision in unified mode
            const edgeMesh = unifiedEdgeSize ? chunk.instancedEdgesThin : chunk.instancedEdgesCollision;
            if (edgeMesh) {
              const collisionHits = raycaster.intersectObject(edgeMesh);
              if (collisionHits.length > 0 && collisionHits[0].distance < closestDistance) {
                closestHit = collisionHits[0];
                closestDistance = closestHit.distance;
                closestChunkKey = chunkKey;
              }
            }
          }

          if (closestHit) {
            const instanceId = closestHit.instanceId;
            const chunk = currentGrid.chunks.get(closestChunkKey);
            const edgeToInstanceMap = chunk ? chunk.edgeToInstanceMap : currentGrid.edgeToInstanceMap;
            // Find edge key using thin/collision index
            for (const [eKey, mapping] of edgeToInstanceMap.entries()) {
              if (mapping.thin === instanceId) {
                mouseUpTarget = eKey;
                break;
              }
            }
          }
        } else {
          // Fallback for single-chunk grids (backwards compatibility)
          // SLEDGEHAMMER: Use thin mesh for collision in unified mode
          const edgeMesh = unifiedEdgeSize ? currentGrid.instancedEdgesThin : currentGrid.instancedEdgesCollision;
          if (edgeMesh) {
            const collisionHits = raycaster.intersectObject(edgeMesh);

            if (collisionHits.length > 0) {
              const instanceId = collisionHits[0].instanceId;
              // Find edge key using thin/collision index
              for (const [eKey, mapping] of currentGrid.edgeToInstanceMap.entries()) {
                if (mapping.thin === instanceId) {
                  mouseUpTarget = eKey;
                  break;
                }
              }
            }
          }
        }
      } else {
        // Individual edge mode - filter out nulls
        const edgeMeshes = Array.from(currentGrid.edges.values())
          .map(e => e.mesh)
          .filter(m => m !== null && m !== undefined);
        const edgeIntersects = raycaster.intersectObjects(edgeMeshes);
        if (edgeIntersects.length > 0) {
          for (const [key, edge] of currentGrid.edges.entries()) {
            if (edge.mesh === edgeIntersects[0].object) {
              mouseUpTarget = key;
              break;
            }
          }
        }
      }
      break;
      
    case 'vertex':
      // Raycast against collision helpers (instanced or individual)
      if (currentGrid.isInstanced) {
        // Check if we have chunks (multi-chunk grid) or global meshes (single-chunk)
        if (currentGrid.chunks && currentGrid.chunks.size > 0) {
          // Iterate all chunks and find closest vertex hit
          let closestHit = null;
          let closestDistance = Infinity;
          let closestChunkKey = null;

          for (const [chunkKey, chunk] of currentGrid.chunks.entries()) {
            if (chunk.instancedVertexCollisionHelpers) {
              const vertexIntersects = raycaster.intersectObject(chunk.instancedVertexCollisionHelpers);
              if (vertexIntersects.length > 0 && vertexIntersects[0].distance < closestDistance) {
                closestHit = vertexIntersects[0];
                closestDistance = closestHit.distance;
                closestChunkKey = chunkKey;
              }
            }
          }

          if (closestHit) {
            const instanceId = closestHit.instanceId;
            const chunk = currentGrid.chunks.get(closestChunkKey);
            const vertexToInstanceMap = chunk ? chunk.vertexToInstanceMap : currentGrid.vertexToInstanceMap;
            // Map instance ID back to vertex key
            for (const [vKey, instanceIdx] of vertexToInstanceMap.entries()) {
              if (instanceIdx === instanceId) {
                mouseUpTarget = vKey;
                break;
              }
            }
          }
        } else if (currentGrid.instancedVertexCollisionHelpers) {
          // Fallback for single-chunk grids (backwards compatibility)
          const vertexIntersects = raycaster.intersectObject(currentGrid.instancedVertexCollisionHelpers);
          if (vertexIntersects.length > 0) {
            const instanceId = vertexIntersects[0].instanceId;
            // Map instance ID back to vertex key
            for (const [vKey, instanceIdx] of currentGrid.vertexToInstanceMap.entries()) {
              if (instanceIdx === instanceId) {
                mouseUpTarget = vKey;
                break;
              }
            }
          }
        }
      } else {
        // Non-instanced mode: use individual collision helpers
        const vertexHelpers = [];
        for (const [vKey, vertexData] of currentGrid.vertices.entries()) {
          if (vertexData.collisionHelper) {
            vertexHelpers.push(vertexData.collisionHelper);
          }
        }
        const vertexIntersects = raycaster.intersectObjects(vertexHelpers);
        if (vertexIntersects.length > 0) {
          mouseUpTarget = vertexIntersects[0].object.userData.vertexKey;
        }
      }
      break;
      
    case 'box':
      const allMeshes = getFilteredBoxMeshes();
      const boxIntersects = raycaster.intersectObjects(allMeshes);
      if (boxIntersects.length > 0) {
        const hit = boxIntersects[0];
        let box = null;
        
        if (currentGrid.isInstanced && hit.instanceId != null) {
          // Instanced mode
          const obj = hit.object;
          if (obj === currentGrid.instancedBoxesXY) box = currentGrid.instancesXY?.[hit.instanceId];
          else if (obj === currentGrid.instancedBoxesXZ) box = currentGrid.instancesXZ?.[hit.instanceId];
          else if (obj === currentGrid.instancedBoxesYZ) box = currentGrid.instancesYZ?.[hit.instanceId];
        } else {
          // Non-instanced: search the Maps
          box = hit.object?.userData?.box;
          if (!box) {
            for (const [key, b] of [...currentGrid.boxesXY, ...currentGrid.boxesXZ, ...currentGrid.boxesYZ]) {
              if (b.mesh === hit.object) {
                box = b;
                console.log('MOUSEUP: Found box via fallback search', box.coords, box.plane);
                break;
              }
            }
          }
        }
        
        if (box) {
          mouseUpTarget = box;
        }
      }
      break;
  }
  
  // Only perform action if mousedown and mouseup targets match
  if (mouseDownType === 'vertex') {
    console.log(`MOUSEUIP VERTEX: mouseDownTarget="${mouseDownTarget}", mouseUpTarget="${mouseUpTarget}", match=${mouseDownTarget === mouseUpTarget}`);
  }
  if (mouseDownTarget === mouseUpTarget && mouseUpTarget !== null) {
    console.log(`MOUSEUP: Action triggered - type="${mouseDownType}", target="${mouseUpTarget}"`);
    performAction(mouseUpTarget, mouseDownType);
  } else if (mouseDownTarget !== null) {
    console.log(`MOUSEUP: No match - down="${mouseDownTarget}", up="${mouseUpTarget}", type="${mouseDownType}"`);
  }

  // Clear stored targets
  mouseDownTarget = null;
  mouseDownType = null;
}

// ==================== ARROW CONTINUITY HELPERS ====================

/**
 * Determines if an arrow points into or out of a specific vertex
 * @param {number} eKey - Edge key
 * @param {number} vKey - Vertex key
 * @returns {boolean} - True if arrow points INTO vertex, false if OUT OF vertex
 */
function doesArrowPointIntoVertex(eKey, vKey) {
  const edge = currentGrid.edges.get(eKey);
  if (!edge || !edge.arrowDirection || edge.arrowDirection === 0) {
    return false;
  }

  const [a, b] = unpackEdge(eKey, currentGrid);
  const aKey = vertexKey(...a, currentGrid);
  const bKey = vertexKey(...b, currentGrid);
  const direction = edge.arrowDirection;

  // direction = 1 means arrow points from a to b (canonical order)
  // direction = -1 means arrow points from b to a (reverse of canonical)

  if (direction === 1) {
    return (bKey === vKey); // Arrow points into b
  } else if (direction === -1) {
    return (aKey === vKey); // Arrow points into a
  }

  return false;
}

/**
 * Determines the correct arrow direction for a new edge based on arrow continuity
 * Uses the "last-added edge" rule to resolve conflicts
 * @param {Array} u - First vertex coordinates [x, y, z]
 * @param {Array} v - Second vertex coordinates [x, y, z]
 * @param {number} eKey - Edge key for the new edge
 * @returns {number} - Arrow direction: 1 (forward), -1 (backward)
 */
function determineArrowDirectionForNewEdge(u, v, eKey) {
  const uKey = vertexKey(...u, currentGrid);
  const vKey = vertexKey(...v, currentGrid);

  if (!currentGrid.lastArrowedEdgeAtVertex) {
    currentGrid.lastArrowedEdgeAtVertex = new Map();
  }

  // Get last arrowed edges at both vertices
  const lastAtU = currentGrid.lastArrowedEdgeAtVertex.get(uKey);
  const lastAtV = currentGrid.lastArrowedEdgeAtVertex.get(vKey);

  // If neither vertex has a last arrowed edge, default to forward
  if (!lastAtU && !lastAtV) {
    return 1; // Default forward direction
  }

  // Determine which edge to use as reference (most recent)
  let referenceInfo = null;

  if (lastAtU && lastAtV) {
    // Both vertices have history - use the more recent one
    referenceInfo = (lastAtU.timestamp > lastAtV.timestamp) ? lastAtU : lastAtV;
  } else {
    // Only one vertex has history
    referenceInfo = lastAtU || lastAtV;
  }

  if (!referenceInfo) return 1; // Fallback

  const referenceEdge = referenceInfo.eKey;

  // Get the reference edge's arrow direction
  const refEdge = currentGrid.edges.get(referenceEdge);
  if (!refEdge || !refEdge.arrowDirection || refEdge.arrowDirection === 0) {
    return 1; // Reference edge has no arrow, default to forward
  }

  // Determine which vertex is shared between reference edge and new edge
  const [refA, refB] = unpackEdge(referenceEdge, currentGrid);
  const refAKey = vertexKey(...refA, currentGrid);
  const refBKey = vertexKey(...refB, currentGrid);

  let sharedVertexKey = null;

  if (refAKey === uKey || refBKey === uKey) {
    sharedVertexKey = uKey;
  } else if (refAKey === vKey || refBKey === vKey) {
    sharedVertexKey = vKey;
  }

  if (!sharedVertexKey) return 1; // No shared vertex (shouldn't happen)

  // Determine if reference arrow points INTO or OUT OF shared vertex
  const arrowPointsInto = doesArrowPointIntoVertex(referenceEdge, sharedVertexKey);

  // Calculate direction for new edge to maintain continuity
  const [newA, newB] = unpackEdge(eKey, currentGrid);
  const newAKey = vertexKey(...newA, currentGrid);
  const sharedIsNewA = (newAKey === sharedVertexKey);

  if (arrowPointsInto) {
    // Reference arrow points INTO shared vertex
    // New arrow should point OUT OF shared vertex (continue flow)
    return sharedIsNewA ? 1 : -1; // Forward if shared is 'a', backward if shared is 'b'
  } else {
    // Reference arrow points OUT OF shared vertex
    // New arrow should point INTO shared vertex (continue flow)
    return sharedIsNewA ? -1 : 1; // Backward if shared is 'a', forward if shared is 'b'
  }
}

/**
 * Updates the last-arrowed-edge tracking for both vertices of an edge
 * @param {number} eKey - Edge key
 */
function updateLastArrowedEdgeTracking(eKey) {
  if (!currentGrid.lastArrowedEdgeAtVertex) {
    currentGrid.lastArrowedEdgeAtVertex = new Map();
  }

  const [a, b] = unpackEdge(eKey, currentGrid);
  const aKey = vertexKey(...a, currentGrid);
  const bKey = vertexKey(...b, currentGrid);
  const timestamp = Date.now();

  currentGrid.lastArrowedEdgeAtVertex.set(aKey, { eKey, timestamp });
  currentGrid.lastArrowedEdgeAtVertex.set(bKey, { eKey, timestamp });
}


function performAction(target, type) {
  switch(type) {
    case 'edge':
      if (mode === "addEdge") {
        if (currentGrid.isInstanced) {
          // Instanced mode edge handling
          const [a, b] = unpackEdge(target);
          
          const edge = currentGrid.edges.get(target);
          if (!edge) return;
          
          const beforeState = captureEdgeState(target);
          
          // ARROW MODE GETS PRIORITY
          if (arrowMode) {
            console.log(`[EdgeClick] Before: edge.arrowDirection=${edge.arrowDirection}, edge.arrows=${edge.arrows}`);
            if (edge.arrowDirection === 0 || edge.arrowDirection === undefined) {
              // Determine arrow direction based on continuity with adjacent edges
              const direction = determineArrowDirectionForNewEdge(a, b, target);
              edge.arrowDirection = direction;

              colorEdgeInstanced(currentGrid, a, b, selectedColor, thickEdgeRadius);
              addArrowsToEdge(edge, direction, a, b, target);

              // Update tracking for arrow continuity
              updateLastArrowedEdgeTracking(target);

              console.log(`[EdgeClick] First click: set to ${direction} (continuity-based)`);

              if (!currentGrid.activeSubgraph) {
                currentGrid.activeSubgraph = new Subgraph(currentGrid);
              }
              currentGrid.activeSubgraph.addEdge(a, b);

              // Also update subgraph's edgeDirections map
              currentGrid.activeSubgraph.edgeDirections.set(target, direction);
            } else if (edge.arrowDirection === 1) {
              edge.arrowDirection = -1;
              addArrowsToEdge(edge, -1, a, b, target);
              console.log(`[EdgeClick] Second click: set to -1`);
            } else if (edge.arrowDirection === -1) {
              edge.arrowDirection = 0;
              removeArrowsFromEdge(edge, target);
              colorEdgeInstanced(currentGrid, a, b, UNCOLORED_COLOR, thinEdgeRadius);
              console.log(`[EdgeClick] Third click: removed`);

              if (currentGrid.activeSubgraph) {
                currentGrid.activeSubgraph.removeEdge(a, b);
              }
            }
            console.log(`[EdgeClick] After: edge.arrowDirection=${edge.arrowDirection}, edge.arrows=${edge.arrows}`);
            
            const afterState = captureEdgeState(target);
            recordAction('EDGE_STATE', { edgeKey: target, beforeState, afterState });
            return;
          }
          
          // Toggle color (no arrow mode)
          const newColor = edge.color === selectedColor ? UNCOLORED_COLOR : selectedColor;
          colorEdgeInstanced(currentGrid, a, b, newColor, newColor === UNCOLORED_COLOR ? thinEdgeRadius : thickEdgeRadius);
          
          // Handle activeSubgraph maintenance
          if (newColor !== UNCOLORED_COLOR) {
            if (!currentGrid.activeSubgraph) {
              currentGrid.activeSubgraph = new Subgraph(currentGrid);
            }
            currentGrid.activeSubgraph.addEdge(a, b);
          } else {
            if (currentGrid.activeSubgraph) {
              currentGrid.activeSubgraph.removeEdge(a, b);
            }
          }
          
          const afterState = captureEdgeState(target);
          recordAction('EDGE_STATE', { edgeKey: target, beforeState, afterState });
        } else {
          // Individual mode - reconstruct intersects array
          const edge = currentGrid.edges.get(target);
          if (edge && edge.mesh) {
            const intersects = [{ object: edge.mesh }];
            handleEdgeClick(intersects);
          }
        }
      } else if (mode === "addCube") {
        const edge = currentGrid.edges.get(target);
        if (edge) {
          const beforeState = captureEdgeState(target);
          
          if (currentGrid.isInstanced) {
            // Instanced mode - pass edge key
            if (edge.blockCube) {
              removeBlockCubeInstanced(currentGrid, edge, target);
            } else {
              addBlockCubeInstanced(currentGrid, edge, target);
            }
          } else {
            // Individual mode
            if (edge.blockCube) {
              removeBlockCube(edge);
            } else {
              addBlockCube(edge);
            }
          }
          
          const afterState = captureEdgeState(target);
          recordAction('EDGE_STATE', { edgeKey: target, beforeState, afterState });
        }
      }
      break;
      
    case 'vertex':
      if (mode === "addVertex") {
        handleVertexSphereClick(target);
      } else if (mode === "addDecoration") {
        handleDecorationClick(target);
      }
      break;
      
	case 'box':
	  console.log('PERFORMACTION: box case', target?.coords, 'switchable?', isSwitchable(target));
	  if (mode === "switch" && isSwitchable(target)) {
		restoreEdgeColor();
		switchBox(target);
	  }
	  break;
}
  }


function handleBackbiteClick() {
  if (!currentGrid.path || currentGrid.path.length < 3) {
    console.warn("No valid Hamiltonian path found for backbite");
    return;
  }
  
  let clickedEdgeKey = null;
  
  if (currentGrid.isInstanced) {
    // Handle instanced edge clicks
    let instanceId = null;
    let meshType = null;
    let hitChunkKey = null;

    // Check if we have chunks (multi-chunk grid) or global meshes (single-chunk)
    if (currentGrid.chunks && currentGrid.chunks.size > 0) {
      // Iterate all chunks and find closest hit
      let closestDistance = Infinity;

      for (const [chunkKey, chunk] of currentGrid.chunks.entries()) {
        if (chunk.instancedEdgesThick) {
          const thickHits = raycaster.intersectObject(chunk.instancedEdgesThick);
          if (thickHits.length > 0 && thickHits[0].distance < closestDistance) {
            closestDistance = thickHits[0].distance;
            instanceId = thickHits[0].instanceId;
            meshType = 'thick';
            hitChunkKey = chunkKey;
          }
        }
        if (chunk.instancedEdgesThin) {
          const thinHits = raycaster.intersectObject(chunk.instancedEdgesThin);
          if (thinHits.length > 0 && thinHits[0].distance < closestDistance) {
            closestDistance = thinHits[0].distance;
            instanceId = thinHits[0].instanceId;
            meshType = 'thin';
            hitChunkKey = chunkKey;
          }
        }
      }

      if (instanceId !== null && hitChunkKey) {
        const chunk = currentGrid.chunks.get(hitChunkKey);
        const edgeToInstanceMap = chunk ? chunk.edgeToInstanceMap : currentGrid.edgeToInstanceMap;
        // Reverse lookup to find edge key
        for (const [eKey, mapping] of edgeToInstanceMap.entries()) {
          if ((meshType === 'thin' && mapping.thin === instanceId) ||
              (meshType === 'thick' && mapping.thick === instanceId)) {
            clickedEdgeKey = eKey;
            break;
          }
        }
      }
    } else {
      // Fallback for single-chunk grids (backwards compatibility)
      const thinHits = raycaster.intersectObject(currentGrid.instancedEdgesThin);
      const thickHits = raycaster.intersectObject(currentGrid.instancedEdgesThick);

      if (thickHits.length > 0) {
        instanceId = thickHits[0].instanceId;
        meshType = 'thick';
      } else if (thinHits.length > 0) {
        instanceId = thinHits[0].instanceId;
        meshType = 'thin';
      }

      if (instanceId !== null) {
        // Reverse lookup to find edge key
        for (const [eKey, mapping] of currentGrid.edgeToInstanceMap.entries()) {
          if ((meshType === 'thin' && mapping.thin === instanceId) ||
              (meshType === 'thick' && mapping.thick === instanceId)) {
            clickedEdgeKey = eKey;
            break;
          }
        }
      }
    }
  } else {
    // Handle individual mesh clicks
    const edgeMeshes = Array.from(currentGrid.edges.values())
      .map(e => e.mesh)
      .filter(m => m !== null);
    const intersects = raycaster.intersectObjects(edgeMeshes);
    
    if (intersects.length > 0) {
      const clickedMesh = intersects[0].object;
      for (const [key, edge] of currentGrid.edges.entries()) {
        if (edge.mesh === clickedMesh) {
          clickedEdgeKey = key;
          break;
        }
      }
    }
  }
  
  if (clickedEdgeKey) {
    performManualBackbite(clickedEdgeKey);
  }
}


function handleVerticesClick() {
  console.log(`Vertices mode clicked: ${mode}`);
  
  // Calculate 3D world position from mouse click
  const vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
  vector.unproject(camera);
  const dir = vector.sub(camera.position).normalize();
  
  // Find closest vertex to the ray
  let closestVertex = null;
  let closestDistance = Infinity;
  
  for (const [vKey, vertexData] of currentGrid.vertices.entries()) {
    const vertexPos = new THREE.Vector3(...vertexData.coords);
    
    const rayOrigin = camera.position.clone();
    const toVertex = vertexPos.clone().sub(rayOrigin);
    const projectionLength = toVertex.dot(dir);
    
    if (projectionLength > 0) {
      const projection = dir.clone().multiplyScalar(projectionLength);
      const rejection = toVertex.clone().sub(projection);
      const distanceToRay = rejection.length();
      
      if (distanceToRay < 0.3 && projectionLength < closestDistance) {
        closestDistance = projectionLength;
        closestVertex = vKey;
      }
    }
  }
  
  if (closestVertex) {
    console.log("Clicked vertex:", closestVertex);
    
    // Behavior based on current mode
    if (mode === "addDecoration") {
      handleDecorationClick(closestVertex);
    } else if (mode === "addVertex") {
      handleVertexSphereClick(closestVertex);
    }
  } else {
    console.log("No vertex close enough to click");
  }
}


function handleSwitchClick() {
  const targets = getFilteredBoxMeshes();
  const hits = raycaster.intersectObjects(targets, false);
  if (!hits.length) return;

  const hit = hits[0];
  let box = null;
  let type = null;
  let center = null;

  if (currentGrid.isInstanced && hit.instanceId != null) {
    const obj = hit.object;

    if (obj === currentGrid.instancedBoxesXY) {
      box = currentGrid.instancesXY?.[hit.instanceId];
      type = 'XY';
    } else if (obj === currentGrid.instancedBoxesXZ) {
      box = currentGrid.instancesXZ?.[hit.instanceId];
      type = 'XZ';
    } else if (obj === currentGrid.instancedBoxesYZ) {
      box = currentGrid.instancesYZ?.[hit.instanceId];
      type = 'YZ';
    }

    if (box) {
      const m = new THREE.Matrix4();
      const p = new THREE.Vector3();
      const q = new THREE.Quaternion();
      const s = new THREE.Vector3();
      obj.getMatrixAt(hit.instanceId, m);
      m.decompose(p, q, s);
      center = p;
    }
  } else if (hit.object?.userData?.box) {
    box = hit.object.userData.box;
    type = box?.plane || null;
    if (box) {
      const [x, y, z] = box.coords;
      if (type === 'XY') center = new THREE.Vector3(x + 0.5, y + 0.5, z);
      else if (type === 'XZ') center = new THREE.Vector3(x + 0.5, y, z + 0.5);
      else center = new THREE.Vector3(x, y + 0.5, z + 0.5);
    }
  } else {
    // Non-instanced fallback: search the Maps
    for (const [key, b] of [...currentGrid.boxesXY, ...currentGrid.boxesXZ, ...currentGrid.boxesYZ]) {
      if (b.mesh === hit.object) {
        box = b;
        type = box.plane || null;
        if (box) {
          const [x, y, z] = box.coords;
          if (type === 'XY') center = new THREE.Vector3(x + 0.5, y + 0.5, z);
          else if (type === 'XZ') center = new THREE.Vector3(x + 0.5, y, z + 0.5);
          else center = new THREE.Vector3(x, y + 0.5, z + 0.5);
        }
        console.log('handleSwitchClick: Found box via fallback search', box.coords, box.plane);
        break;
      }
    }
  }

  if (!box) return;

  // expose for downstream logic
  if (center) {
    box.__hitCenter = { x: center.x, y: center.y, z: center.z };
    box.__hitPlane  = type;
  }

  switchBox(box);
}


function handleDefaultClick() {
  // Edge click-to-color mode
  if (!edgeClickEnabled) return;

  const edgeMeshes = Array.from(currentGrid.edges.values()).map(e => e.mesh).filter(m => m);
  const intersects = raycaster.intersectObjects(edgeMeshes);
  if (intersects.length > 0) {
    handleEdgeClick(intersects);
  }
}


// Handle vertex sphere creation/removal only
function handleVertexSphereClick(vertexKey) {
  const beforeState = captureVertexSphereState(vertexKey);
  
  if (!currentGrid.vertexSpheres.has(vertexKey)) {
    // Create new vertex sphere
    createVertexSphere(currentGrid, vertexKey, selectedColor);
  } else {
    // Remove existing vertex sphere
    removeVertexSphere(currentGrid, vertexKey);
  }
  
  const afterState = captureVertexSphereState(vertexKey);
  recordAction('VERTEX_SPHERE', { vertexKey, beforeState, afterState });
}

// Handle decoration addition/removal only
function handleDecorationClick(vertexKey) {
  const beforeState = captureVertexSphereState(vertexKey);

  // Check if decoration exists (on vertex sphere or standalone)
  let hasDecoration = false;
  let decorationGroup = null;

  if (currentGrid.vertexSpheres.has(vertexKey)) {
    const sphereData = currentGrid.vertexSpheres.get(vertexKey);
    if (sphereData.decoration) {
      hasDecoration = true;
      decorationGroup = sphereData.decoration;
    }
  } else if (currentGrid.standaloneDecorations.has(vertexKey)) {
    hasDecoration = true;
    decorationGroup = currentGrid.standaloneDecorations.get(vertexKey).decorationGroup;
  }

  if (hasDecoration) {
    // Remove decoration
    currentGrid.group.remove(decorationGroup);
    if (decorationGroup.children) {
      decorationGroup.children.forEach(child => {
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
      });
    }

    // Remove from tracking
    if (currentGrid.vertexSpheres.has(vertexKey)) {
      currentGrid.vertexSpheres.get(vertexKey).decoration = null;
    } else if (currentGrid.standaloneDecorations.has(vertexKey)) {
      currentGrid.standaloneDecorations.delete(vertexKey);
    }
  } else {
    // Add decoration (works with or without vertex sphere)
    addVertexDecoration(currentGrid, vertexKey, selectedColor2);
  }

  const afterState = captureVertexSphereState(vertexKey);
  recordAction('VERTEX_DECORATION', { vertexKey, beforeState, afterState });
}



function onMouseMove(event) {
  if (!currentGrid) return;

  // Don't process hover if mouse is over UI areas (sidebars or grid tabs)
  if (isClickInUIArea(event.clientX, event.clientY)) {
    clearAllHighlights();
    return;
  }

  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);

  clearAllHighlights();

  if (coordinateHoverMode) {
    handleCoordinateHover(event);
  } else {
    // Handle hover based on current mode
    switch(mode) {
      case "addEdge":
      case "addCube":
        handleEdgeHover();
        break;
      case "addVertex":
      case "addDecoration":
        handleVertexHover();
        break;
      case "switch":
        // Use simple 2D hover for 2D grids, 3D hover for 3D grids
        if (isGrid2D()) {
          handle2DBoxHover();
        } else {
          handleBoxHover();
        }
        break;
      default:
        // No hover effects in default/backbite modes
        break;
    }
  }
  
  // Set default cursor if no handler changed it
  if (document.body.style.cursor !== 'pointer') {
    document.body.style.cursor = 'default';
  }
}



function clearAllHighlights() {
  // Clear edge highlights
  if (currentGrid.highlightOverlay) {
    currentGrid.highlightOverlay.visible = false;
  }
  if (window.highlightedEdge) {
    const originalColor = window.highlightedEdge.userData.originalColor || 0x888888;
    window.highlightedEdge.material.color.setHex(originalColor);
    window.highlightedEdge.material.opacity = window.highlightedEdge.userData.originalOpacity || 1;
    
    if (window.highlightedEdge.userData.wasHidden) {
      window.highlightedEdge.visible = false;
    }
    window.highlightedEdge = null;
  }
  
  // Clear vertex highlights
  if (currentGrid.vertexHighlight) {
    currentGrid.group.remove(currentGrid.vertexHighlight);
    currentGrid.vertexHighlight = null;
  }

  // Clear 2D box highlights
  clear2DBoxHighlight();
}


function handleEdgeHover() {
  if (currentGrid.isInstanced) {
    handleInstancedEdgeHover();
    return;
  }
  
  // Filter out null meshes before raycasting
  const edgeMeshes = Array.from(currentGrid.edges.values())
    .map(e => e.mesh)
    .filter(m => m !== null);
  
  const intersects = raycaster.intersectObjects(edgeMeshes);
  
  if (intersects.length > 0) {
    const hoveredMesh = intersects[0].object;
    
    // Find edge data
    let edgeData = null;
    for (const [key, edge] of currentGrid.edges.entries()) {
      if (edge.mesh === hoveredMesh) {
        edgeData = edge;
        break;
      }
    }
    
    if (edgeData && edgeData.color === UNCOLORED_COLOR) {
      // Create overlay highlight for uncolored edges
      if (!currentGrid.highlightOverlay) {
        // SLEDGEHAMMER: Use thin radius in unified mode
        const radius = unifiedEdgeSize ? thinEdgeRadius : thickEdgeRadius;
        const highlightGeometry = new THREE.CylinderGeometry(radius, radius, 1, 8);
        const highlightMaterial = new THREE.MeshBasicMaterial({
          color: 0x00ffff,
          transparent: true,
          opacity: 0.5,
          depthTest: false
        });
        currentGrid.highlightOverlay = new THREE.Mesh(highlightGeometry, highlightMaterial);
        currentGrid.group.add(currentGrid.highlightOverlay);
      }
      
      const length = hoveredMesh.geometry.parameters.height;
      currentGrid.highlightOverlay.scale.y = length;
      currentGrid.highlightOverlay.position.copy(hoveredMesh.position);
      currentGrid.highlightOverlay.quaternion.copy(hoveredMesh.quaternion);
      
      // Nudge slightly toward camera to avoid z-fighting
      const cameraDirection = new THREE.Vector3();
      camera.getWorldDirection(cameraDirection);
      currentGrid.highlightOverlay.position.add(cameraDirection.multiplyScalar(-0.001));
      
      currentGrid.highlightOverlay.visible = true;
      
      if (!hoveredMesh.visible) {
        hoveredMesh.visible = true;
        window.highlightedEdge = hoveredMesh;
        window.highlightedEdge.userData.wasHidden = true;
      }
    } else {
      // Color change for colored edges
      hoveredMesh.userData.originalColor = hoveredMesh.material.color.getHex();
      hoveredMesh.userData.originalOpacity = hoveredMesh.material.opacity;
      hoveredMesh.userData.wasHidden = !hoveredMesh.visible;
      
      hoveredMesh.visible = true;
      hoveredMesh.material.color.setHex(0x00ffff);
      hoveredMesh.material.opacity = 1;
      
      window.highlightedEdge = hoveredMesh;
    }
    
    document.body.style.cursor = 'pointer';
  }
}


// =================== I.E.R. FUNCTIONS =================

function handleInstancedEdgeHover() {
  // Check if we have chunks (multi-chunk grid) or global meshes (single-chunk)
  let closestHit = null;
  let closestDistance = Infinity;
  let closestChunkKey = null;

  if (currentGrid.chunks && currentGrid.chunks.size > 0) {
    // Iterate all chunks and find closest hit
    for (const [chunkKey, chunk] of currentGrid.chunks.entries()) {
      const edgeMesh = unifiedEdgeSize ? chunk.instancedEdgesThin : chunk.instancedEdgesCollision;
      if (edgeMesh) {
        const collisionHits = raycaster.intersectObject(edgeMesh);
        if (collisionHits.length > 0 && collisionHits[0].distance < closestDistance) {
          closestHit = collisionHits[0];
          closestDistance = closestHit.distance;
          closestChunkKey = chunkKey;
        }
      }
    }
  } else {
    // Fallback for single-chunk grids
    const edgeMesh = unifiedEdgeSize ? currentGrid.instancedEdgesThin : currentGrid.instancedEdgesCollision;
    if (!edgeMesh) return;
    const collisionHits = raycaster.intersectObject(edgeMesh);
    if (collisionHits.length > 0) {
      closestHit = collisionHits[0];
    }
  }

  if (closestHit) {
    const instanceId = closestHit.instanceId;

    // Find the edge key using the appropriate mapping
    let edgeKey = null;
    let edgeToInstanceMap, instancedEdgesThin, instancedEdgesThick;

    if (closestChunkKey && currentGrid.chunks) {
      const chunk = currentGrid.chunks.get(closestChunkKey);
      edgeToInstanceMap = chunk ? chunk.edgeToInstanceMap : null;
      instancedEdgesThin = chunk ? chunk.instancedEdgesThin : null;
      instancedEdgesThick = chunk ? chunk.instancedEdgesThick : null;
    } else {
      edgeToInstanceMap = currentGrid.edgeToInstanceMap;
      instancedEdgesThin = currentGrid.instancedEdgesThin;
      instancedEdgesThick = currentGrid.instancedEdgesThick;
    }

    if (edgeToInstanceMap) {
      for (const [eKey, mapping] of edgeToInstanceMap.entries()) {
        if (mapping.thin === instanceId) {
          edgeKey = eKey;
          break;
        }
      }
    }

    if (edgeKey) {
      const edge = currentGrid.edges.get(edgeKey);

      if (edge) {
        // Create highlight overlay if it doesn't exist
        if (!currentGrid.highlightOverlay) {
          // SLEDGEHAMMER: Use thin radius in unified mode
          const radius = unifiedEdgeSize ? thinEdgeRadius : thickEdgeRadius;
          const highlightGeometry = new THREE.CylinderGeometry(radius, radius, 1, 8);
          const highlightMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.5,
            depthTest: false
          });
          currentGrid.highlightOverlay = new THREE.Mesh(highlightGeometry, highlightMaterial);
          currentGrid.group.add(currentGrid.highlightOverlay);
        }

        // Get edge position from appropriate mesh (thin or thick)
        const matrix = new THREE.Matrix4();

        // SLEDGEHAMMER: In unified mode, always use thin mesh
        if (unifiedEdgeSize) {
          instancedEdgesThin.getMatrixAt(instanceId, matrix);
        } else {
          const isThick = (edge.color !== UNCOLORED_COLOR);
          if (isThick) {
            instancedEdgesThick.getMatrixAt(instanceId, matrix);
          } else {
            instancedEdgesThin.getMatrixAt(instanceId, matrix);
          }
        }

        const position = new THREE.Vector3();
        const quaternion = new THREE.Quaternion();
        const scale = new THREE.Vector3();
        matrix.decompose(position, quaternion, scale);

        // Apply to highlight overlay
        currentGrid.highlightOverlay.position.copy(position);
        currentGrid.highlightOverlay.quaternion.copy(quaternion);
        currentGrid.highlightOverlay.scale.y = scale.y;

        // Nudge slightly toward camera to avoid z-fighting
        const cameraDirection = new THREE.Vector3();
        camera.getWorldDirection(cameraDirection);
        currentGrid.highlightOverlay.position.add(cameraDirection.multiplyScalar(-0.001));

        currentGrid.highlightOverlay.visible = true;

        window.highlightedEdgeKey = edgeKey;
        document.body.style.cursor = 'pointer';
      }
    }
  }
}



function restoreInstancedEdgeColor(edgeKey, storedColor, meshType) {
  const mapping = currentGrid.edgeToInstanceMap.get(edgeKey);
  if (!mapping) return;
  
  const mesh = meshType === 'thin' ? currentGrid.instancedEdgesThin : currentGrid.instancedEdgesThick;
  const instanceIdx = meshType === 'thin' ? mapping.thin : mapping.thick;
  
  // Use the stored color directly (already has correct dimming applied)
  mesh.setColorAt(instanceIdx, storedColor);
  mesh.instanceColor.needsUpdate = true;
}


// =================== I.E.R. FUNCTIONS =================

function handleVertexHover() {
  // Use instanced collision helpers for raycasting
  // These are pre-created for all vertices during grid initialization
  let vertexHelpers = [];

  if (useInstancedRendering && currentGrid.isInstanced) {
    // Check for chunks (multi-chunk grid)
    if (currentGrid.chunks && currentGrid.chunks.size > 0) {
      for (const chunk of currentGrid.chunks.values()) {
        if (chunk.instancedVertexCollisionHelpers) {
          vertexHelpers.push(chunk.instancedVertexCollisionHelpers);
        }
      }
    } else if (currentGrid.instancedVertexCollisionHelpers) {
      // Single-chunk mode: use the global reference
      vertexHelpers = [currentGrid.instancedVertexCollisionHelpers];
    }
  } else {
    // Fallback to individual collision helpers (non-instanced mode)
    for (const [vKey, vertexData] of currentGrid.vertices.entries()) {
      if (vertexData.collisionHelper) {
        vertexHelpers.push(vertexData.collisionHelper);
      }
    }
  }

  const intersects = raycaster.intersectObjects(vertexHelpers);

  if (intersects.length > 0) {
    const hit = intersects[0];
    let vertexKey = null;
    let [x, y, z] = [0, 0, 0];

    if (hit.instanceId != null) {
      // Instanced mode: get vertex from instance mapping
      // Find which chunk this hit belongs to and get the vertex key
      let foundChunk = null;

      if (currentGrid.chunks && currentGrid.chunks.size > 0) {
        // Multi-chunk: find the chunk that owns this collision helper
        for (const chunk of currentGrid.chunks.values()) {
          if (chunk.instancedVertexCollisionHelpers === hit.object) {
            foundChunk = chunk;
            break;
          }
        }

        if (foundChunk) {
          // Use the chunk's reverse mapping
          for (const [vKey, mapping] of foundChunk.vertexToInstanceMap.entries()) {
            if (mapping === hit.instanceId) {
              vertexKey = vKey;
              [x, y, z] = unpackVertex(vKey);
              break;
            }
          }
        }
      } else {
        // Single-chunk: use global vertex iteration
        let instanceIndex = 0;
        for (const [vKey, vertexData] of currentGrid.vertices.entries()) {
          if (instanceIndex === hit.instanceId) {
            vertexKey = vKey;
            [x, y, z] = unpackVertex(vKey);
            break;
          }
          instanceIndex++;
        }
      }
    } else {
      // Non-instanced mode: get vertex key from userData
      const hoveredHelper = hit.object;
      vertexKey = hoveredHelper.userData.vertexKey;
      [x, y, z] = unpackVertex(vertexKey);
    }

    if (vertexKey !== null && vertexKey !== undefined) {
      // Create highlight sphere
      const highlightGeometry = new THREE.SphereGeometry(vertexRadius, 16, 16);
      const highlightMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.6,
        depthTest: false
      });
      currentGrid.vertexHighlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
      currentGrid.vertexHighlight.position.set(x, y, z);
      currentGrid.group.add(currentGrid.vertexHighlight);

      document.body.style.cursor = 'pointer';
    }
  }
}


// Helper to check if current grid is 2D (exactly one dimension = 1)
function isGrid2D() {
  if (!currentGrid) return false;
  const ones = (currentGrid.width === 1 ? 1 : 0) +
               (currentGrid.height === 1 ? 1 : 0) +
               (currentGrid.depth === 1 ? 1 : 0);
  return ones === 1;
}

// Simple 2D switchbox hover - directly raycast boxes and highlight/switch on click
function handle2DBoxHover() {
  if (!currentGrid || !currentGrid.activeSubgraph) return;

  // Get all box meshes for raycasting
  const meshes = [];
  if (currentGrid.instancedBoxesXY) meshes.push(currentGrid.instancedBoxesXY);
  if (currentGrid.instancedBoxesXZ) meshes.push(currentGrid.instancedBoxesXZ);
  if (currentGrid.instancedBoxesYZ) meshes.push(currentGrid.instancedBoxesYZ);

  const hits = raycaster.intersectObjects(meshes, false);

  if (!hits.length) {
    clear2DBoxHighlight();
    document.body.style.cursor = 'default';
    return;
  }

  const hit = hits[0];
  let box = null;
  let type = null;

  if (hit.instanceId != null) {
    if (hit.object === currentGrid.instancedBoxesXY) {
      type = 'XY';
      box = currentGrid.instancesXY[hit.instanceId];
    } else if (hit.object === currentGrid.instancedBoxesXZ) {
      type = 'XZ';
      box = currentGrid.instancesXZ[hit.instanceId];
    } else if (hit.object === currentGrid.instancedBoxesYZ) {
      type = 'YZ';
      box = currentGrid.instancesYZ[hit.instanceId];
    }
  }

  if (!box) {
    clear2DBoxHighlight();
    document.body.style.cursor = 'default';
    return;
  }

  // Check if this box is switchable
  const switchable = isSwitchable(box);

  // Highlight the hovered box - cyan if switchable, yellow (user color) if not
  const highlightColor = switchable ? 0x00ffff : boxHighlightColor;
  highlight2DBox(box, type, hit.instanceId, hit.object, highlightColor);
  document.body.style.cursor = 'pointer';

  // Store for click handling (only if switchable)
  currentGrid.hovered2DBox = switchable ? box : null;
}

// Highlight a single box in 2D mode
function highlight2DBox(box, type, instanceId, mesh, color = 0x00ffff) {
  // Clear previous highlight
  clear2DBoxHighlight();

  // Create highlight mesh
  let geometry;
  if (type === 'XY') {
    geometry = new THREE.BoxGeometry(1, 1, 0.02);
  } else if (type === 'XZ') {
    geometry = new THREE.BoxGeometry(1, 0.02, 1);
  } else { // YZ
    geometry = new THREE.BoxGeometry(0.02, 1, 1);
  }

  const material = new THREE.MeshBasicMaterial({
    color: color,
    opacity: 0.5,
    transparent: true,
    depthTest: false
  });

  const highlight = new THREE.Mesh(geometry, material);

  // Position at box center
  const [x, y, z] = box.coords;
  if (type === 'XY') {
    highlight.position.set(x + 0.5, y + 0.5, z);
  } else if (type === 'XZ') {
    highlight.position.set(x + 0.5, y, z + 0.5);
  } else { // YZ
    highlight.position.set(x, y + 0.5, z + 0.5);
  }

  currentGrid.group.add(highlight);
  currentGrid.highlight2DBox = highlight;
}

// Clear 2D box highlight
function clear2DBoxHighlight() {
  if (currentGrid && currentGrid.highlight2DBox) {
    currentGrid.group.remove(currentGrid.highlight2DBox);
    currentGrid.highlight2DBox.geometry.dispose();
    currentGrid.highlight2DBox.material.dispose();
    currentGrid.highlight2DBox = null;
  }
  if (currentGrid) {
    currentGrid.hovered2DBox = null;
  }
}

// --- 2) Hover handler that supports both instanced and non-instanced boxes ---
function handleBoxHover() {
  const meshes = getFilteredBoxMeshes();

  const hits = raycaster.intersectObjects(meshes, false);

  if (!hits.length) {
    clearHoveredBoxHighlight?.();
    document.body.style.cursor = 'default';
    return;
  }

  const hit = hits[0];

  let obj = hit.object;
  let box = null;
  let type = null;

  if (currentGrid.isInstanced && hit.instanceId != null) {
    if (obj === currentGrid.instancedBoxesXY) {
      type = 'XY';
      box = currentGrid.instancesXY[hit.instanceId];
    }
    else if (obj === currentGrid.instancedBoxesXZ) {
      type = 'XZ';
      box = currentGrid.instancesXZ[hit.instanceId];
    }
    else if (obj === currentGrid.instancedBoxesYZ) {
      type = 'YZ';
      box = currentGrid.instancesYZ[hit.instanceId];
    }

    if (box) {
      const m = new THREE.Matrix4(), p = new THREE.Vector3(), q = new THREE.Quaternion(), s = new THREE.Vector3();
      obj.getMatrixAt(hit.instanceId, m);
      m.decompose(p, q, s);
      box.__hitCenter = { x: p.x, y: p.y, z: p.z };
      box.__hitPlane  = type;
    }
  } else {
    // non-instanced mode unchanged
    const mesh = hit.object;
    box = mesh.userData.box;
    type = box?.plane || null;
    if (box) {
      const [x,y,z] = box.coords;
      box.__hitCenter = (type === 'XY') ? {x:x+0.5,y:y+0.5,z:z}
                      : (type === 'XZ') ? {x:x+0.5,y:y,z:z+0.5}
                                        : {x:x,y:y+0.5,z:z+0.5};
      box.__hitPlane  = type;
    }
  }

  if (!box) {
    clearHoveredBoxHighlight?.();
    document.body.style.cursor = 'default';
    return;
  }

  highlightHoveredBox(box);  // consume __hitCenter/__hitPlane
  document.body.style.cursor = 'pointer';
}










//     ====================================================================================================================
// 										  8. LAYOUT FUNCTIONS AND ANIMATE FUNCTIONS
//     ====================================================================================================================


const scene = new THREE.Scene();
scene.background = new THREE.Color(0xf5f5dc);
updateTheme('paper-white'); // Initialize with default light theme
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
const centerX = GRID_WIDTH / 2;
const centerY = GRID_HEIGHT / 2;
const centerZ = GRID_DEPTH / 2;

camera.position.set(centerX+8, centerY+8, centerZ+13); // Zooms out if large
camera.lookAt(centerX, centerY, centerZ);
const renderer = new THREE.WebGLRenderer({ antialias: true });
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.zoomSpeed = 0.5 * cameraSensitivity; // Scaled by sensitivity
controls.dampingFactor = 0.15;
controls.rotateSpeed = cameraSensitivity; // Set initial camera sensitivity
controls.screenSpacePanning = false;
controls.minDistance = 0.5;
controls.maxDistance = 500;
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Memory breakdown calculation function
function calculateMemoryBreakdown(grid) {
  if (!grid || !grid.isInstanced) {
    return null;
  }

  const breakdown = {
    thinEdges: 0,
    thickEdges: 0,
    edgeCollision: 0,
    vertexSpheres: 0,
    vertexCollision: 0,
    arrows: 0,
    switchBoxes: 0,
    blockCubes: 0,
    lodBackups: 0,
    stringKeys: 0,
    other: 0,
    total: 0
  };

  const edgeCount = grid.edges.size;
  const vertexCount = grid.vertices.size;

  // Thin edges (always loaded)
  breakdown.thinEdges = edgeCount * 64; // 64 bytes per instance

  // Thick edges (always loaded)
  breakdown.thickEdges = edgeCount * 64;

  // Edge collision meshes (check if loaded)
  if (grid.chunks) {
    let hasEdgeCollision = false;
    for (const chunk of grid.chunks.values()) {
      if (chunk.instancedEdgesCollision) {
        hasEdgeCollision = true;
        break;
      }
    }
    if (hasEdgeCollision) {
      breakdown.edgeCollision = edgeCount * 64;
    }
  }

  // Vertex spheres (check if loaded)
  if (grid.chunks) {
    let hasVertexSpheres = false;
    for (const chunk of grid.chunks.values()) {
      if (chunk.instancedVertexSpheres) {
        hasVertexSpheres = true;
        break;
      }
    }
    if (hasVertexSpheres) {
      breakdown.vertexSpheres = vertexCount * 76; // Visual spheres
    }
  }

  // Vertex collision meshes (check if loaded) - merged with vertex spheres in display
  if (grid.chunks) {
    let hasVertexCollision = false;
    for (const chunk of grid.chunks.values()) {
      if (chunk.instancedVertexCollisionHelpers) {
        hasVertexCollision = true;
        break;
      }
    }
    if (hasVertexCollision) {
      breakdown.vertexSpheres += vertexCount * 64; // Add collision to spheres total
    }
  }

  // Arrows (check if loaded)
  if (grid.instancedArrowsForward && grid.instancedArrowsBackward) {
    breakdown.arrows = edgeCount * 128; // 64 bytes × 2 meshes
  }

  // Switchable boxes (check if loaded)
  if (grid.instancedBoxesXY && grid.instancedBoxesXZ && grid.instancedBoxesYZ) {
    const boxCount = grid.boxCount || (edgeCount * 0.33); // Estimate
    breakdown.switchBoxes = boxCount * 64 * 3 + (grid.boxMaps ? 48 * 1024 * 1024 : 0);
  }

  // Block cubes (instanced)
  if (grid.chunks) {
    let hasBlockCubes = false;
    for (const chunk of grid.chunks.values()) {
      if (chunk.instancedBlockCubes) {
        hasBlockCubes = true;
        break;
      }
    }
    if (hasBlockCubes) {
      breakdown.blockCubes = edgeCount * 76;
    }
  }

  // LOD backups (check if LOD enabled)
  if (lodEnabled && grid.chunks) {
    for (const chunk of grid.chunks.values()) {
      if (chunk.linePositions) breakdown.lodBackups += chunk.linePositions.byteLength;
      if (chunk.lineColors) breakdown.lodBackups += chunk.lineColors.byteLength;
      if (chunk.pointPositions) breakdown.lodBackups += chunk.pointPositions.byteLength;
      if (chunk.pointColors) breakdown.lodBackups += chunk.pointColors.byteLength;
    }
  }

  // Numeric keys + Map overhead (refactored from string keys to numeric keys)
  // Each Map entry: 8 bytes for key (number) + ~24 bytes for Map overhead
  const bytesPerVertexKey = 32; // 8 (number) + 24 (Map overhead)
  const bytesPerEdgeKey = 32;   // 8 (number) + 24 (Map overhead)
  breakdown.stringKeys = (vertexCount * bytesPerVertexKey) + (edgeCount * bytesPerEdgeKey);

  // Calculate subtotal (just our tracked structures)
  const subtotal = breakdown.thinEdges + breakdown.thickEdges + breakdown.edgeCollision +
                   breakdown.vertexSpheres + breakdown.arrows +
                   breakdown.switchBoxes + breakdown.blockCubes + breakdown.lodBackups + breakdown.stringKeys;

  // Other (estimate overhead for non-tracked structures)
  breakdown.other = subtotal * 0.5; // Estimate 50% overhead for misc structures

  // Total is the sum of all parts
  breakdown.total = subtotal + breakdown.other;

  return breakdown;
}

function updateMemoryBreakdown() {
  if (!currentGrid) return;

  const breakdown = calculateMemoryBreakdown(currentGrid);
  if (!breakdown) return;

  const formatMB = (bytes) => {
    if (bytes === 0) return '—';
    const mb = bytes / 1048576;
    return mb >= 10 ? Math.round(mb) + ' MB' : mb.toFixed(1) + ' MB';
  };

  document.getElementById('memThinEdges').textContent = formatMB(breakdown.thinEdges);
  document.getElementById('memThickEdges').textContent = formatMB(breakdown.thickEdges);
  document.getElementById('memEdgeCollision').textContent = formatMB(breakdown.edgeCollision);
  document.getElementById('memVertexSpheres').textContent = formatMB(breakdown.vertexSpheres);
  document.getElementById('memArrows').textContent = formatMB(breakdown.arrows);
  document.getElementById('memSwitchBoxes').textContent = formatMB(breakdown.switchBoxes);
  document.getElementById('memBlockCubes').textContent = formatMB(breakdown.blockCubes);
  document.getElementById('memLODBackups').textContent = formatMB(breakdown.lodBackups);
  document.getElementById('memStringKeys').textContent = formatMB(breakdown.stringKeys);
  document.getElementById('memOther').textContent = formatMB(breakdown.other);
}


function animate() {
  requestAnimationFrame(animate);

  // FPS Counter
  const currentTime = performance.now();
  const frameTime = currentTime - lastFrameTime;
  lastFrameTime = currentTime;
  fpsFrames++;

  if (currentTime - fpsLastTime >= fpsUpdateInterval) {
    const fps = Math.round((fpsFrames * 1000) / (currentTime - fpsLastTime));
    const avgFrameTime = ((currentTime - fpsLastTime) / fpsFrames).toFixed(1);

    // Update FPS display
    const fpsElement = document.getElementById('fpsValue');
    const frameTimeElement = document.getElementById('frameTimeValue');
    const chunksElement = document.getElementById('chunksValue');
    const lodLevelElement = document.getElementById('lodLevelValue');

    if (fpsElement) {
      fpsElement.textContent = fps;
      // Color code FPS: green (60+), yellow (30-59), orange (20-29), red (<20)
      if (fps >= 60) {
        fpsElement.style.color = '#2ecc71';
      } else if (fps >= 30) {
        fpsElement.style.color = '#f39c12';
      } else if (fps >= 20) {
        fpsElement.style.color = '#e67e22';
      } else {
        fpsElement.style.color = '#e74c3c';
      }
    }

    if (frameTimeElement) {
      frameTimeElement.textContent = avgFrameTime + 'ms';
    }

    if (currentGrid && currentGrid.chunks) {
      // Count chunks at each LOD level (only visible) and visibility
      let lod3Count = 0, lod2Count = 0, lod1Count = 0;
      let visibleCount = 0, culledCount = 0;
      for (const chunk of currentGrid.chunks.values()) {
        if (chunk.isVisible === false) {
          culledCount++;
        } else {
          visibleCount++;
          // Only count LOD levels for visible chunks
          switch (chunk.lodState.level) {
            case 3: lod3Count++; break;
            case 2: lod2Count++; break;
            case 1: lod1Count++; break;
          }
        }
      }

      // Update chunks display (visible/total)
      if (chunksElement) {
        const queueSize = lodChunkRebuildQueue.length;
        let chunksText = `${visibleCount}/${visibleCount + culledCount}`;
        if (queueSize > 0) {
          chunksText += ` Q:${queueSize}`;
        }
        chunksElement.textContent = chunksText;
      }

      // Update LOD levels display (distribution)
      if (lodLevelElement) {
        if (lodEnabled) {
          lodLevelElement.textContent = `3:${lod3Count} 2:${lod2Count} 1:${lod1Count}`;
        } else {
          lodLevelElement.textContent = 'Disabled';
        }
      }
    } else {
      if (chunksElement) chunksElement.textContent = '—';
      if (lodLevelElement) {
        lodLevelElement.textContent = lodEnabled ? '—' : 'Disabled';
      }
    }

    // Update renderer stats (Triangles, Draw Calls)
    const trianglesElement = document.getElementById('trianglesValue');
    const drawCallsElement = document.getElementById('drawCallsValue');
    const memoryElement = document.getElementById('memoryValue');

    if (trianglesElement) {
      const triangles = renderer.info.render.triangles;
      if (triangles >= 1000000) {
        trianglesElement.textContent = (triangles / 1000000).toFixed(1) + 'M';
      } else if (triangles >= 1000) {
        trianglesElement.textContent = (triangles / 1000).toFixed(1) + 'K';
      } else {
        trianglesElement.textContent = triangles;
      }
    }

    if (drawCallsElement) {
      drawCallsElement.textContent = renderer.info.render.calls;
    }

    if (memoryElement && currentGrid) {
      // Use breakdown calculation for accurate memory tracking
      const breakdown = calculateMemoryBreakdown(currentGrid);
      if (breakdown) {
        const totalMB = (breakdown.total / 1048576).toFixed(1);
        memoryElement.textContent = totalMB + ' MB';
      } else {
        memoryElement.textContent = 'N/A';
      }
    }

    // Update memory breakdown
    updateMemoryBreakdown();

    // Update camera position inputs (auto-updating as camera moves when disabled)
    const manualCamX = document.getElementById('manualCamX');
    const manualCamY = document.getElementById('manualCamY');
    const manualCamZ = document.getElementById('manualCamZ');
    if (manualCamX && manualCamY && manualCamZ) {
      // Only update if inputs are disabled (display mode)
      if (manualCamX.disabled) {
        manualCamX.value = camera.position.x.toFixed(1);
        manualCamY.value = camera.position.y.toFixed(1);
        manualCamZ.value = camera.position.z.toFixed(1);
      }
    }

    fpsFrames = 0;
    fpsLastTime = currentTime;
  }

  controls.update();  // required for damping to work
  updateFrustumCulling();  // Frustum culling system
  updateLOD();  // Progressive LOD system
  updateFlare();  // Flare animation system
  checkAndApplyAutoTheme();  // Auto-switch theme by time of day
  renderer.render(scene, camera);
}
animate();
initializeColorInterface();
renderer.setSize(window.innerWidth, window.innerHeight);

// Show coordinate axes on page load (after everything is set up)
window.addEventListener('load', () => {
  toggleCoordinateAxes();

  // Apply auto-switch theme on page load if enabled
  if (autoSwitchThemeEnabled) {
    const requiredTheme = getThemeByTime();
    const themeSelect = document.getElementById('themeSelect');
    if (themeSelect && themeSelect.value !== requiredTheme) {
      themeSelect.value = requiredTheme;
      updateTheme(requiredTheme);
    }
  }
});



///     ====================================================================================================================
// 										  9. SAVE AND LOAD FUNCTION
//     ================================================================================================================================

//     =========================================
// 		*** 9.1. Save and related Functions ***
//     =========================================
function serializeGridState() {
  // Save current camera position to currentGrid before serializing
  if (currentGrid && camera && controls) {
    currentGrid.cameraPosition = camera.position.clone();
    currentGrid.cameraTarget = controls.target.clone();
  }

  const saveData = {
    version: "2.1",
    app: "3D-Hamilton",
    timestamp: new Date().toISOString(),
    currentGridId: getCurrentGridId(),
    globalSettings: {
      selectedColor: selectedColor,
      selectedColor2: selectedColor2,
      gridVisible: gridVisible,
      gradientMode: gradientMode,
      arrowMode: arrowMode,
      mode: mode,
      activeEndpoint: activeEndpoint,
      edgeClickEnabled: edgeClickEnabled,
      useInstancedRendering: useInstancedRendering, // Save rendering mode
      showAllVertices: showAllVertices, // Save show all vertices preference
      autoSwitchThemeEnabled: autoSwitchThemeEnabled, // Save auto-switch theme preference
      showPlaneHighlighterPanel: document.getElementById('showPlaneHighlighterPanelCheckbox')?.checked ?? false, // Save plane panel visibility
      autoSyncView: autoSyncView // Save auto-sync view preference
    },
    sceneState: {
      coordinatesVisible: scene.userData.coordGroup?.visible || false
    },
    grids: {}
  };

  for (const [id, grid] of allGrids.entries()) {
    saveData.grids[id] = serializeGrid(grid);
  }

  return JSON.stringify(saveData, null, 2);
}

function applyGlobalVisibilitySettings() {
  console.log(`Applying global visibility: gridVisible = ${gridVisible}`);
  
  for (const [gridId, grid] of allGrids.entries()) {
    if (!grid || !grid.edges) {
      console.warn(`Grid ${gridId} has no edges to update visibility`);
      continue;
    }
    
    if (grid.isInstanced) {
      // In instanced mode, visibility is controlled differently
      // For now, we'll skip this - instanced edges are always visible
      console.log(`Skipping visibility update for instanced grid ${gridId}`);
      continue;
    }
    
    let updatedCount = 0;
    for (const [edgeKey, edge] of grid.edges.entries()) {
      if (!edge.mesh) continue;
      
      const isColored = edge.color !== UNCOLORED_COLOR;
      if (!isColored) {
        edge.mesh.visible = gridVisible;
        updatedCount++;
      }
    }
    console.log(`Updated visibility for ${updatedCount} uncolored edges in grid ${gridId}`);
  }
}

function serializeGrid(grid) {
  const gridData = {
    dimensions: {
      width: grid.width,
      height: grid.height,
      depth: grid.depth
    },
    edges: {},
    vertices: {},
    path: null,
    notes: grid.notes || "",
    cameraState: {
      position: grid.cameraPosition ? {
        x: grid.cameraPosition.x,
        y: grid.cameraPosition.y,
        z: grid.cameraPosition.z
      } : null,
      target: grid.cameraTarget ? {
        x: grid.cameraTarget.x,
        y: grid.cameraTarget.y,
        z: grid.cameraTarget.z
      } : null
    }
  };

  // Save ALL edge states including visibility, arrows, and block cubes
  for (const [edgeKey, edge] of grid.edges.entries()) {
    const needsSaving = edge.color !== UNCOLORED_COLOR || 
                       edge.arrows || 
                       edge.blockCube;
    
    if (needsSaving) {
      const edgeState = {
        color: edge.color,
        hasArrows: !!edge.arrows,
        arrowDirection: edge.arrowDirection || 0,
        hasBlockCube: !!edge.blockCube,
        blockCubeColor: edge.blockCubeColor // Save block cube color
      };

      // Only save visibility if in individual mode (has mesh)
      if (edge.mesh) {
        edgeState.visible = edge.mesh.visible;
      }

      gridData.edges[edgeKey] = edgeState;
    }
  }

  // Save vertex spheres
  if (grid.vertexSpheres) {
    for (const [vertexKey, sphereData] of grid.vertexSpheres.entries()) {
      // Get color (works for both instanced and individual mode)
      const color = grid.isInstanced
        ? sphereData.color
        : sphereData.sphere.material.color.getHex();

      const vertexInfo = {
        color: color
      };

      // Save decoration info if present
      if (sphereData.decoration) {
        vertexInfo.hasDecoration = true;
        // Handle both old single-mesh and new group decorations
        if (sphereData.decoration.children && sphereData.decoration.children.length > 0) {
          vertexInfo.decorationColor = sphereData.decoration.children[0].material.color.getHex();
        } else {
          vertexInfo.decorationColor = sphereData.decoration.material.color.getHex();
        }
      }

      gridData.vertices[vertexKey] = vertexInfo;
    }
  }

  // Save standalone decorations (decorations without vertex spheres)
  if (grid.standaloneDecorations) {
    for (const [vertexKey, decorationData] of grid.standaloneDecorations.entries()) {
      // Only save if not already saved as part of a vertex sphere
      if (!gridData.vertices[vertexKey]) {
        const vertexInfo = {
          color: null, // No vertex sphere
          hasDecoration: true,
          isStandalone: true
        };

        // Get decoration color from the decoration group
        if (decorationData.decorationGroup && decorationData.decorationGroup.children && decorationData.decorationGroup.children.length > 0) {
          vertexInfo.decorationColor = decorationData.decorationGroup.children[0].material.color.getHex();
        }

        gridData.vertices[vertexKey] = vertexInfo;
      }
    }
  }

  // Serialize path
  if (Array.isArray(grid.path) && grid.path.length > 0) {
    // Path contains numeric vertex keys - convert to coordinate strings for JSON
    gridData.path = grid.path.map(vKey => {
      if (typeof vKey === 'number') {
        // Convert numeric vertex key to "x,y,z" string
        const [x, y, z] = unpackVertex(vKey, grid);
        return `${x},${y},${z}`;
      } else {
        console.error('Unexpected vertex key type in grid.path:', typeof vKey, vKey);
        return '0,0,0'; // Fallback
      }
    });
  }

  // Serialize custom planes
  if (grid.customPlanes && grid.customPlanes.length > 0) {
    gridData.customPlanes = grid.customPlanes.map(planeData => ({
      equation: planeData.equation,
      color: planeData.color,
      opacity: planeData.opacity
    }));
  }

  return gridData;
}

function getCurrentGridId() {
  if (!currentGrid) return null;
  
  for (const [id, grid] of allGrids.entries()) {
    if (grid === currentGrid) return id;
  }
  return null;
}

function saveToFile() {
  try {
    // Generate default timestamp-based filename
    const defaultName = `grid-graph-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}`;
    
    // Prompt user for filename with timestamp as default
    const userInput = prompt("Enter filename for save:", defaultName);
    
    // If user cancelled, don't save
    if (userInput === null) {
      console.log('Save cancelled by user');
      return;
    }
    
    // Use user input, but ensure it has .json extension
    let filename = userInput.trim();
    if (filename === '') {
      filename = defaultName; // Fallback to default if empty
    }
    if (!filename.toLowerCase().endsWith('.json')) {
      filename += '.json';
    }
    
    const jsonData = serializeGridState();
    const blob = new Blob([jsonData], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    // Mark that work was just saved
    lastSaveTime = Date.now();
    
    console.log('Grid state saved as:', filename);
  } catch (error) {
    console.error('Error saving grid state:', error);
    alert('Error saving file: ' + error.message);
  }
}

//     =========================================
// 		*** 9.2. Load and related Functions ***
//     =========================================

function loadFromFile(file) {
  const reader = new FileReader();
  
  reader.onload = function(e) {
    try {
      const saveData = JSON.parse(e.target.result);
      loadGridState(saveData);
    } catch (error) {
      console.error('Error loading grid state:', error);
      alert('Error loading file: ' + error.message);
    }
  };
  
  reader.onerror = function() {
    alert('Error reading file');
  };
  
  reader.readAsText(file);
}

async function loadGridState(saveData) {
  // Validate save data
  if (!saveData.version || !saveData.grids) {
    throw new Error('Invalid save file format');
  }

  // Version check
  if (saveData.version !== '2.1' && saveData.version !== '2.0') {
    console.warn('Unknown save version:', saveData.version);
  }

  // Clear existing grids
  clearAllGrids();

  // Restore global settings using nullish coalescing
  if (saveData.globalSettings) {
    const gs = saveData.globalSettings;
    selectedColor = gs.selectedColor ?? selectedColor;
    selectedColor2 = gs.selectedColor2 ?? selectedColor2;

    // Restore rendering mode

    // DON'T restore gridVisible yet - we'll handle it after loading grids
    const savedGridVisible = gs.gridVisible ?? true; // Store for later use
    gradientMode = gs.gradientMode ?? gradientMode;
    arrowMode = gs.arrowMode ?? arrowMode;
    mode = gs.mode ?? mode;
    activeEndpoint = gs.activeEndpoint ?? activeEndpoint;

    // Restore showAllVertices preference
    showAllVertices = gs.showAllVertices ?? false;
    const showAllVerticesCheckbox = document.getElementById('showAllVerticesCheckbox');
    if (showAllVerticesCheckbox) {
      showAllVerticesCheckbox.checked = showAllVertices;
    }

    // Restore autoSwitchThemeEnabled preference
    autoSwitchThemeEnabled = gs.autoSwitchThemeEnabled ?? false;
    const autoSwitchThemeCheckbox = document.getElementById('autoSwitchThemeCheckbox');
    if (autoSwitchThemeCheckbox) {
      autoSwitchThemeCheckbox.checked = autoSwitchThemeEnabled;
    }

    // Restore plane panel visibility preference
    const showPlanePanel = gs.showPlaneHighlighterPanel ?? false;
    const planePanelCheckbox = document.getElementById('showPlaneHighlighterPanelCheckbox');
    if (planePanelCheckbox) {
      planePanelCheckbox.checked = showPlanePanel;
      // Trigger the visibility change
      const planePanel = document.querySelector('.plane-panel');
      if (planePanel) {
        planePanel.style.display = showPlanePanel ? 'block' : 'none';
      }
    }

    // Restore auto-sync view preference
    autoSyncView = gs.autoSyncView ?? true; // Default to true
    const autoSyncViewCheckbox = document.getElementById('autoSyncViewCheckbox');
    if (autoSyncViewCheckbox) {
      autoSyncViewCheckbox.checked = autoSyncView;
    }

    // Update UI elements
    updateGlobalUI();
  } else {
    var savedGridVisible = true; // Default if no settings saved
  }

  // Load each grid - MUST AWAIT for each grid to be fully built
  for (const [gridId, gridData] of Object.entries(saveData.grids)) {
    try {
      await loadGridData(gridId, gridData);
    } catch (error) {
      console.error(`Error loading grid ${gridId}:`, error);
      continue; // Skip this grid but continue with others
    }
  }

  // Update gridCounter to avoid ID collisions
  const numericIds = Object.keys(saveData.grids)
    .map(id => parseInt(id.replace(/\D/g, ''), 10))
    .filter(n => Number.isFinite(n));
  gridCounter = (numericIds.length ? Math.max(...numericIds) : -1) + 1;

  // Apply grid visibility AFTER all grids are loaded
  gridVisible = savedGridVisible;
  applyGlobalVisibilitySettings();

  // Apply showAllVertices setting AFTER all grids are loaded
  updateAllVerticesVisibility();

  // Set current grid after all loading is complete
  requestAnimationFrame(() => {
    if (saveData.currentGridId && allGrids.has(saveData.currentGridId)) {
      switchToGrid(saveData.currentGridId);
    } else if (allGrids.size > 0) {
      switchToGrid(allGrids.keys().next().value);
    }

    console.log(`Loaded ${Object.keys(saveData.grids).length} grids successfully`);
  });
}

async function loadGridData(gridId, gridData) {
  console.log(`Loading grid: ${gridId}`);

  // Set grid dimensions
  GRID_WIDTH = gridData.dimensions.width;
  GRID_HEIGHT = gridData.dimensions.height;
  GRID_DEPTH = gridData.dimensions.depth;

  // Auto-show flare button for large grids (>30k vertices)
  const totalVertices = GRID_WIDTH * GRID_HEIGHT * GRID_DEPTH;
  if (totalVertices > 30000) {
    showFlareButton = true;
    const flareBtn = document.getElementById('flareBtn');
    if (flareBtn) {
      flareBtn.style.display = 'block';
    }
    // Also update the checkbox to reflect this change
    const flareClone = document.getElementById("showFlareButtonCheckboxClone");
    const flareOriginal = document.getElementById("showFlareButtonCheckbox");
    if (flareClone) flareClone.checked = true;
    if (flareOriginal) flareOriginal.checked = true;
  }

  // Create the grid structure
  const grid = createEmptyGridData();
  grid.width = gridData.dimensions.width;
  grid.height = gridData.dimensions.height;
  grid.depth = gridData.dimensions.depth;

  // Initialize subgraph tracking for loaded grid (always active in background)
  grid.activeSubgraph = new Subgraph(grid);

  // Temporarily set currentGrid so edge/vertex functions work
  const savedCurrentGrid = currentGrid;
  currentGrid = grid;

  // Build basic grid content - MUST AWAIT for grid to be fully built
  await buildGridContent(grid);

  // Restore camera state
  if (gridData.cameraState.position) {
    grid.cameraPosition = new THREE.Vector3(
      gridData.cameraState.position.x,
      gridData.cameraState.position.y,
      gridData.cameraState.position.z
    );
  }
  if (gridData.cameraState.target) {
    grid.cameraTarget = new THREE.Vector3(
      gridData.cameraState.target.x,
      gridData.cameraState.target.y,
      gridData.cameraState.target.z
    );
  }

  // CRITICAL: Check if we need to load block cubes system BEFORE restoring edges
  // Look ahead to see if any edges have block cubes
  const hasBlockCubes = Object.values(gridData.edges).some(edgeState => edgeState.hasBlockCube);
  if (grid.isInstanced && hasBlockCubes) {
    if (!grid.instancedBlockCubes) {
      await loadBlockCubes(grid);
    }
  }

  // Restore edge states
  for (const [edgeKeyStr, edgeState] of Object.entries(gridData.edges)) {
    const edgeKey = Number(edgeKeyStr); // Convert string key to number
    const [a, b] = unpackEdge(edgeKey, grid);

    const edge = grid.edges.get(edgeKey);
    if (!edge) continue;
    
    // Color the edge
    if (edgeState.color !== UNCOLORED_COLOR) {
      if (grid.isInstanced) {
        colorEdgeInstanced(grid, a, b, edgeState.color, thickEdgeRadius);
      } else {
        grid.group.remove(edge.mesh);
        const newMesh = makeEdgeMesh(a, b, edgeState.color, thickEdgeRadius);
        grid.edges.set(edgeKey, {
          ...edge,
          color: edgeState.color,
          mesh: newMesh
        });
        grid.group.add(newMesh);
      }
    }
    
    // Set edge visibility (only for individual mode)
    if (!grid.isInstanced && edge.mesh && edgeState.visible !== undefined) {
      edge.mesh.visible = edgeState.visible;
    }
    
    // Restore block cubes
    if (edgeState.hasBlockCube) {
      const cubeColor = edgeState.blockCubeColor || selectedColor2; // Use saved color or fallback
      if (grid.isInstanced) {
        addBlockCubeInstanced(grid, edge, edgeKey, cubeColor);
      } else {
        // Create block cube manually for individual mode
        const geometry = new THREE.BoxGeometry(blockCubeSize, blockCubeSize, blockCubeSize);
        const material = new THREE.MeshBasicMaterial({ color: cubeColor });
        const cube = new THREE.Mesh(geometry, material);

        if (edge.mesh) {
          cube.position.copy(edge.mesh.position);
        }
        cube.raycast = () => {};

        edge.blockCube = cube;
        edge.blockCubeColor = cubeColor; // Store color on edge
        grid.group.add(cube);
      }
    }
    
    // Add arrows with temporary currentGrid swap
    if (edgeState.hasArrows && edgeState.arrowDirection) {
      if (edge && !edge.arrows) {
        const tempCurrentGrid = currentGrid;
        currentGrid = grid;
        // Pass from, to, and edgeKey to avoid edge lookup errors in instanced mode
        addArrowsToEdge(edge, edgeState.arrowDirection, a, b, edgeKey);
        currentGrid = tempCurrentGrid;
      }
    }
  }

  // CRITICAL: Load vertex spheres system BEFORE restoring vertices if grid has any saved vertices
  if (grid.isInstanced && gridData.vertices && Object.keys(gridData.vertices).length > 0) {
    if (!grid.instancedVertexSpheres) {
      await loadVertexSpheres(grid);
    }
  }

  // Restore vertex spheres and standalone decorations
  if (gridData.vertices) {
    for (const [vertexKeyStr, vertexState] of Object.entries(gridData.vertices)) {
      const vertexKey = Number(vertexKeyStr); // Convert string key to number

      // Check if this is a standalone decoration (decoration without vertex sphere)
      if (vertexState.isStandalone) {
        // Only restore the decoration, not a vertex sphere
        if (vertexState.hasDecoration && vertexState.decorationColor) {
          addVertexDecoration(grid, vertexKey, vertexState.decorationColor);
        }
      } else {
        // Regular vertex sphere - restore it
        if (grid.isInstanced) {
          // Use instanced rendering
          createVertexSphere(grid, vertexKey, vertexState.color);
        } else {
          // Use individual mesh rendering
          const [x, y, z] = unpackVertex(vertexKey, grid);
          const geometry = new THREE.SphereGeometry(vertexRadius, 16, 16);
          const material = new THREE.MeshBasicMaterial({ color: vertexState.color });
          const sphere = new THREE.Mesh(geometry, material);
          sphere.position.set(x, y, z);

          grid.group.add(sphere);

          // Store in new format (with sphere/decoration structure)
          grid.vertexSpheres.set(vertexKey, {
            sphere: sphere,
            decoration: null,
            color: vertexState.color
          });
        }

        // If vertex sphere has decoration, restore it
        if (vertexState.hasDecoration && vertexState.decorationColor) {
          addVertexDecoration(grid, vertexKey, vertexState.decorationColor);
        }
      }
    }
  }

  // Restore notes (with backward compatibility)
  if (gridData.notes) {
    // Check if it's HTML (contains tags) or plain text
    const isHtml = /<[a-z][\s\S]*>/i.test(gridData.notes);
    if (isHtml) {
      grid.notes = gridData.notes;
    } else {
      // Convert plain text to HTML
      grid.notes = `<p>${gridData.notes.replace(/\n/g, '</p><p>')}</p>`;
    }
  } else {
    grid.notes = "";
  }

  // Restore path data with proper visual updates
  if (Array.isArray(gridData.path) && gridData.path.length > 0) {
    // Convert path strings back to numeric vertex keys
    // Saved format: strings like "1,2,3" or numbers
    // Need format: numeric vertex keys
    grid.path = gridData.path.map(v => {
      if (typeof v === 'number') {
        return v; // Already a numeric key
      } else if (typeof v === 'string') {
        // Parse "x,y,z" string back to coordinates, then to vertex key
        const parts = v.split(',').map(Number);
        return vertexKey(parts[0], parts[1], parts[2] || 0, grid);
      } else {
        console.error('Unknown path vertex format:', v);
        return 0;
      }
    });

    // Rebuild activeSubgraph from path
    // Note: Edges are ALREADY colored from restore process above, so we just register them in subgraph
    // DON'T create new Subgraph - one was already created at line 24536!
    for (let i = 0; i < grid.path.length - 1; i++) {
      const a = unpackVertex(grid.path[i], grid);
      const b = unpackVertex(grid.path[i + 1], grid);
      const eKey = edgeKey(a, b, grid);
      const aKey = vertexKey(...a, grid);
      const bKey = vertexKey(...b, grid);

      // Manually populate subgraph internals (edges already colored, don't color again)
      grid.activeSubgraph.edges.add(eKey);
      grid.activeSubgraph.vertices.add(aKey);
      grid.activeSubgraph.vertices.add(bKey);

      // Initialize edge direction to 0 (will be synced from grid later)
      if (!grid.activeSubgraph.edgeDirections.has(eKey)) {
        grid.activeSubgraph.edgeDirections.set(eKey, 0);
      }
    }

    // Check if this was a cycle by examining the saved edges
    // A cycle has a closing edge from last vertex back to first vertex
    const totalVertices = grid.width * grid.height * grid.depth;
    const isHamiltonianSize = grid.path.length === totalVertices;

    // Check if there's a closing edge saved (cycle)
    let isCycle = false;
    if (isHamiltonianSize && gridData.edges) {
      const lastVertex = grid.path[grid.path.length - 1];
      const firstVertex = grid.path[0];
      const a = unpackVertex(lastVertex, grid);
      const b = unpackVertex(firstVertex, grid);
      const closingEdgeKey = edgeKey(a, b, grid);

      // Check if the closing edge was saved (indicates it's a cycle)
      isCycle = !!gridData.edges[closingEdgeKey];

      if (isCycle) {
        // Add closing edge to activeSubgraph for cycles
        grid.activeSubgraph.edges.add(closingEdgeKey);
        if (!grid.activeSubgraph.edgeDirections.has(closingEdgeKey)) {
          grid.activeSubgraph.edgeDirections.set(closingEdgeKey, 0);
        }
      }
    }

    // OPTION C: Sync arrow directions from grid edges to subgraph (Single Source of Truth)
    // This ensures subgraph.edgeDirections is populated with saved arrow data
    grid.activeSubgraph.syncArrowsFromGrid();

    // Use subgraph analysis to detect Hamiltonicity (leverages existing infrastructure)
    const analysis = grid.activeSubgraph.analyzeComponentsDetailed();
    const isHamiltonian = analysis.summary.hasHamiltonianPath || analysis.summary.hasHamiltonianCycle;

    // Store flag to create endpoint markers when grid is switched to
    // Only for Hamiltonian paths (not cycles, not partial paths)
    if (isHamiltonian && !isCycle && gridData.path.length >= 2) {
      console.log('✓ Setting needsEndpointMarkers flag for loaded Hamiltonian path');
      grid.needsEndpointMarkers = true;
    } else {
      console.log('✗ Not setting needsEndpointMarkers:', {
        isHamiltonian,
        isCycle,
        pathLength: gridData.path.length
      });
    }
  }

  // Restore custom planes
  if (gridData.customPlanes && Array.isArray(gridData.customPlanes)) {
    for (const planeData of gridData.customPlanes) {
      const { a, b, c, d } = planeData.equation;
      const color = planeData.color;
      const opacity = planeData.opacity;

      // Temporarily ensure currentGrid is set for addTransparentPlane
      const tempCurrentGrid = currentGrid;
      currentGrid = grid;
      addTransparentPlane(a, b, c, d, color, opacity);
      currentGrid = tempCurrentGrid;
    }
  }

  // Add to grids collection and create UI
  allGrids.set(gridId, grid);
  createGridButton(gridId);

  // Restore original currentGrid
  currentGrid = savedCurrentGrid;

  // If this was the only grid or should be current, switch to it
  if (allGrids.size === 1 || !savedCurrentGrid) {
    console.log(`Switching to loaded grid ${gridId} (allGrids.size=${allGrids.size}, savedCurrentGrid=${!!savedCurrentGrid})`);
    switchToGrid(gridId);
  } else {
    console.log(`Not auto-switching to grid ${gridId}`);
  }

  console.log(`Grid ${gridId} loaded successfully`);
}


function clearAllGrids() {
  // Remove all grid groups from scene and dispose resources
  for (const [id, grid] of allGrids.entries()) {
    if (grid) {
      disposeGrid(grid);
      if (grid.group) {
        scene.remove(grid.group);
      }
    }
  }

  // Clear grid list UI
  const gridList = document.getElementById("gridList");
  if (gridList) gridList.innerHTML = "";

  // Clear collections
  allGrids.clear();
  currentGrid = null;
  gridCounter = 0;
}

function updateAllVerticesVisibility() {
  // Update vertex visibility for all grids based on showAllVertices preference
  // Supports both single-chunk and multi-chunk grids
  for (const [gridId, grid] of allGrids.entries()) {
    if (!grid || !grid.isInstanced) continue;

    const grayColor = new THREE.Color(0x888888);
    const zeroMatrix = new THREE.Matrix4().makeScale(0, 0, 0);
    const identityMatrix = new THREE.Matrix4();

    // Determine if this is a chunked grid (even 1 chunk uses chunked API)
    const isChunked = grid.chunks && grid.chunks.size > 0;

    if (isChunked) {
      // Chunked grid: iterate through all chunks
      for (const [chunkKey, chunk] of grid.chunks.entries()) {
        if (!chunk.instancedVertexSpheres || !chunk.vertexToInstanceMap) {
          continue;
        }

        if (grid.showAllVertices) {
          // Show all vertices in this chunk
          chunk.instancedVertexSpheres.visible = true;
          chunk.instancedVertexSpheres.count = chunk.vertexToInstanceMap.size;

          for (const [vKey, instanceIndex] of chunk.vertexToInstanceMap.entries()) {
            const vertexData = grid.vertexSpheres?.get(vKey);
            const hasColoredSphere = vertexData && vertexData.color !== 0x888888;

            if (!hasColoredSphere) {
              // Show gray sphere at this uncolored vertex
              const [x, y, z] = unpackVertex(vKey, grid);
              const matrix = new THREE.Matrix4();
              matrix.setPosition(x, y, z);
              chunk.instancedVertexSpheres.setMatrixAt(instanceIndex, matrix);
              chunk.instancedVertexSpheres.setColorAt(instanceIndex, grayColor);
            }
          }
        } else {
          // Hide all gray vertices in this chunk
          let chunkHasColoredVertices = false;

          for (const [vKey, instanceIndex] of chunk.vertexToInstanceMap.entries()) {
            const vertexData = grid.vertexSpheres?.get(vKey);
            const hasColoredSphere = vertexData && vertexData.color !== 0x888888;

            if (hasColoredSphere) {
              chunkHasColoredVertices = true;
            } else {
              // Hide gray vertex by scaling to zero
              chunk.instancedVertexSpheres.setMatrixAt(instanceIndex, zeroMatrix);
            }
          }

          // Make chunk mesh visible only if it has colored vertices
          chunk.instancedVertexSpheres.visible = chunkHasColoredVertices;
        }

        chunk.instancedVertexSpheres.instanceMatrix.needsUpdate = true;
        if (chunk.instancedVertexSpheres.instanceColor) {
          chunk.instancedVertexSpheres.instanceColor.needsUpdate = true;
        }
      }
    } else {
      // Single-chunk grid: use global references (backwards compatibility)
      if (!grid.instancedVertexSpheres || !grid.vertexToInstanceMap) continue;

      if (grid.showAllVertices) {
        // Show all vertices: make mesh visible and populate with gray spheres at uncolored vertices
        grid.instancedVertexSpheres.visible = true;
        grid.instancedVertexSpheres.count = grid.vertexToInstanceMap.size;

        for (const [vKey, instanceIndex] of grid.vertexToInstanceMap.entries()) {
          const vertexData = grid.vertexSpheres?.get(vKey);
          const hasColoredSphere = vertexData && vertexData.color !== 0x888888;

          if (!hasColoredSphere) {
            // Show gray sphere at this uncolored vertex
            const [x, y, z] = unpackVertex(vKey, grid);
            const matrix = new THREE.Matrix4();
            matrix.setPosition(x, y, z);
            grid.instancedVertexSpheres.setMatrixAt(instanceIndex, matrix);
            grid.instancedVertexSpheres.setColorAt(instanceIndex, grayColor);
          }
        }
      } else {
        // Hide all gray vertices
        const hasColoredVertices = grid.vertexSpheres && grid.vertexSpheres.size > 0;

        for (const [vKey, instanceIndex] of grid.vertexToInstanceMap.entries()) {
          const vertexData = grid.vertexSpheres?.get(vKey);
          const hasColoredSphere = vertexData && vertexData.color !== 0x888888;

          if (!hasColoredSphere) {
            // Hide gray vertex by scaling to zero
            grid.instancedVertexSpheres.setMatrixAt(instanceIndex, zeroMatrix);
          }
        }

        // Make mesh visible only if there are colored vertices
        grid.instancedVertexSpheres.visible = hasColoredVertices;
      }

      grid.instancedVertexSpheres.instanceMatrix.needsUpdate = true;
      if (grid.instancedVertexSpheres.instanceColor) {
        grid.instancedVertexSpheres.instanceColor.needsUpdate = true;
      }
    }
  }
}

function updateGlobalUI() {
  // Update color pickers with safety checks
  const colorInput = document.getElementById("colorInput");
  const colorInput2 = document.getElementById("colorInput2");
  
  if (colorInput) {
    colorInput.value = "#" + selectedColor.toString(16).padStart(6, '0');
  }
  if (colorInput2) {
    colorInput2.value = "#" + selectedColor2.toString(16).padStart(6, '0');
  }
  
  // Update button states
  const gradientCheckbox = document.getElementById("gradientCheckbox");
  if (gradientCheckbox) {
    gradientCheckbox.checked = gradientMode;
  }
  
  const arrowCheckbox = document.getElementById("arrowCheckbox");
  if (arrowCheckbox) arrowCheckbox.checked = arrowMode;
  
  const switchBtn = document.getElementById("switchPill");
  if (switchBtn) switchBtn.classList.toggle("active", mode === "switch");

  const backbiteBtn = document.getElementById("backbitePill");
  if (backbiteBtn) backbiteBtn.classList.toggle("active", mode === "backbite");

  // Auto-manage camera sensitivity checkbox based on backbite mode
  const showCameraSensitivityCheckbox = document.getElementById("showCameraSensitivityCheckbox");
  const cameraSensitivityPanel = document.getElementById("cameraSensitivityPanel");

  if (mode === "backbite") {
    // Entering backbite mode: save current checkbox state and enable it
    if (showCameraSensitivityCheckbox && !showCameraSensitivityCheckbox.checked) {
      showCameraSensitivityBeforeBackbite = showCameraSensitivityInMain;
      showCameraSensitivityInMain = true;
      showCameraSensitivityCheckbox.checked = true;
    }

    // Show panel
    if (cameraSensitivityPanel) cameraSensitivityPanel.style.display = "block";
  } else {
    // Leaving backbite mode: restore original checkbox state
    if (showCameraSensitivityCheckbox) {
      showCameraSensitivityInMain = showCameraSensitivityBeforeBackbite;
      showCameraSensitivityCheckbox.checked = showCameraSensitivityBeforeBackbite;
    }

    // Update panel visibility based on restored checkbox state
    if (cameraSensitivityPanel) {
      cameraSensitivityPanel.style.display = showCameraSensitivityInMain ? "block" : "none";
    }
  }
}

function applyCameraState(grid) {
  // Guard against undefined camera/controls
  if (typeof camera === 'undefined' || typeof controls === 'undefined') {
    console.warn('Camera or controls not available for state restoration');
    return;
  }
  
  if (!grid) {
    console.warn('No grid provided to applyCameraState');
    return;
  }
  
  if (grid.cameraPosition && grid.cameraTarget) {
    camera.position.copy(grid.cameraPosition);
    controls.target.copy(grid.cameraTarget);
    controls.update();
    console.log("Applied saved camera state");
  } else {
    // Default positioning for loaded grids
    const maxDim = Math.max(grid.width, grid.height, grid.depth);
    camera.position.set(maxDim * 1.5, maxDim * 1.5, maxDim * 1.5);
    camera.lookAt(0, 0, 0);
    controls.target.set(0, 0, 0);
    controls.update();
    console.log("Applied default camera state");
  }
}

function createFileInput() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';
  input.style.display = 'none';
  
  input.addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (file) {
      loadFromFile(file);
    }
    // Reset input to allow loading the same file again
    this.value = '';
  });
  
  return input;
}

const fileInput = createFileInput();
document.body.appendChild(fileInput);

function promptLoadFile() {
  fileInput.click();
}

function saveGrid() {
  if (allGrids.size === 0) {
    alert("No grids to save");
    return;
  }
  saveToFile();
}

function loadGridFromDisk() {
  promptLoadFile();
}

// ============================================================================
// OPTIMIZATION: TreapPath and HamiltonianPath classes
// O(log N) path reversal for efficient backbite operations
// ============================================================================

/**
 * TreapPath - O(log N) Path Reversal using Implicit Treap
 *
 * Based on cp-algorithms.com/data_structures/treap.html
 * Implements implicit treap with lazy reversal for efficient interval reversal
 *
 * @author: Generated for GridLab Hamiltonian Path optimization
 * @version: 2.1.0
 */

class TreapNode {
  constructor(value, prior = Math.random()) {
    this.value = value;
    this.prior = prior;
    this.cnt = 1;
    this.rev = false;
    this.l = null;
    this.r = null;
    this.parent = null;  // ← CRITICAL: parent pointer for O(log n) rank
  }
}

class TreapPath {
  constructor(arr = []) {
    this.root = null;
    this.vertexToNode = new Map();  // Map: "x,y,z" -> treap node
    this.nodeList = [];  // Track all nodes in insertion order for mapping

    for (const value of arr) {
      this._insertAtEnd(value);
    }
  }

  _cnt(node) {
    return node ? node.cnt : 0;
  }

  _upd_cnt(node) {
    if (node) {
      node.cnt = 1 + this._cnt(node.l) + this._cnt(node.r);
      // Maintain parent pointers
      if (node.l) node.l.parent = node;
      if (node.r) node.r.parent = node;
    }
  }

  _push(node) {
    if (node && node.rev) {
      node.rev = false;
      [node.l, node.r] = [node.r, node.l];
      if (node.l) node.l.rev ^= true;
      if (node.r) node.r.rev ^= true;
    }
  }

  /**
   * Push all lazy reversal flags on path from node to root
   * Ensures structure is normalized so rank() works correctly
   * O(log n) - walks up parent chain
   */
  _pushPathToRoot(node) {
    if (!node) return;

    const stack = [];
    let cur = node;

    // Climb to root, collecting nodes
    while (cur) {
      stack.push(cur);
      cur = cur.parent;
    }

    // Push from root downwards
    for (let i = stack.length - 1; i >= 0; i--) {
      this._push(stack[i]);
    }
  }

  _split(node, key, add = 0) {
    if (!node) {
      return { l: null, r: null };
    }

    this._push(node);

    const cur_key = add + this._cnt(node.l);

    let l, r;
    if (key <= cur_key) {
      const split_result = this._split(node.l, key, add);
      l = split_result.l;
      node.l = split_result.r;
      if (split_result.r) split_result.r.parent = node;  // Maintain parent
      r = node;
    } else {
      const split_result = this._split(node.r, key, add + 1 + this._cnt(node.l));
      node.r = split_result.l;
      if (split_result.l) split_result.l.parent = node;  // Maintain parent
      r = split_result.r;
      l = node;
    }

    this._upd_cnt(l);
    this._upd_cnt(r);

    // Clear parent of roots
    if (l) l.parent = null;
    if (r) r.parent = null;

    return { l, r };
  }

  _merge(l, r) {
    if (!l) {
      if (r) r.parent = null;
      return r;
    }
    if (!r) {
      if (l) l.parent = null;
      return l;
    }

    this._push(l);
    this._push(r);

    if (l.prior > r.prior) {
      l.r = this._merge(l.r, r);
      if (l.r) l.r.parent = l;  // Maintain parent
      this._upd_cnt(l);
      l.parent = null;
      return l;
    } else {
      r.l = this._merge(l, r.l);
      if (r.l) r.l.parent = r;  // Maintain parent
      this._upd_cnt(r);
      r.parent = null;
      return r;
    }
  }

  _insertAtEnd(value) {
    const newNode = new TreapNode(value);

    // Store mapping from vertex to node
    this.vertexToNode.set(value, newNode);
    this.nodeList.push(newNode);

    if (!this.root) {
      this.root = newNode;
    } else {
      this.root = this._merge(this.root, newNode);
    }
  }

  reverse(L, R) {
    if (L > R || L < 0 || R >= this._cnt(this.root)) {
      console.warn(`Invalid range [${L}, ${R}] for path of length ${this._cnt(this.root)}`);
      return;
    }

    let t1, t2, t3;
    const split1 = this._split(this.root, L);
    t1 = split1.l;
    const t23 = split1.r;

    const split2 = this._split(t23, R - L + 1);
    t2 = split2.l;
    t3 = split2.r;

    if (t2) {
      t2.rev ^= true;
    }

    this.root = this._merge(t1, t2);
    this.root = this._merge(this.root, t3);
  }

  toArray() {
    const result = [];
    this._inorder(this.root, result);
    return result;
  }

  _inorder(node, result) {
    if (!node) return;

    this._push(node);

    this._inorder(node.l, result);
    result.push(node.value);
    this._inorder(node.r, result);
  }

  get(idx) {
    return this.toArray()[idx];
  }

  length() {
    return this._cnt(this.root);
  }

  first() {
    // Get first element WITHOUT materializing - O(log N) tree traversal
    let node = this.root;
    while (node) {
      this._push(node);
      if (node.l) {
        node = node.l;
      } else {
        return node.value;
      }
    }
    return null;
  }

  last() {
    // Get last element WITHOUT materializing - O(log N) tree traversal
    let node = this.root;
    while (node) {
      this._push(node);
      if (node.r) {
        node = node.r;
      } else {
        return node.value;
      }
    }
    return null;
  }

  kth(k) {
    // Get the value at position k (0-indexed) in O(log N)
    // Returns: the vertex at position k, or null if out of bounds
    if (k < 0 || k >= this._cnt(this.root)) return null;
    return this._kthHelper(this.root, k);
  }

  _kthHelper(node, k) {
    if (!node) return null;

    this._push(node);  // Apply lazy reversals

    const leftCount = this._cnt(node.l);

    if (k < leftCount) {
      // k-th element is in left subtree
      return this._kthHelper(node.l, k);
    } else if (k === leftCount) {
      // k-th element is this node
      return node.value;
    } else {
      // k-th element is in right subtree
      return this._kthHelper(node.r, k - leftCount - 1);
    }
  }

  /**
   * Get rank (0-based position) of a vertex in current path: O(log n)
   * Uses parent pointers to walk UP from node to root
   */
  rank(vertex) {
    // Get the position of a vertex in the current path
    // Returns: 0-indexed position, or -1 if not found
    const node = this.vertexToNode.get(vertex);
    if (!node) return -1;

    // Normalize lazy flags along path to ensure correct structure
    this._pushPathToRoot(node);

    // Start with count of left subtree
    let idx = this._cnt(node.l);
    let cur = node;

    // Walk UP to root, accumulating position
    while (cur.parent) {
      const parent = cur.parent;
      // If we came from right child, add left subtree + parent
      if (cur === parent.r) {
        idx += this._cnt(parent.l) + 1;
      }
      cur = parent;
    }

    return idx;
  }

  /**
   * Rank of vertex using vertexToNode map: O(log n)
   * Convenience method combining vertexToNode lookup + rank
   */
  rankVertex(vertexKey) {
    const node = this.vertexToNode.get(vertexKey);
    if (!node) return -1;
    return this.rank(vertexKey);  // Call rank with vertex key
  }

  indexOf(value) {
    // Delegate to rank for consistency
    return this.rank(value);
  }

  static from(arr) {
    return new TreapPath(arr);
  }

  static complexityInfo() {
    return {
      reverse: 'O(log N)',
      toArray: 'O(N)',
      indexOf: 'O(N) - tree traversal without materialization',
      get: 'O(N)',
      length: 'O(1)',
      first: 'O(N)',
      last: 'O(N)',
      space: 'O(N)'
    };
  }
}

/**
 * HamiltonianPath - Data structure for efficient Hamiltonian path manipulation
 *
 * Purpose: Wraps TreapPath to provide a GridLab-specific API optimized for
 * backbite operations and Hamiltonian path generation.
 *
 * @author: Created for GridLab optimization
 * @version: 2.1.0
 */

class HamiltonianPath {
  constructor(vertices = []) {
    this.treap = new TreapPath(vertices);
    this.length = vertices.length;
    // CRITICAL OPTIMIZATION: Keep a Set of vertices for O(1) membership checks
    // This allows us to do "is vertex X in path?" in O(1) instead of O(N)
    this.pathSet = new Set(vertices);
  }

  getHead() {
    return this.treap.first();
  }

  getTail() {
    return this.treap.last();
  }

  toArray() {
    return this.treap.toArray();
  }

  copy() {
    return this.toArray().slice();
  }

  getLength() {
    return this.length;
  }

  getVertex(idx) {
    if (idx < 0 || idx >= this.length) {
      console.warn(`Index ${idx} out of bounds [0, ${this.length - 1}]`);
      return null;
    }
    return this.treap.get(idx);
  }

  indexOf(vertex) {
    // Use the treap's tree-based indexOf (no array materialization)
    return this.treap.indexOf(vertex);
  }

  applyBackbiteMove(idx, isHead) {
    // Apply backbite move: reverse segment from endpoint to neighbor
    // idx = position of neighbor vertex
    // isHead = whether we're reversing from head or tail

    if (isHead) {
      // Reverse from head to neighbor: reverse [0, idx-1]
      this.treap.reverse(0, idx - 1);
    } else {
      // Reverse from neighbor to tail: reverse [idx+1, length-1]
      this.treap.reverse(idx + 1, this.length - 1);
    }
  }

  contains(vertex) {
    return this.indexOf(vertex) !== -1;
  }

  isValid() {
    const arr = this.toArray();
    return new Set(arr).size === arr.length;
  }

  static from(vertices) {
    return new HamiltonianPath(vertices);
  }

  static complexityInfo() {
    return {
      reverseSubpath: 'O(log N)',
      applyBackbiteMove: 'O(log N)',
      toArray: 'O(N)',
      getSubpath: 'O(N)',
      getVertex: 'O(N) [current], O(log N) [potential]',
      indexOf: 'O(N)',
      contains: 'O(N)',
      isValid: 'O(N)',
      getHead: 'O(log N) [current], O(1) [potential]',
      getTail: 'O(log N) [current], O(1) [potential]',
      getLength: 'O(1)'
    };
  }
}


/*
================================================================================
                          BUG HISTORY & RECURRING ISSUES
================================================================================

This section documents bugs that have occurred multiple times or are subtle
enough that they could easily be reintroduced. When fixing a bug, add an entry
here with:
  - Date
  - Symptom
  - Root cause
  - Fix applied
  - How to prevent recurrence

================================================================================

[BUG-001] RECURRING: batchMode inconsistency causing performance freezes
  Date: Dec 2024 (occurred 3+ times)

  Symptom:
    - Undo/redo backbite takes 8+ seconds on small grids (16^3)
    - Manual backbite freezes
    - Path reversal (T key) freezes

  Root Cause:
    - Codebase uses TWO different batchMode variables:
      1. Global `batchMode` (line ~4672)
      2. `currentGrid.batchMode` (grid-specific property)
    - Subgraph.addEdge() checks global `batchMode` at line ~6511
    - But some functions set `currentGrid.batchMode` instead
    - This causes updateSubgraphComponentDropdowns() → _findConnectedComponents()
      to run on EVERY edge addition (N times instead of 1 time)
    - For 1700 edge path = 1700 BFS traversals = billions of operations

  Fix Applied:
    - Changed undoBackbite() and redoBackbite() to use global `batchMode`
    - Changed toggleActiveEndpoint() to use global `batchMode`

  Prevention:
    - ALWAYS use global `batchMode`, NEVER `currentGrid.batchMode`
    - When adding batch operations, grep for "batchMode =" and verify
      you're setting the global variable
    - Consider: Eliminate `grid.batchMode` property entirely to prevent confusion

  Affected Functions:
    - undoBackbite() (line ~10900)
    - redoBackbite() (line ~10960)
    - toggleActiveEndpoint() (line ~13980)
    - Subgraph.addEdge() (line ~6511)

================================================================================

[BUG-002] RECURRING: JavaScript falsy value bugs (0, null, undefined)
  Date: Multiple occurrences throughout development

  Symptom:
    - Vertex at coordinate (0,0,0) not being found/processed
    - Functions returning early when value is 0
    - Conditionals treating 0 as "no value"

  Root Cause:
    - JavaScript treats 0, null, undefined, "", false, NaN as falsy
    - Checks like `if (!value)` or `if (value)` fail when value is 0
    - Grid coordinates can legitimately be 0
    - Vertex keys, edge keys, indices can be 0

  Prevention:
    - Use explicit checks: `if (value === null)` or `if (value === undefined)`
    - For numbers: `if (typeof value === 'number')` or `if (value !== null && value !== undefined)`
    - Never use `if (!value)` when 0 is a valid value
    - Be especially careful with:
      * Vertex coordinates (x, y, z can be 0)
      * Array indices (0 is valid)
      * Vertex/edge keys (can encode to 0)

  Common Fixes:
    - BAD:  `if (!vKey) return;`
    - GOOD: `if (vKey === null || vKey === undefined) return;`
    - BAD:  `if (vertex)`
    - GOOD: `if (vertex !== null && vertex !== undefined)`

================================================================================


================================================================================
                         LOW PRIORITY ENHANCEMENT IDEAS
================================================================================

This section documents potential improvements that would be nice to have but
are not critical for current functionality. These can be implemented when
there's user demand or during feature enhancement phases.

================================================================================

[IDEA-001] Event-driven dynamic triangle budget maintenance
  Date: Dec 2024

  Concept:
    - Automatically maintain triangle budget when geometry is dynamically added
    - Currently, optimizeRenderingSettings() only runs when user clicks "Optimize"
    - Users can exceed budget by loading vertex spheres, adding cubes, etc.

  Proposed Implementation:
    - Event-driven (NOT polling/per-frame checking)
    - Trigger checkAndAdjustTriangleBudget() after these actions:
      * loadVertexSpheres() - when showing all vertices
      * addCube() / block placement
      * addSwitchBox()
      * Adding arrows/decorations
      * Toggling thick edges (changes segment count)
    - Check actual triangle count: renderer.info.render.triangles
    - If exceeds budget threshold, automatically step up LOD/culling
    - Optional "Auto-Maintain Budget" checkbox to enable/disable

  Benefits:
    - Prevents unexpected FPS drops from feature toggles
    - Matches user expectations ("15M budget" stays at 15M)
    - Better UX for teaching/demos/users unfamiliar with performance

  Considerations:
    - Add user notification when auto-adjusting ("Increased LOD to maintain budget")
    - Keep manual optimization as primary tool
    - Zero performance overhead (event-driven only)

  Priority: Low - current manual optimizer works well, this is a polish feature

================================================================================
*/

  </script>
</body>
</html>

